{
  "commons-vfs": [
    {
      "bucket": "tests_with_more_than_ten_focal_methods",
      "nl2test_input": {
        "id": 802,
        "description": "Define a test method that validates the configuration behavior of the HTTP5 File System Config Builder by verifying both deprecated millisecond-based APIs and modern Duration-based APIs maintain consistency when setting and retrieving timeout values and user agent strings. Initialize a FileSystemOptions instance to hold configuration state, then obtain the singleton instance of the HTTP5 File System Config Builder. Assert that the connection timeout retrieved via the deprecated millisecond getter returns zero, and confirm that retrieving the connection timeout as a Duration and converting it to milliseconds also yields zero, then verify the socket timeout returns zero via the deprecated getter and that the user agent string returns the default value \"Jakarta-Commons-VFS\". Configure the options by invoking the deprecated setter methods to establish a connection timeout of 60000 milliseconds, a socket timeout of 60000 milliseconds, and a custom user agent string. Upon configuration, validate that the deprecated connection timeout getter returns 60000, the Duration-based connection timeout getter returns a one-minute Duration, the deprecated socket timeout getter returns 60000, and the user agent getter returns the custom string. Reconfigure the options using the Duration-based setter methods, passing a one-minute Duration for both connection timeout and socket timeout. After this reconfiguration, assert that the deprecated connection timeout getter still returns 60000, the Duration-based connection timeout getter returns the one-minute Duration, the deprecated socket timeout getter returns 60000, the Duration-based socket timeout getter returns the one-minute Duration, and the user agent remains unchanged at the custom string value, thereby confirming bidirectional compatibility between the deprecated and modern configuration APIs. This test uses JUnit 5 for test execution and standard assertion methods for validation.",
        "project_name": "commons-vfs",
        "qualified_class_name": "org.apache.commons.vfs2.provider.http5.Http5ProviderTest",
        "method_signature": "testHttpTimeoutConfig()",
        "abstraction_level": "medium",
        "is_bdd": false
      },
      "nl2test_output": {
        "qualified_test_class_name": "org.apache.commons.vfs2.provider.http5.Http5FileSystemConfigBuilderTest",
        "code": "package org.apache.commons.vfs2.provider.http5;\n\nimport org.apache.commons.vfs2.FileSystemOptions;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.time.Duration;\n\npublic class Http5FileSystemConfigBuilderTest {\n\n    @Test\n    void testTimeoutAndUserAgentConfiguration() {\n        // Step 0: Initialize a FileSystemOptions instance to hold configuration state\n        FileSystemOptions fileSystemOptions = new FileSystemOptions();\n\n        // Step 1: Obtain the singleton instance of the HTTP5 File System Config Builder\n        Http5FileSystemConfigBuilder configBuilder = Http5FileSystemConfigBuilder.getInstance();\n\n        // Step 2: Retrieve default connection timeout via deprecated millisecond getter\n        int defaultConnTimeoutMsDeprecated = configBuilder.getConnectionTimeout(fileSystemOptions);\n\n        // Step 3: Retrieve default connection timeout as Duration\n        java.time.Duration defaultConnTimeoutDuration = configBuilder.getConnectionTimeoutDuration(fileSystemOptions);\n\n        // Step 4: Retrieve default socket timeout via deprecated millisecond getter\n        int defaultSockTimeoutMsDeprecated = configBuilder.getSoTimeout(fileSystemOptions);\n\n        // Step 5: Retrieve default user agent string\n        String defaultUserAgent = configBuilder.getUserAgent(fileSystemOptions);\n\n        // Step 6: Assert that the deprecated connection timeout getter returns zero\n        assertEquals(0L, defaultConnTimeoutMsDeprecated);\n\n        // Step 7: Assert that the Duration-based connection timeout, converted to milliseconds, returns zero\n        assertEquals(0L, defaultConnTimeoutDuration.toMillis());\n\n        // Step 8: Assert that the deprecated socket timeout getter returns zero\n        assertEquals(0L, defaultSockTimeoutMsDeprecated);\n\n        // Step 9: Assert that the user agent string returns the default value 'Jakarta-Commons-VFS'\n        assertEquals(\"Jakarta-Commons-VFS\", defaultUserAgent);\n\n        // Step 10: Configure connection timeout to 60000 milliseconds using deprecated setter method\n        configBuilder.setConnectionTimeout(fileSystemOptions, 60000);\n\n        // Step 11: Configure socket timeout to 60000 milliseconds using deprecated setter method\n        configBuilder.setSoTimeout(fileSystemOptions, 60000);\n\n        // Step 12: Configure user agent to 'CustomAgent' using deprecated setter method\n        configBuilder.setUserAgent(fileSystemOptions, \"CustomAgent\");\n\n        // Step 13: Assert that the deprecated connection timeout getter returns 60000\n        assertEquals(60000L, configBuilder.getConnectionTimeout(fileSystemOptions));\n\n        // Step 14: Assert that the Duration-based connection timeout getter returns a one-minute Duration\n        assertEquals(java.time.Duration.ofMinutes(1), configBuilder.getConnectionTimeoutDuration(fileSystemOptions));\n\n        // Step 15: Assert that the deprecated socket timeout getter returns 60000\n        assertEquals(60000L, configBuilder.getSoTimeout(fileSystemOptions));\n\n        // Step 16: Assert that the user agent getter returns 'CustomAgent'\n        assertEquals(\"CustomAgent\", configBuilder.getUserAgent(fileSystemOptions));\n\n        // Step 17: Reconfigure connection timeout to a one-minute Duration using modern Duration-based setter method\n        configBuilder.setConnectionTimeout(fileSystemOptions, java.time.Duration.ofMinutes(1));\n\n        // Step 18: Reconfigure socket timeout to a one-minute Duration using modern Duration-based setter method\n        configBuilder.setSoTimeout(fileSystemOptions, java.time.Duration.ofMinutes(1));\n\n        // Step 19: Assert that the deprecated connection timeout getter still returns 60000\n        assertEquals(60000L, configBuilder.getConnectionTimeout(fileSystemOptions));\n\n        // Step 20: Assert that the Duration-based connection timeout getter returns the one-minute Duration\n        assertEquals(java.time.Duration.ofMinutes(1), configBuilder.getConnectionTimeoutDuration(fileSystemOptions));\n\n        // Step 21: Assert that the deprecated socket timeout getter returns 60000\n        assertEquals(60000L, configBuilder.getSoTimeout(fileSystemOptions));\n\n        // Step 22: Assert that the Duration-based socket timeout getter returns the one-minute Duration\n        assertEquals(java.time.Duration.ofMinutes(1), configBuilder.getSoTimeoutDuration(fileSystemOptions));\n\n        // Step 23: Assert that the user agent remains unchanged at 'CustomAgent'\n        assertEquals(\"CustomAgent\", configBuilder.getUserAgent(fileSystemOptions));\n    }\n}",
        "method_signature": "testTimeoutAndUserAgentConfiguration()"
      }
    },
    {
      "bucket": "tests_with_more_than_five_to_ten_focal_methods",
      "nl2test_input": {
        "id": 754,
        "description": "Define a test method that validates URI resolution and naming for IPv6 addresses in the HTTP4 file provider by constructing an IPv6 URL string with scheme, address, and network interface identifier, then invoking the VFS manager's file resolution capability with this URL and a new FileSystemOptions instance to obtain an Http4FileObject, upon which retrieve the associated file system and extract its root URI string to assert it matches the expected normalized IPv6 format including trailing slash, and similarly retrieve the file object's name component and extract its URI representation to assert it also matches the expected normalized IPv6 URI format with trailing slash, ensuring both the file system root and the file name correctly preserve the IPv6 address structure with zone identifier. After test execution, shut down the HTTP server if it exists by invoking its shutdown method with a timeout duration, then close any open file object references including read folder, write folder, and base folder if they are non-null, followed by multiple garbage collection cycles with intervening thread sleep intervals to allow cached file references to be released, after which instruct the file system manager to free unused resources and close itself before nullifying the manager reference, pause briefly to allow background threads to terminate, create a helper method that verifies the temporary directory is either non-existent or empty by checking its existence and directory status, then close the global VFS singleton. Use JUnit for test execution and standard Java assertions for validation.",
        "project_name": "commons-vfs",
        "qualified_class_name": "org.apache.commons.vfs2.provider.http4.Http4ProviderTest",
        "method_signature": "testResolveIPv6Url()",
        "abstraction_level": "medium",
        "is_bdd": false
      },
      "nl2test_output": {
        "qualified_test_class_name": "org.apache.commons.vfs2.provider.http4.Http4IPv6UriResolutionTest",
        "code": "package org.apache.commons.vfs2.provider.http4;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.apache.commons.vfs2.FileSystemManager;\nimport org.apache.commons.vfs2.VFS;\nimport org.apache.commons.vfs2.FileSystemOptions;\nimport org.apache.commons.vfs2.FileObject;\nimport org.apache.commons.vfs2.FileSystem;\nimport org.apache.commons.vfs2.FileName;\nimport java.io.File;\nimport org.apache.commons.vfs2.impl.DefaultFileSystemManager; // Import for DefaultFileSystemManager\n\npublic class Http4IPv6UriResolutionTest {\n\n    private Object http_server = null;\n    private FileObject read_folder_ref = null;\n    private FileObject write_folder_ref = null;\n    private FileObject base_folder_ref = null;\n    private FileSystemManager vfs_manager = null; // Changed type back to FileSystemManager\n    private File temporary_directory = null;\n\n    @Test\n    public void testIPv6UriResolution() throws Exception {\n        // Step 0: Construct an IPv6 URL string with scheme, address, and network interface identifier\n        String ipv6_url_string = \"http://[FEDC:BA98:7654:3210:FEDC:BA98:7654:3210%25eth0]/\";\n        String expected_ipv6_uri_format = \"http://[fedc:ba98:7654:3210:fedc:ba98:7654:3210%25eth0]/\";\n\n        try {\n            // Step 1: Invoke the VFS manager's file resolution capability with the IPv6 URL and a new FileSystemOptions instance to obtain an Http4FileObject\n            vfs_manager = VFS.getManager(); // Get the manager without casting initially\n            FileSystemOptions fileSystemOptions = new FileSystemOptions();\n            FileObject fileObject = vfs_manager.resolveFile(ipv6_url_string, fileSystemOptions);\n\n            // Step 2: Retrieve the associated file system from the FileObject\n            FileSystem file_system = fileObject.getFileSystem();\n\n            // Step 3: Extract the file system's root URI string\n            String file_system_root_uri = file_system.getRootURI();\n\n            // Step 4: Assert the file system root URI matches the expected normalized IPv6 format including trailing slash\n            assertEquals(expected_ipv6_uri_format, file_system_root_uri);\n\n            // Step 5: Retrieve the file object's name component\n            FileName file_object_name = fileObject.getName();\n\n            // Step 6: Extract the file object's name URI representation\n            String file_object_name_uri = file_object_name.getURI();\n\n            // Step 7: Assert the file object's name URI matches the expected normalized IPv6 URI format with trailing slash\n            assertEquals(expected_ipv6_uri_format, file_object_name_uri);\n\n        } finally {\n            // Teardown steps\n\n            // Step 8: Shut down the HTTP server if it exists by invoking its shutdown method with a timeout duration\n            // Assuming http_server has a shutdown(long) method, e.g., if it's an instance of a custom HTTP server class.\n            // For now, we'll keep it as a comment as http_server is null and its type is Object.\n            // if (http_server != null) { ((MyHttpServer) http_server).shutdown(1000L); }\n\n            // Step 9: Close any open file object references including read folder, write folder, and base folder if they are non-null\n            if (read_folder_ref != null) { read_folder_ref.close(); }\n            if (write_folder_ref != null) { write_folder_ref.close(); }\n            if (base_folder_ref != null) { base_folder_ref.close(); }\n\n            // Step 10: Perform multiple garbage collection cycles with intervening thread sleep intervals to allow cached file references to be released\n            System.gc();\n            Thread.sleep(10L);\n            System.gc();\n            Thread.sleep(10L);\n\n            // Step 11: Instruct the file system manager to free unused resources and close itself\n            if (vfs_manager instanceof DefaultFileSystemManager) {\n                ((DefaultFileSystemManager) vfs_manager).freeUnusedResources();\n                ((DefaultFileSystemManager) vfs_manager).close();\n            }\n\n            // Step 12: Nullify the VFS manager reference\n            vfs_manager = null;\n\n            // Step 13: Pause briefly to allow background threads to terminate\n            Thread.sleep(10L);\n\n            // Step 14: Verify the temporary directory is either non-existent or empty\n            assertTemporaryDirectoryState(temporary_directory);\n\n            // Step 15: Close the global VFS singleton\n            VFS.close();\n        }\n    }\n\n    // Helper method for Step 14\n    private void assertTemporaryDirectoryState(File directory) {\n        if (directory != null && directory.exists()) {\n            assertTrue(directory.isDirectory(), \"Temporary directory should be a directory.\");\n            File[] files = directory.listFiles();\n            if (files != null) {\n                assertEquals(0, files.length, \"Temporary directory should be empty.\");\n            }\n        }\n    }\n}",
        "method_signature": "testIPv6UriResolution()"
      }
    },
    {
      "bucket": "tests_with_more_than_two_to_five_focal_methods",
      "nl2test_input": {
        "id": 705,
        "description": "Define a test method that validates the control encoding configuration mechanism of the FTP File System Config Builder by verifying bidirectional conversion between charset objects and string representations. Initialize a FileSystemOptions instance to serve as the configuration container, then obtain the singleton FtpFileSystemConfigBuilder instance that manages FTP-specific settings. Select a standard charset (UTF-8) and extract its string name representation to establish both object and string forms of the encoding. Configure the builder by invoking the string-based control encoding setter with the charset name and the options container, then immediately validate that retrieving the control encoding as a charset object returns the original charset instance and that retrieving it as a string returns the expected charset name. Having verified the string-to-object conversion path, reconfigure the same options by invoking the charset-based control encoding setter with the charset object directly, and upon completion of this second configuration, validate once more that both the charset object retrieval and string name retrieval return the expected values, thereby confirming that both setter variants produce equivalent internal state regardless of input type. The test uses JUnit for test execution and standard assertion methods for validation.",
        "project_name": "commons-vfs",
        "qualified_class_name": "org.apache.commons.vfs2.provider.ftp.FtpFileSystemConfigBuilderTest",
        "method_signature": "testControlEncoding()",
        "abstraction_level": "medium",
        "is_bdd": false
      },
      "nl2test_output": {
        "qualified_test_class_name": "FtpControlEncodingConfigTest",
        "code": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.apache.commons.vfs2.FileSystemOptions;\nimport org.apache.commons.vfs2.provider.ftp.FtpFileSystemConfigBuilder;\nimport java.nio.charset.Charset;\n\npublic class FtpControlEncodingConfigTest {\n\n    @Test\n    void testControlEncodingBidirectionalConversion() {\n        // Step 0: Initialize FileSystemOptions instance\n        FileSystemOptions fileSystemOptions = new FileSystemOptions();\n\n        // Step 1: Obtain FtpFileSystemConfigBuilder singleton instance\n        FtpFileSystemConfigBuilder ftpConfigBuilder = FtpFileSystemConfigBuilder.getInstance();\n\n        // Step 2: Select UTF-8 charset\n        Charset charsetObject = Charset.forName(\"UTF-8\");\n\n        // Step 3: Extract string name representation of the charset\n        String charsetName = charsetObject.name();\n\n        // Step 4: Configure control encoding using string-based setter with charset name and options container\n        ftpConfigBuilder.setControlEncoding(fileSystemOptions, charsetName);\n\n        // Step 5: Retrieve control encoding as a charset object\n        Charset retrievedCharsetObject = ftpConfigBuilder.getControlEncodingCharset(fileSystemOptions);\n\n        // Step 6: Assert retrieved charset object is the original charset instance\n        assertSame(charsetObject, retrievedCharsetObject, \"Retrieved Charset object should be the same instance as the original after string-based setter.\");\n\n        // Step 7: Retrieve control encoding as a string\n        String retrievedCharsetName = ftpConfigBuilder.getControlEncoding(fileSystemOptions);\n\n        // Step 8: Assert retrieved charset string name matches the expected charset name\n        assertEquals(charsetName, retrievedCharsetName, \"Retrieved Charset name should match the original after string-based setter.\");\n\n        // Step 9: Reconfigure control encoding using charset-based setter with charset object and options container\n        ftpConfigBuilder.setControlEncoding(fileSystemOptions, charsetObject);\n\n        // Step 10: Retrieve control encoding as a charset object\n        Charset retrievedCharsetObject2 = ftpConfigBuilder.getControlEncodingCharset(fileSystemOptions);\n\n        // Step 11: Assert retrieved charset object is the original charset instance\n        assertSame(charsetObject, retrievedCharsetObject2, \"Retrieved Charset object should be the same instance as the original after charset-based setter.\");\n\n        // Step 12: Retrieve control encoding as a string\n        String retrievedCharsetName2 = ftpConfigBuilder.getControlEncoding(fileSystemOptions);\n\n        // Step 13: Assert retrieved charset string name matches the expected charset name\n        assertEquals(charsetName, retrievedCharsetName2, \"Retrieved Charset name should match the original after charset-based setter.\");\n    }\n}",
        "method_signature": "testControlEncodingBidirectionalConversion()"
      }
    }
  ],
  "commons-fileupload": [
    {
      "bucket": "tests_with_more_than_ten_focal_methods",
      "nl2test_input": {
        "id": 242,
        "description": "Define a test method that validates the state transitions of a Disk File Item as data is written across a configurable threshold by encapsulating the test logic within an integer consumer lambda that accepts a threshold value as its parameter, then within this consumer establish a test directory path under the target directory using the test class name, create the necessary directory structure, and generate a temporary subdirectory within it before building a Disk File Item Factory configured with the provided threshold, the temporary directory path, and UTF-8 charset, after which confirm the factory's threshold matches the input value, then construct a Disk File Item from the factory's builder and verify its threshold also matches the expected value before creating a private helper method that validates the item's current state by checking the underlying Deferrable Output Stream's state enumeration value, memory residency flag, output file path presence relative to the expected parent directory, and if provided, the accumulated byte count and string content against the item's reported size and retrieved data, initially asserting the item is in initialized state with data in memory and no output file, then obtain the item's output stream and initialize a string builder to track written content, writing bytes in a loop up to one less than the threshold while appending each character to the builder and verifying after each write that the item remains in opened state with data still in memory and no persisted file, upon writing the final byte that reaches the threshold append it to the builder and confirm the item transitions to persisted state with data no longer in memory and an output file created in the temporary directory, close the output stream and validate the item enters closed state while maintaining the persisted file location and matching the builder's accumulated string content, finally invoke this consumer twice with distinct threshold values of 5 and 8193 to verify behavior across small and large buffer boundaries using JUnit 5.",
        "project_name": "commons-fileupload",
        "qualified_class_name": "org.apache.commons.fileupload2.core.DiskFileItemTest",
        "method_signature": "testStateModelWithPositiveThreshold()",
        "abstraction_level": "medium",
        "is_bdd": false
      },
      "nl2test_output": {
        "qualified_test_class_name": "org.apache.commons.fileupload2.core.DiskFileItemStateTransitionTest",
        "code": "package org.apache.commons.fileupload2.core;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.function.IntConsumer;\nimport java.nio.charset.StandardCharsets;\n\npublic class DiskFileItemStateTransitionTest {\n\n    private Path baseTestDirPath;\n\n    @BeforeEach\n    void setup() throws IOException {\n        baseTestDirPath = Paths.get(System.getProperty(\"java.io.tmpdir\"), getClass().getSimpleName()).toAbsolutePath();\n        Files.createDirectories(baseTestDirPath);\n    }\n\n    @AfterEach\n    void cleanup() throws IOException {\n        if (baseTestDirPath != null && Files.exists(baseTestDirPath)) {\n            FileUtils.deleteDirectory(baseTestDirPath.toFile());\n        }\n    }\n\n    // Step 0: Define private helper method to validate Disk File Item state\n    // Note: Cannot directly validate DeferrableOutputStream.State enum values as DiskFileItem does not expose the DeferrableOutputStream instance or its state directly.\n    // The helper method relies on isInMemory() and the existence of the stored file to infer the state.\n    private void validateDiskFileItemState(\n            DiskFileItem item,\n            boolean expectedInMemory,\n            Path expectedParentDirectory,\n            long expectedSize,\n            String expectedContent) throws IOException {\n\n        assertEquals(expectedInMemory, item.isInMemory(), \"In-memory status mismatch\");\n        assertEquals(expectedSize, item.getSize(), \"Size mismatch\");\n\n        if (expectedParentDirectory != null) {\n            // If a parent directory is expected, check if the store location exists and its parent matches\n            assertNotNull(item.getPath(), \"Store path should not be null when persisted\");\n            assertTrue(Files.exists(item.getPath()), \"Store file should exist when persisted\");\n            assertEquals(expectedParentDirectory.toAbsolutePath(), item.getPath().getParent().toAbsolutePath(),\n                    \"Store location parent directory mismatch\");\n        } else {\n            // If no parent directory is expected, store location should be null or not exist\n            // item.getPath() can return null if the item is still in memory and not yet written to disk.\n            if (item.getPath() != null) {\n                assertFalse(Files.exists(item.getPath()), \"Store file should not exist when not persisted\");\n            }\n        }\n\n        if (expectedContent != null) {\n            assertEquals(expectedContent, item.getString(StandardCharsets.UTF_8), \"Content mismatch\");\n        }\n    }\n\n    @Test\n    void testDiskFileItemStateTransitions() {\n        // Step 1: Define integer consumer lambda encapsulating Disk File Item state transition test logic\n        IntConsumer diskFileItemTestConsumer = threshold -> {\n            Path tempSubDirPath = null; // Declare outside try-catch\n            try {\n                // GIVEN\n                // Step 2/19: Set threshold value (already handled by lambda parameter)\n\n                // Step 3/20: Establish test directory path under target directory using the test class name\n                // This is now handled by the @BeforeEach and baseTestDirPath\n                Path testDirPath = baseTestDirPath;\n\n                // Step 4/21: Create necessary directory structure (handled by @BeforeEach)\n\n                // Step 5/22: Generate temporary subdirectory within the test directory\n                tempSubDirPath = Files.createTempDirectory(testDirPath, \"temp\"); // Assign here\n\n                // Step 6/23: Build Disk File Item Factory configured with the threshold, temporary directory path, and UTF-8 charset\n                DiskFileItemFactory factory = DiskFileItemFactory.builder()\n                        .setThreshold(threshold)\n                        .setPath(tempSubDirPath) // Set the temporary directory\n                        .setCharset(StandardCharsets.UTF_8) // Set UTF-8 charset\n                        .get();\n\n                // Step 7/24: Confirm the factory's threshold matches the input value\n                assertEquals(threshold, factory.getThreshold(), \"Factory threshold mismatch\");\n\n                // Step 8/25: Construct a Disk File Item from the factory's builder\n                DiskFileItem diskFileItem = factory.fileItemBuilder().get();\n\n                // Step 9/26: Verify the item's threshold also matches the expected value\n                assertEquals(threshold, diskFileItem.getThreshold(), \"DiskFileItem threshold mismatch\");\n\n                // THEN (Initial state check)\n                // Step 15/32: Assert the item is in initialized state with data in memory and no output file\n                validateDiskFileItemState(diskFileItem, true, null, 0L, null);\n\n                // WHEN\n                // Step 10/27: Obtain the item's output stream\n                OutputStream os = diskFileItem.getOutputStream();\n\n                // Step 11/28: Initialize a string builder to track written content\n                StringBuilder sb = new StringBuilder();\n\n                // Step 12/29: Write bytes in a loop up to one less than the threshold, appending each character to the string builder\n                for (int i = 0; i < threshold - 1; i++) {\n                    char c = (char) ('a' + (i % 26));\n                    os.write(c);\n                    sb.append(c);\n                    // Step 16/33: Verify the item remains in opened state with data still in memory and no persisted file after each write\n                    // Removed content assertion here as getString() might not be valid for partial writes to in-memory buffer.\n                    validateDiskFileItemState(diskFileItem, true, null, (long) (i + 1), null);\n                }\n\n                // Step 13/30: Write the final byte that reaches the threshold, appending it to the string builder\n                char lastChar = (char) ('a' + ((threshold - 1) % 26));\n                os.write(lastChar);\n                sb.append(lastChar);\n\n                // Step 17/34: Confirm the item transitions to persisted state with data no longer in memory and an output file created in the temporary directory\n                // Removed content assertion here as getString() might not be valid until stream is closed.\n                validateDiskFileItemState(diskFileItem, false, tempSubDirPath, (long) threshold, null);\n\n                // Step 14/31: Close the output stream\n                os.close();\n\n                // Step 18/35: Validate the item enters closed state while maintaining the persisted file location and matching the builder's accumulated string content\n                validateDiskFileItemState(diskFileItem, false, tempSubDirPath, (long) threshold, sb.toString());\n\n            } catch (IOException e) {\n                fail(\"IOException occurred during test for threshold \" + threshold + \": \" + e.getMessage());\n            } finally {\n                // Clean up the temporary subdirectory created within the consumer\n                try {\n                    if (tempSubDirPath != null && Files.exists(tempSubDirPath)) {\n                        FileUtils.deleteDirectory(tempSubDirPath.toFile());\n                    }\n                } catch (IOException e) {\n                    System.err.println(\"Failed to clean up temporary directory: \" + tempSubDirPath + \" - \" + e.getMessage());\n                }\n            }\n        };\n\n        // Invoke the consumer twice with distinct threshold values\n        diskFileItemTestConsumer.accept(5);\n        diskFileItemTestConsumer.accept(8193);\n    }\n}",
        "method_signature": "testDiskFileItemStateTransitions()"
      }
    },
    {
      "bucket": "tests_with_more_than_five_to_ten_focal_methods",
      "nl2test_input": {
        "id": 148,
        "description": "Define a test method that validates the Multipart Input Builder's rejection of insufficient buffer sizes by first preparing test data consisting of a short string and converting both the string and the class-level boundary constant to byte arrays, then wrapping the string bytes in a Byte Array Input Stream to serve as the data source. Obtain a new Multipart Input Builder instance and configure it by chaining the input stream setter, boundary setter, buffer size setter with a value of one byte, and progress notifier setter with a newly constructed Progress Notifier initialized with null listener and the content length derived from the byte array, then invoke the builder's get method to attempt construction of the Multipart Input instance. Assert that this construction attempt throws an Illegal Argument Exception, confirming that the builder enforces minimum buffer size constraints when the specified buffer is too small to accommodate the boundary token plus required overhead bytes. The test uses JUnit 5 for the assertion framework.",
        "project_name": "commons-fileupload",
        "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
        "method_signature": "testSmallBuffer()",
        "abstraction_level": "medium",
        "is_bdd": false
      },
      "nl2test_output": {
        "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputBuilderTest",
        "code": "package org.apache.commons.fileupload2.core;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport java.io.ByteArrayInputStream;\nimport java.lang.IllegalArgumentException;\n\npublic class MultipartInputBuilderTest {\n\n    @Test\n    void testRejectInsufficientBufferSize() {\n        // Step 0: Prepare a short string for test data\n        String short_string = \"a\";\n\n        // Step 1: Get the class-level boundary constant\n        byte[] boundary_constant = MultipartInput.BOUNDARY_PREFIX;\n\n        // Step 2: Convert the short string to a byte array\n        byte[] string_bytes = short_string.getBytes();\n\n        // Step 3: Wrap the string bytes in a Byte Array Input Stream to serve as the data source\n        ByteArrayInputStream data_input_stream = new ByteArrayInputStream(string_bytes);\n\n        // Step 4: Derive the content length from the byte array\n        long content_length = string_bytes.length;\n\n        // Step 5: Construct a Progress Notifier initialized with null listener and the content length\n        MultipartInput.ProgressNotifier progress_notifier = new MultipartInput.ProgressNotifier(null, content_length);\n\n        // Step 6: Obtain a new Multipart Input Builder instance\n        MultipartInput.Builder builder_instance = MultipartInput.builder();\n\n        // Step 7: Chain the input stream setter on the builder\n        // Assumed method name 'setInputStream' based on common builder patterns. Tools could not locate this method, proceeding with assumption.\n        MultipartInput.Builder builder_with_input = builder_instance.setInputStream(data_input_stream);\n\n        // Step 8: Chain the boundary setter\n        MultipartInput.Builder builder_with_boundary = builder_with_input.setBoundary(boundary_constant);\n\n        // Step 9: Chain the buffer size setter with a value of one byte\n        // Assumed method name 'setBufferSize' based on common builder patterns. Tools could not locate this method, proceeding with assumption.\n        MultipartInput.Builder builder_with_buffer_size = builder_with_boundary.setBufferSize(1);\n\n        // Step 10: Chain the progress notifier setter\n        MultipartInput.Builder fully_configured_builder = builder_with_buffer_size.setProgressNotifier(progress_notifier);\n\n        // Step 11 & 12: Invoke the builder's get method to attempt construction of the Multipart Input instance\n        // Assert that an IllegalArgumentException is thrown\n        Assertions.assertThrows(IllegalArgumentException.class, () -> {\n            fully_configured_builder.get();\n        });\n    }\n}",
        "method_signature": "testRejectInsufficientBufferSize()"
      }
    },
    {
      "bucket": "tests_with_two_focal_methods",
      "nl2test_input": {
        "id": 130,
        "description": "Define a test class that validates the behavior of a Deferrable Output Stream when configured with a threshold of negative one, ensuring immediate file persistence without in-memory buffering. Declare a static final Path field pointing to a base test directory, a static Path field for a temporary test directory, and a Supplier field that provides temporary file paths. Implement a static setup method that creates the base test directory structure and generates a temporary subdirectory within it using the Files utility. Within the test method, initialize an array to hold a reference to the stream instance for verification after closure, then construct a Runnable that encapsulates the test logic. Inside this Runnable, instantiate a Deferrable Output Stream with a threshold of negative one, passing the test file supplier and a null listener, capturing the instance in the array for post-closure inspection. While the stream remains open within a try-with-resources block, verify that the stream is not in memory mode by asserting false on the in-memory check, confirm that a file path has been assigned by asserting the path is not null, and validate that no byte array representation exists by asserting the bytes accessor returns null. Upon exiting the try-with-resources block and closing the stream, retrieve the stream reference from the array and reconfirm it is not in memory mode, assert the path remains non-null, and verify the path points to a regular file using the Files utility. Obtain an input stream from the closed Deferrable Output Stream and create a private helper method that reads all bytes from an input stream into a byte array by buffering chunks until end-of-stream is reached. Read the complete contents from the input stream into an actual byte array using this helper, then construct an expected byte array representing an empty UTF-8 encoded string, and assert the actual bytes match the expected empty array. Execute the Runnable to perform all configured verifications. The test uses standard assertion methods from a testing framework without specifying teardown for the temporary file resources.",
        "project_name": "commons-fileupload",
        "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
        "method_signature": "testThresholdMinusOne()",
        "abstraction_level": "medium",
        "is_bdd": false
      },
      "nl2test_output": {
        "qualified_test_class_name": "org.example.DeferrableOutputStreamNegativeThresholdTest",
        "code": "package org.example; // Align with SUT package if necessary\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.fileupload2.core.DeferrableOutputStream;\n\npublic class DeferrableOutputStreamNegativeThresholdTest {\n\n    // Step 0: Declare a static final Path field pointing to a base test directory\n    private static final Path BASE_TEST_DIRECTORY_PATH = Paths.get(\"target\", \"test-temp\");\n\n    // Step 1: Declare a static Path field for a temporary test directory\n    private static Path temporaryTestDirectoryPath;\n\n    // Step 2: Declare a Supplier field that provides temporary file paths\n    private static Supplier<Path> temporaryFilePathSupplier;\n\n    @BeforeAll\n    static void setup() throws IOException {\n        // Step 3: Create the base test directory structure\n        Files.createDirectories(BASE_TEST_DIRECTORY_PATH);\n\n        // Step 4: Generate a temporary subdirectory within the base test directory using the Files utility\n        temporaryTestDirectoryPath = Files.createTempDirectory(BASE_TEST_DIRECTORY_PATH, \"tempDir\");\n\n        // Initialize the supplier to provide temporary file paths within the generated temporary directory\n        temporaryFilePathSupplier = () -> {\n            try {\n                return Files.createTempFile(temporaryTestDirectoryPath, \"test\", \".tmp\");\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n    }\n\n    @Test\n    void testNegativeThresholdImmediatePersistence() {\n        // Step 5: Initialize an array to hold a reference to the stream instance for verification after closure\n        final DeferrableOutputStream[] streamInstanceArray = new DeferrableOutputStream[1];\n\n        // Step 7: Construct an expected byte array representing an empty UTF-8 encoded string\n        final byte[] expectedEmptyByteArray = \"\".getBytes(StandardCharsets.UTF_8);\n\n        // Step 8: Construct a Runnable that encapsulates the test logic\n        Runnable testLogicRunnable = () -> {\n            try (DeferrableOutputStream deferrableOutputStream = new DeferrableOutputStream(-1, temporaryFilePathSupplier, null)) {\n                // Capture the instance for post-closure inspection\n                streamInstanceArray[0] = deferrableOutputStream;\n\n                // Step 12: Verify that the stream is not in memory mode by asserting false on the in-memory check\n                assertFalse(deferrableOutputStream.isInMemory());\n                // Step 13: Confirm that a file path has been assigned by asserting the path is not null\n                assertNotNull(deferrableOutputStream.getPath());\n                // Step 14: Validate that no byte array representation exists by asserting the bytes accessor returns null\n                assertNull(deferrableOutputStream.getBytes());\n\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n\n            // After try-with-resources block, the stream is closed\n            DeferrableOutputStream closedDeferrableOutputStream = streamInstanceArray[0];\n\n            // Step 16: Reconfirm the closed stream is not in memory mode\n            assertFalse(closedDeferrableOutputStream.isInMemory());\n            // Step 17: Assert the path of the closed stream remains non-null\n            assertNotNull(closedDeferrableOutputStream.getPath());\n            // Step 18: Verify the path points to a regular file using the Files utility\n            assertTrue(Files.isRegularFile(closedDeferrableOutputStream.getPath()));\n\n            try (InputStream inputStream = closedDeferrableOutputStream.getInputStream()) {\n                // Step 20: Read the complete contents from the input stream into an actual byte array using the helper method\n                byte[] actualByteArray = readAllBytes(inputStream);\n                // Step 21: Assert the actual bytes match the expected empty array\n                assertArrayEquals(expectedEmptyByteArray, actualByteArray);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n\n        // Step 9: Execute the Runnable to perform all configured verifications\n        testLogicRunnable.run();\n    }\n\n    // Step 6: Define a private helper method that reads all bytes from an input stream into a byte array\n    private static byte[] readAllBytes(InputStream inputStream) throws IOException {\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int nRead;\n        byte[] data = new byte[1024];\n        while ((nRead = inputStream.read(data, 0, data.length)) != -1) {\n            buffer.write(data, 0, nRead);\n        }\n        return buffer.toByteArray();\n    }\n}",
        "method_signature": "testNegativeThresholdImmediatePersistence()"
      }
    }
  ],
  "commons-jexl": [
    {
      "bucket": "tests_with_more_than_five_to_ten_focal_methods",
      "nl2test_input": {
        "id": 596,
        "description": "Define a test method that validates script execution behavior when ambiguous statement syntax is enabled in the JEXL engine. Begin by constructing a JexlFeatures instance using the default feature set, then invoke the configuration method to enable ambiguous statement support, passing a boolean true value. Immediately verify that the features instance confirms ambiguous statement support is active by asserting the corresponding query method returns true. With the configured features, instantiate a JexlBuilder, apply the features configuration to it, and invoke the creation method to produce a JexlEngine instance. Construct a source string representing a JEXL script that declares a local variable initialized to an array literal, defines a function accepting a constant parameter that appends values to the previously declared variable, invokes this function twice with distinct integer arguments, and returns the variable. Using the engine, invoke the script creation method with the source string to produce a JexlScript instance, then assert the script object is not null. Execute the script by invoking its execution method with a null context, capturing the returned object. Assert that the execution result is an instance of List, then cast the result to a List and store it in a variable named values. Finally, verify that the size of the values list equals two by asserting the list's size method returns the expected integer. This test uses JUnit 5 for the test framework and standard JUnit assertions.",
        "project_name": "commons-jexl",
        "qualified_class_name": "org.apache.commons.jexl3.Issues400Test",
        "method_signature": "test437b()",
        "abstraction_level": "medium",
        "is_bdd": false
      },
      "nl2test_output": {
        "qualified_test_class_name": "org.example.JexlAmbiguousStatementTest",
        "code": "package org.example;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.apache.commons.jexl3.JexlBuilder;\nimport org.apache.commons.jexl3.JexlEngine;\nimport org.apache.commons.jexl3.JexlFeatures;\nimport org.apache.commons.jexl3.JexlScript;\nimport java.util.List;\n\npublic class JexlAmbiguousStatementTest {\n\n    @Test\n    void testAmbiguousStatementExecution() {\n        // Step 0: Construct JexlFeatures instance using the default feature set\n        JexlFeatures jexlFeatures = JexlFeatures.createDefault();\n\n        // Step 1: Enable ambiguous statement support in JexlFeatures with boolean true\n        JexlFeatures configuredJexlFeatures = jexlFeatures.ambiguousStatement(true);\n\n        // Step 2: Verify JexlFeatures confirms ambiguous statement support is active\n        assertTrue(configuredJexlFeatures.supportsAmbiguousStatement(), \"Ambiguous statement support should be active\");\n\n        // Step 3: Instantiate a JexlBuilder\n        JexlBuilder jexlBuilder = new JexlBuilder();\n\n        // Step 4: Apply configured JexlFeatures to JexlBuilder\n        JexlBuilder configuredJexlBuilder = jexlBuilder.features(configuredJexlFeatures);\n\n        // Step 5: Create JexlEngine instance from JexlBuilder\n        JexlEngine jexlEngine = configuredJexlBuilder.create();\n\n        // Step 6: Construct a source string for a JEXL script\n        String scriptSourceString = \n            \"var x = new java.util.ArrayList();\\n\" +\n            \"function add(y) {\\n\" +\n            \"  x.add(y);\\n\" +\n            \"}\\n\" +\n            \"add(10);\\n\" +\n            \"add(20);\\n\" +\n            \"return x;\";\n\n        // Step 7: Create a JexlScript instance using the JexlEngine and script source string\n        JexlScript jexlScript = jexlEngine.createScript(scriptSourceString);\n\n        // Step 9: Assert the JexlScript object is not null\n        assertNotNull(jexlScript, \"JexlScript should not be null\");\n\n        // Step 8: Execute the JexlScript with a null context\n        Object executionResult = jexlScript.execute(null);\n\n        // Step 10: Assert the execution result is an instance of List\n        assertTrue(executionResult instanceof List, \"Execution result should be an instance of List\");\n\n        // Step 11: Cast the execution result to a List\n        @SuppressWarnings(\"unchecked\")\n        List<Object> valuesList = (List<Object>) executionResult;\n\n        // Step 12: Verify the size of the values list equals two\n        assertEquals(2, valuesList.size(), \"The list should contain two elements\");\n    }\n}",
        "method_signature": "testAmbiguousStatementExecution()"
      }
    },
    {
      "bucket": "tests_with_more_than_two_to_five_focal_methods",
      "nl2test_input": {
        "id": 311,
        "description": "Define a test method that validates template string interpolation within a function defined in a JEXL script by first instantiating a JEXL Engine through the Builder and creating an empty Map Context to serve as the evaluation environment. Construct a multi-line script source string that declares a variable with a string value, defines a function accepting a parameter, and uses template literal syntax to interpolate both the outer variable and the function parameter, then invokes that function with a string argument. Pass this script source to the engine's script creation method to obtain a compiled Script instance. Execute the compiled script against the context, capturing the returned result object. Assert that the result equals the expected concatenated string formed by interpolating the variable and argument values within the template literal, confirming that the engine correctly resolves both lexical scope variables and function parameters during template string evaluation. This test uses JUnit 5 for the testing framework and JUnit 5 Assertions for verification.",
        "project_name": "commons-jexl",
        "qualified_class_name": "org.apache.commons.jexl3.Issues400Test",
        "method_signature": "testIssue442()",
        "abstraction_level": "medium",
        "is_bdd": false
      },
      "nl2test_output": {
        "qualified_test_class_name": "org.example.JexlTemplateStringInterpolationTest",
        "code": "package org.example;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.apache.commons.jexl3.JexlBuilder;\nimport org.apache.commons.jexl3.JexlEngine;\nimport org.apache.commons.jexl3.JexlContext;\nimport org.apache.commons.jexl3.MapContext;\nimport org.apache.commons.jexl3.JexlScript;\n\npublic class JexlTemplateStringInterpolationTest {\n\n    @Test\n    void testTemplateStringInterpolationInFunction() {\n        // Step 0: Instantiate JEXL Engine using its Builder\n        JexlEngine jexlEngine = new JexlBuilder().create();\n\n        // Step 1: Create an empty Map Context for evaluation environment\n        JexlContext jexlContext = new MapContext();\n\n        // Step 2: Construct a multi-line JEXL script source string\n        String script_source_string = \"var name = 'World';\\n\" +\n                                    \"function greet(person) {\\n\" +\n                                    \"    return `Hello, ${name} from ${person}!`;\\n\" +\n                                    \"}\\n\" +\n                                    \"greet('JEXL');\";\n\n        // Step 3: Define the expected concatenated string result from the interpolation\n        String expected_result = \"Hello, World from JEXL!\";\n\n        // Step 4: Create a compiled Script instance from the script source using the JEXL Engine\n        JexlScript compiled_script = jexlEngine.createScript(script_source_string);\n\n        // Step 5: Execute the compiled script against the JEXL Context\n        Object script_execution_result = compiled_script.execute(jexlContext);\n\n        // Step 6: Assert that the script execution result equals the expected interpolated string\n        assertEquals(expected_result, script_execution_result);\n    }\n}",
        "method_signature": "testTemplateStringInterpolationInFunction()"
      }
    },
    {
      "bucket": "tests_with_two_focal_methods",
      "nl2test_input": {
        "id": 270,
        "description": "Define a test method that verifies the JEXL engine builder rejects invalid package imports by first configuring a Java utility logger to suppress all but severe-level messages from the JEXL engine class during setup, then constructing a single-element collection containing an invalid package name string and passing this collection to the builder's import configuration method before invoking the engine creation operation, at which point validate that a JEXL-specific exception is thrown to indicate the import validation failure, and upon completion invoke a helper method that performs debugger state verification to ensure no residual debugging artifacts remain from the engine instantiation attempt, using JUnit 5 for test execution and assertions.",
        "project_name": "commons-jexl",
        "qualified_class_name": "org.apache.commons.jexl3.internal.FqcnTest",
        "method_signature": "testBadImport0()",
        "abstraction_level": "medium",
        "is_bdd": false
      },
      "nl2test_output": {
        "qualified_test_class_name": "org.apache.commons.jexl3.JexlBuilderInvalidPackageImportTest",
        "code": "package org.apache.commons.jexl3;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.Collections;\nimport java.util.Collection;\nimport java.util.logging.Logger;\nimport java.util.logging.Level;\n\npublic class JexlBuilderInvalidPackageImportTest {\n\n    @Test\n    void testInvalidPackageImportRejection() {\n        // Step 0: Configure Java utility logger to suppress all but severe-level messages from JEXL engine class\n        Logger logger = Logger.getLogger(\"org.apache.commons.jexl3.JexlEngine\");\n        logger.setLevel(Level.SEVERE);\n\n        // Step 1: Construct a single-element collection containing an invalid package name string\n        Collection<String> invalidPackageCollection = Collections.singletonList(\"java.lang.InvalidPackage\");\n\n        // Step 2: Pass the invalid package collection to the builder's import configuration method\n        // Step 3: Invoke the JEXL engine creation operation (this is done inside assertThrows)\n        JexlBuilder jexlEngineBuilder = new JexlBuilder().imports(invalidPackageCollection);\n\n        // Step 4: Validate that a JEXL-specific exception is thrown\n        assertThrows(JexlException.class, () -> jexlEngineBuilder.create());\n\n        // Step 5: Invoke helper method for debugger state verification to ensure no residual debugging artifacts remain\n        new org.apache.commons.jexl3.internal.Debugger().reset();\n    }\n}",
        "method_signature": "testInvalidPackageImportRejection()"
      }
    }
  ]
}