[
  {
    "compiles": false,
    "nl2test_input": {
      "id": 43,
      "description": "Define a test class that validates YAML configuration parsing behavior by establishing a temporary directory field for file storage, a string field containing YAML content with nested keys and list values, and a YAML Configuration instance field. In the setup phase, instantiate the YAML Configuration object and load the YAML content by reading from a file reader initialized with the YAML string. For the test method, retrieve the property value associated with the nested key path \"key5.example\" from the loaded configuration, storing the result as an object reference. Upon retrieval, assert that the returned property equals a list containing two empty string elements followed by a string value element, verifying that the configuration correctly parses YAML sequences with empty and non-empty string entries. This test uses JUnit 5 for the testing framework.",
      "project_name": "commons-configuration",
      "qualified_class_name": "org.apache.commons.configuration2.TestYAMLConfiguration",
      "method_signature": "testDoubleStringValues()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.configuration2.YamlConfigurationParsingTest",
      "code": "package org.apache.commons.configuration2;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class YamlConfigurationParsingTest {\n\n    @TempDir\n    Path tempDir;\n\n    private String yamlContent;\n    private YAMLConfiguration yamlConfiguration;\n\n    @BeforeEach\n    void setUp() throws IOException, ConfigurationException {\n        // Define the YAML content with nested keys and list values, including empty and non-empty strings.\n        yamlContent = \"key5:\\n\" +\n                      \"  example:\\n\" +\n                      \"    - \\\"\\\"\\n\" +\n                      \"    - \\\"\\\"\\n\" +\n                      \"    - \\\"value\\\"\\n\";\n\n        // Create a temporary file to store the YAML content\n        File tempFile = tempDir.resolve(\"test_config.yaml\").toFile();\n        Files.writeString(tempFile.toPath(), yamlContent);\n\n        // Instantiate YAML Configuration\n        yamlConfiguration = new YAMLConfiguration();\n\n        // Load the YAML content from the temporary file\n        yamlConfiguration.read(new FileReader(tempFile));\n    }\n\n    @Test\n    void testYamlSequenceParsingWithEmptyAndNonEmptyStrings() {\n        // Retrieve the property value associated with the nested key path \"key5.example\"\n        Object actualValue = yamlConfiguration.getProperty(\"key5.example\");\n\n        // Define the expected list\n        List<String> expectedList = Arrays.asList(\"\", \"\", \"value\");\n\n        // Assert that the returned property equals the expected list\n        Assertions.assertEquals(expectedList, actualValue, \"The YAML list parsing with empty and non-empty strings should be correct.\");\n    }\n}",
      "method_signature": "testDoubleStringValues()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 27599,
    "output_tokens": 1730,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 44,
      "description": "Create a test case to validate that the configuration system correctly processes hierarchical settings containing multiple empty text entries followed by an actual value. Before executing the test, establish a temporary workspace and prepare the configuration system by loading a predefined settings document from a file source. Once the system has ingested the configuration, retrieve the setting located under the nested path designated as \"key5.example\" and capture the returned information. Verify that the system accurately preserves the structure of this setting as a sequence containing two empty text entries followed by the text \"value\", ensuring that the configuration parser maintains the exact order and presence of empty values rather than discarding or collapsing them. The test uses JUnit 5 for test execution and standard equality assertions to confirm the retrieved setting matches the expected sequence of values.",
      "project_name": "commons-configuration",
      "qualified_class_name": "org.apache.commons.configuration2.TestYAMLConfiguration",
      "method_signature": "testDoubleStringValues()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.configuration2.HierarchicalEmptyValuesTest",
      "code": "package org.apache.commons.configuration2;\n\nimport org.apache.commons.configuration2.XMLConfiguration;\nimport org.apache.commons.configuration2.builder.fluent.Configurations;\nimport org.apache.commons.configuration2.ex.ConfigurationException;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class HierarchicalEmptyValuesTest {\n\n    @Test\n    void testHierarchicalSettingWithEmptyValues(@TempDir Path tempDir) throws IOException, ConfigurationException {\n        // Prepare the configuration content with multiple empty text entries followed by an actual value\n        String configContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\"\n                               + \"<configuration>\\n\"\n                               + \"  <key5>\\n\"\n                               + \"    <example></example>\\n\"\n                               + \"    <example></example>\\n\"\n                               + \"    <example>value</example>\\n\"\n                               + \"  </key5>\\n\"\n                               + \"</configuration>\";\n\n        // Create a temporary XML file to load the configuration from\n        Path tempFile = tempDir.resolve(\"test_hierarchical_empty_values.xml\");\n        Files.writeString(tempFile, configContent);\n\n        // Establish the configuration system by loading the predefined settings document\n        Configurations configs = new Configurations();\n        XMLConfiguration config = configs.xml(tempFile.toFile());\n\n        // Retrieve the setting located under the nested path \"key5.example\"\n        List<Object> retrievedValues = config.getList(\"key5.example\");\n\n        // Verify that the system accurately preserves the structure as a sequence containing\n        // two empty text entries followed by the text \"value\"\n        List<String> expectedValues = Arrays.asList(\"\", \"\", \"value\");\n        Assertions.assertEquals(expectedValues, retrievedValues,\n            \"The hierarchical setting should correctly preserve the order and presence of empty values.\");\n    }\n}",
      "method_signature": "testDoubleStringValues()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6162,
    "output_tokens": 3453,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 76,
      "description": "Define a test class containing a public field `tempFolder` of type `java.io.File` annotated with `@TempDir`, a private final field `testYaml` of type `java.lang.String`, and a private field `yamlConfiguration` of type `org.apache.commons.configuration2.YAMLConfiguration`. In a setup method annotated with `@BeforeEach` that declares `throws Exception`, instantiate a new `YAMLConfiguration` object using its no-argument constructor and assign it to `yamlConfiguration`, then immediately invoke the `read` method on `yamlConfiguration` passing a newly constructed `FileReader` initialized with the `testYaml` string as its argument. Within the test method annotated with `@Test`, invoke `getProperty` on `yamlConfiguration` with the string literal `\"key5.example\"` as the argument and assign the returned `Object` to a local variable named `property`. Following this retrieval, assert equality by invoking `assertEquals` with two arguments: first, create a list by calling `Arrays.asList` with three string arguments in order\u2014an empty string `\"\"`, another empty string `\"\"`, and the string literal `\"value\"`\u2014and second, pass the `property` variable, thereby verifying that the retrieved property matches the expected list of three strings where the first two are empty and the third is `\"value\"`. The test uses JUnit 5 assertions and the `@TempDir` annotation from JUnit 5, with no teardown logic, no mocking libraries, and no additional class-level or method-level annotations beyond `@Test` on the test method and `@TempDir` on the field.",
      "project_name": "commons-configuration",
      "qualified_class_name": "org.apache.commons.configuration2.TestYAMLConfiguration",
      "method_signature": "testDoubleStringValues()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.configuration2.YAMLConfigurationTestNew",
      "code": "package org.apache.commons.configuration2;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class YAMLConfigurationTestNew {\n\n    @TempDir\n    public File tempFolder;\n\n    private final String testYaml =\n            \"key5:\\n\" +\n            \"  example:\\n\" +\n            \"    - \\\"\\\"\\n\" +\n            \"    - \\\"\\\"\\n\" +\n            \"    - \\\"value\\\"\\n\";\n\n    private YAMLConfiguration yamlConfiguration;\n\n    @BeforeEach\n    void setUp() throws Exception {\n        Path yamlFilePath = tempFolder.toPath().resolve(\"test.yaml\");\n        try (FileWriter writer = new FileWriter(yamlFilePath.toFile())) {\n            writer.write(testYaml);\n        }\n        yamlConfiguration = new YAMLConfiguration();\n        yamlConfiguration.read(new FileReader(yamlFilePath.toFile()));\n    }\n\n    @Test\n    void testGetPropertyWithYamlList() {\n        Object property = yamlConfiguration.getProperty(\"key5.example\");\n        List<String> expected = Arrays.asList(\"\", \"\", \"value\");\n        assertEquals(expected, property);\n    }\n}",
      "method_signature": "testDoubleStringValues()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.8871,
      "line_coverage": 0.7956,
      "branch_coverage": 0.9512
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6348,
    "output_tokens": 3665,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  }
]