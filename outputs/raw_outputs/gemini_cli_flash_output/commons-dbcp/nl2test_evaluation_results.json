[
  {
    "compiles": true,
    "nl2test_input": {
      "id": 30,
      "description": "Define a test method annotated with `@Test` that verifies the behavior of the `clear` method on instances of `CharArray`. Begin by instantiating a new `CharArray` with a null `String` argument by calling `new CharArray((String) null)`, then immediately chain `clear()` on this instance, followed by `get()` to retrieve the internal char array, and assert that the result is null using `assertNull`. Next, create a second `CharArray` instance by passing an empty `String` literal `\"\"` to the constructor, chain `clear()` on this instance, then invoke `get()` to obtain the char array, and use `assertArrayEquals` to verify that the result matches the char array produced by `\"\".toCharArray()`. Finally, instantiate a third `CharArray` with the `String` literal `\"foo\"`, chain `clear()` on this instance, invoke `get()` to retrieve the char array, and assert using `assertArrayEquals` that the result equals the char array produced by `\"\\\\0\\\\0\\\\0\".toCharArray()`, which represents three null characters. The test uses JUnit 5 Assertions with method-level annotation `@Test`.",
      "project_name": "commons-dbcp",
      "qualified_class_name": "org.apache.commons.dbcp2.datasources.CharArrayTest",
      "method_signature": "testClear()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.dbcp2.datasources.CharArrayClearMethodTest",
      "code": "package org.apache.commons.dbcp2.datasources;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Assertions;\n\npublic class CharArrayClearMethodTest {\n\n    @Test\n    void testClearMethodBehavior() {\n        // Instantiate a new CharArray with a null String argument, call clear(), then get(), and assert that the result is null.\n        CharArray charArray1 = new CharArray((String) null);\n        charArray1.clear();\n        Assertions.assertNull(charArray1.get());\n\n        // Create a second CharArray instance by passing an empty String literal \"\", chain clear() on this instance,\n        // then invoke get() to obtain the char array, and use assertArrayEquals to verify that the result matches\n        // the char array produced by \"\".toCharArray().\n        CharArray charArray2 = new CharArray(\"\");\n        charArray2.clear();\n        Assertions.assertArrayEquals(\"\".toCharArray(), charArray2.get());\n\n        // Instantiate a third CharArray with the String literal \"foo\", chain clear() on this instance,\n        // invoke get() to retrieve the char array, and assert using assertArrayEquals that the result equals\n        // the char array produced by \"\\0\\0\\0\".toCharArray().\n        CharArray charArray3 = new CharArray(\"foo\");\n        charArray3.clear();\n        Assertions.assertArrayEquals(new char[] {'\\0', '\\0', '\\0'}, charArray3.get());\n    }\n}",
      "method_signature": "testClear()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.9286,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.5556,
      "line_coverage": 0.3333,
      "branch_coverage": 0.75
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 5791,
    "output_tokens": 3278,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 37,
      "description": "Create a test case to validate that the credential clearing mechanism properly sanitizes authentication information across all possible initial states, ensuring sensitive data is securely removed from memory after use. Begin by establishing scenarios where credentials are configured with missing information, empty values, and populated data, then invoke the clearing operation on each credential set and verify the resulting state matches security requirements. When credentials were initially missing, confirm the cleared state remains absent; when credentials were initially empty, ensure they remain empty after clearing; when credentials contained actual values, verify they are overwritten with nullified characters to prevent memory exposure. Validate this behavior for both the account identifier and secret across all representation formats, confirming that the clearing operation consistently transforms sensitive information into a safe state regardless of how the credentials were originally stored. Use JUnit 5 for the testing framework and standard equality assertions to verify the expected outcomes after each clearing operation.",
      "project_name": "commons-dbcp",
      "qualified_class_name": "org.apache.commons.dbcp2.datasources.UserPassKeyTest",
      "method_signature": "testClear()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.dbcp2.datasources.UserPassKeyCredentialClearingTest",
      "code": "package org.apache.commons.dbcp2.datasources;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.Test;\n\nclass UserPassKeyCredentialClearingTest {\n\n    @Test\n    void testCredentialClearingMechanism() {\n        // Scenario 1: Initially Missing/Null Credentials\n        // A UserPassKey created with null username and password.\n        // UserPassKey(String, char[]) constructor handles null char[] by creating CharArray(null).\n        // UserPassKey(String) constructor handles null String by creating CharArray(null).\n        final UserPassKey nullUserNullPass = new UserPassKey(null, (char[]) null);\n\n        // Clear the credentials\n        nullUserNullPass.clear();\n\n        // Verify that null credentials remain null\n        assertNull(nullUserNullPass.getUserName(), \"Username should remain null after clearing if initially null.\");\n        assertNull(nullUserNullPass.getPasswordCharArray(), \"Password should remain null after clearing if initially null.\");\n\n        // Scenario 2: Initially Empty Credentials\n        // A UserPassKey created with empty username string and empty password char array.\n        // CharArray(String) with \"\" results in char[0].\n        // CharArray(char[]) with new char[0] results in char[0].\n        final UserPassKey emptyUserEmptyPass = new UserPassKey(\"\", new char[0]);\n\n        // Clear the credentials\n        emptyUserEmptyPass.clear();\n\n        // Verify that empty credentials remain empty\n        assertEquals(\"\", emptyUserEmptyPass.getUserName(), \"Username should remain empty after clearing if initially empty.\");\n        assertNotNull(emptyUserEmptyPass.getPasswordCharArray(), \"Password char array should not be null if initially empty.\");\n        assertEquals(0, emptyUserEmptyPass.getPasswordCharArray().length, \"Password char array should remain empty after clearing if initially empty.\");\n        assertArrayEquals(new char[0], emptyUserEmptyPass.getPasswordCharArray(), \"Password char array should contain an empty array.\");\n\n        // Scenario 3: Initially Populated Credentials\n        final String initialUsername = \"secureUser\";\n        final char[] initialPassword = \"superSecretPassword\".toCharArray();\n        final int usernameLength = initialUsername.length();\n        final int passwordLength = initialPassword.length;\n\n        final UserPassKey populatedKey = new UserPassKey(initialUsername, initialPassword);\n\n        // Clear the credentials\n        populatedKey.clear();\n\n        // Verify username is overwritten with null characters\n        final String clearedUsername = populatedKey.getUserName();\n        assertNotNull(clearedUsername, \"Cleared username should not be null.\");\n        assertEquals(usernameLength, clearedUsername.length(), \"Cleared username length should match original length.\");\n        // All characters in the cleared username string should be '\\0'\n        assertTrue(clearedUsername.chars().allMatch(c -> c == '\\0'), \"All characters in the cleared username should be null characters.\");\n\n        // Verify password char array is overwritten with null characters\n        final char[] clearedPassword = populatedKey.getPasswordCharArray();\n        assertNotNull(clearedPassword, \"Cleared password char array should not be null.\");\n        assertEquals(passwordLength, clearedPassword.length, \"Cleared password char array length should match original length.\");\n        // All characters in the cleared password char array should be '\\0'\n        final char[] expectedNullChars = new char[passwordLength];\n        Arrays.fill(expectedNullChars, '\\0');\n        assertArrayEquals(expectedNullChars, clearedPassword, \"All characters in the cleared password char array should be null characters.\");\n    }\n}",
      "method_signature": "testClear()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 0.6667,
      "assertion_precision": 0.5,
      "callable_recall": 0.5,
      "callable_precision": 0.5938,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.8125,
      "line_coverage": 0.8333,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "search_file_content": 6,
          "read_file": 3
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 85429,
    "output_tokens": 5554,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 38,
      "description": "Create a test case to validate that the connection management system correctly updates credential information when a new password is provided as text input. Begin by establishing a connection factory configured with an initial set of credentials including a username and password, along with connection parameters such as timeout settings and validation preferences. Once the factory is initialized with these baseline credentials, simulate a scenario where the system administrator needs to change the password by providing a new password value as a text string. After updating the password through the system's credential management interface, verify that the connection factory has properly stored and will use this new password for future authentication attempts by confirming the updated password matches the newly provided value when retrieved from the factory's configuration. Use JUnit 5 as the testing framework with standard equality assertions to confirm the password update was successful.",
      "project_name": "commons-dbcp",
      "qualified_class_name": "org.apache.commons.dbcp2.datasources.TestCPDSConnectionFactory",
      "method_signature": "testSetPasswordString()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.dbcp2.BasicDataSourcePasswordUpdateTest",
      "code": "package org.apache.commons.dbcp2;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.sql.SQLException;\nimport java.time.Duration;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class BasicDataSourcePasswordUpdateTest {\n\n    private BasicDataSource basicDataSource;\n\n    @BeforeEach\n    public void setUp() {\n        basicDataSource = new BasicDataSource();\n        // Configure with an initial set of credentials and connection parameters\n        basicDataSource.setDriverClassName(\"org.h2.Driver\"); // Using H2 for an in-memory database\n        basicDataSource.setUrl(\"jdbc:h2:mem:test;DB_CLOSE_DELAY=-1\"); // In-memory database, connection persists until JVM exits\n        basicDataSource.setUsername(\"initialUser\");\n        basicDataSource.setPassword(\"initialPassword\");\n        basicDataSource.setMaxWaitDuration(Duration.ofSeconds(10)); // Example timeout setting\n        basicDataSource.setValidationQuery(\"SELECT 1\"); // Example validation query\n        basicDataSource.setTestOnBorrow(true); // Example validation preference\n    }\n\n    @Test\n    public void testPasswordUpdate() throws SQLException {\n        // Verify initial password\n        assertEquals(\"initialPassword\", basicDataSource.getPassword(), \"The initial password should be correctly set.\");\n\n        // Simulate system administrator updating the password\n        String newPassword = \"newSecurePassword\";\n        basicDataSource.setPassword(newPassword);\n\n        // Verify that the connection factory has properly stored and will use this new password\n        assertEquals(newPassword, basicDataSource.getPassword(), \"The password in BasicDataSource should be updated to the new value.\");\n    }\n}",
      "method_signature": "testSetPasswordString()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 2
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 52583,
    "output_tokens": 2179,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 39,
      "description": "Create a test case to validate that the connection pooling system correctly manages the read-only configuration setting for the default user pool through its complete lifecycle of state transitions. Begin by establishing a fresh connection pooling system with no initial read-only preference configured. Verify that when no preference has been set, the system indicates the read-only setting is absent. Next, enable the read-only mode for the default user pool and confirm the system reflects this enabled state. Then disable the read-only mode and ensure the system accurately reports it as disabled. Re-enable the read-only mode once more to verify the system can toggle back to the enabled state successfully. Finally, clear the read-only preference entirely by removing any configured value and confirm the system returns to indicating no read-only setting is present. After completing these state transitions, release the connection pooling system resources. The test uses JUnit 5 as the testing framework with standard equality assertions to verify each configuration state matches the expected business outcome.",
      "project_name": "commons-dbcp",
      "qualified_class_name": "org.apache.commons.dbcp2.datasources.TestPerUserPoolDataSource",
      "method_signature": "testDefaultReadOnly()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.dbcp2.BasicDataSourceReadOnlyLifecycleTest",
      "code": "package org.apache.commons.dbcp2;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\nclass BasicDataSourceReadOnlyLifecycleTest {\n\n    @Test\n    void testDefaultReadOnlyLifecycle() throws Exception {\n        // Use try-with-resources to ensure the data source is closed\n        try (BasicDataSource dataSource = new BasicDataSource()) {\n\n            // 1. Establish a fresh connection pooling system with no initial read-only preference configured.\n            //    Verify that when no preference has been set, the system indicates the read-only setting is absent.\n            assertNull(dataSource.getDefaultReadOnly(), \"Initial state: defaultReadOnly should be null (absent)\");\n\n            // 2. Enable the read-only mode for the default user pool and confirm the system reflects this enabled state.\n            dataSource.setDefaultReadOnly(true);\n            assertTrue(dataSource.getDefaultReadOnly(), \"State after enabling: defaultReadOnly should be true\");\n\n            // 3. Then disable the read-only mode and ensure the system accurately reports it as disabled.\n            dataSource.setDefaultReadOnly(false);\n            assertFalse(dataSource.getDefaultReadOnly(), \"State after disabling: defaultReadOnly should be false\");\n\n            // 4. Re-enable the read-only mode once more to verify the system can toggle back to the enabled state successfully.\n            dataSource.setDefaultReadOnly(true);\n            assertTrue(dataSource.getDefaultReadOnly(), \"State after re-enabling: defaultReadOnly should be true again\");\n\n            // 5. Finally, clear the read-only preference entirely by removing any configured value\n            //    and confirm the system returns to indicating no read-only setting is present.\n            dataSource.setDefaultReadOnly(null);\n            assertNull(dataSource.getDefaultReadOnly(), \"State after clearing: defaultReadOnly should be null (absent)\");\n        }\n    }\n}",
      "method_signature": "testDefaultReadOnly()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.5,
      "callable_precision": 0.6,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 11508,
    "output_tokens": 5272,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 40,
      "description": "Define a test method that validates the clearing behavior of the CharArray component across three distinct initialization scenarios by constructing instances with varying input states and verifying the transformation applied by the clear operation. First, instantiate a CharArray with a null string input, invoke its clear method to obtain the modified instance, then retrieve the underlying character array and assert that the result is null, confirming that clearing a null-initialized array preserves the null state. Next, construct a CharArray with an empty string, apply the clear operation, retrieve the resulting character array, and validate that it matches an empty character array, demonstrating that clearing an empty array maintains its empty structure. Finally, create a CharArray initialized with a non-empty string containing three characters, invoke clear to sanitize the contents, retrieve the character array, and assert that it equals a character array of the same length filled with null characters, verifying that the clear operation zeroes out the content while preserving the original array length rather than deallocating the underlying storage. This test uses JUnit for assertions.",
      "project_name": "commons-dbcp",
      "qualified_class_name": "org.apache.commons.dbcp2.datasources.CharArrayTest",
      "method_signature": "testClear()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.dbcp2.datasources.CharArrayClearTest",
      "code": "package org.apache.commons.dbcp2.datasources;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class CharArrayClearTest {\n\n    @Test\n    public void testClearBehavior() {\n        // Scenario 1: CharArray initialized with null string\n        CharArray charArrayNull = new CharArray(null);\n        CharArray clearedCharArrayNull = charArrayNull.clear();\n        assertNull(\"Clearing a null-initialized CharArray should result in a null character array.\",\n                   clearedCharArrayNull.getChars());\n\n        // Scenario 2: CharArray initialized with an empty string\n        CharArray charArrayEmpty = new CharArray(\"\");\n        CharArray clearedCharArrayEmpty = charArrayEmpty.clear();\n        assertNotNull(\"Clearing an empty-initialized CharArray should not result in a null character array.\",\n                      clearedCharArrayEmpty.getChars());\n        assertArrayEquals(\"Clearing an empty-initialized CharArray should result in an empty character array.\",\n                          new char[0],\n                          clearedCharArrayEmpty.getChars());\n\n        // Scenario 3: CharArray initialized with a non-empty string\n        CharArray charArrayNonEmpty = new CharArray(\"abc\");\n        CharArray clearedCharArrayNonEmpty = charArrayNonEmpty.clear();\n        assertNotNull(\"Clearing a non-empty-initialized CharArray should not result in a null character array.\",\n                      clearedCharArrayNonEmpty.getChars());\n        assertEquals(\"Clearing a non-empty-initialized CharArray should preserve its original length.\",\n                     3,\n                     clearedCharArrayNonEmpty.getChars().length);\n        assertArrayEquals(\"Clearing a non-empty-initialized CharArray should zero out its content.\",\n                          new char[]{0, 0, 0},\n                          clearedCharArrayNonEmpty.getChars());\n    }\n}",
      "method_signature": "testClear()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 5758,
    "output_tokens": 1056,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 51,
      "description": "Create a test case to validate that the system correctly sanitizes sensitive character sequences when instructed to clear their contents for security purposes. Begin by establishing three distinct scenarios: first, configure a character sequence holder initialized with no content to verify clearing handles missing data appropriately, then prepare one with an empty sequence to confirm clearing preserves the empty state, and finally set up a holder containing actual sensitive data represented by a meaningful character sequence. For each scenario, instruct the system to perform the clearing operation and immediately verify the outcome\u2014confirm that clearing a holder with no content results in no content being returned, ensure that clearing an already empty sequence maintains the empty state without modification, and validate that clearing a holder with actual data replaces all characters with neutral placeholders while preserving the original length, effectively rendering the sensitive information unrecoverable. This verification ensures the system properly sanitizes character data across all initialization states, protecting sensitive information from inadvertent exposure. Validate these outcomes using JUnit 5 with standard equality assertions to confirm the clearing behavior produces the expected sanitized results for each input condition.",
      "project_name": "commons-dbcp",
      "qualified_class_name": "org.apache.commons.dbcp2.datasources.CharArrayTest",
      "method_signature": "testClear()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.dbcp2.datasources.CharArrayClearingTest",
      "code": "package org.apache.commons.dbcp2.datasources;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.Test;\n\nclass CharArrayClearingTest {\n\n    @Test\n    void testClearSensitiveCharacterSequences() {\n        // Scenario 1: CharArray initialized with no content (null char array)\n        CharArray noContentCharArray = new CharArray((char[]) null);\n        noContentCharArray.clear();\n        assertNull(noContentCharArray.asString(), \"Clearing a CharArray initialized with null should result in a null string representation.\");\n        assertNull(noContentCharArray.get(), \"Clearing a CharArray initialized with null should result in a null char array.\");\n\n        // Scenario 2: CharArray initialized with an empty sequence (empty char array from empty string)\n        CharArray emptyCharArray = new CharArray(\"\");\n        emptyCharArray.clear();\n        assertEquals(\"\", emptyCharArray.asString(), \"Clearing an empty CharArray should result in an empty string representation.\");\n        assertArrayEquals(new char[0], emptyCharArray.get(), \"Clearing an empty CharArray should result in an empty char array.\");\n\n        // Scenario 3: CharArray containing actual sensitive data\n        String sensitiveData = \"SensitivePassword123\";\n        CharArray sensitiveCharArray = new CharArray(sensitiveData);\n        int originalLength = sensitiveData.length();\n\n        sensitiveCharArray.clear();\n\n        // Prepare the expected cleared character array: same length, all characters replaced with '\\0'\n        char[] expectedClearedChars = new char[originalLength];\n        Arrays.fill(expectedClearedChars, '\\0');\n\n        // Verify that the internal char array contains only neutral placeholders ('\\0') and length is preserved\n        assertArrayEquals(expectedClearedChars, sensitiveCharArray.get(), \"Cleared CharArray's internal content should be replaced with null characters.\");\n        assertEquals(originalLength, sensitiveCharArray.get().length, \"Cleared CharArray should preserve its original length.\");\n\n        // Verify the string representation also reflects the neutral placeholders\n        assertEquals(new String(expectedClearedChars), sensitiveCharArray.asString(), \"Cleared CharArray.asString() should be a string of null characters with original length.\");\n    }\n}",
      "method_signature": "testClear()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.5,
      "assertion_recall": 1.0,
      "assertion_precision": 0.4286,
      "callable_recall": 0.8571,
      "callable_precision": 0.5217,
      "focal_recall": 1.0,
      "focal_precision": 0.6667
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.6667,
      "line_coverage": 0.4444,
      "branch_coverage": 0.75
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "search_file_content": 1,
          "read_file": 3
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 66837,
    "output_tokens": 3528,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 54,
      "description": "Define a test class that validates the default read-only property lifecycle of the Per User Pool Data Source component by first instantiating a fresh data source instance within a try-with-resources block to ensure automatic cleanup. Upon creation, verify that the default read-only property returns null when queried, indicating no initial configuration. Configure the data source by setting the default read-only property to true, then retrieve the property value and assert that it evaluates to the boolean primitive true. Transition the state by setting the property to false, retrieve it again, and confirm it now evaluates to false. Reverse the configuration once more by setting the property back to true, query the value, and validate it returns true. Finally, reset the property by explicitly setting it to null, retrieve the value one last time, and assert that it has returned to the null state, demonstrating that the property correctly cycles through configured and unconfigured states. The try-with-resources construct automatically invokes the close method on the data source upon test completion, ensuring proper resource cleanup. This test uses JUnit for test execution and standard assertion methods for validation.",
      "project_name": "commons-dbcp",
      "qualified_class_name": "org.apache.commons.dbcp2.datasources.TestPerUserPoolDataSource",
      "method_signature": "testDefaultReadOnly()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.dbcp2.datasources.PerUserPoolDataSourceReadOnlyPropertyTest",
      "code": "package org.apache.commons.dbcp2.datasources;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\nimport java.sql.SQLException;\n\npublic class PerUserPoolDataSourceReadOnlyPropertyTest {\n\n    @Test\n    void testDefaultReadOnlyPropertyLifecycle() throws SQLException {\n        try (PerUserPoolDataSource ds = new PerUserPoolDataSource()) {\n            // Upon creation, verify that the default read-only property returns null, indicating no initial configuration.\n            Assertions.assertNull(ds.isDefaultReadOnly(), \"Initial defaultReadOnly property should be null.\");\n\n            // Configure the data source by setting the default read-only property to true.\n            ds.setDefaultReadOnly(true);\n            // Retrieve the property value and assert that it evaluates to the boolean primitive true.\n            Assertions.assertTrue(ds.isDefaultReadOnly(), \"defaultReadOnly property should be true after setting to true.\");\n\n            // Transition the state by setting the property to false.\n            ds.setDefaultReadOnly(false);\n            // Retrieve it again, and confirm it now evaluates to false.\n            Assertions.assertFalse(ds.isDefaultReadOnly(), \"defaultReadOnly property should be false after setting to false.\");\n\n            // Reverse the configuration once more by setting the property back to true.\n            ds.setDefaultReadOnly(true);\n            // Query the value, and validate it returns true.\n            Assertions.assertTrue(ds.isDefaultReadOnly(), \"defaultReadOnly property should be true after setting to true again.\");\n\n            // Finally, reset the property by explicitly setting it to null.\n            ds.setDefaultReadOnly(null);\n            // Retrieve the value one last time, and assert that it has returned to the null state.\n            Assertions.assertNull(ds.isDefaultReadOnly(), \"defaultReadOnly property should be null after setting to null.\");\n        }\n    }\n}",
      "method_signature": "testDefaultReadOnly()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8333,
      "callable_precision": 1.0,
      "focal_recall": 0.2222,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 3
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 75188,
    "output_tokens": 2884,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 62,
      "description": "Define a test class that verifies password mutation behavior on a connection factory component, beginning with a setup method that constructs a connection pool data source proxy wrapping a driver adapter, retrieves the underlying delegate adapter, and configures it with JDBC driver class name, connection URL string, username string, and password character array to establish the data source foundation. Within the test method, instantiate a connection factory by providing the configured proxy, a null validation query, a negative millisecond duration, a false rollback flag, a username string, and a password character array, then assign a single-character password string to a variable and invoke the factory's string-based password setter with this value. Upon setting the new password, retrieve the factory's current password as a character array, convert it to a string representation, and assert that the resulting string matches the single-character value that was set, confirming that the factory correctly updates its internal password state when provided a string input. This test uses JUnit 5 for the testing framework and standard assertion methods for validation.",
      "project_name": "commons-dbcp",
      "qualified_class_name": "org.apache.commons.dbcp2.datasources.TestCPDSConnectionFactory",
      "method_signature": "testSetPasswordString()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.dbcp2.datasources.CPDSConnectionFactoryPasswordMutationTest",
      "code": "package org.apache.commons.dbcp2.datasources;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.sql.Connection;\n\nimport org.apache.commons.dbcp2.cpdsadapter.DriverAdapterCPDS;\nimport org.junit.jupiter.api.Test;\n\nclass CPDSConnectionFactoryPasswordMutationTest {\n\n    @Test\n    void testPasswordMutationWithStringSetter() {\n        // Setup: constructs a connection pool data source proxy wrapping a driver adapter\n        // and configures it with JDBC driver class name, connection URL string, username string,\n        // and password character array to establish the data source foundation.\n        final DriverAdapterCPDS cpds = new DriverAdapterCPDS();\n        cpds.setDriver(\"org.h2.Driver\"); // Using H2 for a simple JDBC driver\n        cpds.setUrl(\"jdbc:h2:mem:test;DB_CLOSE_DELAY=-1\"); // In-memory database\n        cpds.setUser(\"initialUser\");\n        cpds.setPassword(\"initialPassword\".toCharArray());\n\n        // Instantiate a connection factory by providing the configured proxy,\n        // a null validation query, a negative millisecond duration,\n        // a false rollback flag, a username string, and a password character array.\n        // The username and password for the underlying connection are set on the cpds object.\n        final CPDSConnectionFactory factory = new CPDSConnectionFactory(\n                cpds,\n                null,              // validationQuery (null)\n                -1,                // validationQueryTimeout (negative millisecond duration)\n                false,             // defaultTestOnBorrow\n                false,             // defaultAutoCommit\n                false,             // defaultReadOnly\n                Connection.TRANSACTION_NONE, // defaultTransactionIsolation\n                null,              // defaultCatalog\n                null,              // defaultSchema\n                false,             // poolStatements\n                -1,                // maxOpenPreparedStatements\n                false,             // enableAutoCommitOnReturn\n                false              // rollbackOnReturn (false rollback flag)\n        );\n\n        // Assign a single-character password string to a variable\n        final String newSingleCharPassword = \"x\";\n\n        // Invoke the factory's string-based password setter with this value.\n        factory.setPassword(newSingleCharPassword);\n\n        // Upon setting the new password, retrieve the factory's current password as a character array,\n        // convert it to a string representation, and assert that the resulting string matches\n        // the single-character value that was set.\n        final char[] retrievedPasswordChars = factory.getPassword();\n        final String retrievedPasswordString = new String(retrievedPasswordChars);\n\n        assertEquals(newSingleCharPassword, retrievedPasswordString, \"The factory's password should be updated correctly.\");\n    }\n}",
      "method_signature": "testSetPasswordString()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 45181,
    "output_tokens": 7329,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 66,
      "description": "Define a test method that validates the clear operation on the User Pass Key component across multiple initialization states and credential representations. Construct a User Pass Key instance initialized with a null username, invoke its clear method, and verify that retrieving the username returns null, then create another instance with an empty string username, clear it, and confirm the username retrieves as an empty string, followed by instantiating a key with a non-empty username string, clearing it, and asserting the username now contains null-character-filled content matching the original length. Repeat this validation pattern for password credentials by constructing instances with null username and null password, clearing them, and verifying the password retrieves as null, then with empty string credentials, clearing, and confirming an empty string password, and finally with non-empty username and password strings, clearing, and validating the password contains null-character-filled content. Extend the verification to cover password character array representation by creating instances with null username and null character array password, clearing them, and asserting the password character array is null, then with empty string credentials, clearing, and verifying the character array matches an empty string converted to characters, and lastly with non-empty credentials, clearing, and confirming the password character array equals null-character-filled content matching the original password length. This test uses JUnit and standard assertion utilities.",
      "project_name": "commons-dbcp",
      "qualified_class_name": "org.apache.commons.dbcp2.datasources.UserPassKeyTest",
      "method_signature": "testClear()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.dbcp2.datasources.UserPassKeyClearTest",
      "code": "package org.apache.commons.dbcp2.datasources;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test for {@link UserPassKey#clear()}.\n */\nclass UserPassKeyClearTest {\n\n    @Test\n    void testClear() {\n        // --- Username validation after clear ---\n\n        // 1. Null username\n        UserPassKey key1 = new UserPassKey(null, (String) null);\n        key1.clear();\n        assertNull(key1.getUserName(), \"Username should be null after clear for a null initial username\");\n\n        // 2. Empty string username\n        UserPassKey key2 = new UserPassKey(\"\", \"\");\n        key2.clear();\n        assertEquals(\"\", key2.getUserName(), \"Username should be an empty string after clear for an empty initial username\");\n\n        // 3. Non-empty username\n        final String originalName = \"testuser\";\n        UserPassKey key3 = new UserPassKey(originalName, \"\");\n        key3.clear();\n        char[] expectedNullCharsName = new char[originalName.length()];\n        Arrays.fill(expectedNullCharsName, '\\0');\n        assertEquals(new String(expectedNullCharsName), key3.getUserName(), \"Username should be null-character-filled after clear for a non-empty initial username\");\n\n        // --- Password (String) validation after clear ---\n\n        // 1. Null password\n        UserPassKey key4 = new UserPassKey(\"user\", (String) null);\n        key4.clear();\n        assertNull(key4.getPassword(), \"Password (String) should be null after clear for a null initial password\");\n\n        // 2. Empty string password\n        UserPassKey key5 = new UserPassKey(\"user\", \"\");\n        key5.clear();\n        assertEquals(\"\", key5.getPassword(), \"Password (String) should be an empty string after clear for an empty initial password\");\n\n        // 3. Non-empty password\n        final String originalPassword = \"testpassword\";\n        UserPassKey key6 = new UserPassKey(\"user\", originalPassword);\n        key6.clear();\n        char[] expectedNullCharsPassword = new char[originalPassword.length()];\n        Arrays.fill(expectedNullCharsPassword, '\\0');\n        assertEquals(new String(expectedNullCharsPassword), key6.getPassword(), \"Password (String) should be null-character-filled after clear for a non-empty initial password\");\n\n        // --- Password (char array) validation after clear ---\n\n        // 1. Null char array password\n        UserPassKey key7 = new UserPassKey(\"user\", (char[]) null);\n        key7.clear();\n        assertNull(key7.getPasswordCharArray(), \"Password (char[]) should be null after clear for a null initial char[] password\");\n\n        // 2. Empty string credentials (resulting in empty char array password)\n        UserPassKey key8 = new UserPassKey(\"user\", \"\".toCharArray());\n        key8.clear();\n        assertArrayEquals(\"\".toCharArray(), key8.getPasswordCharArray(), \"Password (char[]) should be an empty char[] after clear for an empty initial char[] password\");\n\n        // 3. Non-empty credentials (non-empty char array password)\n        final char[] originalPasswordChars = \"anotherTestPassword\".toCharArray();\n        UserPassKey key9 = new UserPassKey(\"anotherUser\", originalPasswordChars);\n        key9.clear();\n        char[] expectedNullCharsCharArray = new char[originalPasswordChars.length];\n        Arrays.fill(expectedNullCharsCharArray, '\\0');\n        assertArrayEquals(expectedNullCharsCharArray, key9.getPasswordCharArray(), \"Password (char[]) should be null-character-filled after clear for a non-empty initial char[] password\");\n    }\n}",
      "method_signature": "testClear()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.5,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.8261,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.7895,
      "line_coverage": 0.6222,
      "branch_coverage": 0.8
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 2
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 35467,
    "output_tokens": 4159,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 71,
      "description": "Define a test class containing a protected field `cpds` of type `org.apache.commons.dbcp2.datasources.ConnectionPoolDataSourceProxy`, and implement a setup method annotated with `@BeforeEach` that instantiates `cpds` by passing a new `DriverAdapterCPDS` instance to the `ConnectionPoolDataSourceProxy` constructor, then invoke `getDelegate()` on `cpds`, cast the result to `DriverAdapterCPDS`, and assign it to a local variable `delegate`, after which invoke `setDriver` on `delegate` with argument `\"org.apache.commons.dbcp2.TesterDriver\"`, invoke `setUrl` with argument `\"jdbc:apache:commons:testdriver\"`, invoke `setUser` with argument `\"userName\"`, and invoke `setPassword` with argument `\"password\"`. In the test method annotated with `@Test`, instantiate a `CPDSConnectionFactory` by passing six arguments to its constructor: the field `cpds`, `null`, the result of calling `Duration.ofMillis(-1)`, the boolean literal `false`, the String literal `\"userName\"`, and the result of invoking `toCharArray()` on the String literal `\"password\"`, assigning the constructed factory to a local variable `factory`, then assign the String literal `\"a\"` to a local variable `pwd`, invoke `setPassword` on `factory` with argument `pwd`, and assert using `assertEquals` that the String literal `\"a\"` equals the result of calling `String.valueOf` on the char array returned by invoking `getPasswordCharArray()` on `factory`. The test uses the `@Test` annotation from JUnit 5, and assertions are performed using JUnit 5's `assertEquals` method.",
      "project_name": "commons-dbcp",
      "qualified_class_name": "org.apache.commons.dbcp2.datasources.TestCPDSConnectionFactory",
      "method_signature": "testSetPasswordString()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.dbcp2.datasources.CPDSConnectionFactoryPasswordTest",
      "code": "package org.apache.commons.dbcp2.datasources;\n\nimport org.apache.commons.dbcp2.cpdsadapter.DriverAdapterCPDS;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.time.Duration;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CPDSConnectionFactoryPasswordTest {\n\n    protected ConnectionPoolDataSourceProxy cpds;\n\n    @BeforeEach\n    void setUp() {\n        cpds = new ConnectionPoolDataSourceProxy(new DriverAdapterCPDS());\n        DriverAdapterCPDS delegate = (DriverAdapterCPDS) cpds.getDelegate();\n        delegate.setDriver(\"org.apache.commons.dbcp2.TesterDriver\");\n        delegate.setUrl(\"jdbc:apache:commons:testdriver\");\n        delegate.setUser(\"userName\");\n        delegate.setPassword(\"password\");\n    }\n\n    @Test\n    void testSetPasswordAndGetPasswordCharArray() {\n        CPDSConnectionFactory factory = new CPDSConnectionFactory(\n                cpds,\n                null,\n                Duration.ofMillis(-1),\n                false,\n                \"userName\",\n                \"password\".toCharArray()\n        );\n\n        String pwd = \"a\";\n        factory.setPassword(pwd);\n\n        assertEquals(pwd, String.valueOf(factory.getPasswordCharArray()));\n    }\n}",
      "method_signature": "testSetPasswordString()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 5907,
    "output_tokens": 1707,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 73,
      "description": "Define a test method annotated with `@Test` that verifies the behavior of the `clear()` method on `UserPassKey` instances across multiple scenarios involving null, empty, and non-empty username and password values. Begin by instantiating a `UserPassKey` with a single `String` argument cast to `null`, then chain a call to `clear()` followed by `getUserName()`, and assert the result is null using `assertNull`. Next, construct a `UserPassKey` with an empty string `\"\"` as the single argument, chain `clear()` and `getUserName()`, and assert the result equals `\"\"` using `assertEquals`. Following this, create a `UserPassKey` with the string literal `\"foo\"`, chain `clear()` and `getUserName()`, and assert the result equals the string `\"\\0\\0\\0\"` using `assertEquals`. Transition to password validation by instantiating a `UserPassKey` with two `String` arguments both cast to `null`, chain `clear()` and `getPassword()`, and assert the result is null using `assertNull`. Then construct a `UserPassKey` with two empty strings `\"\"` and `\"\"`, chain `clear()` and `getPassword()`, and assert the result equals `\"\"` using `assertEquals`. Subsequently, create a `UserPassKey` with string literals `\"foo\"` and `\"bar\"`, chain `clear()` and `getPassword()`, and assert the result equals `\"\\0\\0\\0\"` using `assertEquals`. Proceed to password character array verification by instantiating a `UserPassKey` with a `String` argument cast to `null` and a `char[]` argument cast to `null`, chain `clear()` and `getPasswordCharArray()`, and assert the result is null using `assertNull`. Next, construct a `UserPassKey` with two empty strings `\"\"` and `\"\"`, chain `clear()` and `getPasswordCharArray()`, convert the expected empty string `\"\"` to a character array using `toCharArray()`, and assert array equality using `assertArrayEquals`. Finally, create a `UserPassKey` with string literals `\"foo\"` and `\"bar\"`, chain `clear()` and `getPasswordCharArray()`, convert the string `\"\\0\\0\\0\"` to a character array using `toCharArray()`, and assert array equality using `assertArrayEquals`. The test uses JUnit 5 Assertions with method-level annotation `@Test`.",
      "project_name": "commons-dbcp",
      "qualified_class_name": "org.apache.commons.dbcp2.datasources.UserPassKeyTest",
      "method_signature": "testClear()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.dbcp2.datasources.UserPassKeyClearTest",
      "code": "package org.apache.commons.dbcp2.datasources;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\npublic class UserPassKeyClearTest {\n\n    @Test\n    void testClearMethodScenarios() {\n        // Scenario 1: UserPassKey with a single String argument cast to null, then chain clear() and getUserName(), assert null.\n        UserPassKey key1 = new UserPassKey((String) null);\n        key1.clear();\n        assertNull(key1.getUserName());\n\n        // Scenario 2: UserPassKey with an empty string \"\" as the single argument, chain clear() and getUserName(), assert equals \"\".\n        UserPassKey key2 = new UserPassKey(\"\");\n        key2.clear();\n        assertEquals(\"\", key2.getUserName());\n\n        // Scenario 3: UserPassKey with the string literal \"foo\", chain clear() and getUserName(), assert equals \"\\0\\0\\0\".\n        UserPassKey key3 = new UserPassKey(\"foo\");\n        key3.clear();\n        assertEquals(\"\\0\\0\\0\", key3.getUserName());\n\n        // Scenario 4: UserPassKey with two String arguments both cast to null, chain clear() and getPassword(), assert null.\n        UserPassKey key4 = new UserPassKey((String) null, (String) null);\n        key4.clear();\n        assertNull(key4.getPassword());\n\n        // Scenario 5: UserPassKey with two empty strings \"\" and \"\", chain clear() and getPassword(), assert equals \"\".\n        UserPassKey key5 = new UserPassKey(\"\", \"\");\n        key5.clear();\n        assertEquals(\"\", key5.getPassword());\n\n        // Scenario 6: UserPassKey with string literals \"foo\" and \"bar\", chain clear() and getPassword(), assert equals \"\\0\\0\\0\".\n        UserPassKey key6 = new UserPassKey(\"foo\", \"bar\");\n        key6.clear();\n        assertEquals(\"\\0\\0\\0\", key6.getPassword());\n\n        // Scenario 7: UserPassKey with a String argument cast to null and a char[] argument cast to null, chain clear() and getPasswordCharArray(), assert null.\n        UserPassKey key7 = new UserPassKey((String) null, (char[]) null);\n        key7.clear();\n        assertNull(key7.getPasswordCharArray());\n\n        // Scenario 8: UserPassKey with two empty strings \"\" and \"\", chain clear() and getPasswordCharArray(), convert the expected empty string \"\" to a character array using toCharArray(), and assert array equality.\n        UserPassKey key8 = new UserPassKey(\"\", \"\".toCharArray());\n        key8.clear();\n        assertArrayEquals(\"\".toCharArray(), key8.getPasswordCharArray());\n\n        // Scenario 9: UserPassKey with string literals \"foo\" and \"bar\", chain clear() and getPasswordCharArray(), convert the string \"\\0\\0\\0\" to a character array using toCharArray(), and assert array equality.\n        UserPassKey key9 = new UserPassKey(\"foo\", \"bar\".toCharArray());\n        key9.clear();\n        assertArrayEquals(\"\\0\\0\\0\".toCharArray(), key9.getPasswordCharArray());\n    }\n}",
      "method_signature": "testClear()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.95,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.8421,
      "line_coverage": 0.6667,
      "branch_coverage": 0.8
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 13093,
    "output_tokens": 3673,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 99,
      "description": "Define a test class containing three private fields: a static final `Duration` named `DURATION_1_MILLISECOND`, a `DataSource` named `ds`, and a `String` named `user`. Implement a setup method that assigns the string literal `\"foo\"` to `user`, then instantiate a `DriverAdapterCPDS` object assigned to `pcds`, invoke `setDriver` on `pcds` with argument `\"org.apache.commons.dbcp2.TesterDriver\"`, invoke `setUrl` with `\"jdbc:apache:commons:testdriver\"`, invoke `setUser` passing the `user` variable, invoke `setPassword` with `\"bar\"`, and invoke `setAccessToUnderlyingConnectionAllowed` with boolean `true`. Next, instantiate a `PerUserPoolDataSource` object assigned to `tds`, invoke `setConnectionPoolDataSource` on `tds` passing `pcds`, invoke `setDefaultMaxTotal` passing the result of calling `getMaxTotal()`, invoke `setDefaultMaxWait` passing the result of calling `getMaxWaitDuration()`, invoke `setPerUserMaxTotal` with arguments `user` and the result of `getMaxTotal()`, invoke `setPerUserMaxWait` with `user` and the result of `getMaxWaitDuration()`, invoke `setDefaultTransactionIsolation` with the constant `Connection.TRANSACTION_READ_COMMITTED`, invoke `setDefaultAutoCommit` with `Boolean.TRUE`, and finally assign `tds` to the class field `ds`. In the test method, open a try-with-resources block by instantiating a new `PerUserPoolDataSource` assigned to local variable `ds`, then immediately invoke `isDefaultReadOnly()` on this `ds` instance and pass the result to `assertNull`. Following this assertion, invoke `setDefaultReadOnly` on `ds` with boolean `true`, then invoke `isDefaultReadOnly()` again, call `booleanValue()` on the returned `Boolean`, and pass the primitive result to `assertTrue`. Proceed by invoking `setDefaultReadOnly` with boolean `false`, invoke `isDefaultReadOnly()`, chain `booleanValue()`, and pass the result to `assertFalse`. Continue by invoking `setDefaultReadOnly` with boolean `true`, invoke `isDefaultReadOnly()`, chain `booleanValue()`, and pass to `assertTrue`. Then invoke `setDefaultReadOnly` with `null`, invoke `isDefaultReadOnly()`, and pass the result to `assertNull`, completing the try-with-resources block which automatically closes `ds`. Implement a teardown method that first defines a private method executing a loop: while a `connectionStack` (of type `Stack<Connection>`) is not empty, pop an element, cast it to `AutoCloseable`, and pass it to `Utils.closeQuietly`, then invoke this private method. After invoking the inherited teardown logic, cast the class field `ds` to `PerUserPoolDataSource` and invoke `close()` on it. The test uses the `@Test` annotation at the method level, JUnit 5 Assertions for `assertNull`, `assertTrue`, and `assertFalse`, and no mocking libraries.",
      "project_name": "commons-dbcp",
      "qualified_class_name": "org.apache.commons.dbcp2.datasources.TestPerUserPoolDataSource",
      "method_signature": "testDefaultReadOnly()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.dbcp2.datasources.PerUserPoolDataSourceReadOnlyTest",
      "code": "package org.apache.commons.dbcp2.datasources;\n\nimport java.sql.Connection;\nimport java.time.Duration;\nimport java.util.Stack;\n\nimport javax.sql.DataSource;\n\nimport org.apache.commons.dbcp2.Utils;\nimport org.apache.commons.dbcp2.cpdsadapter.DriverAdapterCPDS;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nclass PerUserPoolDataSourceReadOnlyTest {\n\n    private static final Duration DURATION_1_MILLISECOND = Duration.ofMillis(1);\n    private DataSource ds;\n    private String user;\n    private final Stack<Connection> connectionStack = new Stack<>(); // Following the instruction for teardown\n\n    @BeforeEach\n    void setUp() throws Exception {\n        user = \"foo\";\n\n        DriverAdapterCPDS pcds = new DriverAdapterCPDS();\n        pcds.setDriver(\"org.apache.commons.dbcp2.TesterDriver\");\n        pcds.setUrl(\"jdbc:apache:commons:testdriver\");\n        pcds.setUser(user);\n        pcds.setPassword(\"bar\");\n        pcds.setAccessToUnderlyingConnectionAllowed(true);\n\n        PerUserPoolDataSource tds = new PerUserPoolDataSource();\n        tds.setConnectionPoolDataSource(pcds);\n        tds.setDefaultMaxTotal(tds.getDefaultMaxTotal()); // As per instruction \"result of calling getMaxTotal()\"\n        tds.setDefaultMaxWait(tds.getMaxWaitDuration()); // As per instruction \"result of calling getMaxWaitDuration()\"\n        tds.setPerUserMaxTotal(user, tds.getDefaultMaxTotal()); // As per instruction \"result of getMaxTotal()\"\n        tds.setPerUserMaxWait(user, tds.getMaxWaitDuration()); // As per instruction \"result of getMaxWaitDuration()\"\n        tds.setDefaultTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        tds.setDefaultAutoCommit(Boolean.TRUE);\n        ds = tds;\n    }\n\n    @AfterEach\n    void tearDown() throws Exception {\n        cleanupConnections(); // Call the private cleanup method\n        if (ds instanceof PerUserPoolDataSource) {\n            ((PerUserPoolDataSource) ds).close();\n        }\n    }\n\n    private void cleanupConnections() {\n        while (!connectionStack.isEmpty()) {\n            Connection connection = connectionStack.pop();\n            Utils.closeQuietly(connection);\n        }\n    }\n\n    @Test\n    void testDefaultReadOnlyBehavior() throws Exception {\n        try (PerUserPoolDataSource localDs = new PerUserPoolDataSource()) {\n            Assertions.assertNull(localDs.isDefaultReadOnly());\n\n            localDs.setDefaultReadOnly(true);\n            Assertions.assertTrue(localDs.isDefaultReadOnly().booleanValue());\n\n            localDs.setDefaultReadOnly(false);\n            Assertions.assertFalse(localDs.isDefaultReadOnly().booleanValue());\n\n            localDs.setDefaultReadOnly(true);\n            Assertions.assertTrue(localDs.isDefaultReadOnly().booleanValue());\n\n            localDs.setDefaultReadOnly(null);\n            Assertions.assertNull(localDs.isDefaultReadOnly());\n        }\n    }\n}",
      "method_signature": "testDefaultReadOnly()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 35296,
    "output_tokens": 4864,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  }
]