[
  {
    "compiles": false,
    "nl2test_input": {
      "id": 101,
      "description": "Create a test case to validate that the output system immediately switches to file-based storage when configured with a threshold indicating no in-memory buffering should occur, ensuring that even when no data is written, the system maintains a persistent storage location and correctly reports its storage mode both during active operation and after closure, then verify that the system can successfully retrieve empty content from the persisted storage location and that the storage location exists as a valid file on the system. Configure the output mechanism with a threshold value indicating immediate file creation, then confirm the system reports it is not operating in memory mode and has established a storage location while no in-memory buffer exists. After closing the output mechanism, verify again that the system continues to report file-based operation with an accessible storage location that exists as a regular file, then retrieve the stored content and confirm it matches an empty data set. Use JUnit 5 for the testing framework with standard equality and boolean assertions to verify storage mode, storage location presence, file existence, and content matching.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testThresholdMinusOne()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamZeroThresholdNoWriteTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.function.Supplier;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link DeferrableOutputStream} when configured with a zero-byte threshold\n * and no data is written, ensuring immediate file-based storage.\n */\npublic class DeferrableOutputStreamZeroThresholdNoWriteTest {\n\n    @TempDir\n    private static Path tempDir;\n\n    private final Supplier<Path> pathSupplier = () -> {\n        try {\n            return Files.createTempFile(tempDir, \"test-\", \".dat\");\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    };\n\n    /**\n     * Reads all bytes from an input stream into a byte array by buffering through an\n     * intermediate byte array output stream.\n     *\n     * @param inputStream The input stream to read.\n     * @return A new byte array containing the contents of the stream.\n     * @throws IOException If an I/O error occurs.\n     */\n    private byte[] readAllBytes(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final byte[] buffer = new byte[1024];\n        int len;\n        while ((len = inputStream.read(buffer)) != -1) {\n            baos.write(buffer, 0, len);\n        }\n        return baos.toByteArray();\n    }\n\n    @Test\n    public void testZeroThresholdNoInMemoryBufferingNoWrite() {\n        final DeferrableOutputStream[] streamHolder = new DeferrableOutputStream[1];\n        Path writtenFilePath = null;\n\n        try (DeferrableOutputStream stream = new DeferrableOutputStream(0, pathSupplier, null)) {\n            streamHolder[0] = stream;\n\n            // Verify initial state: immediately file-backed, with a persistent path, and no in-memory buffer.\n            assertFalse(stream.isInMemory(), \"Stream should immediately be file-backed with zero threshold.\");\n            assertNotNull(stream.getPath(), \"Stream path should be non-null immediately with zero threshold.\");\n            assertNull(stream.getData(), \"Data byte array should be null immediately with zero threshold.\");\n            writtenFilePath = stream.getPath();\n            assertTrue(Files.isRegularFile(writtenFilePath), \"File should exist immediately for zero threshold.\");\n\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n\n        // After auto-close, verify the stream remains file-backed and readable, and its content is empty.\n        final DeferrableOutputStream closedStream = streamHolder[0];\n        assertFalse(closedStream.isInMemory(), \"Closed stream should remain file-backed.\");\n        assertNotNull(closedStream.getPath(), \"Path of closed stream should be non-null.\");\n        assertTrue(Files.isRegularFile(closedStream.getPath()), \"Path should point to a regular file after close.\");\n\n        try (InputStream inputStream = closedStream.toInputStream()) {\n            final byte[] actualContent = readAllBytes(inputStream);\n            assertArrayEquals(new byte[0], actualContent, \"File content should be empty when no data was written.\");\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        } finally {\n            if (writtenFilePath != null) {\n                try {\n                    Files.deleteIfExists(writtenFilePath);\n                } catch (final IOException e) {\n                    // Suppress cleanup exception\n                }\n            }\n        }\n    }\n}",
      "method_signature": "testThresholdMinusOne()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6978,
    "output_tokens": 2743,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 103,
      "description": "Create a test case to validate that the multipart input processing system can be properly initialized when configured with a data source, boundary delimiter, and progress tracking capability, ensuring the system is ready to handle file upload streams conforming to multipart format specifications. Prepare a sample text payload and convert it into a byte stream suitable for processing, then configure the boundary marker that will separate different sections of the multipart data by converting the predefined boundary text into its byte representation. Establish a progress monitoring component that tracks upload progress based on the total size of the incoming data without attaching an external listener, allowing the system to monitor data flow internally. Configure the multipart processing system by supplying the data source, boundary delimiter, and progress tracker, then request the system to construct the fully initialized processor. After the processor is built, verify that the system successfully created a functioning multipart input handler ready to parse and process file upload data, confirming the initialization completed without errors and the processor is available for subsequent operations. Use JUnit 5 as the testing framework and verify the outcome using standard equality assertions to ensure the processor exists and is properly instantiated.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testTwoParamConstructor()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartProcessorInitializationTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for validating the initialization of the multipart input processing system.\n * It ensures that a FileItemInputIterator, which serves as the core processor,\n * can be properly constructed and made ready for operation when provided with\n * a data source, boundary delimiter, and a progress tracking mechanism.\n */\npublic class MultipartProcessorInitializationTest {\n\n    @Test\n    void testMultipartProcessorInitialization() throws IOException, FileUploadException {\n        // 1. Prepare a sample text payload conforming to multipart format.\n        // This minimal valid multipart message is sufficient for the FileItemInputIteratorImpl\n        // constructor to perform its initialization checks without requiring full data parsing.\n        final String boundary = \"----------aBcDeFgH\"; // A plausible boundary string\n        final String payloadString = \"--\" + boundary + \"\\r\\n\" +\n                                     \"Content-Disposition: form-data; name=\\\"field1\\\"\\r\\n\" +\n                                     \"\\r\\n\" +\n                                     \"value1\\r\\n\" +\n                                     \"--\" + boundary + \"--\\r\\n\";\n        final byte[] payloadBytes = payloadString.getBytes(StandardCharsets.US_ASCII);\n\n        // 2. Configure the boundary marker: The boundary is part of the Content-Type header.\n\n        // 3. Establish a progress monitoring component.\n        // The description specifies \"without attaching an external listener, allowing the system\n        // to monitor data flow internally.\" ProgressListener.NOP (No Operation) is suitable\n        // for this, as it satisfies the requirement of a listener without external side effects.\n        final ProgressListener progressListener = ProgressListener.NOP;\n\n        // 4. Create a concrete FileItemFactory. DiskFileItemFactory is a standard implementation.\n        final DiskFileItemFactory factory = DiskFileItemFactory.builder().get();\n\n        // 5. Create a concrete AbstractFileUpload implementation using an anonymous inner class.\n        // This test uses RequestContext as the concrete type for the generic parameter R,\n        // and DiskFileItem for I, and DiskFileItemFactory for F.\n        // Abstract methods must be implemented, even if they delegate or throw,\n        // as the test primarily focuses on the initialization of FileItemInputIterator.\n        final AbstractFileUpload<RequestContext, DiskFileItem, DiskFileItemFactory> fileUpload =\n            new AbstractFileUpload<>() {\n                @Override\n                public List<DiskFileItem> parseRequest(final RequestContext request) throws FileUploadException {\n                    // Delegate to the superclass's implementation which utilizes getItemIterator.\n                    try {\n                        return super.parseRequest(request);\n                    } catch (final IOException e) {\n                        throw new FileUploadException(\"Error during parseRequest in test mock\", e);\n                    }\n                }\n\n                @Override\n                public Map<String, List<DiskFileItem>> parseParameterMap(final RequestContext request) throws FileUploadException {\n                    // Delegate to the superclass's implementation which utilizes getItemIterator.\n                    try {\n                        return super.parseParameterMap(request);\n                    } catch (final IOException e) {\n                        throw new FileUploadException(\"Error during parseParameterMap in test mock\", e);\n                    }\n                }\n\n                @Override\n                public FileItemInputIterator getItemIterator(final RequestContext request) throws FileUploadException, IOException {\n                    // This abstract method takes a RequestContext. The AbstractFileUpload class\n                    // provides a concrete implementation of getItemIterator(RequestContext requestContext)\n                    // which constructs the FileItemInputIteratorImpl. We delegate to that.\n                    return super.getItemIterator(request);\n                }\n            };\n\n        // Set the FileItemFactory and ProgressListener on our AbstractFileUpload instance.\n        fileUpload.setFileItemFactory(factory);\n        fileUpload.setProgressListener(progressListener);\n\n        // 6. Create a mock RequestContext. This provides the necessary environment\n        // information (content type, length, and input stream) to the multipart processor.\n        final RequestContext requestContext = new AbstractRequestContext() {\n            @Override\n            public String getCharacterEncoding() {\n                return StandardCharsets.US_ASCII.name();\n            }\n\n            @Override\n            public String getContentType() {\n                return \"multipart/form-data; boundary=\" + boundary;\n            }\n\n            @Override\n            public int getContentLength() {\n                return payloadBytes.length;\n            }\n\n            @Override\n            public InputStream getInputStream() throws IOException {\n                return new ByteArrayInputStream(payloadBytes);\n            }\n        };\n\n        // 7. Request the system to construct the fully initialized processor.\n        // This call will internally create an instance of FileItemInputIteratorImpl.\n        final FileItemInputIterator processor = fileUpload.getItemIterator(requestContext);\n\n        // 8. Verify that the system successfully created a functioning multipart input handler.\n        // A non-null return value confirms successful initialization without errors,\n        // indicating the processor is ready for subsequent operations (e.g., iterating items).\n        assertNotNull(processor, \"The multipart input processor (FileItemInputIterator) should be successfully initialized.\");\n    }\n}",
      "method_signature": "testTwoParamConstructor()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19578,
    "output_tokens": 7485,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 104,
      "description": "Define a test class containing a private static final field `BOUNDARY_TEXT` of type `String`, then write a test method annotated with `@Test` that declares it may throw `Exception`. Begin by assigning the String literal `\"foobar\"` to a local variable `strData`, then invoke `getBytes()` on `strData` and assign the resulting byte array to variable `contents`. Instantiate a `ByteArrayInputStream` by passing `contents` as the constructor argument and assign it to variable `input` of type `InputStream`. Invoke `getBytes()` on the class field `BOUNDARY_TEXT` and assign the resulting byte array to variable `boundary`. Invoke the static method `MultipartInput.builder()` to obtain a builder instance, then chain `setInputStream(input)` passing the `input` variable, chain `setBoundary(boundary)` passing the `boundary` variable, chain `setProgressNotifier(new MultipartInput.ProgressNotifier(null, contents.length))` where you construct a new `ProgressNotifier` by passing `null` as the first argument and `contents.length` as the second argument, and finally chain `get()` to build the `MultipartInput` instance, assigning the result to variable `ms`. Assert that `ms` is not null by invoking `assertNotNull(ms)`. The test uses JUnit 5 Assertions with the `@Test` annotation and no mocking libraries.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testTwoParamConstructor()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\npublic class MultipartInputTest {\n\n    private static final String BOUNDARY_TEXT = \"---my_boundary---\";\n\n    @Test\n    public void testMultipartInputBuilderWithProgressNotifier() throws Exception {\n        String strData = \"foobar\";\n        byte[] contents = strData.getBytes(StandardCharsets.UTF_8);\n        InputStream input = new ByteArrayInputStream(contents);\n        byte[] boundary = BOUNDARY_TEXT.getBytes(StandardCharsets.UTF_8);\n\n        // Assuming MultipartInput and MultipartInput.ProgressNotifier exist in the codebase\n        // and have the methods/constructors as implied by the test description.\n        MultipartInput ms = MultipartInput.builder()\n                .setInputStream(input)\n                .setBoundary(boundary)\n                .setProgressNotifier(new MultipartInput.ProgressNotifier(null, contents.length))\n                .get();\n\n        assertNotNull(ms);\n    }\n}",
      "method_signature": "testTwoParamConstructor()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 16821,
    "output_tokens": 2910,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 116,
      "description": "Create a test case to validate the system's behavior when configured with a zero-byte threshold for managing incoming data streams, ensuring immediate transition from temporary storage to persistent file storage upon receiving the first byte of data. Begin by establishing a reusable validation routine that initializes a data stream configured to trigger file creation immediately upon any data arrival, then confirm the stream starts in an initialized state with no file location assigned and no buffered content available. Execute three distinct scenarios to verify consistent behavior across different data writing approaches: first, simulate writing a single character directly to the stream and verify the system immediately transitions from temporary storage to file-based storage, confirming a file location becomes available while buffered content remains unavailable during the active writing phase; after closing the stream, retrieve the persisted content and verify it matches the expected single character. Repeat this validation pattern by simulating the same character transmission using a byte collection, then again using a partial write from a larger byte collection containing multiple characters but transmitting only the first one. Across all three scenarios, confirm the stream consistently transitions to file-based storage upon receiving the first byte, properly persists the transmitted data, and produces retrievable content matching the expected comma character when read back after closure. The validation relies on JUnit 5 for test execution and standard assertion libraries for verifying state transitions, content availability, file creation, and data integrity through byte-level comparison.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testThresholdZero()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamZeroThresholdTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link DeferrableOutputStream} when configured with a zero-byte threshold.\n * This test validates that writing even a single byte triggers immediate transition\n * from memory to file-based storage across different write methods.\n */\npublic class DeferrableOutputStreamZeroThresholdTest {\n\n    /**\n     * Defines a write operation that can be passed to the test logic and may throw\n     * an {@link IOException}.\n     */\n    @FunctionalInterface\n    private interface WriteOperation {\n        void perform(DeferrableOutputStream stream) throws IOException;\n    }\n\n    @TempDir\n    private static Path tempDir;\n\n    private final Supplier<Path> pathSupplier = () -> {\n        try {\n            return Files.createTempFile(tempDir, \"test-\", \".dat\");\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    };\n\n    /**\n     * Reads all bytes from an input stream into a byte array by buffering through an\n     * intermediate byte array output stream.\n     *\n     * @param inputStream The input stream to read.\n     * @return A new byte array containing the contents of the stream.\n     * @throws IOException If an I/O error occurs.\n     */\n    private byte[] readAllBytes(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final byte[] buffer = new byte[1024];\n        int len;\n        while ((len = inputStream.read(buffer)) != -1) {\n            baos.write(buffer, 0, len);\n        }\n        return baos.toByteArray();\n    }\n\n    @Test\n    public void testZeroThresholdLifecycleAcrossWriteVariants() {\n        final DeferrableOutputStream[] streamHolder = new DeferrableOutputStream[1];\n        final byte[] expectedCommaByte = \",\".getBytes(StandardCharsets.UTF_8);\n\n        // A reusable testing lambda that encapsulates the complete lifecycle verification pattern.\n        final Consumer<WriteOperation> testLifecyclePattern = writeCallback -> {\n            Path writtenFilePath = null;\n            try (DeferrableOutputStream stream = new DeferrableOutputStream(0, pathSupplier, null)) {\n                streamHolder[0] = stream;\n\n                // Verify initial state: in-memory, null path, and empty (initialized).\n                assertTrue(stream.isInMemory(), \"Stream should start in-memory.\");\n                assertNull(stream.getPath(), \"Stream path should be null before writing.\");\n                assertNotNull(stream.getData(), \"Initial data byte array should not be null.\");\n                assertEquals(0, stream.getData().length, \"Initial data byte array should be empty.\");\n\n                // Invoke the provided write callback, triggering the transition.\n                writeCallback.perform(stream);\n\n                // Confirm the stream has transitioned to file-backed storage.\n                assertFalse(stream.isInMemory(), \"Stream should be file-backed after write.\");\n                assertNotNull(stream.getPath(), \"Stream path should be non-null after transition.\");\n                writtenFilePath = stream.getPath();\n                assertNull(stream.getData(), \"Data byte array should be null when file-backed.\");\n\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n\n            // After auto-close, verify the stream remains file-backed and readable.\n            final DeferrableOutputStream closedStream = streamHolder[0];\n            assertFalse(closedStream.isInMemory(), \"Closed stream should remain file-backed.\");\n            assertTrue(Files.isRegularFile(closedStream.getPath()), \"Path should point to a regular file.\");\n\n            try (InputStream inputStream = closedStream.toInputStream()) {\n                final byte[] actualContent = readAllBytes(inputStream);\n                assertArrayEquals(expectedCommaByte, actualContent, \"File content mismatch.\");\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            } finally {\n                if (writtenFilePath != null) {\n                    try {\n                        Files.deleteIfExists(writtenFilePath);\n                    } catch (final IOException e) {\n                        // Suppress cleanup exception\n                    }\n                }\n            }\n        };\n\n        // Exercise the testing lambda with three distinct write operation variants.\n\n        // 1. Single-byte write method.\n        testLifecyclePattern.accept(stream -> stream.write(','));\n\n        // 2. Byte array write method.\n        testLifecyclePattern.accept(stream -> stream.write(new byte[]{','}));\n\n        // 3. Ranged byte array write method (writing only the comma).\n        testLifecyclePattern.accept(stream -> stream.write(new byte[]{',', '-'}, 0, 1));\n    }\n}",
      "method_signature": "testThresholdZero()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7048,
    "output_tokens": 2450,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 125,
      "description": "Create a test case to validate that the system correctly transitions from in-memory storage to file-based storage when incoming data exceeds a configured size threshold, ensuring this behavior works consistently across all supported write operations. Establish a temporary storage location for the test scenario, then configure a deferrable output mechanism with a threshold of five bytes that will initially hold data in memory but switch to file-based storage once that limit is exceeded. Verify the mechanism starts in an initialized state with no storage location assigned and no buffered content available. Write four bytes of data individually to confirm the system remains in an active in-memory state after each write, with the storage location still unassigned and no buffered content accessible while staying below the threshold. At this point, simulate exceeding the threshold by writing one additional byte through three different approaches: first by writing a single byte directly, then by writing a single-element byte sequence, and finally by writing a portion of a multi-element byte sequence. After each threshold-crossing write, confirm the system has transitioned out of memory-based storage, established a file-based storage location, and cleared the in-memory buffer. Once the write operation completes and the mechanism closes, verify the system maintains its file-based storage state with an active storage location that exists as a regular file in the temporary area. Retrieve the complete written content from the closed mechanism and confirm it matches the expected five-byte sequence that was written during the test. Validate the behavior using JUnit 5 with standard equality and state assertions to confirm storage mode transitions, storage location availability, and content accuracy throughout the lifecycle.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testExceedPositiveThreshold()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamThresholdTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.function.Supplier;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link DeferrableOutputStream} to validate the transition from in-memory\n * to file-based storage when data exceeds a configured size threshold.\n */\npublic class DeferrableOutputStreamThresholdTest {\n\n    @TempDir\n    private static Path tempDir;\n\n    private final Supplier<Path> pathSupplier = () -> {\n        try {\n            return Files.createTempFile(tempDir, \"test-\", \".tmp\");\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    };\n\n    /**\n     * Reads all bytes from an input stream into a byte array.\n     *\n     * @param inputStream The input stream to read.\n     * @return A new byte array containing the contents of the stream.\n     * @throws IOException If an I/O error occurs.\n     */\n    private byte[] readAllBytes(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final byte[] buffer = new byte[1024];\n        int len;\n        while ((len = inputStream.read(buffer)) != -1) {\n            baos.write(buffer, 0, len);\n        }\n        return baos.toByteArray();\n    }\n\n    /**\n     * Helper method to perform the initial 4-byte write and state assertions.\n     *\n     * @param stream The DeferrableOutputStream to write to.\n     * @param initialBytes The bytes to write (must be 4 bytes long).\n     * @throws IOException If an I/O error occurs.\n     */\n    private void writeInitialBytesAndAssertInMemory(DeferrableOutputStream stream, byte[] initialBytes) throws IOException {\n        for (int i = 0; i < initialBytes.length; i++) {\n            stream.write(initialBytes[i]);\n            assertTrue(stream.isInMemory(), \"After \" + (i + 1) + \" byte(s): Stream should still be in-memory.\");\n            assertNull(stream.getPath(), \"After \" + (i + 1) + \" byte(s): Stream path should still be null.\");\n            assertNotNull(stream.getData(), \"After \" + (i + 1) + \" byte(s): Data byte array should not be null.\");\n            assertEquals(i + 1, stream.getData().length, \"After \" + (i + 1) + \" byte(s): Data size mismatch.\");\n            assertArrayEquals(Arrays.copyOf(initialBytes, i + 1), stream.getData(), \"After \" + (i + 1) + \" byte(s): Data content mismatch.\");\n        }\n    }\n\n\n    @Test\n    public void testInMemoryToFileTransitionAcrossWriteVariants() throws IOException {\n        final int threshold = 5;\n        final byte[] initialBytes = \"abcd\".getBytes(StandardCharsets.UTF_8);\n        final byte fifthByte = 'e';\n        final byte[] expectedTotalContent = \"abcde\".getBytes(StandardCharsets.UTF_8);\n\n        // --- Scenario 1: Exceed threshold using write(int) ---\n        Path writtenFilePath1 = null;\n        DeferrableOutputStream stream1 = null; // Declare outside try for post-close assertions\n        try (DeferrableOutputStream stream = new DeferrableOutputStream(threshold, pathSupplier, null)) {\n            stream1 = stream; // Assign to outer variable\n\n            // Verify initial state: in-memory, null path, and empty\n            assertTrue(stream.isInMemory(), \"Initial 1: Stream should be in-memory.\");\n            assertNull(stream.getPath(), \"Initial 1: Stream path should be null.\");\n            assertNotNull(stream.getData(), \"Initial 1: Data byte array should not be null.\");\n            assertEquals(0, stream.getData().length, \"Initial 1: Data byte array should be empty.\");\n\n            writeInitialBytesAndAssertInMemory(stream, initialBytes);\n\n            // Write the 5th byte, triggering transition\n            stream.write(fifthByte);\n\n            // Confirm transition to file-backed storage\n            assertFalse(stream.isInMemory(), \"After threshold 1: Stream should be file-backed.\");\n            assertNotNull(stream.getPath(), \"After threshold 1: Stream path should be non-null.\");\n            writtenFilePath1 = stream.getPath(); // Store path for cleanup and post-close check\n            assertNull(stream.getData(), \"After threshold 1: Data byte array should be null (cleared).\");\n\n        } // stream1 is closed here\n        // After auto-close, verify the stream remains file-backed and readable\n        assertFalse(stream1.isInMemory(), \"After close 1: Closed stream should remain file-backed.\");\n        assertNotNull(stream1.getPath(), \"After close 1: Path should still be non-null.\");\n        assertTrue(Files.exists(stream1.getPath()), \"After close 1: File should exist at path.\");\n        assertTrue(Files.isRegularFile(stream1.getPath()), \"After close 1: Path should point to a regular file.\");\n        try (InputStream inputStream = stream1.toInputStream()) {\n            assertArrayEquals(expectedTotalContent, readAllBytes(inputStream), \"After close 1: File content mismatch.\");\n        } finally {\n            if (writtenFilePath1 != null) {\n                Files.deleteIfExists(writtenFilePath1);\n            }\n        }\n\n        // --- Scenario 2: Exceed threshold using write(byte[]) ---\n        Path writtenFilePath2 = null;\n        DeferrableOutputStream stream2 = null;\n        try (DeferrableOutputStream stream = new DeferrableOutputStream(threshold, pathSupplier, null)) {\n            stream2 = stream;\n\n            // Verify initial state: in-memory, null path, and empty\n            assertTrue(stream.isInMemory(), \"Initial 2: Stream should be in-memory.\");\n            assertNull(stream.getPath(), \"Initial 2: Stream path should be null.\");\n            assertNotNull(stream.getData(), \"Initial 2: Data byte array should not be null.\");\n            assertEquals(0, stream.getData().length, \"Initial 2: Data byte array should be empty.\");\n\n            writeInitialBytesAndAssertInMemory(stream, initialBytes);\n\n            // Write the 5th byte, triggering transition\n            stream.write(new byte[]{fifthByte});\n\n            // Confirm transition to file-backed storage\n            assertFalse(stream.isInMemory(), \"After threshold 2: Stream should be file-backed.\");\n            assertNotNull(stream.getPath(), \"After threshold 2: Stream path should be non-null.\");\n            writtenFilePath2 = stream.getPath();\n            assertNull(stream.getData(), \"After threshold 2: Data byte array should be null (cleared).\");\n\n        }\n        // After auto-close, verify the stream remains file-backed and readable\n        assertFalse(stream2.isInMemory(), \"After close 2: Closed stream should remain file-backed.\");\n        assertNotNull(stream2.getPath(), \"After close 2: Path should still be non-null.\");\n        assertTrue(Files.exists(stream2.getPath()), \"After close 2: File should exist at path.\");\n        assertTrue(Files.isRegularFile(stream2.getPath()), \"After close 2: Path should point to a regular file.\");\n        try (InputStream inputStream = stream2.toInputStream()) {\n            assertArrayEquals(expectedTotalContent, readAllBytes(inputStream), \"After close 2: File content mismatch.\");\n        } finally {\n            if (writtenFilePath2 != null) {\n                Files.deleteIfExists(writtenFilePath2);\n            }\n        }\n\n        // --- Scenario 3: Exceed threshold using write(byte[], int, int) ---\n        Path writtenFilePath3 = null;\n        DeferrableOutputStream stream3 = null;\n        try (DeferrableOutputStream stream = new DeferrableOutputStream(threshold, pathSupplier, null)) {\n            stream3 = stream;\n\n            // Verify initial state: in-memory, null path, and empty\n            assertTrue(stream.isInMemory(), \"Initial 3: Stream should be in-memory.\");\n            assertNull(stream.getPath(), \"Initial 3: Stream path should be null.\");\n            assertNotNull(stream.getData(), \"Initial 3: Data byte array should not be null.\");\n            assertEquals(0, stream.getData().length, \"Initial 3: Data byte array should be empty.\");\n\n            writeInitialBytesAndAssertInMemory(stream, initialBytes);\n\n            // Write the 5th byte, triggering transition\n            stream.write(new byte[]{'x', fifthByte, 'y'}, 1, 1);\n\n            // Confirm transition to file-backed storage\n            assertFalse(stream.isInMemory(), \"After threshold 3: Stream should be file-backed.\");\n            assertNotNull(stream.getPath(), \"After threshold 3: Stream path should be non-null.\");\n            writtenFilePath3 = stream.getPath();\n            assertNull(stream.getData(), \"After threshold 3: Data byte array should be null (cleared).\");\n\n        }\n        // After auto-close, verify the stream remains file-backed and readable\n        assertFalse(stream3.isInMemory(), \"After close 3: Closed stream should remain file-backed.\");\n        assertNotNull(stream3.getPath(), \"After close 3: Path should still be non-null.\");\n        assertTrue(Files.exists(stream3.getPath()), \"After close 3: File should exist at path.\");\n        assertTrue(Files.isRegularFile(stream3.getPath()), \"After close 3: Path should point to a regular file.\");\n        try (InputStream inputStream = stream3.toInputStream()) {\n            assertArrayEquals(expectedTotalContent, readAllBytes(inputStream), \"After close 3: File content mismatch.\");\n        } finally {\n            if (writtenFilePath3 != null) {\n                Files.deleteIfExists(writtenFilePath3);\n            }\n        }\n    }\n}",
      "method_signature": "testExceedPositiveThreshold()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7098,
    "output_tokens": 7532,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 130,
      "description": "Define a test class that validates the behavior of a Deferrable Output Stream when configured with a threshold of negative one, ensuring immediate file persistence without in-memory buffering. Declare a static final Path field pointing to a base test directory, a static Path field for a temporary test directory, and a Supplier field that provides temporary file paths. Implement a static setup method that creates the base test directory structure and generates a temporary subdirectory within it using the Files utility. Within the test method, initialize an array to hold a reference to the stream instance for verification after closure, then construct a Runnable that encapsulates the test logic. Inside this Runnable, instantiate a Deferrable Output Stream with a threshold of negative one, passing the test file supplier and a null listener, capturing the instance in the array for post-closure inspection. While the stream remains open within a try-with-resources block, verify that the stream is not in memory mode by asserting false on the in-memory check, confirm that a file path has been assigned by asserting the path is not null, and validate that no byte array representation exists by asserting the bytes accessor returns null. Upon exiting the try-with-resources block and closing the stream, retrieve the stream reference from the array and reconfirm it is not in memory mode, assert the path remains non-null, and verify the path points to a regular file using the Files utility. Obtain an input stream from the closed Deferrable Output Stream and create a private helper method that reads all bytes from an input stream into a byte array by buffering chunks until end-of-stream is reached. Read the complete contents from the input stream into an actual byte array using this helper, then construct an expected byte array representing an empty UTF-8 encoded string, and assert the actual bytes match the expected empty array. Execute the Runnable to perform all configured verifications. The test uses standard assertion methods from a testing framework without specifying teardown for the temporary file resources.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testThresholdMinusOne()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamNegativeThresholdTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.function.Supplier;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link DeferrableOutputStream} when configured with a negative one threshold,\n * ensuring immediate file persistence without in-memory buffering.\n */\npublic class DeferrableOutputStreamNegativeThresholdTest {\n\n    /**\n     * Base directory for all temporary test output.\n     */\n    private static final Path BASE_TEST_DIRECTORY = Paths.get(\"target\", \"test-output\", \"DeferrableOutputStreamNegativeThresholdTest\");\n\n    /**\n     * Temporary directory for the current test run, generated within {@link #BASE_TEST_DIRECTORY}.\n     */\n    private static Path tempTestDirectory;\n\n    /**\n     * Supplier for creating temporary files within {@link #tempTestDirectory}.\n     */\n    private static Supplier<Path> tempFileSupplier;\n\n    /**\n     * Sets up the base test directory and initializes the temporary directory and file supplier.\n     *\n     * @throws IOException if an I/O error occurs during directory creation.\n     */\n    @BeforeAll\n    static void setup() throws IOException {\n        Files.createDirectories(BASE_TEST_DIRECTORY);\n        tempTestDirectory = Files.createTempDirectory(BASE_TEST_DIRECTORY, \"test-\");\n        tempFileSupplier = () -> {\n            try {\n                return Files.createTempFile(tempTestDirectory, \"file-\", \".tmp\");\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n    }\n\n    /**\n     * Reads all bytes from an input stream into a byte array by buffering through an\n     * intermediate byte array output stream.\n     *\n     * @param inputStream The input stream to read.\n     * @return A new byte array containing the contents of the stream.\n     * @throws IOException If an I/O error occurs.\n     */\n    private byte[] readAllBytes(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final byte[] buffer = new byte[1024];\n        int len;\n        while ((len = inputStream.read(buffer)) != -1) {\n            baos.write(buffer, 0, len);\n        }\n        return baos.toByteArray();\n    }\n\n    /**\n     * Validates the behavior of {@link DeferrableOutputStream} when initialized with a\n     * threshold of negative one, ensuring immediate file backing and proper handling\n     * of an empty stream.\n     */\n    @Test\n    public void testNegativeThresholdBehavior() {\n        // Initialize an array to hold a reference to the stream instance for verification after closure.\n        final DeferrableOutputStream[] streamHolder = new DeferrableOutputStream[1];\n\n        // Construct a Runnable that encapsulates the test logic.\n        final Runnable testLogic = () -> {\n            try (DeferrableOutputStream stream = new DeferrableOutputStream(-1, tempFileSupplier, null)) {\n                // Capture the instance in the array for post-closure inspection.\n                streamHolder[0] = stream;\n\n                // While the stream remains open within a try-with-resources block,\n                // verify that the stream is not in memory mode by asserting false on the in-memory check,\n                assertFalse(stream.isInMemory(), \"Stream should immediately be file-backed with negative threshold.\");\n                // confirm that a file path has been assigned by asserting the path is not null,\n                assertNotNull(stream.getPath(), \"Stream path should be non-null with negative threshold.\");\n                // and validate that no byte array representation exists by asserting the bytes accessor returns null.\n                assertNull(stream.getData(), \"Data byte array should be null when file-backed immediately.\");\n\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n\n            // Upon exiting the try-with-resources block and closing the stream,\n            // retrieve the stream reference from the array\n            final DeferrableOutputStream closedStream = streamHolder[0];\n            // and reconfirm it is not in memory mode,\n            assertFalse(closedStream.isInMemory(), \"Closed stream should remain file-backed.\");\n            // assert the path remains non-null,\n            assertNotNull(closedStream.getPath(), \"Closed stream path should remain non-null.\");\n            // and verify the path points to a regular file using the Files utility.\n            assertTrue(Files.isRegularFile(closedStream.getPath()), \"Path should point to a regular file after close.\");\n\n            // Obtain an input stream from the closed Deferrable Output Stream\n            try (InputStream inputStream = closedStream.toInputStream()) {\n                // Read the complete contents from the input stream into an actual byte array using this helper,\n                final byte[] actualBytes = readAllBytes(inputStream);\n                // then construct an expected byte array representing an empty UTF-8 encoded string,\n                final byte[] expectedBytes = \"\".getBytes(StandardCharsets.UTF_8);\n                // and assert the actual bytes match the expected empty array.\n                assertArrayEquals(expectedBytes, actualBytes, \"Content should be empty for negative threshold stream with no writes.\");\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n        // Execute the Runnable to perform all configured verifications.\n        testLogic.run();\n    }\n}",
      "method_signature": "testThresholdMinusOne()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7173,
    "output_tokens": 5857,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 138,
      "description": "Define a test method that validates the behavior of a Deferrable Output Stream configured with a zero-byte threshold by establishing a reusable testing lambda that encapsulates the complete lifecycle verification pattern, then exercising this pattern across three distinct write operation variants. Begin by declaring an array to capture stream references across lambda boundaries and construct a Consumer that accepts a write operation callback, where within a try-with-resources block you instantiate the Deferrable Output Stream with threshold zero, a path supplier field, and null listener, then immediately verify the stream reports in-memory status, null path, null byte array, and initialized state before invoking the provided write callback and subsequently confirming the stream has transitioned to file-backed storage with non-null path and null byte array. After the stream auto-closes, retrieve the captured stream reference and confirm it remains file-backed with a valid regular file at the reported path, then obtain an input stream from the closed Deferrable Output Stream and create a private helper method that reads all bytes from an input stream into a byte array by buffering through an intermediate byte array output stream, comparing the read content against the expected single-byte comma representation in UTF-8 encoding. Exercise this testing lambda three times by providing distinct write callbacks: first invoke the single-byte write method with the comma character integer value, second invoke the byte array write method with a single-element comma byte array, and third invoke the ranged byte array write method with a two-element array containing comma and dash bytes while specifying offset zero and length one to write only the comma. The test validates that regardless of write method variant, a zero threshold immediately triggers file persistence upon the first byte written, transitioning from initialized state directly to persisted state without an intermediate in-memory phase, and that the persisted file correctly contains the written data accessible after stream closure. This test uses JUnit 5 for test execution and standard JUnit assertions for state verification.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testThresholdZero()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamZeroThresholdLifecycleTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link DeferrableOutputStream} when configured with a zero-byte threshold,\n * validating the complete lifecycle behavior across various write operations.\n */\npublic class DeferrableOutputStreamZeroThresholdLifecycleTest {\n\n    /**\n     * Defines a write operation that can be passed to the test logic and may throw\n     * an {@link IOException}.\n     */\n    @FunctionalInterface\n    private interface WriteOperation {\n        void perform(DeferrableOutputStream stream) throws IOException;\n    }\n\n    @TempDir\n    private static Path tempDir;\n\n    private final Supplier<Path> pathSupplier = () -> {\n        try {\n            return Files.createTempFile(tempDir, \"test-\", \".dat\");\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    };\n\n    /**\n     * Reads all bytes from an input stream into a byte array by buffering through an\n     * intermediate byte array output stream.\n     *\n     * @param inputStream The input stream to read.\n     * @return A new byte array containing the contents of the stream.\n     * @throws IOException If an I/O error occurs.\n     */\n    private byte[] readAllBytes(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final byte[] buffer = new byte[1024];\n        int len;\n        while ((len = inputStream.read(buffer)) != -1) {\n            baos.write(buffer, 0, len);\n        }\n        return baos.toByteArray();\n    }\n\n    @Test\n    public void testZeroThresholdLifecycleAcrossWriteVariants() {\n        final DeferrableOutputStream[] streamHolder = new DeferrableOutputStream[1];\n        final byte[] expectedCommaByte = \",\".getBytes(StandardCharsets.UTF_8);\n\n        // A reusable testing lambda that encapsulates the complete lifecycle verification pattern.\n        final Consumer<WriteOperation> testLifecyclePattern = writeCallback -> {\n            Path writtenFilePath = null;\n            try (DeferrableOutputStream stream = new DeferrableOutputStream(0, pathSupplier, null)) {\n                streamHolder[0] = stream;\n\n                // Verify initial state: in-memory, null path, and empty (initialized).\n                assertTrue(stream.isInMemory(), \"Stream should start in-memory.\");\n                assertNull(stream.getPath(), \"Stream path should be null before writing.\");\n                assertNotNull(stream.getData(), \"Initial data byte array should not be null.\");\n                assertEquals(0, stream.getData().length, \"Initial data byte array should be empty.\");\n\n                // Invoke the provided write callback, triggering the transition.\n                writeCallback.perform(stream);\n\n                // Confirm the stream has transitioned to file-backed storage.\n                assertFalse(stream.isInMemory(), \"Stream should be file-backed after write.\");\n                assertNotNull(stream.getPath(), \"Stream path should be non-null after transition.\");\n                writtenFilePath = stream.getPath();\n                assertNull(stream.getData(), \"Data byte array should be null when file-backed.\");\n\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n\n            // After auto-close, verify the stream remains file-backed and readable.\n            final DeferrableOutputStream closedStream = streamHolder[0];\n            assertFalse(closedStream.isInMemory(), \"Closed stream should remain file-backed.\");\n            assertNotNull(closedStream.getPath(), \"Closed stream path should be non-null.\");\n            assertTrue(Files.isRegularFile(closedStream.getPath()), \"Path should point to a regular file.\");\n\n            try (InputStream inputStream = closedStream.toInputStream()) {\n                final byte[] actualContent = readAllBytes(inputStream);\n                assertArrayEquals(expectedCommaByte, actualContent, \"File content mismatch for stream: \" + closedStream.getPath());\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            } finally {\n                if (writtenFilePath != null) {\n                    try {\n                        Files.deleteIfExists(writtenFilePath);\n                    } catch (final IOException e) {\n                        // Suppress cleanup exception\n                    }\n                }\n            }\n        };\n\n        // Exercise the testing lambda with three distinct write operation variants.\n\n        // 1. Single-byte write method.\n        testLifecyclePattern.accept(stream -> stream.write(','));\n\n        // 2. Byte array write method.\n        testLifecyclePattern.accept(stream -> stream.write(new byte[]{','}));\n\n        // 3. Ranged byte array write method (writing only the comma).\n        testLifecyclePattern.accept(stream -> stream.write(new byte[]{',', '-'}, 0, 1));\n    }\n}",
      "method_signature": "testThresholdZero()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7161,
    "output_tokens": 3170,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 142,
      "description": "Create a test case to validate that the multipart stream processing system properly rejects configurations with insufficient processing capacity by preparing a sample data stream containing a short text payload and defining a stream boundary marker, then configuring the system to process this multipart content with an extremely limited processing capacity of only one unit, which is inadequate for handling the boundary detection requirements, and simultaneously attaching progress monitoring capabilities to track the expected data volume, then attempting to initialize the stream processor with these inadequate settings and verifying that the system immediately recognizes the insufficient capacity constraint and refuses to proceed by signaling an invalid configuration condition, thereby ensuring the system protects itself against configurations that would prevent proper boundary recognition and reliable stream parsing, with validation performed using JUnit 5 as the testing framework and standard assertion capabilities to confirm the expected rejection behavior occurs.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testSmallBuffer()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartStreamInsufficientCapacityTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport org.apache.commons.fileupload2.core.AbstractFileUpload;\nimport org.apache.commons.fileupload2.core.DiskFileItemFactory;\nimport org.apache.commons.fileupload2.core.FileUploadByteCountLimitException;\nimport org.apache.commons.fileupload2.core.AbstractRequestContext;\n\n/**\n * Tests the multipart stream processing system's ability to reject configurations\n * with insufficient processing capacity. Specifically, it validates that a\n * {@link FileUploadByteCountLimitException} is thrown when the configured\n * maximum request size is too small to even accommodate the multipart boundary,\n * preventing proper boundary detection and reliable stream parsing.\n */\npublic class MultipartStreamInsufficientCapacityTest {\n\n    /**\n     * JUnit 5 annotation to provide a temporary directory for test files.\n     */\n    @TempDir\n    static Path tempDir;\n\n    /**\n     * Tests that the multipart processing system throws {@link FileUploadByteCountLimitException}\n     * when the configured maximum request size is insufficient for boundary detection.\n     *\n     * @throws IOException if an I/O error occurs during stream operations\n     */\n    @Test\n    void testMultipartProcessingRejectsInsufficientCapacity() throws IOException {\n        // Define a boundary marker that is longer than the allowed processing capacity.\n        final String boundary = \"----WebKitFormBoundaryRandomStringHere12345\"; // Length: 42\n        final String contentType = \"multipart/form-data; boundary=\" + boundary;\n\n        // Prepare a minimal sample data stream containing a short text payload.\n        // The crucial part is that the boundary itself will exceed the 1-byte limit.\n        final String partHeader = \"Content-Disposition: form-data; name=\\\"testField\\\"\\r\\n\\r\\n\";\n        final String partContent = \"a\"; // Short payload\n        final String multipartContent = \"--\" + boundary + \"\\r\\n\" +\n                                        partHeader +\n                                        partContent + \"\\r\\n\" +\n                                        \"--\" + boundary + \"--\\r\\n\";\n\n        final byte[] contentBytes = multipartContent.getBytes(StandardCharsets.US_ASCII);\n\n        // Configure a mock RequestContext to simulate an incoming multipart request.\n        final AbstractRequestContext requestContext = new AbstractRequestContext() {\n            @Override\n            public String getContentType() {\n                return contentType;\n            }\n\n            @Override\n            public String getCharacterEncoding() {\n                return StandardCharsets.US_ASCII.name();\n            }\n\n            @Override\n            public long contentLength() {\n                return contentBytes.length;\n            }\n\n            @Override\n            public InputStream getInputStream() throws IOException {\n                return new ByteArrayInputStream(contentBytes);\n            }\n        };\n\n        // Configure the file upload system with an extremely limited processing capacity of only one unit.\n        // This capacity (1 byte) is deliberately inadequate for handling the boundary detection requirements,\n        // as the boundary string (42 bytes plus -- prefix and CRLF suffixes) is significantly longer.\n        final DiskFileItemFactory fileItemFactory = new DiskFileItemFactory(0, tempDir.toFile());\n        final AbstractFileUpload fileUpload = new AbstractFileUpload(fileItemFactory);\n        fileUpload.setSizeMax(1); // Set overall request size limit to 1 byte\n\n        // Attach a dummy progress monitoring listener to track expected data volume.\n        // While its state is not directly asserted in this test, its presence fulfills the requirement.\n        final AtomicLong bytesRead = new AtomicLong();\n        fileUpload.setProgressListener((pBytesRead, pContentLength, pItems) -> {\n            bytesRead.set(pBytesRead);\n        });\n\n        // Attempt to initialize and process the stream with these inadequate settings.\n        // Verify that the system immediately recognizes the insufficient capacity constraint\n        // and refuses to proceed by signaling an invalid configuration condition,\n        // specifically a FileUploadByteCountLimitException.\n        assertThrows(FileUploadByteCountLimitException.class, () -> {\n            fileUpload.parseRequest(requestContext);\n        }, \"FileUpload should throw FileUploadByteCountLimitException because the request size limit is too small to even read the multipart boundary.\");\n    }\n}",
      "method_signature": "testSmallBuffer()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6930,
    "output_tokens": 4961,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 145,
      "description": "Define a test class containing three private fields: a static final `Path` named `testDir`, a static `Path` named `tempTestDir`, and a non-static `Supplier<Path>` named `testFileSupplier`. Implement a static setup method annotated with `@BeforeAll` that invokes `Files.createDirectories(testDir)` to ensure the directory exists, then assigns the result of `Files.createTempDirectory(testDir, \"testDir\")` to `tempTestDir`. Within the test method annotated with `@Test`, declare a local variable `streams` as a `DeferrableOutputStream` array of size 1 using `new DeferrableOutputStream[1]`. Next, define a local variable `tester` of type `Runnable` initialized with a lambda expression that executes the following logic: open a try-with-resources block instantiating a `DeferrableOutputStream` named `dos` by invoking the constructor with arguments `-1`, `testFileSupplier`, and `null`, then immediately assign `dos` to `streams[0]`. Within the try block, invoke `dos.isInMemory()` and pass the result to `assertFalse`, then invoke `dos.getPath()` and pass the result to `assertNotNull`, and invoke `dos.getBytes()` and pass the result to `assertNull`. In the catch block for `IOException` named `ioe`, throw a new `UncheckedIOException` constructed with `ioe`. After the try-with-resources completes, declare a final variable `dos` of type `DeferrableOutputStream` and assign it the value `streams[0]`. Invoke `dos.isInMemory()` and pass the result to `assertFalse`, then invoke `dos.getPath()` and pass the result to `assertNotNull`. Invoke `Files.isRegularFile(dos.getPath())` and pass the result to `assertTrue`. Declare an uninitialized final `byte[]` variable named `actual`, then open a try-with-resources block declaring an `InputStream` named `is` initialized by invoking `dos.getInputStream()`. Within this try block, define a private method that creates a `ByteArrayOutputStream` named `baos`, declares a `byte[]` buffer of size 8192, enters an infinite loop invoking `pIs.read(buffer)` and assigning the result to an `int` variable `res`, returns `baos.toByteArray()` if `res` equals `-1`, otherwise invokes `baos.write(buffer, 0, res)` if `res` is greater than 0, and invoke this method with `is` as the argument, assigning the returned byte array to `actual`. In the catch block for `IOException` named `ioe`, throw a new `UncheckedIOException` constructed with `ioe`. After the try-with-resources, declare a final `byte[]` variable `expect` initialized by invoking `\"\".getBytes(StandardCharsets.UTF_8)`, then invoke `assertArrayEquals(expect, actual)`. Finally, after the lambda definition, invoke `tester.run()` to execute the test logic. The test uses JUnit 5 Assertions with method-level annotation `@Test` and no class-level annotations.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testThresholdMinusOne()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamFileBasedTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.function.Supplier;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\npublic class DeferrableOutputStreamFileBasedTest {\n\n    private static final Path testDir = Paths.get(\"target\", \"test-dos-filebased\");\n    private static Path tempTestDir;\n    private Supplier<Path> testFileSupplier;\n\n    @BeforeAll\n    public static void setUp() throws IOException {\n        Files.createDirectories(testDir);\n        tempTestDir = Files.createTempDirectory(testDir, \"testDir\");\n    }\n\n    private byte[] readAllBytes(final InputStream pIs) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final byte[] buffer = new byte[8192];\n        int res;\n        while ((res = pIs.read(buffer)) != -1) {\n            if (res > 0) {\n                baos.write(buffer, 0, res);\n            }\n        }\n        return baos.toByteArray();\n    }\n\n    @Test\n    public void testFileBasedOutputStreamBehavior() {\n        testFileSupplier = () -> {\n            try {\n                return Files.createTempFile(tempTestDir, \"test-\", \".tmp\");\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n\n        final DeferrableOutputStream[] streams = new DeferrableOutputStream[1];\n        final Runnable tester = () -> {\n            try (DeferrableOutputStream dos = new DeferrableOutputStream(-1, testFileSupplier, null)) {\n                streams[0] = dos;\n                assertFalse(dos.isInMemory());\n                assertNotNull(dos.getPath());\n                assertNull(dos.getBytes());\n            } catch (final IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n\n            final DeferrableOutputStream dos = streams[0];\n            assertFalse(dos.isInMemory());\n            assertNotNull(dos.getPath());\n            assertTrue(Files.isRegularFile(dos.getPath()));\n\n            final byte[] actual;\n            try (InputStream is = dos.getInputStream()) {\n                actual = readAllBytes(is);\n            } catch (final IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n\n            final byte[] expect = \"\".getBytes(StandardCharsets.UTF_8);\n            assertArrayEquals(expect, actual);\n        };\n        tester.run();\n    }\n}",
      "method_signature": "testThresholdMinusOne()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.96,
      "callable_precision": 0.8889,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 0.8864,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7442,
    "output_tokens": 3148,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 147,
      "description": "Define a test method that validates the behavior of a Deferrable Output Stream when exceeding a positive memory threshold by creating a reusable test harness implemented as a Consumer that accepts write operations, then invoke this harness three times with different write strategies to confirm consistent threshold-crossing behavior. Initialize a single-element array to capture the stream instance for post-closure verification, then define the test harness as a Consumer that constructs a Deferrable Output Stream with a threshold of 5 bytes and a path supplier for temporary file creation. Upon stream creation, verify the stream reports in-memory status, returns null for both file path and byte array accessors, and reflects an initialized state. Write four bytes individually using the single-byte write method, confirming after each write that the state transitions to opened while maintaining in-memory status with null path and byte array values. Pass the stream to the provided write operation Consumer to trigger the threshold-crossing write, then verify the stream transitions to file-backed storage by confirming it no longer reports in-memory status, now returns a non-null file path, and still returns null for the byte array accessor since data resides on disk. After the stream closes via try-with-resources, retrieve the captured stream instance from the array and confirm it remains in file-backed state with a non-null path that references a regular file on the filesystem. Obtain an input stream from the closed Deferrable Output Stream and create a private helper method that reads all bytes from an input stream into a byte array by buffering chunks until end-of-stream, then use this helper to extract the written content. Convert the expected content string to a byte array and assert the actual bytes match the expected sequence of four dots followed by a comma. Invoke the test harness with a Consumer that writes a single comma byte using the single-byte write method to cross the threshold, then invoke it again with a Consumer that writes a single-element byte array containing a comma using the array write method, and finally invoke it with a Consumer that writes the first byte from a two-element byte array using the bounded array write method with offset zero and length one, ensuring all three write strategies produce identical threshold-crossing behavior and file persistence outcomes using JUnit 5 assertions.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testExceedPositiveThreshold()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamPositiveThresholdTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link DeferrableOutputStream} when configured with a positive byte threshold.\n * This test validates the behavior of the stream transitioning from in-memory to\n * file-backed storage when a positive threshold is exceeded across different write methods.\n */\npublic class DeferrableOutputStreamPositiveThresholdTest {\n\n    @TempDir\n    private static Path tempDir;\n\n    private final Supplier<Path> pathSupplier = () -> {\n        try {\n            return Files.createTempFile(tempDir, \"pos-test-\", \".dat\");\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    };\n\n    /**\n     * Reads all bytes from an input stream into a byte array by buffering through an\n     * intermediate byte array output stream.\n     *\n     * @param inputStream The input stream to read.\n     * @return A new byte array containing the contents of the stream.\n     * @throws IOException If an I/O error occurs.\n     */\n    private byte[] readAllBytes(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final byte[] buffer = new byte[1024];\n        int len;\n        while ((len = inputStream.read(buffer)) != -1) {\n            baos.write(buffer, 0, len);\n        }\n        return baos.toByteArray();\n    }\n\n    /**\n     * Defines a write operation that can be passed to the test logic and may throw\n     * an {@link IOException}. This operation is intended to perform the threshold-crossing write.\n     */\n    @FunctionalInterface\n    private interface WriteOperation {\n        void perform(DeferrableOutputStream stream) throws IOException;\n    }\n\n    @Test\n    void testPositiveThresholdLifecycleAcrossWriteVariants() {\n        final DeferrableOutputStream[] streamHolder = new DeferrableOutputStream[1];\n        final String expectedContentString = \"....,\"; // Four dots, then a comma (5 bytes total)\n        final byte[] expectedContentBytes = expectedContentString.getBytes(StandardCharsets.UTF_8);\n\n        // A reusable testing lambda that encapsulates the complete lifecycle verification pattern.\n        final Consumer<WriteOperation> testHarness = thresholdCrossingWriteOperation -> {\n            Path writtenFilePath = null;\n            try (DeferrableOutputStream stream = new DeferrableOutputStream(5, pathSupplier, null)) { // Threshold of 5 bytes\n                streamHolder[0] = stream;\n\n                // 1. Verify initial state upon stream creation.\n                // It should be in-memory, have no file path, and an empty (but non-null) data buffer.\n                assertTrue(stream.isInMemory(), \"Stream should start in-memory.\");\n                assertNull(stream.getPath(), \"Initial stream path should be null.\");\n                assertNotNull(stream.getData(), \"Initial data byte array should not be null when in-memory.\");\n                assertEquals(0, stream.getData().length, \"Initial data byte array should be empty.\");\n\n                // 2. Write four bytes individually, confirming in-memory status after each write.\n                // This brings the stream to just below the threshold.\n                for (int i = 0; i < 4; i++) {\n                    stream.write('.'); // Writing a dot character\n                    assertTrue(stream.isInMemory(), \"Stream should remain in-memory after writing \" + (i + 1) + \" bytes.\");\n                    assertNull(stream.getPath(), \"Stream path should be null while in-memory.\");\n                    assertNotNull(stream.getData(), \"Data byte array should not be null while in-memory.\");\n                    assertEquals(i + 1, stream.getData().length, \"Data byte array length mismatch after writing \" + (i + 1) + \" bytes.\");\n                }\n\n                // 3. Pass the stream to the provided WriteOperation to trigger the threshold-crossing write.\n                thresholdCrossingWriteOperation.perform(stream);\n\n                // 4. Verify the stream transitions to file-backed storage after crossing the threshold.\n                assertFalse(stream.isInMemory(), \"Stream should be file-backed after crossing threshold.\");\n                assertNotNull(stream.getPath(), \"Stream path should be non-null after transition to file.\");\n                writtenFilePath = stream.getPath(); // Capture the path for post-closure verification and cleanup\n                assertTrue(Files.exists(writtenFilePath), \"File should exist on disk after transition.\");\n                assertNull(stream.getData(), \"Data byte array should be null when file-backed.\");\n\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n\n            // 5. Post-closure verification: Retrieve the captured stream instance and verify its final state.\n            final DeferrableOutputStream closedStream = streamHolder[0];\n            assertFalse(closedStream.isInMemory(), \"Closed stream should remain file-backed.\");\n            assertNotNull(closedStream.getPath(), \"Closed stream path should be non-null.\");\n            assertTrue(Files.isRegularFile(closedStream.getPath()), \"Path should point to a regular file after closure.\");\n\n            // 6. Obtain an input stream from the closed DeferrableOutputStream and verify its content.\n            try (InputStream inputStream = closedStream.toInputStream()) {\n                final byte[] actualContent = readAllBytes(inputStream);\n                assertArrayEquals(expectedContentBytes, actualContent, \"File content mismatch after closure.\");\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            } finally {\n                // Clean up the temporary file if it was created and still exists.\n                if (writtenFilePath != null && Files.exists(writtenFilePath)) {\n                    try {\n                        Files.delete(writtenFilePath);\n                    } catch (final IOException e) {\n                        // Log or suppress cleanup exception if it occurs, as it should not fail the test\n                        System.err.println(\"Failed to clean up temporary file: \" + writtenFilePath + \" - \" + e.getMessage());\n                    }\n                }\n            }\n        };\n\n        // Invoke the test harness with three different write strategies to cross the threshold.\n\n        // Strategy 1: Use the single-byte write method to write the threshold-crossing byte.\n        testHarness.accept(stream -> stream.write(','));\n\n        // Strategy 2: Use the byte array write method to write the threshold-crossing byte.\n        testHarness.accept(stream -> stream.write(new byte[]{','}));\n\n        // Strategy 3: Use the bounded byte array write method to write the threshold-crossing byte\n        // (writing the first byte from a two-element array, which is the comma).\n        testHarness.accept(stream -> stream.write(new byte[]{',', 'x'}, 0, 1));\n    }\n}",
      "method_signature": "testExceedPositiveThreshold()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7230,
    "output_tokens": 7460,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 148,
      "description": "Define a test method that validates the Multipart Input Builder's rejection of insufficient buffer sizes by first preparing test data consisting of a short string and converting both the string and the class-level boundary constant to byte arrays, then wrapping the string bytes in a Byte Array Input Stream to serve as the data source. Obtain a new Multipart Input Builder instance and configure it by chaining the input stream setter, boundary setter, buffer size setter with a value of one byte, and progress notifier setter with a newly constructed Progress Notifier initialized with null listener and the content length derived from the byte array, then invoke the builder's get method to attempt construction of the Multipart Input instance. Assert that this construction attempt throws an Illegal Argument Exception, confirming that the builder enforces minimum buffer size constraints when the specified buffer is too small to accommodate the boundary token plus required overhead bytes. The test uses JUnit 5 for the assertion framework.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testSmallBuffer()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputBufferSizeTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MultipartInputBufferSizeTest {\n\n    @Test\n    public void testBuilderRejectsInsufficientBufferSize() {\n        // 1. Prepare test data\n        final String testContent = \"short\";\n        final byte[] testContentBytes = testContent.getBytes(StandardCharsets.UTF_8);\n        final byte[] boundaryBytes = \"myboundary\".getBytes(StandardCharsets.UTF_8);\n\n        // 2. Wrap the string bytes in a ByteArrayInputStream\n        final ByteArrayInputStream inputStream = new ByteArrayInputStream(testContentBytes);\n\n        // 3. Obtain a new Multipart Input Builder instance\n        final MultipartInput.Builder builder = MultipartInput.builder();\n\n        // 4. Configure the builder with an insufficient buffer size\n        final long contentLength = testContentBytes.length;\n        final MultipartInput.ProgressNotifier progressNotifier = new MultipartInput.ProgressNotifier(null, contentLength);\n\n        builder.setInputStream(inputStream)\n                .setBoundary(boundaryBytes)\n                .setBufferSize(1) // Set buffer size to 1 byte, which is insufficient\n                .setProgressNotifier(progressNotifier);\n\n        // 5. Assert that invoking builder.get() throws an IllegalArgumentException\n        assertThrows(IllegalArgumentException.class, () -> builder.get(),\n                \"MultipartInput.Builder should reject an insufficient buffer size.\");\n    }\n}",
      "method_signature": "testSmallBuffer()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "search_file_content": 1,
          "read_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 29456,
    "output_tokens": 1667,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 152,
      "description": "Create a test case to validate that the system enforces size restrictions on metadata sections when processing multi-part file upload requests. Prepare a simulated upload request containing two file submissions, each with associated metadata headers, and configure the upload processor with a maximum metadata size limit of 100 bytes per file part. Initiate processing of the request by skipping any preamble content and entering a loop to process each file part sequentially. For each part encountered, attempt to extract the metadata headers and confirm their presence, then process the file content itself before advancing to the next part boundary. Expect the system to reject the request with a size violation error during this processing, as the metadata for one of the file parts exceeds the configured limit. When the size violation occurs, verify that the error reports the correct permitted size threshold of 100 bytes, confirming the system properly enforces metadata size constraints to protect against oversized header attacks. If processing completes without triggering the expected size violation, the test should fail to indicate that the enforcement mechanism is not functioning correctly. Verify using standard equality assertions with JUnit 5 and confirm the appropriate business failure condition is raised when metadata limits are exceeded.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testPartHeaderSizeMaxLimit()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.FileUploadMetadataLimitTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FileUploadMetadataLimitTest {\n\n    private static final String BOUNDARY = \"---------------------------735323031399963166993862128\";\n    private static final String CONTENT_TYPE = \"multipart/form-data; boundary=\" + BOUNDARY;\n    private static final String HEADER_ENCODING = StandardCharsets.UTF_8.name();\n\n    /**\n     * Custom RequestContext implementation for testing.\n     * Provides a controlled input stream for multipart request data.\n     */\n    private static class TestRequestContext extends AbstractRequestContext {\n        private final byte[] requestData;\n\n        public TestRequestContext(final byte[] requestData) {\n            super(CONTENT_TYPE, HEADER_ENCODING);\n            this.requestData = requestData;\n        }\n\n        @Override\n        public InputStream getInputStream() throws IOException {\n            return new ByteArrayInputStream(requestData);\n        }\n    }\n\n    /**\n     * Tests that the system enforces size restrictions on metadata sections (headers)\n     * when processing multi-part file upload requests.\n     */\n    @Test\n    void testMetadataSizeLimitEnforcement() throws IOException {\n        // Prepare a simulated upload request with two file submissions.\n        // The first part has short, valid headers.\n        String part1Headers =\n                \"--\" + BOUNDARY + \"\\r\\n\" +\n                \"Content-Disposition: form-data; name=\\\"field1\\\"\\r\\n\" +\n                \"\\r\\n\";\n        String part1Content = \"value1\\r\\n\";\n\n        // The second part has an intentionally oversized Content-Disposition header.\n        // This header's byte length will exceed the 100-byte limit set for metadata.\n        String oversizedHeaderValue =\n                \"form-data; name=\\\"long_field_name_that_exceeds_one_hundred_bytes_when_encoded_in_utf8_\" +\n                \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx_\" +\n                \"this_is_a_very_long_header_value_to_trigger_the_limit_for_testing_purposes\\\"; filename=\\\"longfile.txt\\\"\";\n\n        // Assert that the crafted header value indeed exceeds 100 bytes.\n        assertTrue(oversizedHeaderValue.getBytes(StandardCharsets.UTF_8).length > 100,\n                \"Oversized header value must be longer than 100 bytes to trigger the limit.\");\n\n        String part2Headers =\n                \"--\" + BOUNDARY + \"\\r\\n\" +\n                \"Content-Disposition: \" + oversizedHeaderValue + \"\\r\\n\" +\n                \"Content-Type: text/plain\\r\\n\" +\n                \"\\r\\n\";\n        String part2Content = \"content_for_long_header_file\\r\\n\";\n\n        String endBoundary = \"--\" + BOUNDARY + \"--\\r\\n\";\n\n        // Assemble the full multipart request body.\n        String requestBodyString = part1Headers + part1Content + part2Headers + part2Content + endBoundary;\n        byte[] requestData = requestBodyString.getBytes(StandardCharsets.UTF_8);\n\n        // Create a custom RequestContext for the simulated request.\n        TestRequestContext requestContext = new TestRequestContext(requestData);\n\n        // Configure the upload processor (AbstractFileUpload) with a metadata size limit of 100 bytes.\n        AbstractFileUpload upload = new AbstractFileUpload(new DiskFileItemFactory());\n        upload.setHeaderReadThreshold(100); // This sets the maximum bytes allowed for all headers of a single part.\n\n        // Obtain an iterator to process the file parts.\n        FileItemInputIterator iterator = upload.getItemIterator(requestContext);\n\n        // Process the first file part. It should pass without issues as its headers are small.\n        assertTrue(iterator.hasNext(), \"The iterator should have the first part.\");\n        FileItemInput item1 = iterator.next();\n        assertNotNull(item1.getHeaders(), \"First item should have non-null headers.\");\n\n        // Read and drain the content of the first part to advance to the next boundary.\n        try (InputStream is1 = item1.openStream()) {\n            byte[] buffer = new byte[1024];\n            while (is1.read(buffer) != -1) { /* drain stream */ }\n        }\n\n        // Attempt to process the second file part.\n        // This is expected to trigger a FileUploadByteCountLimitException\n        // because its metadata headers exceed the configured 100-byte limit.\n        FileUploadByteCountLimitException caughtException = null;\n        try {\n            assertTrue(iterator.hasNext(), \"The iterator should attempt to read the second part.\");\n            FileItemInput item2 = iterator.next(); // Header parsing occurs here or during next access.\n            // Explicitly access headers to ensure parsing is attempted if lazy.\n            item2.getHeaders();\n            // Also attempt to open stream, as header processing might be deferred.\n            try (InputStream is2 = item2.openStream()) {\n                byte[] buffer = new byte[1024];\n                while (is2.read(buffer) != -1) { /* drain stream */ }\n            }\n            fail(\"Expected FileUploadByteCountLimitException but no exception was thrown.\");\n        } catch (FileUploadByteCountLimitException e) {\n            caughtException = e; // Catch the specific exception\n        } catch (FileUploadException e) {\n            // Catching a generic FileUploadException here would indicate a different issue than expected.\n            fail(\"Expected FileUploadByteCountLimitException but caught a different FileUploadException: \" + e.getMessage());\n        }\n\n        // Verify that the expected exception was thrown.\n        assertNotNull(caughtException, \"FileUploadByteCountLimitException should have been thrown for oversized metadata.\");\n        // Verify the exception reports the correct permitted size threshold.\n        assertEquals(100, caughtException.getPermitted(),\n                \"The exception's 'permitted' size should match the configured headerReadThreshold (100 bytes).\");\n        // Verify the exception reports an actual size greater than the permitted limit.\n        assertTrue(caughtException.getActual() > 100,\n                \"The exception's 'actual' size should be greater than the permitted 100 bytes.\");\n\n        // After the error, there should be no more parts.\n        assertFalse(iterator.hasNext(), \"No more parts should be available after a metadata limit violation.\");\n    }\n}",
      "method_signature": "testPartHeaderSizeMaxLimit()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7010,
    "output_tokens": 6806,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 155,
      "description": "Define a test class containing a static final field `BOUNDARY_TEXT` of type `String`, then write a test method annotated with `@Test` that begins by assigning the String literal `\"foobar\"` to a local variable `strData`, immediately invoking `getBytes()` on `strData` to produce a byte array assigned to `contents`, constructing a `ByteArrayInputStream` by passing `contents` to its constructor and assigning the result to a variable `input` of type `InputStream`, invoking `getBytes()` on the field `BOUNDARY_TEXT` to produce a byte array assigned to `boundary`, and assigning the integer literal `1` to a variable `iBufSize`. With these variables prepared, invoke `assertThrows` passing `IllegalArgumentException.class` as the first argument and a lambda expression as the second argument, where the lambda invokes `MultipartInput.builder()` to obtain a builder instance, chains `setInputStream` passing `input`, chains `setBoundary` passing `boundary`, chains `setBufferSize` passing `iBufSize`, chains `setProgressNotifier` passing a newly constructed `MultipartInput.ProgressNotifier` instance created by invoking its constructor with arguments `null` and `contents.length`, and finally chains `get()` to trigger the builder's construction logic, thereby verifying that the builder throws `IllegalArgumentException` when the buffer size is too small. The test uses JUnit 5 Assertions via the `@Test` annotation and the `assertThrows` method.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testSmallBuffer()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputBufferSizeTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MultipartInputBufferSizeTest {\n\n    private static final String BOUNDARY_TEXT = \"someBoundary\";\n\n    @Test\n    void testBufferSizeTooSmallThrowsIllegalArgumentException() {\n        final String strData = \"foobar\";\n        final byte[] contents = strData.getBytes(StandardCharsets.UTF_8);\n        final InputStream input = new ByteArrayInputStream(contents);\n        final byte[] boundary = BOUNDARY_TEXT.getBytes(StandardCharsets.UTF_8);\n        final int iBufSize = 1;\n\n        assertThrows(IllegalArgumentException.class, () -> {\n            MultipartInput.builder()\n                .setInputStream(input)\n                .setBoundary(boundary)\n                .setBufferSize(iBufSize)\n                .setProgressNotifier(new MultipartInput.ProgressNotifier(null, contents.length))\n                .get();\n        });\n    }\n}",
      "method_signature": "testSmallBuffer()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.9091,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 30092,
    "output_tokens": 2034,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 157,
      "description": "Define a test class containing three private fields: a static final `Path` named `testDir`, a static `Path` named `tempTestDir`, and a `Supplier<Path>` named `testFileSupplier`. Implement a static setup method annotated with `@BeforeAll` that invokes `Files.createDirectories(testDir)` and assigns the result of `Files.createTempDirectory(testDir, \"testDir\")` to `tempTestDir`. In the test method annotated with `@Test`, declare a `DeferrableOutputStream` array named `streams` with length `1`. Define a `Consumer<Consumer<OutputStream>>` variable named `tester` initialized with a lambda that accepts a `Consumer<OutputStream>` parameter named `consumer`, and within this lambda's body, open a try-with-resources block that instantiates a `DeferrableOutputStream` named `dos` by passing arguments `0`, `testFileSupplier`, and `null` to the constructor, then assign `dos` to `streams[0]`, invoke `assertTrue(dos.isInMemory())`, invoke `assertNull(dos.getPath())`, invoke `assertNull(dos.getBytes())`, invoke `assertSame(State.initialized, dos.getState())`, invoke `consumer.accept(dos)`, invoke `assertFalse(dos.isInMemory())`, invoke `assertNotNull(dos.getPath())`, and invoke `assertNull(dos.getBytes())`, catching any `IOException` named `ioe` and rethrowing it wrapped in a new `UncheckedIOException(ioe)`. After the try-with-resources block, assign `streams[0]` to a final `DeferrableOutputStream` variable named `dos`, invoke `assertFalse(dos.isInMemory())`, invoke `assertNotNull(dos.getPath())`, invoke `assertTrue(Files.isRegularFile(dos.getPath()))`, declare a `byte[]` variable named `actual` without initialization, open a try-with-resources block that invokes `dos.getInputStream()` and assigns the result to an `InputStream` variable named `is`, then define a private method that accepts an `InputStream` parameter, creates a `ByteArrayOutputStream` named `baos`, declares a `byte[]` named `buffer` initialized to `new byte[8192]`, enters an infinite loop that invokes `pIs.read(buffer)` and assigns the result to an `int` variable named `res`, returns `baos.toByteArray()` if `res` equals `-1`, otherwise invokes `baos.write(buffer, 0, res)` if `res` is greater than `0`, and invoke this method with `is` to assign the result to `actual`, catching any `IOException` named `ioe` and rethrowing it wrapped in a new `UncheckedIOException(ioe)`. After the try-with-resources block, declare a `byte[]` variable named `expect` initialized to `\",\".getBytes(StandardCharsets.UTF_8)` and invoke `assertArrayEquals(expect, actual)`. Following the `tester` definition, invoke `tester.accept` with a lambda that accepts an `OutputStream` parameter named `os`, and within a try block invoke `os.write(',')` (the character literal for comma), catching any `IOException` named `ioe` and rethrowing it wrapped in a new `UncheckedIOException(ioe)`. Next, invoke `tester.accept` again with a lambda that accepts an `OutputStream` parameter named `os`, declares a `byte[]` variable named `buffer` initialized to `new byte[] { ',' }`, and within a try block invokes `os.write(buffer)`, catching any `IOException` named `ioe` and rethrowing it wrapped in a new `UncheckedIOException(ioe)`. Finally, invoke `tester.accept` a third time with a lambda that accepts an `OutputStream` parameter named `os`, declares a `byte[]` variable named `buffer` initialized to `new byte[] { ',', '-' }`, and within a try block invokes `os.write(buffer, 0, 1)`, catching any `IOException` named `ioe` and rethrowing it wrapped in a new `UncheckedIOException(ioe)`. The test uses method-level annotation `@Test`, assertion libraries JUnit 5 Assertions, and no mocking libraries.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testThresholdZero()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest1",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport org.apache.commons.fileupload2.core.DeferrableOutputStream.State;\n\npublic class DeferrableOutputStreamTest1 {\n\n    private static final Path testDir = Paths.get(System.getProperty(\"java.io.tmpdir\"), \"DeferrableOutputStreamTestDir_\" + System.nanoTime());\n    private static Path tempTestDir;\n    private Supplier<Path> testFileSupplier;\n\n    @BeforeAll\n    static void setUp() throws IOException {\n        Files.createDirectories(testDir);\n        tempTestDir = Files.createTempDirectory(testDir, \"testDir\");\n    }\n\n    private byte[] readInputStreamFully(InputStream pIs) {\n        try {\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final byte[] buffer = new byte[8192];\n            int res;\n            while ((res = pIs.read(buffer)) != -1) {\n                if (res > 0) {\n                    baos.write(buffer, 0, res);\n                }\n            }\n            return baos.toByteArray();\n        } catch (IOException ioe) {\n            throw new UncheckedIOException(ioe);\n        }\n    }\n\n    @Test\n    public void testDeferrableOutputStreamBehavior() {\n        testFileSupplier = () -> {\n            try {\n                return Files.createTempFile(tempTestDir, \"upload-\", \".tmp\");\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n\n        final DeferrableOutputStream[] streams = new DeferrableOutputStream[1];\n\n        final Consumer<Consumer<OutputStream>> tester = consumer -> {\n            Path writtenFilePath = null;\n            try (DeferrableOutputStream dos = new DeferrableOutputStream(0, testFileSupplier, null)) {\n                streams[0] = dos;\n\n                assertTrue(dos.isInMemory());\n                assertNull(dos.getPath());\n                assertNotNull(dos.data); // Accessing protected field directly\n                assertSame(State.INITIALIZED, dos.getState());\n\n                consumer.accept(dos);\n\n                assertFalse(dos.isInMemory());\n                assertNotNull(dos.getPath());\n                assertNull(dos.data); // Accessing protected field directly\n                writtenFilePath = dos.getPath();\n\n            } catch (IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n\n            final DeferrableOutputStream dos = streams[0];\n            assertFalse(dos.isInMemory());\n            assertNotNull(dos.getPath());\n            assertTrue(Files.isRegularFile(dos.getPath()));\n\n            byte[] actual;\n            try (InputStream is = dos.getInputStream()) {\n                actual = readInputStreamFully(is);\n            } catch (IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n\n            final byte[] expect = \",\".getBytes(StandardCharsets.UTF_8);\n            assertArrayEquals(expect, actual);\n\n            // Clean up the file created by the stream, as no @AfterAll is defined.\n            if (writtenFilePath != null && Files.exists(writtenFilePath)) {\n                try {\n                    Files.delete(writtenFilePath);\n                } catch (IOException e) {\n                    // Suppress cleanup exception\n                }\n            }\n        };\n\n        tester.accept(os -> {\n            try {\n                os.write(',');\n            } catch (IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n        });\n\n        tester.accept(os -> {\n            final byte[] buffer = new byte[]{','};\n            try {\n                os.write(buffer);\n            } catch (IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n        });\n\n        tester.accept(os -> {\n            final byte[] buffer = new byte[]{',', '-'};\n            try {\n                os.write(buffer, 0, 1);\n            } catch (IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n        });\n    }\n}",
      "method_signature": "testThresholdZero()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7684,
    "output_tokens": 6586,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 169,
      "description": "Define a test class containing three private fields: a static final `Path` named `testDir`, a static `Path` named `tempTestDir`, and an instance `Supplier<Path>` named `testFileSupplier`. Implement a static setup method annotated with `@BeforeAll` that invokes `Files.createDirectories(testDir)` and assigns the result of `Files.createTempDirectory(testDir, \"testDir\")` to `tempTestDir`. Within the test method, declare a local variable `streams` as a `DeferrableOutputStream` array of length `1`, then define a local variable `tester` of type `Consumer<Consumer<OutputStream>>` initialized with a lambda expression accepting parameter `consumer`. Inside the lambda body, open a try-with-resources block declaring `dos` as a new `DeferrableOutputStream` constructed with arguments `5`, `testFileSupplier`, and `null`, then assign `dos` to `streams[0]`. Immediately invoke `assertTrue(dos.isInMemory())`, followed by `assertNull(dos.getPath())`, `assertNull(dos.getBytes())`, and `assertSame(State.initialized, dos.getState())`. Enter a for loop with `int i = 0`, condition `i < 4`, and increment `i++`, where each iteration wraps `dos.write('.')` in a try-catch block that catches `IOException` and rethrows it as `new UncheckedIOException(ioe)`, then after each write invokes `assertSame(State.opened, dos.getState())`, `assertTrue(dos.isInMemory())`, `assertNull(dos.getPath())`, and `assertNull(dos.getBytes())`. After the loop completes, invoke `consumer.accept(dos)`, then assert `assertFalse(dos.isInMemory())`, `assertNotNull(dos.getPath())`, and `assertNull(dos.getBytes())`. Close the try-with-resources block with a catch clause for `IOException` that rethrows as `new UncheckedIOException(ioe)`. Outside the try block, assign `streams[0]` to a new local variable `dos`, then invoke `assertFalse(dos.isInMemory())`, `assertNotNull(dos.getPath())`, and `assertTrue(Files.isRegularFile(dos.getPath()))`. Declare a local `byte[]` variable `actual` without initialization, then open a try-with-resources block declaring `is` as the result of `dos.getInputStream()`. Within this block, define a private method that creates a `ByteArrayOutputStream` named `baos`, declares a `byte[]` buffer of size `8192`, enters an infinite for loop that invokes `pIs.read(buffer)` and assigns the result to `int res`, returns `baos.toByteArray()` if `res == -1`, otherwise invokes `baos.write(buffer, 0, res)` if `res > 0`, and invoke this method passing `is` to assign the result to `actual`, catching `IOException` and rethrowing as `new UncheckedIOException(ioe)`. After the try block, declare `expect` as `\"....,\".getBytes(StandardCharsets.UTF_8)` and invoke `assertArrayEquals(expect, actual)`. Having defined the `tester` lambda, invoke `tester.accept` three times with distinct lambda arguments: first, pass a lambda accepting `os` that wraps `os.write(',')` in a try-catch rethrowing `IOException` as `UncheckedIOException`; second, pass a lambda that declares `buffer` as `new byte[] { ',' }`, then wraps `os.write(buffer)` in a try-catch rethrowing `IOException` as `UncheckedIOException`; third, pass a lambda that declares `buffer` as `new byte[] { ',', '-' }`, then wraps `os.write(buffer, 0, 1)` in a try-catch rethrowing `IOException` as `UncheckedIOException`. The test uses JUnit 5 Assertions with method-level annotation `@Test` and class-level setup annotation `@BeforeAll`.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testExceedPositiveThreshold()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamScenarioTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.fileupload2.core.DeferrableOutputStream.State;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\npublic class DeferrableOutputStreamScenarioTest { // Renamed class to avoid conflict and reflect scenario-based testing\n\n    private static final Path testDir = Paths.get(\"target\", \"test-deferrable-output\");\n    private static Path tempTestDir;\n    private final Supplier<Path> testFileSupplier;\n\n    public DeferrableOutputStreamScenarioTest() {\n        // Initialize testFileSupplier in the constructor, referencing tempTestDir\n        this.testFileSupplier = () -> {\n            try {\n                // Ensure tempTestDir is initialized before use; it's static and set in @BeforeAll.\n                // In a multi-threaded test runner, this could be an issue, but JUnit's @BeforeAll is per-class.\n                return Files.createTempFile(tempTestDir, \"test-file-\", \".tmp\");\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n    }\n\n    @BeforeAll\n    static void setUp() throws IOException {\n        Files.createDirectories(testDir);\n        tempTestDir = Files.createTempDirectory(testDir, \"testDir\");\n    }\n\n    @Test\n    void testDeferrableOutputStreamVariousWriteScenarios() {\n        final DeferrableOutputStream[] streams = new DeferrableOutputStream[1];\n\n        // This lambda encapsulates the common setup, initial writes, and pre-transition assertions\n        final Consumer<Consumer<OutputStream>> tester = consumer -> {\n            try (DeferrableOutputStream dos = new DeferrableOutputStream(5, testFileSupplier, null)) {\n                streams[0] = dos; // Store the current DeferrableOutputStream for post-try-block assertions\n\n                assertTrue(dos.isInMemory());\n                assertNull(dos.getPath());\n                assertNull(dos.getBytes());\n                assertSame(State.initialized, dos.getState());\n\n                for (int i = 0; i < 4; i++) {\n                    try {\n                        dos.write('.');\n                    } catch (final IOException ioe) {\n                        throw new UncheckedIOException(ioe);\n                    }\n                    assertSame(State.opened, dos.getState());\n                    assertTrue(dos.isInMemory());\n                    assertNull(dos.getBytes()); // Bytes should be null when not in memory or after transfer to file\n                    assertNull(dos.getPath()); // Path should be null while in memory\n                }\n\n                // This is where the 5th byte (or more) will be written, triggering transition\n                consumer.accept(dos);\n\n                // Assertions immediately after consumer.accept, still within try-with-resources\n                assertFalse(dos.isInMemory());\n                assertNotNull(dos.getPath());\n                assertNull(dos.getBytes()); // Bytes should be null after transition to file\n            } catch (final IOException ioe) {\n                throw new UncheckedIOException(\"IOException during stream operations: \" + ioe.getMessage(), ioe);\n            }\n\n            // Outside the try-with-resources block, proceed with further assertions and verification\n            final DeferrableOutputStream closedDos = streams[0]; // Retrieve the stream created in the lambda\n            assertFalse(closedDos.isInMemory());\n            assertNotNull(closedDos.getPath());\n            assertTrue(Files.isRegularFile(closedDos.getPath()));\n\n            byte[] actual;\n            try (InputStream is = closedDos.getInputStream()) {\n                actual = readAllBytes(is);\n            } catch (final IOException ioe) {\n                throw new UncheckedIOException(\"IOException reading from stream: \" + ioe.getMessage(), ioe);\n            }\n\n            // The expected content is 4 dots from the loop and 1 comma from the consumer\n            final byte[] expect = \"....,\".getBytes(StandardCharsets.UTF_8);\n            assertArrayEquals(expect, actual);\n\n            // Clean up the temporary file created by this specific stream instance\n            try {\n                Files.delete(closedDos.getPath());\n            } catch (final IOException e) {\n                // Log or ignore cleanup errors, but ensure test completion.\n                System.err.println(\"Failed to delete temporary file: \" + closedDos.getPath() + \" - \" + e.getMessage());\n            }\n        };\n\n        // --- Invoke tester with three distinct write methods ---\n\n        // Scenario 1: Single byte write\n        tester.accept(os -> {\n            try {\n                os.write(',');\n            } catch (final IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n        });\n\n        // Scenario 2: Byte array write\n        tester.accept(os -> {\n            final byte[] buffer = {','};\n            try {\n                os.write(buffer);\n            } catch (final IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n        });\n\n        // Scenario 3: Ranged byte array write\n        tester.accept(os -> {\n            final byte[] buffer = {',', '-'};\n            try {\n                os.write(buffer, 0, 1); // Write only the first byte (comma)\n            } catch (final IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n        });\n    }\n\n    /**\n     * Reads all bytes from an input stream into a byte array.\n     *\n     * @param pIs The input stream to read.\n     * @return A new byte array containing the contents of the stream.\n     * @throws IOException If an I/O error occurs.\n     */\n    private byte[] readAllBytes(final InputStream pIs) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final byte[] buffer = new byte[8192];\n        int res;\n        while ((res = pIs.read(buffer)) != -1) {\n            if (res > 0) {\n                baos.write(buffer, 0, res);\n            }\n        }\n        return baos.toByteArray();\n    }\n}",
      "method_signature": "testExceedPositiveThreshold()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.9808,
      "callable_precision": 0.8644,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7635,
    "output_tokens": 9118,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 185,
      "description": "Create a test case to validate that the multipart data processing system can be properly configured and initialized with all essential operational parameters when using the comprehensive configuration approach. Begin by preparing sample content data as a stream source, then convert a predefined boundary marker into its binary representation suitable for stream parsing. Calculate the minimum buffer capacity required to safely accommodate the boundary marker along with its protocol prefix characters and at least one data byte, ensuring efficient stream processing without performance degradation. Configure the multipart processing system by specifying the input data stream, the boundary marker for partitioning the content, the calculated buffer capacity, and a progress tracking mechanism initialized without an active listener but aware of the total expected content size. Once the system is fully configured, construct the multipart processor and verify that the initialization completed successfully, confirming the system is ready to parse multipart formatted data streams. Validate using standard equality assertions with JUnit 5 as the testing framework and AssertJ for assertion capabilities.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testThreeParamConstructor()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.FileUploadComprehensiveConfigurationTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for comprehensive configuration and initialization of the multipart data processing system.\n */\npublic class FileUploadComprehensiveConfigurationTest {\n\n    // A concrete implementation of AbstractFileUpload for testing purposes.\n    private static class TestFileUpload extends AbstractFileUpload<RequestContext, DiskFileItem, DiskFileItemFactory> {\n        @Override\n        public List<DiskFileItem> parseRequest(final RequestContext request) throws FileUploadException {\n            throw new UnsupportedOperationException(\"Not implemented for this test\");\n        }\n\n        @Override\n        public Map<String, List<DiskFileItem>> parseParameterMap(final RequestContext request) throws FileUploadException {\n            throw new UnsupportedOperationException(\"Not implemented for this test\");\n        }\n\n        @Override\n        public FileItemInputIterator getItemIterator(final RequestContext request) throws FileUploadException, IOException {\n            // Delegate to the base implementation which internally uses FileItemInputIteratorImpl\n            return super.getItemIterator(request);\n        }\n    }\n\n    // A mock RequestContext to control input data and headers.\n    private static class MockRequestContext implements RequestContext {\n        private final String contentType;\n        private final long contentLength;\n        private final InputStream inputStream;\n        private final String characterEncoding;\n\n        MockRequestContext(final String contentType, final long contentLength, final InputStream inputStream, final String characterEncoding) {\n            this.contentType = contentType;\n            this.contentLength = contentLength;\n            this.inputStream = inputStream;\n            this.characterEncoding = characterEncoding;\n        }\n\n        @Override\n        public String getCharacterEncoding() {\n            return characterEncoding;\n        }\n\n        @Override\n        public long getContentLength() {\n            return contentLength;\n        }\n\n        @Override\n        public String getContentType() {\n            return contentType;\n        }\n\n        @Override\n        public InputStream getInputStream() throws IOException {\n            return inputStream;\n        }\n\n        @Override\n        public boolean isMultipartRelated() {\n            return false; // Not relevant for this test\n        }\n    }\n\n    // A custom ProgressListener to capture updated values.\n    private static class CapturingProgressListener implements ProgressListener {\n        private long latestBytesRead = -1;\n        private long latestContentLength = -1;\n        private int latestItems = -1;\n\n        @Override\n        public void update(final long bytesRead, final long contentLength, final int items) {\n            this.latestBytesRead = bytesRead;\n            this.latestContentLength = contentLength;\n            this.latestItems = items;\n        }\n\n        public long getLatestBytesRead() {\n            return latestBytesRead;\n        }\n\n        public long getLatestContentLength() {\n            return latestContentLength;\n        }\n\n        public int getLatestItems() {\n            return latestItems;\n        }\n    }\n\n    @Test\n    void testComprehensiveConfigurationAndInitialization() throws FileUploadException, IOException {\n        // 1. Prepare sample content data\n        final String boundaryString = \"myBoundary\";\n        final String charEncoding = StandardCharsets.UTF_8.name();\n        final String multipartContentType = \"multipart/form-data; boundary=\" + boundaryString;\n\n        final StringBuilder multipartContentBuilder = new StringBuilder();\n        multipartContentBuilder.append(\"--\").append(boundaryString).append(\"\\r\\n\");\n        multipartContentBuilder.append(\"Content-Disposition: form-data; name=\\\"testField\\\"\").append(\"\\r\\n\");\n        multipartContentBuilder.append(\"Content-Type: text/plain\").append(\"\\r\\n\");\n        multipartContentBuilder.append(\"Content-Length: 9\").append(\"\\r\\n\"); // Content-Length of \"testValue\"\n        multipartContentBuilder.append(\"\\r\\n\");\n        multipartContentBuilder.append(\"testValue\").append(\"\\r\\n\");\n        multipartContentBuilder.append(\"--\").append(boundaryString).append(\"--\").append(\"\\r\\n\");\n\n        final byte[] multipartData = multipartContentBuilder.toString().getBytes(StandardCharsets.ISO_8859_1);\n        final long expectedContentLength = multipartData.length;\n\n        final InputStream mockInputStream = new ByteArrayInputStream(multipartData);\n        final MockRequestContext mockRequestContext = new MockRequestContext(multipartContentType, expectedContentLength, mockInputStream, charEncoding);\n\n        // 2. Convert predefined boundary marker into its binary representation\n        final byte[] boundaryBytes = boundaryString.getBytes(StandardCharsets.ISO_8859_1);\n\n        // 3. Calculate the minimum buffer capacity\n        // MultipartInput buffer needs to accommodate BOUNDARY_PREFIX + boundary + at least 1 data byte\n        final int minRequiredBufferSize = MultipartInput.BOUNDARY_PREFIX.length + boundaryBytes.length + 1;\n        \n        // Assert that the default buffer size in MultipartInput is sufficient\n        // This is an internal check to ensure the system's defaults are robust for typical cases.\n        assertThat(MultipartInput.DEFAULT_BUFSIZE).isGreaterThanOrEqualTo(minRequiredBufferSize);\n\n        // 4. Configure the multipart processing system\n        final TestFileUpload fileUpload = new TestFileUpload();\n\n        // FileItemFactory\n        final DiskFileItemFactory diskFileItemFactory = new DiskFileItemFactory();\n        fileUpload.setFileItemFactory(diskFileItemFactory);\n\n        // Header Charset\n        fileUpload.setHeaderCharset(StandardCharsets.UTF_8);\n\n        // Max part header size\n        fileUpload.setMaxPartHeaderSize(MultipartInput.DEFAULT_PART_HEADER_SIZE_MAX);\n\n        // Max request size (total content size)\n        fileUpload.setMaxSize(expectedContentLength + 100); // Add some buffer\n\n        // Max file size (single file/part size)\n        fileUpload.setMaxFileSize(expectedContentLength + 100); // Add some buffer\n\n        // Max file count\n        fileUpload.setMaxFileCount(10);\n\n        // Progress tracking mechanism\n        final CapturingProgressListener capturingProgressListener = new CapturingProgressListener();\n        fileUpload.setProgressListener(capturingProgressListener);\n\n        // 5. Construct the multipart processor\n        final FileItemInputIterator iterator = fileUpload.getItemIterator(mockRequestContext);\n\n        // 6. Verify that the initialization completed successfully\n        assertThat(iterator).isNotNull();\n        assertThat(iterator.hasNext()).isTrue(); // Expect at least one item\n\n        // Verify progress listener awareness of content length\n        // The progress listener is updated when MultipartInput.ProgressNotifier is created.\n        // The update method may not be called immediately during initialization,\n        // but the ProgressNotifier constructor itself records the contentLength.\n        // We can assert that the internal ProgressNotifier was created with the correct contentLength\n        // if we could access it, but since we cannot, we rely on the fact that the system is\n        // configured to use it, and the initial call to next() or hasNext() will trigger\n        // the first byte reads which will update the listener.\n        // For the purpose of \"aware of the total expected content size\",\n        // the configuration itself passes this info. The test description implies\n        // the configuration is the focus, not the actual progress updates.\n        // A simple check that the progress listener was set and *could* receive updates is enough.\n        \n        // After calling hasNext(), the internal MultipartInput will have been initialized,\n        // and the ProgressNotifier would have been created with the correct content length.\n        // The first call to update() would also occur when bytes are read for preamble/headers.\n        // However, the prompt implies \"initialized without an active listener but aware of the total expected content size\"\n        // meaning that the system is *configured* with the content size, which is achieved by passing\n        // expectedContentLength to the MockRequestContext. The CapturingProgressListener would eventually\n        // reflect this awareness once bytes are actually read.\n        \n        // Given that hasNext() implies some reading, the listener should have been updated at least once.\n        iterator.next(); // Consume the first item to trigger updates.\n        \n        assertThat(capturingProgressListener.getLatestContentLength()).isEqualTo(expectedContentLength);\n        assertThat(capturingProgressListener.getLatestBytesRead()).isPositive(); // Some bytes should have been read (preamble, headers)\n        assertThat(capturingProgressListener.getLatestItems()).isEqualTo(1); // One item processed\n    }\n}",
      "method_signature": "testThreeParamConstructor()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 5
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 101638,
    "output_tokens": 7323,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 187,
      "description": "Define a test method that validates the construction of a Multipart Input Stream using a builder pattern with three essential parameters: an input stream, a boundary byte array, and a buffer size. Begin by preparing a sample data string and converting it to a byte array to serve as the content source, then wrap this byte array in a ByteArrayInputStream to simulate streaming input. Convert the boundary text constant to a byte array, then calculate the required buffer size by summing the boundary array length, the Multipart Input's boundary prefix length, and an additional byte. Using the Multipart Input Builder, configure the builder by chaining calls to set the input stream, boundary array, and calculated buffer size, then attach a Progress Notifier initialized with a null listener and the content byte array length as the expected size. Invoke the builder's get method to construct the Multipart Input instance and capture the result. Assert that the constructed Multipart Input instance is not null to confirm successful instantiation. This test uses JUnit 5 for the testing framework and standard JUnit assertions.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testThreeParamConstructor()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputBuilderTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link MultipartInput.Builder} for proper construction of {@link MultipartInput} instances.\n */\npublic class MultipartInputBuilderTest {\n\n    /**\n     * Validates the construction of a Multipart Input Stream using a builder pattern\n     * with an input stream, a boundary byte array, a buffer size, and a progress notifier.\n     *\n     * @throws IOException if an I/O error occurs during stream operations.\n     */\n    @Test\n    public void testMultipartInputBuilderConstruction() throws IOException {\n        // Prepare sample data\n        final String content = \"This is some sample data for the multipart input stream.\";\n        final byte[] contentBytes = content.getBytes(StandardCharsets.UTF_8);\n        final ByteArrayInputStream inputStream = new ByteArrayInputStream(contentBytes);\n\n        // Prepare boundary data\n        final String boundaryText = \"---------------------------12345\";\n        final byte[] boundaryBytes = boundaryText.getBytes(StandardCharsets.US_ASCII);\n\n        // Calculate required buffer size\n        final int boundaryPrefixLength = MultipartInput.BOUNDARY_PREFIX.length;\n        // Buffer must be at least boundaryLength + 1 (for one data byte)\n        final int bufferSize = boundaryBytes.length + boundaryPrefixLength + 1;\n\n        // Initialize ProgressNotifier with a null listener and content length\n        final MultipartInput.ProgressNotifier notifier = new MultipartInput.ProgressNotifier(null, contentBytes.length);\n\n        // Construct MultipartInput using the builder\n        final MultipartInput multipartInput = MultipartInput.builder()\n                .setInputStream(inputStream)\n                .setBoundary(boundaryBytes)\n                .setBufferSize(bufferSize)\n                .setProgressNotifier(notifier)\n                .get();\n\n        // Assert that the constructed instance is not null\n        assertNotNull(multipartInput, \"MultipartInput instance should not be null after construction.\");\n    }\n}",
      "method_signature": "testThreeParamConstructor()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.5,
      "method_coverage": 0.6,
      "line_coverage": 0.8958,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "search_file_content": 2,
          "read_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 40634,
    "output_tokens": 2259,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 207,
      "description": "Define a test method that validates the enforcement of the maximum part header size limit when processing multipart stream data by constructing a multipart request string containing two file parts with headers and body content, then converting this request string to a byte array using UTF-8 encoding and wrapping it in a ByteArrayInputStream to simulate an incoming data stream. Configure a boundary byte array from a boundary marker string, then use the MultipartInput Builder to construct a MultipartInput instance by chaining setInputStream with the byte array input stream, setBoundary with the boundary bytes, and setMaxPartHeaderSize with a limit of 100 bytes before invoking get to obtain the configured instance. Assert that the resulting MultipartInput instance is not null to confirm successful initialization. Within a try block, invoke skipPreamble on the MultipartInput instance to advance past any preamble content and capture the boolean result indicating whether an encapsulation was found, then enter a while loop that continues as long as additional parts are detected. Inside the loop, call readHeaders on the MultipartInput instance to retrieve the header content as a string, print the header length and content to standard output for diagnostic purposes, and assert that the headers string is not null to verify successful header retrieval. After processing headers, invoke readBodyData on the MultipartInput instance with a null output stream to consume the body content without storing it, then call readBoundary to advance to the next part boundary and update the loop continuation flag. If the loop completes without throwing an exception, invoke fail with a message indicating that an expected exception was not raised, thereby signaling test failure. In the catch block for FileUploadSizeException, assert that the exception's permitted size value equals 100 by calling getPermitted on the caught exception, thereby confirming that the size limit enforcement triggered correctly when header size exceeded the configured maximum. This test uses JUnit for assertions and exception handling.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testPartHeaderSizeMaxLimit()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputMaxPartHeaderSizeTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\n\nimport org.apache.commons.io.output.NullOutputStream;\nimport org.junit.jupiter.api.Test;\n\npublic class MultipartInputMaxPartHeaderSizeTest {\n\n    @Test\n    public void testMaxPartHeaderSizeEnforcement() throws IOException {\n        final String boundaryString = \"----WebKitFormBoundary7MA4YWxkTrZu0gW\";\n        final byte[] boundaryBytes = boundaryString.getBytes(StandardCharsets.UTF_8);\n\n        // Construct a multipart request string with two parts.\n        // The second part's headers will intentionally exceed the 100-byte limit.\n        final StringBuilder requestBuilder = new StringBuilder();\n        requestBuilder.append(\"--\").append(boundaryString).append(\"\\r\\n\");\n        requestBuilder.append(\"Content-Disposition: form-data; name=\\\"file1\\\"; filename=\\\"test1.txt\\\"\\r\\n\");\n        requestBuilder.append(\"Content-Type: text/plain\\r\\n\");\n        requestBuilder.append(\"\\r\\n\");\n        requestBuilder.append(\"This is test file 1.\\r\\n\");\n        requestBuilder.append(\"--\").append(boundaryString).append(\"\\r\\n\");\n        // Header for part 2, designed to exceed 100 bytes.\n        // The first line alone is 70 chars. Add another to exceed 100.\n        requestBuilder.append(\"Content-Disposition: form-data; name=\\\"file2\\\"; filename=\\\"test2.txt\\\"; size=12345678901234567890123456789012345678901234567890\\r\\n\"); // 120 chars\n        requestBuilder.append(\"X-Another-Header: 123456789012345678901234567890\\r\\n\"); // 30 chars\n        requestBuilder.append(\"Content-Type: application/octet-stream\\r\\n\"); // 32 chars\n        requestBuilder.append(\"\\r\\n\");\n        requestBuilder.append(\"This is test file 2.\\r\\n\");\n        requestBuilder.append(\"--\").append(boundaryString).append(\"--\\r\\n\");\n\n        final byte[] requestBytes = requestBuilder.toString().getBytes(StandardCharsets.UTF_8);\n        final ByteArrayInputStream inputStream = new ByteArrayInputStream(requestBytes);\n\n        final MultipartInput multipartInput = MultipartInput.builder()\n                .setInputStream(inputStream)\n                .setBoundary(boundaryBytes)\n                .setMaxPartHeaderSize(100)\n                .get();\n\n        assertNotNull(multipartInput, \"MultipartInput instance should not be null\");\n\n        try {\n            boolean nextPart = multipartInput.skipPreamble();\n            while (nextPart) {\n                final String headers = multipartInput.readHeaders();\n                System.out.println(\"Header Length: \" + headers.length());\n                System.out.println(\"Headers:\\n\" + headers);\n                assertNotNull(headers, \"Headers should not be null\");\n\n                // Use NullOutputStream.INSTANCE to consume body without storing it.\n                // This is equivalent to `readBodyData(null)` as per the Javadoc.\n                multipartInput.readBodyData(NullOutputStream.INSTANCE);\n                nextPart = multipartInput.readBoundary();\n            }\n            fail(\"Expected FileUploadSizeException was not thrown.\");\n        } catch (final FileUploadSizeException e) {\n            assertEquals(100, e.getPermitted(), \"Expected permitted size to be 100\");\n            System.out.println(\"Caught expected FileUploadSizeException: \" + e.getMessage());\n        }\n    }\n}",
      "method_signature": "testPartHeaderSizeMaxLimit()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.5,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8947,
      "callable_precision": 0.4048,
      "focal_recall": 1.0,
      "focal_precision": 0.9
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 208,
      "description": "Define a test method annotated with `@Test` that declares it throws `Exception`, then begin by assigning the String literal `\"foobar\"` to a final variable `strData`, and immediately invoke `getBytes()` on `strData` to produce a byte array assigned to final variable `contents`. Construct a new `ByteArrayInputStream` by passing `contents` as the constructor argument, assigning the result to final variable `input` of type `InputStream`. Invoke `getBytes()` on the static field `BOUNDARY_TEXT` to obtain a byte array assigned to final variable `boundary`. Compute the buffer size by adding `boundary.length`, the static field `MultipartInput.BOUNDARY_PREFIX.length`, and the integer literal `1`, assigning the sum to final variable `iBufSize`. Invoke the static method `MultipartInput.builder()` to obtain a `Builder` instance, then chain `setInputStream(input)` passing `input`, chain `setBoundary(boundary)` passing `boundary`, chain `setBufferSize(iBufSize)` passing `iBufSize`, and chain `setProgressNotifier(new MultipartInput.ProgressNotifier(null, contents.length))` where the `ProgressNotifier` constructor receives `null` as the first argument and `contents.length` as the second argument, and finally invoke `get()` on the builder chain to produce a `MultipartInput` instance assigned to final variable `ms`. Assert that `ms` is not null by invoking `assertNotNull(ms)`. The test uses the `@Test` annotation from JUnit 5 and the `assertNotNull` assertion from JUnit 5 Assertions, with no integration annotations, parameterized test sources, or mocking libraries present.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testThreeParamConstructor()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputBuilderTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MultipartInputBuilderTest {\n\n    // Assuming BOUNDARY_TEXT is a static string field. Since it was not found,\n    // and to make the test compilable as per instructions, it's defined here.\n    private static final String BOUNDARY_TEXT = \"---------------------------7d110114000c2\";\n\n    @Test\n    void testBuilderPattern() throws Exception {\n        final String strData = \"foobar\";\n        final byte[] contents = strData.getBytes();\n        final InputStream input = new ByteArrayInputStream(contents);\n        final byte[] boundary = BOUNDARY_TEXT.getBytes();\n        final int iBufSize = boundary.length + MultipartInput.BOUNDARY_PREFIX.length + 1;\n\n        final MultipartInput ms = MultipartInput.builder()\n                .setInputStream(input)\n                .setBoundary(boundary)\n                .setBufferSize(iBufSize)\n                .setProgressNotifier(new MultipartInput.ProgressNotifier(null, contents.length))\n                .get();\n\n        assertNotNull(ms);\n    }\n}",
      "method_signature": "testThreeParamConstructor()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.5,
      "method_coverage": 0.6,
      "line_coverage": 0.8958,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 1,
          "search_file_content": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 53129,
    "output_tokens": 3187,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 220,
      "description": "Define a test method that verifies the maximum part header size limit enforcement in multipart stream processing by first constructing a multipart request string literal `request` containing the exact concatenated value `\"-----1234\\r\\n\" + \"Content-Disposition: form-data; name=\\\"file1\\\"; filename=\\\"foo1.tab\\\"\\r\\n\" + \"Content-Type: text/whatever\\r\\n\" + \"Content-Length: 10\\r\\n\" + \"\\r\\n\" + \"This is the content of the file\\n\" + \"\\r\\n\" + \"-----1234\\r\\n\" + \"Content-Disposition: form-data; name=\\\"file2\\\"; filename=\\\"foo2.tab\\\"\\r\\n\" + \"Content-Type: text/whatever\\r\\n\" + \"\\r\\n\" + \"This is the content of the file\\n\" + \"\\r\\n\" + \"-----1234--\\r\\n\"`, then invoke `getBytes(StandardCharsets.UTF_8)` on `request` and assign the result to `byteContents` of type `byte[]`, instantiate a `ByteArrayInputStream` passing `byteContents` as the constructor argument and assign it to `input` of type `InputStream`, invoke `getBytes()` on the String literal `\"---1234\"` and assign the result to `boundary` of type `byte[]`, invoke `MultipartInput.builder()` to obtain a builder instance, chain `setInputStream(input)` passing `input`, chain `setBoundary(boundary)` passing `boundary`, chain `setMaxPartHeaderSize(100)` passing the integer literal `100`, and finally chain `get()` to construct the `MultipartInput` instance, assigning it to `mi`, immediately assert that `mi` is not null using `assertNotNull(mi)`, then begin a try block by invoking `skipPreamble()` on `mi` and assigning the boolean result to `nextPart`, enter a while loop that continues while `nextPart` is true, and within the loop body invoke `readHeaders()` on `mi` assigning the String result to `headers`, print to `System.out` the concatenated string `\"Headers=\" + headers.length() + \", \" + headers`, assert that `headers` is not null using `assertNotNull(headers)`, invoke `readBodyData(NullOutputStream.INSTANCE)` on `mi` passing `NullOutputStream.INSTANCE` as the argument, invoke `readBoundary()` on `mi` and assign the boolean result back to `nextPart`, after the while loop completes invoke `fail(\"Expected Exception\")` to signal that an exception should have been thrown, then define a catch block for `FileUploadSizeException` with the variable name `fuse`, and within the catch block invoke `assertEquals(100, fuse.getPermitted())` to assert that the permitted size returned by `getPermitted()` on `fuse` equals the integer literal `100`. Annotate the test method with `@Test` and declare it to throw `Exception`.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testPartHeaderSizeMaxLimit()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputMaxPartHeaderSizeTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\nimport org.apache.commons.io.output.NullOutputStream;\nimport org.junit.jupiter.api.Test;\n\npublic class MultipartInputMaxPartHeaderSizeTest {\n\n    @Test\n    public void testMaxPartHeaderSizeEnforcement() throws Exception {\n        // Constructing the multipart request string literal\n        final String request = \"-----1234\\r\\n\" +\n                \"Content-Disposition: form-data; name=\\\"file1\\\"; filename=\\\"foo1.tab\\\"\\r\\n\" +\n                \"Content-Type: text/whatever\\r\\n\" +\n                \"Content-Length: 10\\r\\n\" +\n                \"\\r\\n\" +\n                \"This is the content of the file\\n\" +\n                \"\\r\\n\" +\n                \"-----1234\\r\\n\" +\n                \"Content-Disposition: form-data; name=\\\"file2\\\"; filename=\\\"foo2.tab\\\"\\r\\n\" +\n                \"Content-Type: text/whatever\\r\\n\" +\n                \"\\r\\n\" +\n                \"This is the content of the file\\n\" +\n                \"\\r\\n\" +\n                \"-----1234--\\r\\n\";\n        // Convert request string to byte array\n        final byte[] byteContents = request.getBytes(StandardCharsets.UTF_8);\n        // Instantiate ByteArrayInputStream\n        final InputStream input = new ByteArrayInputStream(byteContents);\n        // Get boundary bytes\n        final byte[] boundary = \"---1234\".getBytes();\n\n        // Build MultipartInput instance\n        MultipartInput mi = MultipartInput.builder()\n                .setInputStream(input)\n                .setBoundary(boundary)\n                .setMaxPartHeaderSize(100)\n                .get();\n\n        // Assert MultipartInput is not null\n        assertNotNull(mi);\n\n        try {\n            // Begin processing the multipart stream\n            boolean nextPart = mi.skipPreamble();\n            while (nextPart) {\n                final String headers = mi.readHeaders();\n                System.out.println(\"Headers=\" + headers.length() + \", \" + headers);\n                assertNotNull(headers);\n                mi.readBodyData(NullOutputStream.INSTANCE);\n                nextPart = mi.readBoundary();\n            }\n            // If execution reaches here, no exception was thrown, which is unexpected\n            fail(\"Expected Exception\");\n        } catch (final FileUploadSizeException fuse) {\n            // Assert that the permitted size in the exception matches the configured limit\n            assertEquals(100, fuse.getPermitted());\n        }\n    }\n}",
      "method_signature": "testPartHeaderSizeMaxLimit()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.9474,
      "callable_precision": 0.9474,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 30835,
    "output_tokens": 3397,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 225,
      "description": "Create a test case to validate the file upload system's behavior when configured with a zero-byte threshold, ensuring that uploaded content immediately transitions to persistent storage rather than remaining in memory once data arrives. Prepare a temporary directory within the system records area to serve as the storage location, then configure the file item factory with a zero-byte threshold, UTF-8 character encoding, and the designated storage location. Verify that the factory's threshold setting remains at zero as configured. Obtain a new file item from the factory and confirm its threshold also reflects zero. At this initial state, before any data arrives, verify the file item shows as initialized, indicates content is in memory, and has no associated storage location or content. Simulate uploading a small file by writing a series of characters (first five characters, then eight thousand characters on a second pass) to the file item's output channel, and after each character is written, confirm the system has transitioned to persistent storage mode, shows content is no longer in memory, and has created a storage file in the designated location, though the actual content verification is deferred. Once all data is written and the output channel is closed, verify the file item has transitioned to a closed state, confirms content is stored on disk rather than in memory, maintains the storage location reference, and contains the exact sequence of characters that were written. Execute this validation pattern twice with different data volumes to ensure consistent behavior across varying upload sizes. Use JUnit 5 as the testing framework and standard equality assertions to verify all state transitions, threshold values, storage locations, and content integrity throughout the upload lifecycle.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DiskFileItemTest",
      "method_signature": "testStateModelWithThresholdZero()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DiskFileItemZeroByteThresholdTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Test case to validate the file upload system's behavior when configured\n * with a zero-byte threshold for DiskFileItemFactory, ensuring that uploaded\n * content immediately transitions to persistent storage rather than remaining\n * in memory once data arrives.\n */\npublic class DiskFileItemZeroByteThresholdTest {\n\n    /**\n     * JUnit 5's TempDir extension provides a temporary directory for tests.\n     */\n    @TempDir\n    Path tempDir;\n\n    /**\n     * Generates a string of a specified length, useful for creating varying data volumes.\n     * The content is composed of repeating lowercase English letters ('a' through 'z').\n     *\n     * @param length The desired length of the string.\n     * @return A string of the specified length.\n     */\n    private static String generateLargeString(final int length) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            sb.append((char) ('a' + (i % 26)));\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Performs a single file upload validation run with a zero-byte threshold\n     * for the given content. This method encapsulates the setup, write process,\n     * and assertions for one data volume.\n     *\n     * @param content The string content to write to the file item.\n     * @throws IOException If an I/O error occurs during file operations.\n     */\n    private void validateZeroByteThresholdUpload(final String content) throws IOException {\n        // Prepare a temporary directory within the system records area to serve as the storage location.\n        final Path repositoryDir = Files.createTempDirectory(tempDir, \"repo-\");\n\n        // Configure the file item factory with a zero-byte threshold,\n        // and the designated storage location. UTF-8 character encoding is\n        // implicitly handled by byte conversion and content type.\n        final DiskFileItemFactory factory = new DiskFileItemFactory();\n        factory.setSizeThreshold(0); // Set zero-byte threshold\n        factory.setRepository(repositoryDir.toFile());\n\n        // Verify that the factory's threshold setting remains at zero as configured.\n        assertEquals(0, factory.getSizeThreshold(), \"Factory's size threshold should be zero.\");\n        assertNotNull(factory.getRepository(), \"Factory's repository should be set.\");\n        assertEquals(repositoryDir.toFile(), factory.getRepository(), \"Factory's repository should match the temp directory.\");\n\n        // Obtain a new file item from the factory.\n        // contentType includes charset for verification consistency.\n        final FileItem fileItem = factory.createItem(\"fileField\", \"text/plain; charset=UTF-8\", false, \"uploadedFile.txt\");\n        \n        // Cast to DiskFileItem to access implementation-specific methods like getStoreLocation().\n        final DiskFileItem diskFileItem = (DiskFileItem) fileItem;\n\n        // At this initial state, before any data arrives, verify the file item shows as initialized,\n        // indicates content is in memory, and has no associated storage location or content.\n        assertTrue(diskFileItem.isInMemory(), \"Initial state: DiskFileItem should be in memory.\");\n        assertNull(diskFileItem.getStoreLocation(), \"Initial state: No store location should be set.\");\n        assertEquals(0, diskFileItem.getSize(), \"Initial state: Size should be zero.\");\n        assertArrayEquals(new byte[0], diskFileItem.get(), \"Initial state: Content should be an empty byte array.\");\n        \n        // Verify other initial properties.\n        assertEquals(\"fileField\", diskFileItem.getFieldName());\n        assertEquals(\"text/plain; charset=UTF-8\", diskFileItem.getContentType());\n        assertEquals(\"uploadedFile.txt\", diskFileItem.getName());\n        assertFalse(diskFileItem.isFormField());\n\n        // Prepare content bytes using UTF-8 encoding.\n        final byte[] contentBytes = content.getBytes(StandardCharsets.UTF_8);\n\n        // Simulate uploading by writing character by character.\n        try (OutputStream outputStream = diskFileItem.getOutputStream()) {\n            for (int i = 0; i < contentBytes.length; i++) {\n                outputStream.write(contentBytes[i]);\n\n                // After each character is written, confirm the system has transitioned to persistent storage mode,\n                // shows content is no longer in memory, and has created a storage file in the designated location.\n                assertFalse(diskFileItem.isInMemory(), \"After writing byte \" + (i + 1) + \": DiskFileItem should NOT be in memory (zero threshold).\");\n                assertNotNull(diskFileItem.getStoreLocation(), \"After writing byte \" + (i + 1) + \": Store location should be set.\");\n                assertTrue(Files.exists(diskFileItem.getStoreLocation().toPath()), \"After writing byte \" + (i + 1) + \": Storage file should exist.\");\n                assertTrue(diskFileItem.getStoreLocation().toPath().startsWith(repositoryDir), \"After writing byte \" + (i + 1) + \": Storage file should be in the designated repository.\");\n            }\n        } // The outputStream is implicitly closed here.\n\n        // Once all data is written and the output channel is closed, verify the file item\n        // has transitioned to a closed state, confirms content is stored on disk rather\n        // than in memory, maintains the storage location reference, and contains the\n        // exact sequence of characters that were written.\n        assertFalse(diskFileItem.isInMemory(), \"Final state: DiskFileItem should NOT be in memory after stream close.\");\n        assertNotNull(diskFileItem.getStoreLocation(), \"Final state: Store location must persist after stream close.\");\n        assertTrue(Files.exists(diskFileItem.getStoreLocation().toPath()), \"Final state: Storage file must exist on disk.\");\n        assertEquals(contentBytes.length, diskFileItem.getSize(), \"Final state: DiskFileItem size should match the total written content length.\");\n        \n        // Verify the content integrity of the file item (reads from disk).\n        final byte[] retrievedContent = diskFileItem.get();\n        assertArrayEquals(contentBytes, retrievedContent, \"Final state: Retrieved content should match the original written content.\");\n\n        // Clean up the file item by deleting its underlying temporary file.\n        final File storeLocation = diskFileItem.getStoreLocation();\n        diskFileItem.delete();\n        assertFalse(Files.exists(storeLocation.toPath()), \"After delete: Storage file should no longer exist.\");\n    }\n\n    /**\n     * Tests the zero-byte threshold lifecycle for DiskFileItem with varying content lengths.\n     * This method executes the validation pattern twice with different data volumes\n     * as required by the problem description.\n     *\n     * @throws IOException If an I/O error occurs during the test.\n     */\n    @Test\n    void testZeroByteThresholdLifecycleWithVaryingContentLengths() throws IOException {\n        // Execute this validation pattern twice with different data volumes.\n\n        // First scenario: small content (e.g., 5 characters).\n        final String smallContent = \"abcde\";\n        validateZeroByteThresholdUpload(smallContent);\n\n        // Second scenario: larger content (e.g., 8000 characters).\n        final String largeContent = generateLargeString(8000);\n        validateZeroByteThresholdUpload(largeContent);\n    }\n}",
      "method_signature": "testStateModelWithThresholdZero()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7099,
    "output_tokens": 8304,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 229,
      "description": "Create a test case to validate the file upload system's behavior when configured with positive threshold values, ensuring the system correctly transitions through its operational states as data accumulates and either remains in memory or persists to temporary storage based on size limits. Establish a temporary working directory within the test output area and configure the file upload factory with a specified threshold value, along with UTF-8 character encoding, then verify the factory retained the configured threshold setting. Prepare a new upload item from the factory and confirm it also preserves the threshold configuration, then verify the item begins in an initialized state with all data held in memory and no temporary storage file created. Begin writing data to the upload item one byte at a time, tracking the accumulated content, and after each byte before reaching the threshold confirm the system remains in an opened state with data still held in memory and no temporary storage file present. Once the threshold is reached by writing one additional byte, verify the system immediately transitions to a persisted state where data is no longer held in memory and a temporary storage file has been created within the designated working directory. After closing the upload stream, confirm the system transitions to a closed state while maintaining the data in the temporary storage file with the complete accumulated content available for retrieval, then repeat this entire validation scenario with two different threshold values to ensure consistent behavior across varying size limits. Validate all state transitions and data integrity using JUnit 5 with AssertJ-style equality assertions to confirm expected values match actual system behavior at each checkpoint.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DiskFileItemTest",
      "method_signature": "testStateModelWithPositiveThreshold()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DiskFileItemThresholdTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests the file upload system's behavior when configured with positive threshold values,\n * ensuring correct transitions through operational states as data accumulates.\n * This test validates that data remains in memory or persists to temporary storage\n * based on size limits, using DiskFileItemFactory and DiskFileItem.\n */\npublic class DiskFileItemThresholdTest {\n\n    @TempDir\n    private Path tempDir;\n\n    /**\n     * Helper method to append a byte to a byte array.\n     *\n     * @param array The original byte array.\n     * @param element The byte to append.\n     * @return A new byte array with the element appended.\n     */\n    private byte[] appendByte(final byte[] array, final byte element) {\n        final byte[] newArray = Arrays.copyOf(array, array.length + 1);\n        newArray[array.length] = element;\n        return newArray;\n    }\n\n    @Test\n    void testPositiveThresholdLifecycle() throws IOException {\n        final int[] thresholds = {10, 20}; // Two different threshold values to test\n\n        for (final int threshold : thresholds) {\n            // 1. Establish a temporary working directory and configure the file upload factory\n            final DiskFileItemFactory factory = new DiskFileItemFactory();\n            factory.setRepository(tempDir.toFile());\n            factory.setSizeThreshold(threshold);\n            factory.setDefaultCharset(StandardCharsets.UTF_8);\n\n            // 2. Verify the factory retained the configured threshold setting\n            assertThat(factory.getSizeThreshold()).as(\"Factory threshold should match configured value\").isEqualTo(threshold);\n            assertThat(factory.getDefaultCharset()).as(\"Factory character set should be UTF-8\").isEqualTo(StandardCharsets.UTF_8);\n\n            // 3. Prepare a new upload item from the factory\n            final String fieldName = \"testField\";\n            final String contentType = \"text/plain\";\n            final boolean isFormField = true;\n            final String fileName = \"testFile.txt\";\n            final FileItem fileItem = factory.createItem(fieldName, contentType, isFormField, fileName);\n\n            // 4. Confirm the item also preserves the threshold configuration\n            assertThat(fileItem.getSizeThreshold()).as(\"FileItem threshold should match factory's threshold\").isEqualTo(threshold);\n            assertThat(fileItem.getFieldName()).as(\"FileItem field name\").isEqualTo(fieldName);\n            assertThat(fileItem.getContentType()).as(\"FileItem content type\").isEqualTo(contentType);\n            assertThat(fileItem.isFormField()).as(\"FileItem is form field\").isTrue();\n            assertThat(fileItem.getName()).as(\"FileItem file name\").isEqualTo(fileName);\n\n            // 5. Verify the item begins in an initialized state: all data held in memory and no temporary storage file created\n            assertThat(fileItem.isInMemory()).as(\"Initially, FileItem should be in memory\").isTrue();\n            assertThat(fileItem.getStoreLocation()).as(\"Initially, no temporary file should be created\").isNull();\n            assertThat(fileItem.getSize()).as(\"Initially, FileItem size should be 0\").isEqualTo(0L);\n\n            byte[] accumulatedContent = new byte[0];\n            try (OutputStream os = fileItem.getOutputStream()) {\n                // 6. Begin writing data to the upload item one byte at a time\n                // Loop up to (but not including) the threshold\n                for (int i = 0; i < threshold; i++) {\n                    final byte dataByte = (byte) ThreadLocalRandom.current().nextInt(256);\n                    os.write(dataByte);\n                    accumulatedContent = appendByte(accumulatedContent, dataByte);\n\n                    // After each byte before reaching the threshold, confirm the system remains in memory\n                    assertThat(fileItem.isInMemory()).as(\"Before threshold, FileItem should be in memory (byte \" + i + \")\").isTrue();\n                    assertThat(fileItem.getStoreLocation()).as(\"Before threshold, no temporary file should be created (byte \" + i + \")\").isNull();\n                    assertThat(fileItem.getSize()).as(\"FileItem size should match accumulated content length (byte \" + i + \")\").isEqualTo(accumulatedContent.length);\n                }\n\n                // 7. Once the threshold is reached by writing one additional byte, verify transition\n                final byte dataByte = (byte) ThreadLocalRandom.current().nextInt(256);\n                os.write(dataByte); // This write operation should trigger the transition\n                accumulatedContent = appendByte(accumulatedContent, dataByte);\n\n                // Verify the system immediately transitions to a persisted state\n                assertThat(fileItem.isInMemory()).as(\"After threshold, FileItem should be file-backed\").isFalse();\n                final File storeLocation = fileItem.getStoreLocation();\n                assertThat(storeLocation).as(\"After threshold, a temporary file should be created\").isNotNull();\n                assertThat(storeLocation.getParentFile()).as(\"Temporary file should be in the designated repository\").isEqualTo(tempDir.toFile());\n                assertThat(fileItem.getSize()).as(\"FileItem size should match accumulated content length after threshold\").isEqualTo(accumulatedContent.length);\n\n                // Ensure the physical file exists and its size is correct\n                assertThat(storeLocation.exists()).as(\"Temporary file should exist on disk\").isTrue();\n                assertThat(Files.isRegularFile(storeLocation.toPath())).as(\"Store location should be a regular file\").isTrue();\n                assertThat(Files.size(storeLocation.toPath())).as(\"Temporary file size should match accumulated content length\").isEqualTo(accumulatedContent.length);\n\n                // Data should be retrievable via get() which now reads from disk\n                assertThat(fileItem.get()).as(\"Content retrieved from FileItem should match accumulated content\").isEqualTo(accumulatedContent);\n\n            } // OutputStream is closed here, completing the write process\n\n            // 8. After closing the upload stream, confirm the system maintains data in the temporary storage file\n            assertThat(fileItem.isInMemory()).as(\"After stream close, FileItem should remain file-backed\").isFalse();\n            final File storeLocation = fileItem.getStoreLocation();\n            assertThat(storeLocation).as(\"After stream close, temporary file location should still be available\").isNotNull();\n            assertThat(storeLocation.exists()).as(\"After stream close, temporary file should still exist on disk\").isTrue();\n            assertThat(fileItem.getSize()).as(\"After stream close, FileItem size should still match accumulated content length\").isEqualTo(accumulatedContent.length);\n\n            // Verify content again after stream close\n            assertThat(fileItem.get()).as(\"Content retrieved from FileItem after close should still match accumulated content\").isEqualTo(accumulatedContent);\n\n            // Clean up the temporary file created by the DiskFileItem\n            fileItem.delete();\n            assertThat(fileItem.getStoreLocation()).as(\"After delete, store location should be null\").isNull();\n            assertThat(fileItem.getSize()).as(\"After delete, FileItem size should be 0\").isEqualTo(0L);\n            assertThat(storeLocation.exists()).as(\"After delete, the temporary file should no longer exist on disk\").isFalse();\n        }\n    }\n}",
      "method_signature": "testStateModelWithPositiveThreshold()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7077,
    "output_tokens": 5775,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 242,
      "description": "Define a test method that validates the state transitions of a Disk File Item as data is written across a configurable threshold by encapsulating the test logic within an integer consumer lambda that accepts a threshold value as its parameter, then within this consumer establish a test directory path under the target directory using the test class name, create the necessary directory structure, and generate a temporary subdirectory within it before building a Disk File Item Factory configured with the provided threshold, the temporary directory path, and UTF-8 charset, after which confirm the factory's threshold matches the input value, then construct a Disk File Item from the factory's builder and verify its threshold also matches the expected value before creating a private helper method that validates the item's current state by checking the underlying Deferrable Output Stream's state enumeration value, memory residency flag, output file path presence relative to the expected parent directory, and if provided, the accumulated byte count and string content against the item's reported size and retrieved data, initially asserting the item is in initialized state with data in memory and no output file, then obtain the item's output stream and initialize a string builder to track written content, writing bytes in a loop up to one less than the threshold while appending each character to the builder and verifying after each write that the item remains in opened state with data still in memory and no persisted file, upon writing the final byte that reaches the threshold append it to the builder and confirm the item transitions to persisted state with data no longer in memory and an output file created in the temporary directory, close the output stream and validate the item enters closed state while maintaining the persisted file location and matching the builder's accumulated string content, finally invoke this consumer twice with distinct threshold values of 5 and 8193 to verify behavior across small and large buffer boundaries using JUnit 5.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DiskFileItemTest",
      "method_signature": "testStateModelWithPositiveThreshold()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DiskFileItemThresholdTransitionTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport org.apache.commons.fileupload2.core.DeferrableOutputStream.State;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.function.IntConsumer;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DiskFileItemThresholdTransitionTest {\n\n    @TempDir\n    private Path tempDir;\n\n    private static final String TEST_CHAR = \"x\";\n\n    /**\n     * Helper method to access the private 'deferrableOutputStream' field of DiskFileItem via reflection.\n     * This is necessary to validate the DeferrableOutputStream's internal state as required by the test description.\n     *\n     * @param item The DiskFileItem instance.\n     * @return The underlying DeferrableOutputStream.\n     */\n    private DeferrableOutputStream getDeferrableOutputStream(DiskFileItem item) {\n        try {\n            java.lang.reflect.Field field = DiskFileItem.class.getDeclaredField(\"deferrableOutputStream\");\n            field.setAccessible(true); // Temporarily make the private field accessible\n            return (DeferrableOutputStream) field.get(item);\n        } catch (NoSuchFieldException | IllegalAccessException e) {\n            fail(\"Could not access deferrableOutputStream field via reflection: \" + e.getMessage());\n            return null; // Should not be reached\n        }\n    }\n\n    /**\n     * Helper method to access the private 'threshold' field of DeferrableOutputStream via reflection.\n     *\n     * @param deferrableOutputStream The DeferrableOutputStream instance.\n     * @return The threshold value.\n     */\n    private int getDeferrableOutputStreamThreshold(DeferrableOutputStream deferrableOutputStream) {\n        try {\n            java.lang.reflect.Field field = DeferrableOutputStream.class.getDeclaredField(\"threshold\");\n            field.setAccessible(true); // Temporarily make the private field accessible\n            return field.getInt(deferrableOutputStream);\n        } catch (NoSuchFieldException | IllegalAccessException e) {\n            fail(\"Could not access DeferrableOutputStream's threshold field via reflection: \" + e.getMessage());\n            return -1; // Should not be reached\n        }\n    }\n\n    /**\n     * Helper method to validate the current state of a DiskFileItem and its underlying DeferrableOutputStream.\n     *\n     * @param item                          The DiskFileItem to validate.\n     * @param expectedDeferrableOutputStreamState The expected state of the DeferrableOutputStream.\n     * @param expectedInMemory              True if the item is expected to be in memory.\n     * @param expectedParentPathForFile     The expected parent directory for the persisted file, or null if no file is expected.\n     * @param expectedByteCount             The expected total number of bytes written, or null if not checking.\n     * @param expectedStringContent         The expected string content, or null if not checking.\n     * @throws IOException                  If an I/O error occurs during content retrieval.\n     */\n    private void validateDiskFileItemState(\n            DiskFileItem item,\n            State expectedDeferrableOutputStreamState,\n            boolean expectedInMemory,\n            Path expectedParentPathForFile,\n            Long expectedByteCount,\n            String expectedStringContent\n    ) throws IOException {\n        DeferrableOutputStream dos = getDeferrableOutputStream(item);\n        assertEquals(expectedDeferrableOutputStreamState, dos.getStreamState(), \"DeferrableOutputStream state mismatch\");\n        assertEquals(expectedInMemory, item.isInMemory(), \"DiskFileItem memory residency mismatch\");\n\n        if (expectedParentPathForFile != null) {\n            assertNotNull(item.getStoreLocation(), \"Store location should not be null when file is expected\");\n            assertTrue(item.getStoreLocation().toPath().startsWith(expectedParentPathForFile), \"Persisted file not in expected parent directory\");\n            if (!expectedInMemory) { // Only check file existence if not in memory (i.e., persisted)\n                assertTrue(Files.exists(item.getStoreLocation().toPath()), \"Persisted file should exist\");\n            } else {\n                assertFalse(Files.exists(item.getStoreLocation().toPath()), \"Persisted file should not exist when still in memory\");\n            }\n        } else {\n            assertNull(item.getStoreLocation(), \"Store location should be null when no file is expected\");\n        }\n\n        if (expectedByteCount != null) {\n            assertEquals(expectedByteCount.longValue(), item.getSize(), \"DiskFileItem size mismatch\");\n        }\n        if (expectedStringContent != null) {\n            assertEquals(expectedStringContent, item.getString(StandardCharsets.UTF_8.name()), \"DiskFileItem content mismatch\");\n        }\n    }\n\n    @Test\n    void testDiskFileItemThresholdStateTransitions() {\n        IntConsumer thresholdTestConsumer = threshold -> {\n            Path tempSubDir = null;\n            try {\n                // Establish a test directory path under the target directory using the test class name\n                Path testClassDir = tempDir.resolve(getClass().getSimpleName());\n                Files.createDirectories(testClassDir);\n\n                // Generate a temporary subdirectory within it\n                tempSubDir = Files.createTempDirectory(testClassDir, \"fileitem-test-\");\n\n                // Build a DiskFileItemFactory configured with the provided threshold,\n                // the temporary directory path, and UTF-8 charset\n                DiskFileItemFactory factory = DiskFileItemFactory.builder()\n                        .setSizeThreshold(threshold)\n                        .setRepository(tempSubDir.toFile())\n                        .setCharset(StandardCharsets.UTF_8)\n                        .get();\n\n                // Confirm the factory's threshold matches the input value\n                assertEquals(threshold, factory.getSizeThreshold(), \"Factory threshold mismatch\");\n\n                // Construct a DiskFileItem from the factory's builder\n                DiskFileItem item = factory.builder()\n                        .setFieldName(\"testField\")\n                        .setContentType(\"text/plain\")\n                        .setFormField(true)\n                        .setFileName(\"testfile.txt\")\n                        .get();\n\n                // Verify its threshold also matches the expected value (via DeferrableOutputStream)\n                DeferrableOutputStream dos = getDeferrableOutputStream(item);\n                assertEquals(threshold, getDeferrableOutputStreamThreshold(dos), \"DeferrableOutputStream threshold mismatch\");\n\n                // Initially assert the item is in initialized state with data in memory and no output file\n                validateDiskFileItemState(item, State.INITIALIZED, true, null, 0L, \"\");\n\n                // Obtain the item's output stream and initialize a string builder to track written content\n                OutputStream os = item.getOutputStream();\n                StringBuilder writtenContentBuilder = new StringBuilder();\n\n                // Write bytes in a loop up to the threshold-th byte\n                // (i.e., `threshold` bytes total, where `threshold` is the size at which it still resides in memory)\n                for (int i = 0; i < threshold; i++) {\n                    os.write(TEST_CHAR.getBytes(StandardCharsets.UTF_8));\n                    writtenContentBuilder.append(TEST_CHAR);\n                    // Verify after each write that the item remains in opened state with data still in memory and no persisted file\n                    validateDiskFileItemState(item, State.OPENED, true, null, (long) (i + 1), writtenContentBuilder.toString());\n                }\n                // At this point, `item.getSize()` == `threshold`. It should still be in memory.\n\n                // Upon writing the final byte that exceeds the threshold (making it threshold + 1 bytes total)\n                os.write(TEST_CHAR.getBytes(StandardCharsets.UTF_8));\n                writtenContentBuilder.append(TEST_CHAR);\n                // Confirm the item transitions to persisted state with data no longer in memory\n                // and an output file created in the temporary directory\n                validateDiskFileItemState(item, State.PERSISTED, false, tempSubDir, (long) (threshold + 1), writtenContentBuilder.toString());\n\n                // Close the output stream and validate the item enters closed state\n                // while maintaining the persisted file location and matching the builder's accumulated string content\n                os.close();\n                validateDiskFileItemState(item, State.CLOSED, false, tempSubDir, (long) (threshold + 1), writtenContentBuilder.toString());\n\n                // Clean up the created item's store location\n                if (item.getStoreLocation() != null) {\n                    Files.delete(item.getStoreLocation().toPath());\n                }\n\n            } catch (IOException e) {\n                fail(\"Test failed due to IOException: \" + e.getMessage());\n            } finally {\n                // Ensure temporary directory is cleaned up even if test fails\n                if (tempSubDir != null) {\n                    try {\n                        Files.deleteIfExists(tempSubDir);\n                    } catch (IOException e) {\n                        // Suppress cleanup exception\n                    }\n                }\n            }\n        };\n\n        // Invoke this consumer twice with distinct threshold values of 5 and 8193\n        // to verify behavior across small and large buffer boundaries\n        thresholdTestConsumer.accept(5);\n        thresholdTestConsumer.accept(8193);\n    }\n}",
      "method_signature": "testStateModelWithPositiveThreshold()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7141,
    "output_tokens": 9963,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 250,
      "description": "Define a test method that validates the state transitions of a Disk File Item when configured with a zero threshold by encapsulating the verification logic within a parameterized consumer that accepts byte count values. Within the consumer implementation, establish a test directory path under the target folder using the test class's simple name, create the directory structure, then generate a temporary subdirectory within it. Build a Disk File Item Factory with buffer size set to zero, the temporary directory as the repository path, and UTF-8 charset, then verify the factory's threshold equals zero. From this factory, construct a Disk File Item builder and obtain the file item instance, confirming its threshold also equals zero. Create a private helper method that validates the file item's current state by retrieving its output stream, asserting the stream's state matches the expected state enumeration value, verifying the in-memory status matches both the file item and its underlying stream, checking whether the stream's path is null or resides within the expected parent directory, and if a test string is provided, confirming the size and content match across both the file item and stream while also validating the string representation and byte array retrieval. Immediately after constructing the file item, invoke this helper to confirm the initialized state with in-memory status true and null path. Prepare a string builder to track written content, then open the file item's output stream within a try-with-resources block and iterate for the specified number of bytes, writing a period character to the stream and appending it to the builder while invoking the state validation helper after each write to confirm the persisted state with in-memory status false and the temporary directory as parent, passing null for content validation since the stream remains open. After the loop, write a comma character to both the stream and builder, then allow the stream to close automatically. Upon stream closure, invoke the state validation helper once more to verify the closed state with in-memory status false, the temporary directory as parent, and the complete accumulated string content for validation. Execute the consumer twice with different byte counts: first with five bytes, then with a value exceeding typical buffer size by one to ensure state transitions occur correctly across varying data volumes. This test uses JUnit 5 for the test framework and standard assertion methods for validation.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DiskFileItemTest",
      "method_signature": "testStateModelWithThresholdZero()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DiskFileItemZeroThresholdTransitionTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.function.Consumer;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests the state transitions of {@link DiskFileItem} when configured with a zero threshold,\n * ensuring immediate transition from memory to file storage upon any write operation.\n */\npublic class DiskFileItemZeroThresholdTransitionTest {\n\n    @TempDir\n    private Path tempBaseDir; // Base temporary directory for the test class\n\n    /**\n     * Helper method to validate the state of a {@link DiskFileItem}.\n     *\n     * @param fileItem          The {@link DiskFileItem} instance to validate.\n     * @param expectedInMemory  True if the item is expected to be in memory, false otherwise.\n     * @param expectedParentPath The expected parent directory path if the item is file-backed, null if in-memory.\n     * @param expectedContent   The expected content string for content validation, null to skip content validation.\n     * @throws IOException If an I/O error occurs during file operations.\n     */\n    private void validateFileItemState(\n            final DiskFileItem fileItem,\n            final boolean expectedInMemory,\n            final Path expectedParentPath,\n            final String expectedContent\n    ) throws IOException {\n        assertNotNull(fileItem, \"FileItem should not be null.\");\n\n        assertEquals(expectedInMemory, fileItem.isInMemory(), \"FileItem inMemory status mismatch.\");\n\n        final Path currentPath = fileItem.getPath();\n        if (expectedParentPath == null) {\n            assertNull(currentPath, \"FileItem path should be null when expectedParentPath is null.\");\n        } else {\n            assertNotNull(currentPath, \"FileItem path should not be null when expectedParentPath is present.\");\n            assertTrue(Files.exists(currentPath), \"File should exist at path: \" + currentPath);\n            // Verify parent directory\n            assertEquals(expectedParentPath.toAbsolutePath(), currentPath.getParent().toAbsolutePath(), \"FileItem path parent mismatch.\");\n        }\n\n        if (expectedContent != null) {\n            final byte[] expectedBytes = expectedContent.getBytes(StandardCharsets.UTF_8);\n            final byte[] actualBytes = fileItem.get(); // Reads content from memory or file\n            assertArrayEquals(expectedBytes, actualBytes, \"Content mismatch for get().\");\n            assertEquals(expectedContent, fileItem.getString(StandardCharsets.UTF_8.name()), \"String representation mismatch.\");\n            assertEquals(expectedBytes.length, fileItem.getSize(), \"Size mismatch.\");\n        } else {\n            // If content is null, we are not validating content specifically.\n            // If in-memory, and content is not being validated, size should generally be 0 initially.\n            if (expectedInMemory && fileItem.isInMemory()) {\n                assertEquals(0, fileItem.getSize(), \"Expected 0 size for in-memory item with no content validation.\");\n            }\n        }\n    }\n\n    @Test\n    void testDiskFileItemZeroThresholdStateTransitions() {\n        // Encapsulate the verification logic within a parameterized consumer that accepts byte count values.\n        final Consumer<Integer> testConsumer = byteCount -> {\n            try {\n                // Establish a test directory path under the target folder using the test class's simple name.\n                final Path testClassDir = tempBaseDir.resolve(getClass().getSimpleName());\n                Files.createDirectories(testClassDir); // Create the directory structure.\n\n                // Generate a temporary subdirectory within it.\n                final Path tempRepositoryDir = Files.createTempDirectory(testClassDir, \"repo-\");\n\n                // Build a Disk File Item Factory with buffer size set to zero,\n                // the temporary directory as the repository path, and UTF-8 charset.\n                final int sizeThreshold = 0;\n                final DiskFileItemFactory factory = new DiskFileItemFactory();\n                factory.setSizeThreshold(sizeThreshold);\n                factory.setRepository(tempRepositoryDir.toFile());\n                factory.setFileCharset(StandardCharsets.UTF_8.name());\n\n                // Verify the factory's threshold equals zero.\n                assertEquals(sizeThreshold, factory.getSizeThreshold(), \"Factory size threshold should be zero.\");\n                assertEquals(tempRepositoryDir.toAbsolutePath(), factory.getRepository().toPath().toAbsolutePath(), \"Factory repository path mismatch.\");\n                assertEquals(StandardCharsets.UTF_8.name(), factory.getFileCharset(), \"Factory file charset mismatch.\");\n\n                // From this factory, construct a Disk File Item and obtain the file item instance,\n                // confirming its threshold also equals zero.\n                final String fieldName = \"testField\";\n                final String contentType = \"text/plain\";\n                final boolean isFormField = true;\n                final String fileName = \"testFile.txt\";\n                final DiskFileItem fileItem = (DiskFileItem) factory.createItem(fieldName, contentType, isFormField, fileName);\n\n                assertEquals(sizeThreshold, fileItem.getSizeThreshold(), \"FileItem size threshold should be zero.\");\n                assertEquals(fieldName, fileItem.getFieldName(), \"FileItem field name mismatch.\");\n                assertEquals(contentType, fileItem.getContentType(), \"FileItem content type mismatch.\");\n                assertEquals(isFormField, fileItem.isFormField(), \"FileItem isFormField mismatch.\");\n                assertEquals(fileName, fileItem.getName(), \"FileItem name mismatch.\");\n\n                // Immediately after constructing the file item, invoke this helper to confirm the initialized state\n                // with in-memory status true and null path.\n                validateFileItemState(fileItem, true, null, null);\n\n                // Prepare a string builder to track written content.\n                final StringBuilder writtenContentBuilder = new StringBuilder();\n\n                // Open the file item's output stream within a try-with-resources block.\n                try (OutputStream os = fileItem.getOutputStream()) {\n                    // Iterate for the specified number of bytes, writing a period character to the stream\n                    // and appending it to the builder.\n                    for (int i = 0; i < byteCount; i++) {\n                        os.write('.');\n                        writtenContentBuilder.append('.');\n                        // Invoke the state validation helper after each write to confirm the persisted state\n                        // with in-memory status false and the temporary directory as parent,\n                        // passing null for content validation since the stream remains open.\n                        validateFileItemState(fileItem, false, tempRepositoryDir, null);\n                    }\n\n                    // After the loop, write a comma character to both the stream and builder.\n                    os.write(',');\n                    writtenContentBuilder.append(',');\n                } // Allow the stream to close automatically.\n\n                // Upon stream closure, invoke the state validation helper once more to verify the closed state\n                // with in-memory status false, the temporary directory as parent, and the complete accumulated string content for validation.\n                validateFileItemState(fileItem, false, tempRepositoryDir, writtenContentBuilder.toString());\n\n                // Ensure the file is actually on disk and matches content.\n                final Path finalFilePath = fileItem.getPath();\n                assertNotNull(finalFilePath, \"Final file path should not be null.\");\n                assertTrue(Files.exists(finalFilePath), \"Final file should exist.\");\n                assertEquals(writtenContentBuilder.toString(), Files.readString(finalFilePath, StandardCharsets.UTF_8), \"File content on disk mismatch.\");\n\n                // Clean up the created file.\n                Files.delete(finalFilePath);\n                Files.delete(tempRepositoryDir); // Clean up the temporary repository directory.\n                Files.delete(testClassDir);     // Clean up the test class directory.\n\n            } catch (final IOException e) {\n                fail(\"IOException occurred during test: \" + e.getMessage(), e);\n            }\n        };\n\n        // Execute the consumer twice with different byte counts:\n        // First with five bytes.\n        testConsumer.accept(5);\n\n        // Then with a value exceeding typical buffer size by one to ensure state transitions\n        // occur correctly across varying data volumes (e.g., a larger number like 8192+1).\n        testConsumer.accept(8193);\n    }\n}",
      "method_signature": "testStateModelWithThresholdZero()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7230,
    "output_tokens": 7444,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 282,
      "description": "Define a test method annotated with `@Test` that begins by declaring a lambda variable `tester` of type `IntConsumer` which accepts an `int` parameter `numBytes` and executes the following logic within a try-catch block that catches `IOException` and wraps it in `UncheckedIOException`: invoke `Paths.get` with the concatenated string `\"target/unit-tests/\"` plus the result of calling `getSimpleName()` on `DiskFileItemTest.class`, assigning the result to a `Path` variable `testDir`, then invoke `Files.createDirectories` passing `testDir` to ensure the directory exists, followed by invoking `Files.createTempDirectory` with arguments `testDir` and string literal `\"testDir\"` and assigning the returned `Path` to variable `tempTestDir`, then invoke `DiskFileItemFactory.builder()` and chain `setBufferSize(0)`, `setPath(tempTestDir)`, `setCharset(StandardCharsets.UTF_8)`, and finally `get()` to construct a `DiskFileItemFactory` instance assigned to variable `dfif`, immediately assert using `assertEquals` that `dfif.getThreshold()` returns `0`, then invoke `dfif.fileItemBuilder().get()` to create a `DiskFileItem` instance assigned to variable `dfi`, assert again using `assertEquals` that `dfi.getThreshold()` returns `0`, and invoke a private method that casts `dfi.getOutputStream()` to `DeferrableOutputStream` assigned to variable `dos`, asserts using `assertEquals` that `dos.getState()` equals `State.initialized`, asserts using `assertEquals` that `dfi.isInMemory()` returns `true`, asserts using `assertEquals` that `dos.isInMemory()` returns `true`, checks if the fourth parameter (representing `parentDir`) is `null` and if so asserts using `assertNull` that `dos.getPath()` is `null`, otherwise asserts using `assertNotNull` that `dos.getPath()` is not `null` and asserts using `assertEquals` that `dos.getPath().getParent()` equals the `parentDir` value, and checks if the fifth parameter (representing `testString`) is `null` and if so asserts using `assertNull` that `dfi.get()` and `dfi.getString()` are both `null`, otherwise asserts using `assertEquals` that `testString.length()` equals `dfi.getSize()`, asserts using `assertEquals` that `testString.length()` equals `dos.getSize()`, asserts using `assertEquals` that `testString` equals `dfi.getString()`, and asserts using `assertArrayEquals` that `testString.getBytes()` equals `dfi.get()`, invoking this private method with arguments `dfi`, `State.initialized`, `true`, `null`, and `null`, then instantiate a new `StringBuilder` assigned to variable `sb`, open a try-with-resources block declaring `OutputStream` variable `os` initialized by invoking `dfi.getOutputStream()`, enter a for loop with `int` variable `i` initialized to `0`, condition `i < numBytes`, and increment `i++`, within the loop invoke `os.write('.')` passing the character literal `'.'`, invoke `sb.append('.')` to append the same character to the builder, and invoke the same private method with arguments `dfi`, `State.persisted`, `false`, `tempTestDir`, and `null` to verify the state after each byte written, after the loop completes invoke `os.write(',')` passing character literal `','` and invoke `sb.append(',')` to append the comma, then after the try-with-resources block closes the output stream invoke the private method again with arguments `dfi`, `State.closed`, `false`, `tempTestDir`, and `sb.toString()` to verify the final closed state with the complete string content, and if an `IOException` occurs in the try block catch it and throw a new `UncheckedIOException` wrapping the caught exception. After defining the `tester` lambda, invoke `tester.accept(5)` to execute the test logic with `numBytes` equal to `5`, then invoke `tester.accept(8193)` to execute the test logic again with `numBytes` equal to `8193` representing a typical buffer size plus one. The test uses JUnit 5 assertions (`assertEquals`, `assertNull`, `assertNotNull`, `assertArrayEquals`) and is annotated with `@Test`.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DiskFileItemTest",
      "method_signature": "testStateModelWithThresholdZero()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DiskFileItemCustomThresholdTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport org.junit.jupiter.api.Test;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.function.IntConsumer;\n// Not strictly needed, but good for clarity for StringBuilder\n// import java.lang.StringBuilder;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\n/**\n * Tests the lifecycle of {@link DiskFileItem} with a custom threshold\n * (specifically, a zero-byte threshold implied by setBufferSize(0)).\n */\npublic class DiskFileItemCustomThresholdTest {\n\n    /**\n     * Helper method to verify the state of a {@link DiskFileItem} and its\n     * underlying {@link DeferrableOutputStream}.\n     *\n     * @param dfi The {@link DiskFileItem} instance to check.\n     * @param expectedState The expected {@link DeferrableOutputStream.State}.\n     * @param expectedInMemory The expected in-memory status for both {@link DiskFileItem} and {@link DeferrableOutputStream}.\n     * @param expectedParentDir The expected parent directory if the stream is file-backed; null otherwise.\n     * @param expectedTestString The expected string content; null if no content is expected or if the content is not yet finalized.\n     * @throws IOException If an I/O error occurs during content retrieval.\n     */\n    private void verifyDiskFileItemState(\n        DiskFileItem dfi,\n        DeferrableOutputStream.State expectedState,\n        boolean expectedInMemory,\n        Path expectedParentDir,\n        String expectedTestString\n    ) throws IOException {\n        DeferrableOutputStream dos = (DeferrableOutputStream) dfi.getOutputStream();\n\n        assertEquals(expectedState, dos.getState(), \"DeferrableOutputStream state mismatch\");\n        assertEquals(expectedInMemory, dfi.isInMemory(), \"DiskFileItem inMemory status mismatch\");\n        assertEquals(expectedInMemory, dos.isInMemory(), \"DeferrableOutputStream inMemory status mismatch\");\n\n        if (expectedParentDir == null) {\n            assertNull(dos.getPath(), \"DeferrableOutputStream path should be null\");\n        } else {\n            assertNotNull(dos.getPath(), \"DeferrableOutputStream path should not be null\");\n            assertEquals(expectedParentDir, dos.getPath().getParent(), \"DeferrableOutputStream parent path mismatch\");\n        }\n\n        if (expectedTestString == null) {\n            // As per instruction: \"asserts using assertNull that dfi.get() and dfi.getString() are both null\"\n            assertNull(dfi.get(), \"DiskFileItem content (byte[]) should be null\");\n            assertNull(dfi.getString(), \"DiskFileItem content (String) should be null\");\n        } else {\n            assertEquals(expectedTestString.length(), dfi.getSize(), \"DiskFileItem size mismatch\");\n            assertEquals(expectedTestString.length(), dos.getSize(), \"DeferrableOutputStream size mismatch\");\n            assertEquals(expectedTestString, dfi.getString(StandardCharsets.UTF_8.name()), \"DiskFileItem string content mismatch\");\n            assertArrayEquals(expectedTestString.getBytes(StandardCharsets.UTF_8), dfi.get(), \"DiskFileItem byte array content mismatch\");\n        }\n    }\n\n    @Test\n    public void testCustomThresholdItemLifecycle() {\n        final IntConsumer tester = numBytes -> {\n            try {\n                // \"invoke Paths.get with the concatenated string \"target/unit-tests/\" plus the result of calling getSimpleName() on DiskFileItemTest.class\"\n                // Assuming DiskFileItemTest exists and is resolvable for compilation.\n                // If DiskFileItemTest class is not found, this line will cause a compilation error.\n                Path testDir = Paths.get(\"target/unit-tests/\" + DiskFileItemTest.class.getSimpleName());\n                // \"then invoke Files.createDirectories passing testDir to ensure the directory exists\"\n                Files.createDirectories(testDir);\n                // \"followed by invoking Files.createTempDirectory with arguments testDir and string literal \"testDir\" and assigning the returned Path to variable tempTestDir\"\n                Path tempTestDir = Files.createTempDirectory(testDir, \"testDir\");\n\n                // \"then invoke DiskFileItemFactory.builder() and chain setBufferSize(0), setPath(tempTestDir), setCharset(StandardCharsets.UTF_8), and finally get() to construct a DiskFileItemFactory instance assigned to variable dfif\"\n                DiskFileItemFactory dfif = DiskFileItemFactory.builder()\n                    .setBufferSize(0)\n                    .setPath(tempTestDir)\n                    .setCharset(StandardCharsets.UTF_8)\n                    .get();\n\n                // \"immediately assert using assertEquals that dfif.getThreshold() returns 0\"\n                assertEquals(0, dfif.getThreshold(), \"DiskFileItemFactory threshold should be 0\");\n\n                // \"then invoke dfif.fileItemBuilder().get() to create a DiskFileItem instance assigned to variable dfi\"\n                DiskFileItem dfi = (DiskFileItem) dfif.fileItemBuilder().get();\n\n                // \"assert again using assertEquals that dfi.getThreshold() returns 0\"\n                assertEquals(0, dfi.getThreshold(), \"DiskFileItem threshold should be 0\");\n\n                // \"invoking this private method with arguments dfi, State.initialized, true, null, and null\"\n                verifyDiskFileItemState(dfi, DeferrableOutputStream.State.initialized, true, null, null);\n\n                // \"then instantiate a new StringBuilder assigned to variable sb\"\n                StringBuilder sb = new StringBuilder();\n                // \"open a try-with-resources block declaring OutputStream variable os initialized by invoking dfi.getOutputStream()\"\n                try (OutputStream os = dfi.getOutputStream()) {\n                    // \"enter a for loop with int variable i initialized to 0, condition i < numBytes, and increment i++\"\n                    for (int i = 0; i < numBytes; i++) {\n                        // \"within the loop invoke os.write('.') passing the character literal '.'\"\n                        os.write('.');\n                        // \"invoke sb.append('.') to append the same character to the builder\"\n                        sb.append('.');\n                        // \"and invoke the same private method with arguments dfi, State.persisted, false, tempTestDir, and null to verify the state after each byte written\"\n                        verifyDiskFileItemState(dfi, DeferrableOutputStream.State.persisted, false, tempTestDir, null);\n                    }\n                    // \"after the loop completes invoke os.write(',') passing character literal ',' and invoke sb.append(',') to append the comma\"\n                    os.write(',');\n                    sb.append(',');\n                } // The try-with-resources block ensures os.close() is called implicitly here\n\n                // \"then after the try-with-resources block closes the output stream invoke the private method again with arguments dfi, State.closed, false, tempTestDir, and sb.toString() to verify the final closed state with the complete string content\"\n                verifyDiskFileItemState(dfi, DeferrableOutputStream.State.closed, false, tempTestDir, sb.toString());\n\n            } catch (IOException e) {\n                // \"and if an IOException occurs in the try block catch it and throw a new UncheckedIOException wrapping the caught exception.\"\n                throw new UncheckedIOException(e);\n            }\n        };\n\n        // \"After defining the tester lambda, invoke tester.accept(5) to execute the test logic with numBytes equal to 5\"\n        tester.accept(5);\n        // \"then invoke tester.accept(8193) to execute the test logic again with numBytes equal to 8193 representing a typical buffer size plus one.\"\n        tester.accept(8193);\n    }\n}",
      "method_signature": "testStateModelWithThresholdZero()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7716,
    "output_tokens": 8749,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 293,
      "description": "Define a test method that begins by creating a lambda expression of type `IntConsumer` assigned to variable `tester`, which accepts an `int` parameter `numBytes` and executes the following logic within a try-catch block that catches `IOException` and rethrows it as `UncheckedIOException`: first, create a `Path` variable `testDir` by invoking `Paths.get` with the concatenated string `\"target/unit-tests/\"` plus the result of calling `getSimpleName()` on `DiskFileItemTest.class`, then invoke `Files.createDirectories` passing `testDir` to ensure the directory exists, next create a `Path` variable `tempTestDir` by invoking `Files.createTempDirectory` with arguments `testDir` and string literal `\"testDir\"`, then construct a `DiskFileItemFactory` variable `dfif` by chaining `DiskFileItemFactory.builder()`, `.setThreshold(numBytes)`, `.setPath(tempTestDir)`, `.setCharset(StandardCharsets.UTF_8)`, and finally `.get()`, immediately assert using `assertEquals` that `numBytes` equals the result of invoking `dfif.getThreshold()`, then create a `DiskFileItem` variable `dfi` by chaining `dfif.fileItemBuilder()` and `.get()`, assert again using `assertEquals` that `numBytes` equals `dfi.getThreshold()`, define a private method that accepts a `DiskFileItem`, a `State` enum value, a `boolean` for in-memory status, a `Path` for parent directory (nullable), and a `String` for test content (nullable), and within this method cast the result of invoking `dfi.getOutputStream()` to `DeferrableOutputStream` and assign it to variable `dos`, assert using `assertEquals` that the provided `State` matches `dos.getState()`, assert using `assertEquals` that the provided `boolean` matches both `dfi.isInMemory()` and `dos.isInMemory()`, conditionally assert using `assertNull(dos.getPath())` if the provided `Path` is null, otherwise assert using `assertNotNull(dos.getPath())` and `assertEquals` that the provided `Path` matches `dos.getPath().getParent()`, conditionally assert if the provided `String` is not null by using `assertEquals` to verify `testString.length()` matches both `dfi.getSize()` and `dos.getSize()`, then assert using `assertEquals` that `testString` matches `dfi.getString()`, and assert using `assertArrayEquals` that `testString.getBytes()` matches `dfi.get()`, otherwise if the `String` is null assert using `assertNull(dfi.get())` and `assertNull(dfi.getString())`, then invoke this private method with arguments `dfi`, `State.initialized`, `true`, `null`, and `null` to verify the initial state, create a `StringBuilder` variable `sb` by invoking `new StringBuilder()`, open a try-with-resources block declaring `OutputStream` variable `os` initialized by invoking `dfi.getOutputStream()`, within this block execute a for loop with `int` variable `i` initialized to `0`, continuing while `i < numBytes - 1`, incrementing `i` each iteration, and in each iteration invoke `os.write('.')` passing the character literal `'.'`, invoke `sb.append('.')` to mirror the written character, and invoke the private method with arguments `dfi`, `State.opened`, `true`, `null`, and `null` to verify the opened state, after the loop completes invoke `os.write(',')` passing the character literal `','`, invoke `sb.append(',')` to append the comma, and invoke the private method with arguments `dfi`, `State.persisted`, `false`, `tempTestDir`, and `null` to verify the persisted state, upon exiting the try-with-resources block (which automatically closes `os`) invoke the private method with arguments `dfi`, `State.closed`, `false`, `tempTestDir`, and `sb.toString()` to verify the closed state with the complete written content, after defining the lambda invoke `tester.accept(5)` to execute the test logic with threshold value `5`, then invoke `tester.accept(8193)` to execute the test logic with threshold value `8193`, annotate the test method with `@Test`, use assertion library JUnit 5 Assertions for `assertEquals`, `assertNull`, `assertNotNull`, and `assertArrayEquals`, and note that no class-level annotations, mocking libraries, or additional method-level annotations are present.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DiskFileItemTest",
      "method_signature": "testStateModelWithPositiveThreshold()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DiskFileItemLifecycleTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.function.IntConsumer;\n\nimport org.junit.jupiter.api.Test;\n\npublic class DiskFileItemLifecycleTest {\n\n    /**\n     * Private helper method to verify the state of a DiskFileItem and its underlying DeferrableOutputStream.\n     *\n     * @param dfi The DiskFileItem to verify.\n     * @param expectedState The expected State of the DeferrableOutputStream.\n     * @param expectedInMemory The expected in-memory status.\n     * @param expectedParentPath The expected parent directory path for file-backed items (null if in memory or no path).\n     * @param expectedContent The expected content string (null if no content is expected to be accessible yet).\n     * @throws IOException If an I/O error occurs during verification.\n     */\n    private void verifyItemState(DiskFileItem dfi, DeferrableOutputStream.State expectedState, boolean expectedInMemory, Path expectedParentPath, String expectedContent) throws IOException {\n        final DeferrableOutputStream dos = (DeferrableOutputStream) dfi.getOutputStream();\n\n        assertEquals(expectedState, dos.getState(), \"DeferrableOutputStream state mismatch.\");\n        assertEquals(expectedInMemory, dfi.isInMemory(), \"DiskFileItem isInMemory() status mismatch.\");\n        assertEquals(expectedInMemory, dos.isInMemory(), \"DeferrableOutputStream isInMemory() status mismatch.\");\n\n        if (expectedParentPath == null) {\n            assertNull(dos.getPath(), \"DeferrableOutputStream path should be null.\");\n        } else {\n            assertNotNull(dos.getPath(), \"DeferrableOutputStream path should not be null.\");\n            // dos.getPath() returns the actual file, so getParent() is needed to compare with the directory path.\n            assertEquals(expectedParentPath, dos.getPath().getParent(), \"DeferrableOutputStream parent path mismatch.\");\n        }\n\n        if (expectedContent != null) {\n            assertEquals(expectedContent.length(), dfi.getSize(), \"DiskFileItem getSize() mismatch for content.\");\n            assertEquals(expectedContent.length(), dos.getSize(), \"DeferrableOutputStream getSize() mismatch for content.\");\n            assertEquals(expectedContent, dfi.getString(StandardCharsets.UTF_8), \"DiskFileItem getString() mismatch.\");\n            assertArrayEquals(expectedContent.getBytes(StandardCharsets.UTF_8), dfi.get(), \"DiskFileItem get() byte array mismatch.\");\n        } else {\n            // According to the prompt's explicit instruction for `null` expectedContent.\n            assertNull(dfi.get(), \"DiskFileItem get() should be null if no content expected yet.\");\n            assertNull(dfi.getString(StandardCharsets.UTF_8), \"DiskFileItem getString() should be null if no content expected yet.\");\n            // Size should be 0 when get() and getString() are null\n            assertEquals(0, dfi.getSize(), \"DiskFileItem getSize() should be 0 if no content expected yet.\");\n            assertEquals(0, dos.getSize(), \"DeferrableOutputStream getSize() should be 0 if no content expected yet.\");\n        }\n    }\n\n    @Test\n    public void testDiskFileItemCreationAndLifecycle() {\n        final IntConsumer tester = numBytes -> {\n            try {\n                // Create test directory: \"target/unit-tests/\" + DiskFileItemLifecycleTest.class.getSimpleName()\n                final Path testDir = Paths.get(\"target/unit-tests/\" + DiskFileItemLifecycleTest.class.getSimpleName());\n                Files.createDirectories(testDir); // Ensure the directory exists\n\n                // Create a temporary test directory within testDir\n                final Path tempTestDir = Files.createTempDirectory(testDir, \"testDir\");\n\n                // Construct DiskFileItemFactory\n                final DiskFileItemFactory dfif = DiskFileItemFactory.builder()\n                        .setThreshold(numBytes)\n                        .setPath(tempTestDir)\n                        .setCharset(StandardCharsets.UTF_8)\n                        .get();\n\n                // Assert dfif threshold\n                assertEquals(numBytes, dfif.getThreshold(), \"DiskFileItemFactory threshold mismatch.\");\n\n                // Create DiskFileItem\n                final DiskFileItem dfi = dfif.fileItemBuilder().get();\n\n                // Assert dfi threshold\n                assertEquals(numBytes, dfi.getThreshold(), \"DiskFileItem threshold mismatch.\");\n\n                // Verify initial state: dfi, State.initialized (mapped to initial), true, null, null\n                verifyItemState(dfi, DeferrableOutputStream.State.initial, true, null, null);\n\n                // Prepare StringBuilder for content\n                final StringBuilder sb = new StringBuilder();\n\n                // Open OutputStream and write content\n                try (OutputStream os = dfi.getOutputStream()) {\n                    // Loop to write numBytes - 1 characters\n                    for (int i = 0; i < numBytes - 1; i++) {\n                        os.write('.');\n                        sb.append('.');\n                        // Verify opened state: dfi, State.opened (mapped to open), true, null, null\n                        // Note: Per prompt, expectedContent is null here, asserting get() and getString() are null.\n                        verifyItemState(dfi, DeferrableOutputStream.State.open, true, null, null);\n                    }\n\n                    // Write final character\n                    os.write(',');\n                    sb.append(',');\n\n                    // Verify persisted state: dfi, State.persisted (mapped to open), false, tempTestDir, null\n                    // Note: Per prompt, expectedContent is null here, asserting get() and getString() are null.\n                    // The 'false' for inMemory and 'tempTestDir' for parent path are key for this \"persisted\" check.\n                    verifyItemState(dfi, DeferrableOutputStream.State.open, false, tempTestDir, null);\n\n                } // OutputStream 'os' is automatically closed here by try-with-resources\n\n                // Verify closed state: dfi, State.closed, false, tempTestDir, sb.toString()\n                // Now content should be accessible from dfi.\n                verifyItemState(dfi, DeferrableOutputStream.State.closed, false, tempTestDir, sb.toString());\n\n                // Clean up the temporary directory after the test\n                Files.walk(tempTestDir)\n                    .sorted(java.util.Comparator.reverseOrder())\n                    .map(Path::toFile)\n                    .forEach(java.io.File::delete);\n                Files.deleteIfExists(tempTestDir); // Delete the directory itself\n                Files.deleteIfExists(testDir); // Attempt to delete the parent directory as well\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n\n        // Execute test logic with threshold 5\n        tester.accept(5);\n\n        // Execute test logic with threshold 8193\n        tester.accept(8193);\n    }\n}",
      "method_signature": "testStateModelWithPositiveThreshold()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7761,
    "output_tokens": 7878,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 97,
      "description": "Define a test method that validates the construction of a Multipart Input processor using its builder pattern with input stream, boundary, and progress notifier configuration. Prepare a simple string value, convert it to a byte array to represent the content payload, and wrap this byte array in a ByteArrayInputStream to serve as the data source. Convert the boundary text constant to a byte array to establish the multipart stream delimiter. Obtain a builder instance from the Multipart Input factory, then configure it by setting the input stream to the prepared ByteArrayInputStream, specifying the boundary byte array, and attaching a Progress Notifier initialized with a null listener reference and the content length derived from the byte array size. Invoke the builder's get method to construct the Multipart Input instance, which triggers internal validation of buffer sizing against boundary requirements and initializes the stream processing infrastructure. Upon receiving the constructed instance, assert that it is not null to confirm successful instantiation through the builder pattern. This test uses JUnit for test execution and standard assertion methods for validation.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testTwoParamConstructor()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputBuilderTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MultipartInputBuilderTest {\n\n    @Test\n    void testMultipartInputBuilderWithProgressNotifier() throws IOException {\n        // Prepare a simple string value, convert it to a byte array to represent the content payload\n        final String contentString = \"---------------------------2824921612140417643228399047\\r\\n\"\n                + \"Content-Disposition: form-data; name=\\\"file\\\"; filename=\\\"test.txt\\\"\\r\\n\"\n                + \"Content-Type: text/plain\\r\\n\"\n                + \"\\r\\n\"\n                + \"Hello World\\r\\n\"\n                + \"---------------------------2824921612140417643228399047--\\r\\n\";\n        final byte[] contentBytes = contentString.getBytes(StandardCharsets.US_ASCII); // Use ASCII for multipart boundaries\n\n        // Wrap this byte array in a ByteArrayInputStream to serve as the data source\n        final ByteArrayInputStream inputStream = new ByteArrayInputStream(contentBytes);\n\n        // Convert the boundary text constant to a byte array to establish the multipart stream delimiter\n        final String boundaryString = \"---------------------------2824921612140417643228399047\";\n        final byte[] boundaryBytes = boundaryString.getBytes(StandardCharsets.US_ASCII);\n\n        // Attach a Progress Notifier initialized with a null listener reference and the content length derived from the byte array size\n        final MultipartInput.ProgressNotifier progressNotifier = new MultipartInput.ProgressNotifier(null, contentBytes.length);\n\n        // Obtain a builder instance from the Multipart Input factory\n        final MultipartInput multipartInput = MultipartInput.builder()\n                // Configure it by setting the input stream to the prepared ByteArrayInputStream\n                .setInputStream(inputStream)\n                // Specifying the boundary byte array\n                .setBoundary(boundaryBytes)\n                // And attaching a Progress Notifier\n                .setProgressNotifier(progressNotifier)\n                // Invoke the builder's get method to construct the Multipart Input instance\n                .get();\n\n        // Upon receiving the constructed instance, assert that it is not null to confirm successful instantiation\n        assertNotNull(multipartInput, \"MultipartInput instance should not be null\");\n    }\n}",
      "method_signature": "testTwoParamConstructor()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.5,
      "method_coverage": 0.6,
      "line_coverage": 0.8958,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 1,
          "search_file_content": 3
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 26349,
    "output_tokens": 1892,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  }
]