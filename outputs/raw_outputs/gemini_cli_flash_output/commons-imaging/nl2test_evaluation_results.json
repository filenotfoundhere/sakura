[
  {
    "compiles": false,
    "nl2test_input": {
      "id": 120,
      "description": "Define a parameterized test method that validates the default file extension property across all supported image format types by iterating through each enumeration constant in the ImageFormats enum, where for each format constant passed as a parameter, invoke the getDefaultExtension method to retrieve the associated file extension string, then immediately verify that the returned extension is not null to ensure every format provides a default extension value, and subsequently validate that the extension string is not empty to confirm it contains meaningful content, using the testing framework JUnit 5 with its parameterized test capabilities driven by an enum source.",
      "project_name": "commons-imaging",
      "qualified_class_name": "org.apache.commons.imaging.ImageFormatsTest",
      "method_signature": "testDefaultExtension(org.apache.commons.imaging.ImageFormats)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 127,
      "description": "Define a parameterized test method that accepts a single parameter of type `ImageFormats` and annotate it with `@ParameterizedTest` and `@EnumSource(ImageFormats.class)` to supply all enum constants of `ImageFormats` as test arguments. Within the method body, invoke `getDefaultExtension()` on the `imageFormats` parameter and immediately pass the returned `String` value to `assertNotNull` to verify the result is not null. Following this assertion, invoke `getDefaultExtension()` again on the same `imageFormats` parameter, chain the `isEmpty()` method on the returned `String`, and pass the boolean result to `assertFalse` to verify the default extension is not an empty string. The test uses JUnit 5 Assertions with method-level annotations `@ParameterizedTest` and `@EnumSource(ImageFormats.class)`.",
      "project_name": "commons-imaging",
      "qualified_class_name": "org.apache.commons.imaging.ImageFormatsTest",
      "method_signature": "testDefaultExtension(org.apache.commons.imaging.ImageFormats)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 131,
      "description": "Define a parameterized test method that accepts each enumeration constant from the ImageFormats enumeration as input, iterating through all available image format types to validate their name properties. For each provided ImageFormats instance, invoke the getName method to retrieve the format's string identifier, then assert that the returned value is not null to confirm proper initialization of the enumeration constant. Following this, invoke isEmpty on the retrieved name string and assert that it returns false, thereby verifying that every image format enumeration constant maintains a non-empty name identifier. This test validates the completeness of metadata across all enumeration values without requiring any mocking or external dependencies, using JUnit 5 for parameterization and standard assertion methods.",
      "project_name": "commons-imaging",
      "qualified_class_name": "org.apache.commons.imaging.ImageFormatsTest",
      "method_signature": "testName(org.apache.commons.imaging.ImageFormats)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 133,
      "description": "Define a test method annotated with `@ParameterizedTest` and `@EnumSource(ImageFormats.class)` that accepts a single parameter of type `ImageFormats` named `imageFormats`, which will be automatically populated with each constant from the `ImageFormats` enum during test execution. Within the method body, invoke `getName()` on the `imageFormats` parameter and immediately pass the returned `String` value to `assertNotNull`, verifying that the name is not null. Following this, invoke `getName()` again on the same `imageFormats` parameter, chain the `isEmpty()` method on the resulting `String`, and pass the boolean result to `assertFalse`, thereby confirming that the name is not an empty string. The test uses JUnit 5 Assertions for verification, specifically `assertNotNull` and `assertFalse`, and relies on the parameterized test mechanism provided by `@ParameterizedTest` with `@EnumSource` to iterate through all enum constants of `ImageFormats`.",
      "project_name": "commons-imaging",
      "qualified_class_name": "org.apache.commons.imaging.ImageFormatsTest",
      "method_signature": "testName(org.apache.commons.imaging.ImageFormats)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 134,
      "description": "Create a test case to validate that every recognized image format type in the system maintains a properly defined default file extension for consistent file handling and format identification. Ensure the system handles all supported image format variations correctly by verifying each format type provides a valid extension designation. For each image format type recognized by the system, confirm that the format declares an associated default extension and verify this extension designation is not missing or empty, ensuring the system can reliably identify and process files of that format. After confirming each format type has a valid extension, validate that the extension value contains meaningful content rather than being blank, which would prevent proper file type recognition. Use JUnit 5 with standard equality and presence assertions to verify the extension configuration for each format type.",
      "project_name": "commons-imaging",
      "qualified_class_name": "org.apache.commons.imaging.ImageFormatsTest",
      "method_signature": "testDefaultExtension(org.apache.commons.imaging.ImageFormats)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 135,
      "description": "Create a test case to validate that every supported image format recognized by the system maintains a properly defined display name for user-facing identification purposes. Ensure the validation covers all available image format types by systematically examining each one to confirm its display name exists and contains meaningful content rather than being missing or empty. For each format variation, verify the system provides a non-empty textual representation that can be used for labeling, categorization, or presentation to end users. This comprehensive check ensures consistent naming conventions across all image format options supported by the platform, preventing any format from lacking proper identification. Use JUnit 5 for the testing framework with standard equality and boolean assertions to confirm each format's display name meets the required business criteria.",
      "project_name": "commons-imaging",
      "qualified_class_name": "org.apache.commons.imaging.ImageFormatsTest",
      "method_signature": "testName(org.apache.commons.imaging.ImageFormats)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 146,
      "description": "Create a test case to validate that the image processing system correctly handles and preserves international character encoding within embedded metadata, specifically verifying support for non-Latin scripts. Obtain a sample image file that contains embedded metadata with text in Mandarin Chinese characters from the available test resources, then process this image through the system's metadata extraction capabilities to retrieve the complete metadata structure. Once the metadata is extracted, access the embedded descriptive information and locate the specific metadata entry containing the Mandarin text. After identifying this entry, verify that the system has correctly preserved the international characters by comparing the extracted text against the expected Mandarin phrase meaning \"thank you\" when both are represented in their Unicode byte form, ensuring the encoding matches UTF-8 standards throughout the comparison. This validation confirms the system's ability to maintain character encoding integrity for international content embedded within image metadata. Use JUnit 5 for the testing framework and standard array equality assertions to verify the byte-level accuracy of the encoded text.",
      "project_name": "commons-imaging",
      "qualified_class_name": "org.apache.commons.imaging.formats.jpeg.iptc.IptcParserTest",
      "method_signature": "testEncodingSupport()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 149,
      "description": "Define a test method that validates the JPEG image parser's ability to correctly decode and preserve non-ASCII character encodings within IPTC metadata by first creating a utility that resolves a test resource path to a File object for the specific JPEG image containing Photoshop metadata with Mandarin characters, then instantiate a JPEG Image Parser and invoke its metadata extraction capability on the resolved file to obtain JPEG Image Metadata. From the retrieved metadata, access the Photoshop metadata component and extract its collection of metadata items, then retrieve the fourth item from this collection which contains the Mandarin text. To verify correct encoding preservation, convert the expected Unicode string representation of the Mandarin characters to UTF-8 byte representation and assert that this byte array matches the byte array obtained by converting the text value from the retrieved metadata item to UTF-8, confirming that the parser maintains character encoding integrity throughout the parsing pipeline. The test uses JUnit for test execution and standard assertion methods for byte array comparison.",
      "project_name": "commons-imaging",
      "qualified_class_name": "org.apache.commons.imaging.formats.jpeg.iptc.IptcParserTest",
      "method_signature": "testEncodingSupport()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 178,
      "description": "Create a test case to validate the system's capability to extract embedded technical metadata from image files that include supplementary descriptive information stored in a specialized format, specifically focusing on verifying that the image processing system correctly retrieves and interprets description text embedded within the image's technical metadata structure. Begin by locating a sample image file from the system's test resources that contains embedded descriptive metadata, then configure the image processing system to analyze this file and extract its technical metadata. Once the system has parsed the image, verify that the embedded description text matches the expected value by confirming the presence of the specific author or creator name stored in the root metadata section. Additionally, confirm that the image's textual annotation section remains empty, as this particular file stores its descriptive information exclusively in the technical metadata format rather than in standard text annotations. Repeat the metadata extraction process to ensure consistency, then verify once more that the description text retrieved from the technical metadata structure matches the expected value, confirming the system reliably accesses embedded metadata regardless of how many times the image is processed. Use JUnit 5 as the testing framework and AssertJ for standard equality assertions to validate both the presence of the expected description text and the absence of textual annotations.",
      "project_name": "commons-imaging",
      "qualified_class_name": "org.apache.commons.imaging.formats.png.PngReadTest",
      "method_signature": "testReadExif()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 179,
      "description": "Define a test method that verifies the PNG Image Parser correctly extracts EXIF metadata embedded within the 'eXIf' chunk of a PNG file by resolving the test image resource path from the classpath, instantiating a PNG Image Parser, and invoking its metadata extraction capability on the resolved file to obtain PNG Image Metadata. From the retrieved PNG metadata, extract the embedded EXIF metadata as TIFF Image Metadata, then locate the root directory within the TIFF structure and retrieve the image description field value, asserting that it matches the expected author string. To confirm that textual metadata is stored exclusively in the EXIF chunk rather than as separate PNG text chunks, invoke the metadata extraction method a second time on the same file to obtain a fresh PNG Image Metadata instance, retrieve its textual information collection, and verify that the collection is empty. Having confirmed the absence of text chunks, extract the EXIF metadata from this second metadata instance, navigate to the root directory, retrieve the image description field value again, and assert that it still matches the expected author string, thereby confirming that EXIF data persists correctly across multiple reads and that the parser correctly segregates EXIF from textual metadata. The test relies on JUnit 5 for assertions.",
      "project_name": "commons-imaging",
      "qualified_class_name": "org.apache.commons.imaging.formats.png.PngReadTest",
      "method_signature": "testReadExif()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 180,
      "description": "Define a test method annotated with `@Test` that declares it throws `IOException` and `ImagingException`, then begin by obtaining a `File` reference by invoking `TestResources.resourceToFile` with the String argument `\"/images/jpeg/iptc/IMAGING-168/111083453-c07f1880-851e-11eb-8b61-2757f7d934bf.jpg\"` and assigning the result to variable `file`, where the helper logic constructs a `File` by first calling `resourceToURI` with the path argument and passing the resulting `URI` to the `File` constructor. Next, instantiate a `JpegImageParser` using its no-argument constructor and assign it to variable `parser`, then invoke `getMetadata` on `parser` passing `file` as the argument, cast the returned value to `JpegImageMetadata`, and assign it to variable `metadata`. Having obtained the metadata, invoke `getPhotoshop()` on `metadata` to retrieve the `JpegPhotoshopMetadata` and assign it to variable `photoshopMetadata`, then call `getItems()` on `photoshopMetadata`, cast the result to `List<GenericImageMetadataItem>` with a `@SuppressWarnings(\"unchecked\")` annotation on the variable declaration, and assign it to variable `items`. With the items list populated, invoke `get(3)` on `items` to retrieve the fourth element and assign it to variable `thanksInMandarin` of type `GenericImageMetadataItem`. Finally, assert that the byte arrays are equal by calling `assertArrayEquals` with the first argument being the byte array obtained by invoking `getBytes(StandardCharsets.UTF_8)` on the Unicode escape String literal `\"\\u8c22\\u8c22\"` and the second argument being the byte array obtained by first calling `getText()` on `thanksInMandarin` to retrieve its text value, then invoking `getBytes(StandardCharsets.UTF_8)` on that result. The test uses JUnit 5 Assertions with method-level annotation `@Test`.",
      "project_name": "commons-imaging",
      "qualified_class_name": "org.apache.commons.imaging.formats.jpeg.iptc.IptcParserTest",
      "method_signature": "testEncodingSupport()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 210,
      "description": "Define a test method that declares a `throws` clause for `IOException` and `ImagingException`, then assign the String literal `\"/images/png/IMAGING-340/image-with-exif.png\"` to variable `input`, invoke `getResource(input)` on the class literal `PngReadTest.class` to obtain a `URL`, immediately chain `getFile()` on that result and assign the returned String to variable `file`, instantiate a `PngImageParser` using its no-argument constructor and assign it to variable `parser`, construct a `File` instance by passing `file` as the argument, invoke `getMetadata` on `parser` with that `File` instance, cast the returned value to `PngImageMetadata` and assign it to variable `pngMetadata`, invoke `getExif()` on `pngMetadata` and assign the resulting `TiffImageMetadata` to variable `exifMetadata`, then invoke `findDirectory` on `exifMetadata` passing the constant `TiffDirectoryConstants.DIRECTORY_TYPE_ROOT` as the argument to obtain a `TiffDirectory`, immediately chain `getFieldValue` on that directory passing the constant `TiffTagConstants.TIFF_TAG_IMAGE_DESCRIPTION` as the argument, and assert using `assertEquals` that the returned value equals the String literal `\"Glavo\"`, construct another `File` instance by passing `file` again, invoke `getMetadata` on `parser` with this second `File` instance, cast the result to `PngImageMetadata` and assign it to variable `metadata`, invoke `getTextualInformation()` on `metadata` to obtain an `ImageMetadata` instance, chain `getItems()` on that result to retrieve a `List`, invoke `isEmpty()` on the list and assert using `assertTrue` that it returns `true`, then invoke `getExif()` on `metadata` to obtain a `TiffImageMetadata`, chain `findDirectory` on that result passing `TiffDirectoryConstants.DIRECTORY_TYPE_ROOT`, chain `getFieldValue` on the returned `TiffDirectory` passing `TiffTagConstants.TIFF_TAG_IMAGE_DESCRIPTION`, and assert using `assertEquals` that this final value equals the String literal `\"Glavo\"`. The test uses the `@Test` annotation and no class-level or method-level integration annotations, relies on JUnit 5 Assertions for `assertEquals` and `assertTrue`, and does not employ any mocking libraries.",
      "project_name": "commons-imaging",
      "qualified_class_name": "org.apache.commons.imaging.formats.png.PngReadTest",
      "method_signature": "testReadExif()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  }
]