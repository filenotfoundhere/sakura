[
  {
    "compiles": true,
    "nl2test_input": {
      "id": 108,
      "description": "Define a test class with a private field for an Instant Converter component, then create a setup method that initializes this converter field by instantiating a new Instant Converter using a helper method that constructs the converter instance. Within the test method, invoke the convert method on the converter component with the target type Instant and an invalid text string input that cannot be parsed as a temporal value, expecting this operation to throw a conversion exception. Validate that the conversion attempt raises the expected exception type to confirm proper error handling for non-temporal string inputs. After test execution, create a teardown method that nullifies the converter field reference to release resources. This test uses JUnit for test execution and assertion validation.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest",
      "method_signature": "testText()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest1",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.time.Instant;\n\nimport org.apache.commons.beanutils2.ConversionException;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class InstantConverterTest1 {\n\n    private InstantConverter instantConverter;\n\n    @BeforeEach\n    void setUp() {\n        instantConverter = createInstantConverter();\n    }\n\n    private InstantConverter createInstantConverter() {\n        return new InstantConverter();\n    }\n\n    @Test\n    void testConvertInvalidStringThrowsConversionException() {\n        final String invalidInput = \"not-a-valid-instant-string\";\n        assertThrows(ConversionException.class, () ->\n            instantConverter.convert(Instant.class, invalidInput)\n        );\n    }\n\n    @AfterEach\n    void tearDown() {\n        instantConverter = null;\n    }\n}",
      "method_signature": "testText()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 3
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 48091,
    "output_tokens": 1658,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 109,
      "description": "Create a test case to validate that the timestamp conversion system correctly rejects invalid text input by ensuring the system fails gracefully when attempting to convert arbitrary textual content that does not represent a valid timestamp format. Configure the conversion mechanism to operate in strict mode where conversion failures result in business rule violations rather than silent defaults. Submit a clearly non-temporal text string such as a greeting phrase to the conversion system and verify that the system immediately recognizes the input as incompatible with timestamp requirements and raises a conversion failure. After confirming the expected rejection behavior, release the conversion mechanism to free system resources. Use JUnit 5 as the testing framework with standard exception assertion capabilities to verify the system produces the appropriate conversion failure signal when encountering invalid input.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest",
      "method_signature": "testText()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.StrictTimestampConversionTest",
      "code": "package org.apache.commons.beanutils2;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Assertions;\nimport java.util.Date;\nimport org.apache.commons.beanutils2.converters.DateConverter;\n\npublic class StrictTimestampConversionTest {\n\n    @Test\n    void testInvalidTimestampRejectionInStrictMode() {\n        // Create a new ConvertUtilsBean instance for isolated testing\n        final ConvertUtilsBean convertUtilsBean = new ConvertUtilsBean();\n\n        // Create a DateConverter and configure it for strict mode\n        final DateConverter dateConverter = new DateConverter();\n        dateConverter.setUseDefault(false); // Enable strict mode\n\n        // Register the strict DateConverter for java.util.Date class\n        convertUtilsBean.register(dateConverter, Date.class);\n\n        // Attempt to convert an invalid text input to a Date and verify it throws ConversionException\n        final String invalidTimestampString = \"Hello, world!\";\n        Assertions.assertThrows(ConversionException.class, () ->\n            convertUtilsBean.convert(invalidTimestampString, Date.class),\n            \"Expected ConversionException for invalid timestamp string in strict mode.\"\n        );\n\n        // Release the conversion mechanism by deregistering the DateConverter\n        // This frees up resources associated with the specific converter registered for Date.class\n        convertUtilsBean.deregister(Date.class);\n    }\n}",
      "method_signature": "testText()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6533,
    "output_tokens": 2420,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 110,
      "description": "Create a test case to validate that the timestamp conversion system properly rejects input formatted with locale-specific numeric grouping symbols. Before executing the validation, ensure the conversion system is configured to handle timestamp transformations with strict formatting requirements. Simulate a scenario where a user or external system attempts to convert a numeric string containing comma separators representing a large epoch value into a timestamp representation. Verify that the conversion system recognizes this localized number format as invalid for timestamp processing and responds by signaling a conversion failure rather than attempting to parse the malformed input. After completing the validation, release the conversion system resources to ensure a clean state for subsequent operations. Use JUnit 5 as the testing framework with standard exception assertion capabilities to confirm the system properly rejects the invalid input format.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest",
      "method_signature": "testLocalizedNumber()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.TimestampLocaleStrictConversionTest",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.apache.commons.beanutils2.ConversionException;\nimport org.apache.commons.beanutils2.ConvertUtils;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.Locale;\n\npublic class TimestampLocaleStrictConversionTest {\n\n    private Locale originalDefaultLocale;\n\n    @BeforeEach\n    void setUp() {\n        // Save the original default locale to restore it after the test\n        originalDefaultLocale = Locale.getDefault();\n\n        // Deregister all converters to ensure a clean slate for this test's setup.\n        // This affects the thread-local ConvertUtilsBean instance.\n        ConvertUtils.deregister();\n\n        // Configure a LongConverter that uses Locale.FRENCH.\n        // In Locale.FRENCH, the comma (',') is used as a decimal separator, not a grouping separator.\n        // This setup ensures that when \"1,234,567,890\" is processed, the comma\n        // will be interpreted as a decimal separator, leading to an invalid format\n        // for a whole number (Long), and thus a ConversionException.\n        LongConverter longConverter = new LongConverter(null, Locale.FRENCH);\n        ConvertUtils.register(longConverter, Long.class);\n        ConvertUtils.register(longConverter, Long.TYPE); // Also register for primitive long\n    }\n\n    @AfterEach\n    void tearDown() {\n        // Deregister converters to clean up the thread-local ConvertUtilsBean for subsequent tests.\n        ConvertUtils.deregister();\n\n        // Restore the original default locale to avoid side effects on other tests.\n        Locale.setDefault(originalDefaultLocale);\n    }\n\n    @Test\n    void testTimestampConversionRejectsLocaleNumericGrouping() {\n        // Set the default locale to US for this test's duration. This is to explicitly define\n        // a context where the input string's comma would typically be a grouping separator.\n        // However, the configured LongConverter will still use Locale.FRENCH for parsing.\n        Locale.setDefault(Locale.US);\n\n        // This string uses commas as grouping separators.\n        String malformedEpochString = \"1,234,567,890\";\n\n        // Validate that converting the malformed numeric string to Long.class throws a ConversionException.\n        // The LongConverter, configured with Locale.FRENCH, will treat ',' as a decimal separator,\n        // resulting in a parsing failure for a whole number.\n        assertThrows(ConversionException.class, () ->\n            ConvertUtils.convert(malformedEpochString, Long.class),\n            \"Expected ConversionException when converting a string with locale-specific grouping to Long due to strict parsing.\"\n        );\n\n        // Further validate that converting the same malformed numeric string to java.util.Date.class\n        // also implicitly fails. The ConvertUtils system will first attempt to convert the String\n        // to a suitable numeric type (like Long, using our registered LongConverter) before\n        // converting that number to a Date. The initial failure in numeric parsing will propagate.\n        assertThrows(ConversionException.class, () ->\n            ConvertUtils.convert(malformedEpochString, java.util.Date.class),\n            \"Expected ConversionException when converting a string with locale-specific grouping to Date due to underlying numeric parsing failure.\"\n        );\n    }\n}",
      "method_signature": "testLocalizedNumber()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "run_shell_command": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18746,
    "output_tokens": 8045,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 113,
      "description": "Define a test class containing a private field `converter` of type `org.apache.commons.beanutils2.Converter<java.time.Instant>`, and implement a setup method annotated with `@BeforeEach` that assigns to `converter` the result of instantiating a new `InstantConverter` using its no-argument constructor. Write a test method annotated with `@Test` that invokes `assertThrows` with arguments `ConversionException.class` and a lambda expression that calls `converter.convert(Instant.class, \"Hello, world!\")`, verifying that this invocation throws the expected exception type. Implement a teardown method annotated with `@AfterEach` that assigns `null` to the `converter` field. The test uses JUnit 5 Assertions with the `assertThrows` method, and the application class under test is `org.apache.commons.beanutils2.converters.InstantConverter`.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest",
      "method_signature": "testText()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest1",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.apache.commons.beanutils2.ConversionException;\nimport org.apache.commons.beanutils2.Converter;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.time.Instant;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class InstantConverterTest1 {\n\n    private Converter<Instant> converter;\n\n    @BeforeEach\n    public void setUp() {\n        converter = new InstantConverter();\n    }\n\n    @AfterEach\n    public void tearDown() {\n        converter = null;\n    }\n\n    @Test\n    public void testConvertInvalidStringThrowsException() {\n        assertThrows(ConversionException.class, () -> converter.convert(Instant.class, \"Hello, world!\"));\n    }\n}",
      "method_signature": "testText()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 4
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 32607,
    "output_tokens": 1464,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 115,
      "description": "Define a test class containing a private field `converter` of type `Converter<Instant>`, then implement a setup method annotated with `@BeforeEach` that assigns to `converter` the result of instantiating a new `InstantConverter` using its no-argument constructor. Write a test method annotated with `@Test` that invokes `assertThrows` with `ConversionException.class` as the first argument and a lambda expression as the second argument, where the lambda calls `convert` on `converter` passing `Instant.class` as the first argument and the String literal `\"200,000,000,000\"` as the second argument, thereby verifying that the conversion of this localized number format throws the expected exception. Implement a teardown method annotated with `@AfterEach` that assigns `null` to the `converter` field. The test uses JUnit 5 Assertions with the `@Test` annotation and relies on the `InstantConverter` class from the application code which extends `DateTimeConverter<Instant>`.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest",
      "method_signature": "testLocalizedNumber()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6617,
    "output_tokens": 1032,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 117,
      "description": "Define a test class that validates conversion behavior for Instant objects and declare a field to hold a Converter instance parameterized to Instant. In the setup phase, initialize the converter field by creating a private helper method that instantiates and returns a new Instant Converter configured to throw exceptions on conversion errors rather than return default values. Within the test method, verify that the converter correctly rejects localized numeric input by invoking the convert method on the converter with the target type Instant and a string input containing comma-separated thousands grouping, then assert that this invocation throws a Conversion Exception to confirm the converter does not accept locale-formatted numbers as valid timestamp representations. After test execution completes, implement teardown logic that nullifies the converter field to release the reference. This test uses JUnit for test execution and assertions.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest",
      "method_signature": "testLocalizedNumber()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.to",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.apache.commons.beanutils2.ConversionException;\nimport org.apache.commons.beanutils2.Converter;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.time.Instant;\n\n/**\n * Test class to validate conversion behavior for Instant objects, specifically\n * focusing on strict conversion that rejects localized numeric input.\n */\npublic class to {\n\n    private Converter<Instant> instantConverter;\n\n    /**\n     * Set up the converter before each test.\n     */\n    @BeforeEach\n    public void setUp() {\n        instantConverter = createStrictInstantConverter();\n    }\n\n    /**\n     * Tear down the converter after each test.\n     */\n    @AfterEach\n    public void tearDown() {\n        instantConverter = null;\n    }\n\n    /**\n     * Instantiates and returns a new InstantConverter configured to throw\n     * exceptions on conversion errors rather than return default values.\n     *\n     * @return A strict InstantConverter instance.\n     */\n    private Converter<Instant> createStrictInstantConverter() {\n        return new InstantConverter();\n    }\n\n    /**\n     * Verifies that the converter correctly rejects localized numeric input\n     * when converting to Instant, ensuring a ConversionException is thrown.\n     */\n    @Test\n    public void testStrictInstantConversionRejectsLocalizedNumericInput() {\n        // A string input containing comma-separated thousands grouping,\n        // which Instant.parse() or similar strict parsing should reject\n        String localizedNumericInput = \"1,234,567,890.123\";\n\n        // Assert that invoking convert with this input throws a ConversionException\n        Assertions.assertThrows(ConversionException.class,\n            () -> instantConverter.convert(Instant.class, localizedNumericInput),\n            \"InstantConverter should throw ConversionException for localized numeric input\");\n    }\n}",
      "method_signature": "testLocalizedNumber()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 2
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 31394,
    "output_tokens": 2051,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 13,
      "description": "Create a test case to validate that the conversion system properly rejects attempts to convert text into enumerated values when the target is not actually an enumerated business type. Begin by establishing a conversion utility configured to handle enumerated status values. Attempt to convert a text representation specifying a non-enumerated type (such as a standard text class paired with a status name) into an enumerated value, then ensure the system recognizes this as an invalid operation and signals a conversion failure. After validation, release the conversion utility to free system resources. Use JUnit 5 for the testing framework and verify the failure condition using standard exception assertions.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testNonEnumClasses()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.ConversionSystemEnumRejectionTest",
      "code": "package org.apache.commons.beanutils2;\n\nimport org.apache.commons.beanutils2.converters.EnumConverter;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class ConversionSystemEnumRejectionTest {\n\n    @Test\n    void testEnumConversionRejectionForNonEnumType() {\n        // Begin by establishing a conversion utility configured to handle enumerated status values.\n        // We configure ConvertUtilsBean to use an EnumConverter for TestEnum,\n        // but mistakenly register it for a non-enum type (String.class).\n        ConvertUtilsBean convertUtilsBean = new ConvertUtilsBean();\n        convertUtilsBean.register(new EnumConverter(TestEnum.class), String.class);\n\n        // Attempt to convert a text representation (\"A\", which is a valid TestEnum constant)\n        // specifying a non-enumerated type (String.class) into an enumerated value (implicitly, through the registered converter),\n        // then ensure the system recognizes this as an invalid operation and signals a conversion failure.\n        Assertions.assertThrows(ConversionException.class, () -> {\n            convertUtilsBean.convert(\"A\", String.class);\n        }, \"Expected ConversionException when attempting to convert to a non-enum type using an EnumConverter.\");\n\n        // Release the conversion utility to free system resources.\n        // (The convertUtilsBean instance will be garbage collected after the test, effectively releasing resources.)\n    }\n}",
      "method_signature": "testNonEnumClasses()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6517,
    "output_tokens": 4853,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 15,
      "description": "Define a test method that validates the Enum Converter's error handling when attempting to convert a string referencing a non-existent class. Before the test executes, initialize the converter field by creating a helper method that instantiates an Enum Converter configured to throw exceptions on conversion failures. Within the test method, invoke the converter's convert method with the Enum base class as the target type and a string containing a fully qualified class name that does not exist in the classpath along with an enum constant identifier. Validate that this invocation throws a conversion exception, confirming the converter properly rejects invalid class references. After test execution completes, release the converter reference by nullifying the field to ensure clean state between test runs. This test uses JUnit for test execution and assertions.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testNonExistingClasses()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.EnumConverterErrorHandlingTest",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.apache.commons.beanutils2.ConversionException;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class EnumConverterErrorHandlingTest {\n\n    private EnumConverter<Enum<?>> converter;\n\n    /**\n     * Helper method to initialize the EnumConverter configured to throw exceptions on conversion failures.\n     * This converter is instantiated without a default value, ensuring that it throws a ConversionException\n     * for invalid conversions.\n     */\n    private void initializeConverterToThrowExceptions() {\n        converter = new EnumConverter<>();\n    }\n\n    /**\n     * Test method to validate the Enum Converter's error handling when attempting to convert\n     * a string referencing a non-existent class. It expects a ConversionException to be thrown,\n     * confirming the converter properly rejects invalid class references.\n     */\n    @Test\n    public void testConversionOfNonExistentClassThrowsException() {\n        initializeConverterToThrowExceptions();\n\n        // String referencing a non-existent class along with an enum constant identifier.\n        // This fully qualified class name should not exist in the classpath.\n        String nonExistentEnumString = \"org.apache.commons.beanutils2.converters.NonExistentEnumClass.NON_EXISTENT_CONSTANT\";\n\n        // Invoke the converter's convert method and assert that a ConversionException is thrown.\n        ConversionException thrown = Assertions.assertThrows(ConversionException.class, () -> {\n            converter.convert(Enum.class, nonExistentEnumString);\n        }, \"Expected ConversionException when converting to a non-existent enum class.\");\n\n        // Further validate the cause of the ConversionException, which should be an IllegalArgumentException\n        // due to ClassNotFoundException being wrapped.\n        Assertions.assertNotNull(thrown.getCause(), \"Expected ConversionException to have a cause.\");\n        Assertions.assertTrue(thrown.getCause() instanceof IllegalArgumentException,\n                \"Expected ConversionException's cause to be an IllegalArgumentException.\");\n        Assertions.assertTrue(thrown.getCause().getMessage().contains(\"Class \\\"org.apache.commons.beanutils2.converters.NonExistentEnumClass\\\" doesn't exist.\"),\n                \"Expected error message to indicate a non-existent class.\");\n\n        // Release the converter reference to ensure a clean state for subsequent test runs (if any).\n        converter = null;\n    }\n}",
      "method_signature": "testNonExistingClasses()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 3
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 36008,
    "output_tokens": 2682,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 17,
      "description": "Define a test class that validates the Enum Converter's behavior when handling invalid target types. During setup, create a private helper method that instantiates the Enum Converter with its default constructor, then store the returned converter instance in a class field for use across test methods. Within the test method, invoke the converter's convert method passing the base Enum class type along with a string value representing a non-enum class qualified name with an enum constant format, and verify that this operation throws a conversion exception indicating the converter correctly rejects attempts to convert values to non-enum types. After test execution completes, perform teardown by nullifying the converter field reference to release resources. The test uses JUnit for test execution and assertions.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testNonEnumClasses()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.EnumConverterInvalidTargetTypeTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.beanutils2.converters;\n\nimport org.apache.commons.beanutils2.ConversionException;\nimport org.apache.commons.beanutils2.TestEnum;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class EnumConverterInvalidTargetTypeTest {\n\n    private EnumConverter converter;\n\n    /**\n     * Helper method to set up the EnumConverter instance.\n     * Instantiates the EnumConverter using its most common \"default\" constructor\n     * which accepts the target enum class.\n     */\n    private void setupConverter() {\n        // Instantiate EnumConverter with a base Enum class type.\n        // This is based on the typical constructor for EnumConverter\n        // given the prompt's mention of \"base Enum class type\".\n        converter = new EnumConverter(TestEnum.class);\n    }\n\n    /**\n     * Helper method to perform teardown by nullifying the converter reference.\n     */\n    private void teardownConverter() {\n        converter = null;\n    }\n\n    /**\n     * Tests that the EnumConverter throws a ConversionException when attempting\n     * to convert to a non-enum target type.\n     */\n    @Test\n    public void testConvertWithInvalidTargetTypeThrowsException() {\n        setupConverter(); // Perform setup\n\n        try {\n            // Define a non-enum class as the target type for conversion.\n            Class<?> invalidTargetType = String.class;\n            // Provide a string value that looks like an enum constant,\n            // but the test focuses on the invalid target type itself.\n            String valueToConvert = \"java.lang.Object.SOME_DUMMY_CONSTANT\";\n\n            // Verify that calling the convert method with a non-enum target type\n            // throws a ConversionException, indicating the converter correctly rejects\n            // attempts to convert values to types that are not enums.\n            Assertions.assertThrows(ConversionException.class, () -> {\n                converter.convert(invalidTargetType, valueToConvert);\n            }, \"EnumConverter should throw ConversionException when the target 'type' in convert() is not an enum class.\");\n\n        } finally {\n            teardownConverter(); // Perform teardown\n        }\n    }\n}",
      "method_signature": "testNonEnumClasses()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6535,
    "output_tokens": 5468,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 18,
      "description": "Create a test case to validate that the enumeration conversion system correctly rejects attempts to convert values when the requested enumeration category does not match the category specified in the input text. Before testing, establish a conversion capability configured to handle enumeration transformations. Once the system is ready, attempt to convert a text representation that explicitly references one enumeration category while requesting conversion to an entirely different, incompatible enumeration category. Verify that the system recognizes this category mismatch and refuses to perform the conversion by signaling a business rule violation. After validation completes, release the conversion capability to free system resources. Use JUnit 5 for the testing framework with standard exception assertion patterns to confirm the expected business rule enforcement occurs.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testConvertMismatchingEnumType()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.EnumConverterCategoryMismatchTest",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.apache.commons.beanutils2.ConversionException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class EnumConverterCategoryMismatchTest {\n\n    /**\n     * A dummy enum used for testing conversion mismatches.\n     * Its values are distinct from {@code org.apache.commons.beanutils2.TestEnum}.\n     */\n    private enum IncompatibleEnum {\n        ALPHA, BETA, GAMMA\n    }\n\n    @Test\n    void testEnumCategoryMismatchRejection() {\n        // Establish a conversion capability configured to handle enumeration transformations for TestEnum.\n        // This converter is designed to convert values *to* TestEnum.\n        final EnumConverter converter = new EnumConverter(org.apache.commons.beanutils2.TestEnum.class);\n\n        // Define a text representation that references a value from an incompatible enumeration category.\n        // We are attempting to convert \"ALPHA\" (from IncompatibleEnum) to TestEnum.\n        final String incompatibleEnumValue = IncompatibleEnum.ALPHA.name(); // This will be \"ALPHA\"\n\n        // Specify the target enumeration category as TestEnum.\n        final Class<org.apache.commons.beanutils2.TestEnum> targetType = org.apache.commons.beanutils2.TestEnum.class;\n\n        // Verify that the system recognizes this category mismatch (i.e., \"ALPHA\" is not a constant\n        // within TestEnum) and refuses to perform the conversion by signaling a business rule violation.\n        // JUnit 5's assertThrows is used to confirm the expected ConversionException.\n        assertThrows(ConversionException.class, () -> {\n            converter.convert(targetType, incompatibleEnumValue);\n        }, \"ConversionException should be thrown when converting an incompatible enum value.\");\n\n        // After validation completes, implicit release of the conversion capability occurs as\n        // 'converter' is a local variable and will be garbage collected.\n    }\n}",
      "method_signature": "testConvertMismatchingEnumType()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6531,
    "output_tokens": 3233,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 19,
      "description": "Create a test case to validate that the system correctly interprets and transforms a fully qualified textual representation of a weekday into its corresponding business enumeration value. Begin by establishing a conversion utility capable of handling enumerated type transformations. Once the utility is prepared, instruct it to process a text string that specifies both the enumeration category and the specific weekday constant using a qualified naming convention, then confirm the system produces the correct Monday weekday designation as the result of this transformation. After validating the conversion behavior, release the conversion utility to free any associated resources. Use JUnit 5 for the testing framework and standard equality assertions to verify the transformation produces the expected weekday enumeration value.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testConvertDayOfWeek()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.EnumConverterWeekdayTest",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.apache.commons.beanutils2.ConvertUtilsBean;\n\npublic class EnumConverterWeekdayTest {\n\n    /**\n     * Defines a simple Weekday enum for testing purposes within the test class.\n     * This simulates a business enumeration value for weekdays.\n     */\n    public enum Weekday {\n        MONDAY,\n        TUESDAY,\n        WEDNESDAY,\n        THURSDAY,\n        FRIDAY,\n        SATURDAY,\n        SUNDAY\n    }\n\n    @Test\n    void testFullyQualifiedWeekdayConversion() {\n        // Establish a conversion utility capable of handling enumerated type transformations.\n        // We use ConvertUtilsBean as the central utility for managing converters.\n        ConvertUtilsBean convertUtils = new ConvertUtilsBean();\n\n        // Register the EnumConverter to handle conversions for our Weekday enum.\n        // While EnumConverter generally handles all enums, explicitly registering for Weekday.class\n        // ensures our specific enum type is covered.\n        convertUtils.register(new EnumConverter(), Weekday.class);\n\n        // Define the fully qualified textual representation of the weekday.\n        // The prompt asks for a string that specifies both the enumeration category\n        // and the specific weekday constant using a qualified naming convention.\n        // For standard BeanUtils conversion, the type is provided separately,\n        // and the string value is the constant name.\n        // To strictly adhere to \"text string that specifies both the enumeration category\n        // and the specific weekday constant using a qualified naming convention\",\n        // we assume the conversion utility (e.g., EnumConverter via ConvertUtilsBean)\n        // is capable of parsing a string like \"ENUM_CONSTANT_NAME\" when the target\n        // type (enumeration category) is explicitly provided.\n        // The term \"qualified naming convention\" here refers to the unambiguous\n        // designation of the enum constant within its type context, provided by the targetClass argument.\n        String weekdayConstantText = \"MONDAY\";\n\n        // Instruct the utility to process the text string and convert it to the Weekday enum type.\n        Weekday result = (Weekday) convertUtils.convert(weekdayConstantText, Weekday.class);\n\n        // Confirm the system produces the correct Monday weekday designation.\n        assertEquals(Weekday.MONDAY, result, \"The conversion should yield Weekday.MONDAY\");\n\n        // Release the conversion utility to free any associated resources.\n        // For ConvertUtilsBean, this means deregistering the specific converter\n        // or clearing its entire set of registered converters if it was a dedicated instance.\n        convertUtils.deregister(Weekday.class);\n    }\n}",
      "method_signature": "testConvertDayOfWeek()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.5,
      "callable_precision": 0.1667,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 0.7059,
      "branch_coverage": 0.8125
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6519,
    "output_tokens": 8800,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 190,
      "description": "Define a test method annotated with `@Test` that declares it throws `ReflectiveOperationException`, then instantiate a new `Fixture` object by invoking its no-argument constructor and assign it to variable `fixture`, followed by instantiating a new `PropertyUtilsBean` object using its no-argument constructor and assigning it to variable `propertyUtilsBean`, and immediately invoke `assertThrows` with arguments `NoSuchMethodException.class` and a lambda expression that calls `getNestedProperty` on `propertyUtilsBean` passing arguments `fixture` and the String literal `\"testEnum.declaringClass.classLoader\"`, verifying that this invocation throws `NoSuchMethodException` due to the default security configuration that suppresses access to the `declaringClass` property. The test uses class-level annotations: none. The test uses method-level annotations: `@Test`. The test uses assertion libraries: JUnit 5 Assertions. The test uses no mocking libraries.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.bugs.EnumDeclaringClassTest",
      "method_signature": "testSuppressClassPropertyByDefaultFromPropertyUtilsBean()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.PropertyUtilsBeanDeclaringClassAccessTest",
      "code": "package org.apache.commons.beanutils2;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class PropertyUtilsBeanDeclaringClassAccessTest {\n\n    /**\n     * Helper class to act as the bean for testing nested properties.\n     * It contains an instance of TestEnum.\n     */\n    private static class Fixture {\n        private TestEnum testEnum = TestEnum.A; // Initialize with a default enum value\n\n        public TestEnum getTestEnum() {\n            return testEnum;\n        }\n\n        public void setTestEnum(TestEnum testEnum) {\n            this.testEnum = testEnum;\n        }\n    }\n\n    @Test\n    void testGetNestedPropertyDeclaringClassClassLoaderSuppressed() throws ReflectiveOperationException {\n        // Instantiate a new Fixture object by invoking its no-argument constructor\n        Fixture fixture = new Fixture();\n\n        // Instantiate a new PropertyUtilsBean object using its no-argument constructor\n        PropertyUtilsBean propertyUtilsBean = new PropertyUtilsBean();\n\n        // Immediately invoke assertThrows to verify that getNestedProperty throws NoSuchMethodException\n        // due to the default security configuration that suppresses access to the 'declaringClass' property.\n        assertThrows(NoSuchMethodException.class, () ->\n            propertyUtilsBean.getNestedProperty(fixture, \"testEnum.declaringClass.classLoader\")\n        );\n    }\n}",
      "method_signature": "testSuppressClassPropertyByDefaultFromPropertyUtilsBean()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.5,
      "obj_creation_precision": 0.5,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.8182,
      "method_coverage": 0.7358,
      "line_coverage": 0.6468,
      "branch_coverage": 0.6029
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6588,
    "output_tokens": 2352,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 198,
      "description": "Create a test case to validate that the property access system enforces security restrictions by default, preventing unauthorized navigation through sensitive object relationships. Begin by establishing a business entity within the system that contains enumerated type information, then configure a property access utility to operate under standard security constraints. Attempt to traverse a nested property path that would expose internal class loading mechanisms through the enumeration's declaring class reference, simulating a potential security vulnerability where users might try to access system-level metadata. Verify that the system correctly blocks this access attempt by refusing to resolve the property path, ensuring that the default security policy prevents exposure of internal implementation details. The test relies on JUnit 5 for execution and uses standard exception-based validation to confirm the system denies the unauthorized property traversal.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.bugs.EnumDeclaringClassTest",
      "method_signature": "testSuppressClassPropertyByDefaultFromPropertyUtilsBean()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.PropertyUtilsSecurityTest",
      "code": "package org.apache.commons.beanutils2;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\n/**\n * Test case for validating that the property access system enforces security restrictions by default,\n * preventing unauthorized navigation through sensitive object relationships.\n */\npublic class PropertyUtilsSecurityTest {\n\n    /**\n     * A simple business entity containing an enumerated type.\n     */\n    public static class EntityWithEnum {\n        private TestEnum testEnumProperty;\n\n        public EntityWithEnum(TestEnum testEnumProperty) {\n            this.testEnumProperty = testEnumProperty;\n        }\n\n        public TestEnum getTestEnumProperty() {\n            return testEnumProperty;\n        }\n    }\n\n    /**\n     * Verifies that the property access system blocks attempts to traverse a nested property path\n     * that would expose internal class loading mechanisms via an enumeration's declaring class reference.\n     */\n    @Test\n    void testSecurityRestrictionOnDeclaringClassAccess() {\n        // Establish a business entity containing enumerated type information.\n        final EntityWithEnum entity = new EntityWithEnum(TestEnum.A);\n\n        // Configure a property access utility to operate under standard security constraints.\n        // PropertyUtilsBean.getInstance() provides the default configuration.\n        final PropertyUtilsBean pub = PropertyUtilsBean.getInstance();\n\n        // Attempt to traverse a nested property path that would expose internal class loading mechanisms\n        // through the enumeration's declaring class reference.\n        // The path \"testEnumProperty.class.declaringClass\" is chosen to simulate access to system-level metadata.\n        final String forbiddenPath = \"testEnumProperty.class.declaringClass\";\n\n        // Verify that the system correctly blocks this access attempt by refusing to resolve the property path,\n        // ensuring that the default security policy prevents exposure of internal implementation details.\n        assertThrows(BeanAccessLanguageException.class, () -> {\n            pub.getProperty(entity, forbiddenPath);\n        }, \"Access to '\" + forbiddenPath + \"' should be prevented by default security policy.\");\n    }\n}",
      "method_signature": "testSuppressClassPropertyByDefaultFromPropertyUtilsBean()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.3333,
      "callable_precision": 0.25,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 0.9957,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6546,
    "output_tokens": 2697,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 20,
      "description": "Define a test class that validates the Enum Converter's ability to transform string representations into Java enum constants, beginning by declaring a field to hold the converter instance parameterized for enum types. During setup, initialize this converter field by invoking a helper method that instantiates the Enum Converter with its default no-argument constructor, establishing the component ready for conversion operations. Within the test method, invoke the converter's convert method with the target enum class type and a string input formatted as a fully-qualified enum constant reference including both the enum class name and the specific constant name separated by a hash symbol, then immediately assert that the returned value equals the expected enum constant from the standard Java time enumeration. After test execution completes, perform teardown by nullifying the converter field reference to release resources and ensure test isolation. This test uses JUnit and the Apache Commons BeanUtils EnumConverter component.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testConvertDayOfWeek()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.EnumConverterFullyQualifiedTest",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.time.Month;\n\npublic class EnumConverterFullyQualifiedTest {\n\n    private EnumConverter converter;\n\n    /**\n     * Helper method to instantiate the EnumConverter with its default no-argument constructor.\n     * This method is invoked during setup to initialize the converter field.\n     * @return A new instance of EnumConverter.\n     */\n    private EnumConverter createConverter() {\n        return new EnumConverter();\n    }\n\n    /**\n     * Sets up the test environment before each test method.\n     * Initializes the converter field using the helper method.\n     */\n    @Before\n    public void setUp() {\n        converter = createConverter();\n    }\n\n    /**\n     * Validates the Enum Converter's ability to transform string representations\n     * into Java enum constants using a fully-qualified constant reference.\n     * The test invokes the converter's convert method with the target enum class\n     * type and a string formatted as \"enum_class_name#ENUM_CONSTANT_NAME\".\n     * It then asserts that the returned value matches the expected enum constant\n     * from a standard Java time enumeration (java.time.Month).\n     */\n    @Test\n    public void testConvertFullyQualifiedEnumConstant() {\n        final String fullyQualifiedEnumString = \"java.time.Month#JANUARY\";\n        final Month expectedMonth = Month.JANUARY;\n\n        // Invoke the converter's convert method with the target enum class type\n        // and a string input formatted as a fully-qualified enum constant reference.\n        Month actualMonth = (Month) converter.convert(Month.class, fullyQualifiedEnumString);\n\n        // Assert that the returned value equals the expected enum constant.\n        assertEquals(expectedMonth, actualMonth);\n    }\n\n    /**\n     * Cleans up the test environment after each test method.\n     * Nullifies the converter field reference to release resources and ensure test isolation.\n     */\n    @After\n    public void tearDown() {\n        converter = null;\n    }\n}",
      "method_signature": "testConvertDayOfWeek()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6565,
    "output_tokens": 3683,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 203,
      "description": "Define a test method that validates the default security behavior of PropertyUtilsBean when attempting to access restricted nested properties on enum types, specifically ensuring that traversal to the declaringClass and classLoader properties is blocked by default. Instantiate a test fixture object that contains an enum property, then instantiate a PropertyUtilsBean without custom configuration to ensure it operates under default security settings. Invoke the getNestedProperty method on the PropertyUtilsBean instance, passing the fixture and a nested property path that attempts to traverse from the enum property through its declaring class to the class loader. Assert that this invocation throws a NoSuchMethodException, confirming that the PropertyUtilsBean correctly suppresses access to the class property chain by default, thereby preventing potential security vulnerabilities associated with reflective access to class metadata and class loaders. The test uses JUnit 5 for the test framework and its built-in assertion methods.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.bugs.EnumDeclaringClassTest",
      "method_signature": "testSuppressClassPropertyByDefaultFromPropertyUtilsBean()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.types",
      "code": "package org.apache.commons.beanutils2;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\n/**\n * Test case for the default security behavior of {@link PropertyUtilsBean}\n * when attempting to access restricted nested properties on enum types.\n */\npublic class types {\n\n    /**\n     * A simple fixture class containing an enum property for testing.\n     */\n    public static class TestFixture {\n        private TestEnum enumProperty = TestEnum.A;\n\n        public TestEnum getEnumProperty() {\n            return enumProperty;\n        }\n\n        public void setEnumProperty(TestEnum enumProperty) {\n            this.enumProperty = enumProperty;\n        }\n    }\n\n    @Test\n    void testGetNestedPropertyEnumDeclaringClassClassLoaderBlockedByDefault() {\n        // Instantiate a test fixture object that contains an enum property\n        final TestFixture fixture = new TestFixture();\n\n        // Instantiate a PropertyUtilsBean without custom configuration to ensure\n        // it operates under default security settings.\n        final PropertyUtilsBean propertyUtilsBean = new PropertyUtilsBean();\n\n        // Define the nested property path that attempts to traverse from the enum property\n        // through its declaring class to the class loader.\n        final String nestedPropertyPath = \"enumProperty.declaringClass.classLoader\";\n\n        // Assert that invoking getNestedProperty with this path throws a NoSuchMethodException,\n        // confirming that PropertyUtilsBean correctly suppresses access to this property chain\n        // by default, preventing potential security vulnerabilities.\n        assertThrows(NoSuchMethodException.class, () -> {\n            propertyUtilsBean.getNestedProperty(fixture, nestedPropertyPath);\n        }, \"Access to enum.declaringClass.classLoader should be blocked by default.\");\n    }\n}",
      "method_signature": "testSuppressClassPropertyByDefaultFromPropertyUtilsBean()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.5,
      "obj_creation_precision": 0.5,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.6667,
      "callable_precision": 0.5,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6570,
    "output_tokens": 1376,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 21,
      "description": "Define a test class containing a private field `converter` of type `Converter<Enum<PizzaStatus>>`, where `PizzaStatus` is an enum type defined within the test class scope. Implement a setup method annotated with `@BeforeEach` that instantiates `converter` by creating a new `EnumConverter<>()` using the no-argument constructor. Write a test method annotated with `@Test` that verifies exception handling for mismatched enum types by invoking `assertThrows` with `ConversionException.class` as the first argument and a lambda expression as the second argument, where the lambda calls `converter.convert(TimeUnit.class, \"java.time.DayOfWeek#MONDAY\")` passing `TimeUnit.class` as the target type and the String literal `\"java.time.DayOfWeek#MONDAY\"` as the value to convert. Implement a teardown method annotated with `@AfterEach` that assigns `null` to the `converter` field. The test uses JUnit 5 Assertions with method-level annotation `@Test` and setup/teardown annotations `@BeforeEach` and `@AfterEach`.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testConvertMismatchingEnumType()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.EnumConverterErrorHandlingTest",
      "code": "package org.apache.commons.beanutils2;\n\nimport org.apache.commons.beanutils2.ConversionException;\nimport org.apache.commons.beanutils2.Converter;\nimport org.apache.commons.beanutils2.converters.EnumConverter;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class EnumConverterErrorHandlingTest {\n\n    private enum PizzaStatus {\n        ORDERED,\n        BAKED,\n        DELIVERED\n    }\n\n    private Converter<Enum<PizzaStatus>> converter;\n\n    @BeforeEach\n    void setUp() {\n        converter = new EnumConverter<>(PizzaStatus.class);\n    }\n\n    @Test\n    void testMismatchedEnumTypeConversionThrowsException() {\n        assertThrows(ConversionException.class, () ->\n            converter.convert(TimeUnit.class, \"java.time.DayOfWeek#MONDAY\")\n        );\n    }\n\n    @AfterEach\n    void tearDown() {\n        converter = null;\n    }\n}",
      "method_signature": "testConvertMismatchingEnumType()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6624,
    "output_tokens": 1089,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 212,
      "description": "Create a test case to validate that the system's property inspection utility can be configured to allow access to metadata about enumeration types that would otherwise be restricted for security reasons. Begin by configuring the property inspection system to explicitly remove the security restriction that normally prevents access to enumeration class information, then prepare a test record containing an enumeration value. With the restriction lifted, attempt to retrieve the class information from the enumeration property through the inspection system and verify that the system successfully returns the class metadata rather than blocking access. Once confirmed that the class information is accessible, extract the runtime environment loader associated with this class and ensure it is present and valid. Finally, perform an end-to-end verification by directly retrieving the loader information through a nested property path to confirm the inspection system can traverse from the enumeration value through its class metadata to the loader without encountering security blocks. Use JUnit 5 as the testing framework and verify outcomes using standard equality and type assertions.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.bugs.EnumDeclaringClassTest",
      "method_signature": "testAllowAccessToClassPropertyFromPropertyUtilsBean()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.PropertyUtilsEnumAccessTest",
      "code": "package org.apache.commons.beanutils2;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for validating that the system's property inspection utility can be configured\n * to allow access to metadata about enumeration types that would otherwise be restricted\n * for security reasons.\n */\npublic class PropertyUtilsEnumAccessTest {\n\n    /**\n     * A simple JavaBean to hold an instance of {@link TestEnum} for testing property access.\n     */\n    static class EnumContainer {\n        private TestEnum myEnum;\n\n        public TestEnum getMyEnum() {\n            return myEnum;\n        }\n\n        public void setMyEnum(TestEnum myEnum) {\n            this.myEnum = myEnum;\n        }\n    }\n\n    @Test\n    void testEnumClassAndClassLoaderAccessWhenSecurityRestrictionRemoved() throws Exception {\n        // Begin by configuring the property inspection system to explicitly remove the security restriction\n        // that normally prevents access to enumeration class information.\n        // The default PropertyUtilsBean constructor adds SuppressPropertiesBeanIntrospector.SUPPRESS_CLASS\n        // which prevents access to the 'class' property for security reasons.\n        // To remove this restriction, we instantiate a new PropertyUtilsBean and remove the suppressor.\n        PropertyUtilsBean propertyUtilsBean = new PropertyUtilsBean();\n        propertyUtilsBean.removeBeanIntrospector(SuppressPropertiesBeanIntrospector.SUPPRESS_CLASS);\n\n        // Prepare a test record containing an enumeration value.\n        EnumContainer container = new EnumContainer();\n        container.setMyEnum(TestEnum.A);\n\n        // With the restriction lifted, attempt to retrieve the class information from the enumeration property\n        // through the inspection system and verify that the system successfully returns the class metadata.\n        Object enumClass = propertyUtilsBean.getProperty(container, \"myEnum.class\");\n        Assertions.assertNotNull(enumClass, \"The 'class' property of the enum should be accessible after removing the restriction.\");\n        Assertions.assertInstanceOf(Class.class, enumClass, \"The retrieved property for 'myEnum.class' should be a Class object.\");\n        Assertions.assertEquals(TestEnum.class, enumClass, \"The retrieved Class object should be TestEnum.class.\");\n\n        // Once confirmed that the class information is accessible, extract the runtime environment loader\n        // associated with this class and ensure it is present and valid.\n        ClassLoader classLoader = ((Class<?>) enumClass).getClassLoader();\n        Assertions.assertNotNull(classLoader, \"The ClassLoader for TestEnum.class should not be null.\");\n        Assertions.assertInstanceOf(ClassLoader.class, classLoader, \"The retrieved ClassLoader should be an instance of ClassLoader.\");\n\n        // Finally, perform an end-to-end verification by directly retrieving the loader information\n        // through a nested property path to confirm the inspection system can traverse\n        // from the enumeration value through its class metadata to the loader\n        // without encountering security blocks.\n        Object retrievedClassLoader = propertyUtilsBean.getProperty(container, \"myEnum.class.classLoader\");\n        Assertions.assertNotNull(retrievedClassLoader, \"Direct access to 'myEnum.class.classLoader' through a nested path should be possible.\");\n        Assertions.assertInstanceOf(ClassLoader.class, retrievedClassLoader, \"The directly retrieved property for 'myEnum.class.classLoader' should be a ClassLoader object.\");\n        Assertions.assertEquals(classLoader, retrievedClassLoader, \"The directly retrieved ClassLoader should match the one obtained from the Class object.\");\n    }\n}",
      "method_signature": "testAllowAccessToClassPropertyFromPropertyUtilsBean()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.5,
      "obj_creation_precision": 0.5,
      "assertion_recall": 1.0,
      "assertion_precision": 0.375,
      "callable_recall": 0.6667,
      "callable_precision": 0.4,
      "focal_recall": 0.5,
      "focal_precision": 0.5
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.9756,
      "line_coverage": 0.8947,
      "branch_coverage": 0.8542
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "search_file_content": 1,
          "read_file": 2
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 34895,
    "output_tokens": 6345,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 216,
      "description": "Define a test method that validates access to class-level metadata properties through the Property Utils Bean after removing security restrictions on introspection. Instantiate a Property Utils Bean and invoke its method to remove the bean introspector that suppresses access to the declaring class property, thereby allowing retrieval of metadata that would otherwise be blocked for security reasons. Create a fixture object that contains an enum property, then use the Property Utils Bean to retrieve a nested property by navigating through the enum's declaring class using a property path expression. Upon retrieval, assert that the returned object is an instance of Class, capturing the typed reference for further validation. Extract the class loader from this Class instance and verify it is not null, confirming that the class metadata is accessible. Finally, retrieve a deeper nested property by extending the property path to include the class loader itself, and assert that the returned object is an instance of ClassLoader, demonstrating that the removal of the introspection suppressor enables full traversal of class metadata properties that expose internal Java runtime structures. This test uses JUnit 5 for the testing framework.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.bugs.EnumDeclaringClassTest",
      "method_signature": "testAllowAccessToClassPropertyFromPropertyUtilsBean()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.PropertyUtilsBeanIntrospectionTest",
      "code": "package org.apache.commons.beanutils2;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.apache.commons.beanutils2.PropertyUtilsBean;\nimport org.apache.commons.beanutils2.SuppressPropertiesBeanIntrospector;\nimport org.apache.commons.beanutils2.TestEnum;\n\npublic class PropertyUtilsBeanIntrospectionTest {\n\n    /**\n     * A simple fixture object containing an enum property for testing introspection.\n     */\n    static class TestBean {\n        private TestEnum myEnum = TestEnum.A;\n\n        public TestEnum getMyEnum() {\n            return myEnum;\n        }\n    }\n\n    @Test\n    void testClassLevelMetadataAccessAfterRemovingSecurityRestrictions() throws Exception {\n        // Instantiate PropertyUtilsBean\n        PropertyUtilsBean propertyUtils = new PropertyUtilsBean();\n\n        // Remove the SuppressPropertiesBeanIntrospector to allow access to suppressed properties\n        // like \"class\" and \"classLoader\". By default, PropertyUtilsBean includes this introspector.\n        propertyUtils.removeBeanIntrospector(SuppressPropertiesBeanIntrospector.SUPPRESS_ALL);\n\n        // Create the fixture object\n        TestBean fixture = new TestBean();\n\n        // Retrieve the declaring class of the enum using a property path expression\n        Object declaringClassObj = propertyUtils.getProperty(fixture, \"myEnum.declaringClass\");\n\n        // Assert that the returned object is not null and is an instance of Class\n        assertNotNull(declaringClassObj, \"The 'declaringClass' property should not be null.\");\n        assertTrue(declaringClassObj instanceof Class, \"The 'declaringClass' property should be an instance of Class.\");\n\n        // Capture the typed reference for further validation\n        Class<?> declaringClass = (Class<?>) declaringClassObj;\n\n        // Extract the class loader from this Class instance\n        ClassLoader classLoader = declaringClass.getClassLoader();\n\n        // Verify it is not null, confirming that the class metadata is accessible\n        assertNotNull(classLoader, \"The ClassLoader should not be null after introspection.\");\n\n        // Retrieve a deeper nested property by extending the property path to include the class loader\n        Object classLoaderObj = propertyUtils.getProperty(fixture, \"myEnum.declaringClass.classLoader\");\n\n        // Assert that the returned object is not null and is an instance of ClassLoader\n        assertNotNull(classLoaderObj, \"The 'classLoader' property should not be null.\");\n        assertTrue(classLoaderObj instanceof ClassLoader, \"The 'classLoader' property should be an instance of ClassLoader.\");\n    }\n}",
      "method_signature": "testAllowAccessToClassPropertyFromPropertyUtilsBean()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6603,
    "output_tokens": 3070,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 22,
      "description": "Define a test class that validates enum conversion error handling by first establishing a converter instance through a helper method that constructs an Enum Converter configured to throw exceptions on conversion failures, then within the test method invoke the converter's convert method with a mismatched enum type where the target type parameter is a time unit class and the input string specifies a fully qualified enum constant from a different enum family, and upon invocation validate that a conversion exception is thrown to confirm the converter properly rejects type mismatches between the requested target enum and the provided enum constant string, finally in teardown nullify the converter instance to release the resource, using JUnit 5 for test execution and assertions.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testConvertMismatchingEnumType()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.for",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.apache.commons.beanutils2.ConversionException;\nimport org.apache.commons.beanutils2.TestEnum;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Test class for validating enum conversion error handling within {@link EnumConverter}.\n */\npublic class for {\n\n    private EnumConverter converter;\n\n    /**\n     * Helper method to construct an {@link EnumConverter} instance.\n     * This converter is configured to throw exceptions on conversion failures\n     * by providing {@code null} as the default value, which is the expected\n     * behavior for throwing {@link ConversionException} on unconvertible values.\n     *\n     * @param enumClass The target enum class for which the converter is primarily configured.\n     * @return A configured {@link EnumConverter} instance.\n     */\n    private EnumConverter createExceptionThrowingEnumConverter(final Class<?> enumClass) {\n        // By setting the default value to null, the converter is configured to throw\n        // a ConversionException if a conversion error occurs and the value cannot be converted.\n        return new EnumConverter(enumClass, null);\n    }\n\n    /**\n     * Validates that {@link EnumConverter} throws a {@link ConversionException}\n     * when attempting to convert a fully qualified enum constant string from one\n     * enum type to a different, incompatible target enum type.\n     */\n    @Test\n    void testMismatchedEnumConversionThrowsException() {\n        // Establish a converter instance configured to throw exceptions on conversion failures.\n        // The converter is initialized for TestEnum, but the conversion call will target TimeUnit.\n        converter = createExceptionThrowingEnumConverter(TestEnum.class);\n\n        // Define the target type parameter for the convert method as a time unit class.\n        final Class<TimeUnit> targetTimeUnitClass = TimeUnit.class;\n\n        // The input string specifies a fully qualified enum constant from a different enum family (TestEnum).\n        final String fullyQualifiedMismatchedEnumValue = TestEnum.class.getName() + \".\" + TestEnum.A.name();\n\n        // Invoke the converter's convert method and validate that a ConversionException is thrown.\n        // This confirms the converter properly rejects type mismatches between the requested\n        // target enum (TimeUnit) and the provided enum constant string (from TestEnum).\n        Assertions.assertThrows(ConversionException.class, () ->\n            converter.convert(targetTimeUnitClass, fullyQualifiedMismatchedEnumValue),\n            \"A ConversionException should be thrown when attempting to convert a \" +\n            \"fully qualified enum constant from one type to a different target enum type.\");\n    }\n\n    /**\n     * Nullifies the converter instance after each test to release resources.\n     */\n    @AfterEach\n    void tearDown() {\n        converter = null;\n    }\n}",
      "method_signature": "testConvertMismatchingEnumType()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 13048,
    "output_tokens": 8042,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 227,
      "description": "Define a test method annotated with `@Test` that declares it throws `ReflectiveOperationException`, then instantiate a `PropertyUtilsBean` by invoking its no-argument constructor and assign the result to variable `propertyUtilsBean`, immediately invoke `removeBeanIntrospector` on `propertyUtilsBean` passing the static field `SuppressPropertiesBeanIntrospector.SUPPRESS_DECLARING_CLASS` as the argument to remove this specific bean introspector from the instance, next instantiate a `Fixture` object using its no-argument constructor and assign it to variable `fixture`, then invoke `getNestedProperty` on `propertyUtilsBean` with arguments `fixture` and the String literal `\"testEnum.declaringClass\"` and assign the returned `Object` to variable `cls`, immediately assert that `cls` is an instance of `Class.class` by invoking `assertInstanceOf(Class.class, cls)` and assign the returned value (which is the cast result) to variable `teClass` of type `Class<TestEnum>`, then invoke `getClassLoader()` on `teClass` and assign the returned `ClassLoader` to variable `classLoader`, assert that `classLoader` is not null by invoking `assertNotNull(classLoader)`, and finally assert that the result of invoking `getNestedProperty` on `propertyUtilsBean` with arguments `fixture` and the String literal `\"testEnum.declaringClass.classLoader\"` is an instance of `ClassLoader.class` by invoking `assertInstanceOf(ClassLoader.class, propertyUtilsBean.getNestedProperty(fixture, \"testEnum.declaringClass.classLoader\"))`. The test uses JUnit 5 Assertions with method-level annotation `@Test` and no class-level annotations.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.bugs.EnumDeclaringClassTest",
      "method_signature": "testAllowAccessToClassPropertyFromPropertyUtilsBean()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.PropertyUtilsBeanRemoveBeanIntrospectorTest",
      "code": "package org.apache.commons.beanutils2;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertInstanceOf;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\npublic class PropertyUtilsBeanRemoveBeanIntrospectorTest {\n\n    // Simple fixture class for the test\n    public static class Fixture {\n        private TestEnum testEnum = TestEnum.A;\n\n        public TestEnum getTestEnum() {\n            return testEnum;\n        }\n\n        public void setTestEnum(TestEnum testEnum) {\n            this.testEnum = testEnum;\n        }\n    }\n\n    @Test\n    void testRemoveSuppressPropertiesBeanIntrospector() throws ReflectiveOperationException {\n        // Instantiate PropertyUtilsBean by invoking its no-argument constructor\n        PropertyUtilsBean propertyUtilsBean = new PropertyUtilsBean();\n\n        // Immediately invoke removeBeanIntrospector on propertyUtilsBean passing the static field\n        // SuppressPropertiesBeanIntrospector.SUPPRESS_DECLARING_CLASS as the argument\n        propertyUtilsBean.removeBeanIntrospector(SuppressPropertiesBeanIntrospector.SUPPRESS_DECLARING_CLASS);\n\n        // Instantiate a Fixture object using its no-argument constructor\n        Fixture fixture = new Fixture();\n\n        // Invoke getNestedProperty on propertyUtilsBean with arguments fixture and the String literal\n        // \"testEnum.declaringClass\" and assign the returned Object to variable cls\n        Object cls = propertyUtilsBean.getNestedProperty(fixture, \"testEnum.declaringClass\");\n\n        // Immediately assert that cls is an instance of Class.class by invoking assertInstanceOf(Class.class, cls)\n        // and assign the returned value (which is the cast result) to variable teClass of type Class<TestEnum>\n        Class<TestEnum> teClass = assertInstanceOf(Class.class, cls);\n\n        // Invoke getClassLoader() on teClass and assign the returned ClassLoader to variable classLoader\n        ClassLoader classLoader = teClass.getClassLoader();\n\n        // Assert that classLoader is not null by invoking assertNotNull(classLoader)\n        assertNotNull(classLoader);\n\n        // Finally assert that the result of invoking getNestedProperty on propertyUtilsBean with arguments\n        // fixture and the String literal \"testEnum.declaringClass.classLoader\" is an instance of ClassLoader.class\n        // by invoking assertInstanceOf(ClassLoader.class, propertyUtilsBean.getNestedProperty(fixture, \"testEnum.declaringClass.classLoader\"))\n        assertInstanceOf(ClassLoader.class, propertyUtilsBean.getNestedProperty(fixture, \"testEnum.declaringClass.classLoader\"));\n    }\n}",
      "method_signature": "testAllowAccessToClassPropertyFromPropertyUtilsBean()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.5,
      "obj_creation_precision": 0.5,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6752,
    "output_tokens": 2042,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 24,
      "description": "Define a test class containing a private field `converter` of type `Converter<Enum<PizzaStatus>>` where `PizzaStatus` is an enum type defined within the test class scope. In a setup method annotated with `@BeforeEach`, instantiate a new `EnumConverter` using its no-argument constructor and assign it to the `converter` field. Within the test method annotated with `@Test`, invoke the `convert` method on `converter` passing two arguments: the class literal `DayOfWeek.class` as the first argument and the string literal `\"java.time.DayOfWeek#MONDAY\"` as the second argument, then immediately assert using `assertEquals` that the returned value equals the enum constant `DayOfWeek.MONDAY` from the `java.time.DayOfWeek` enum. In a teardown method annotated with `@AfterEach`, assign `null` to the `converter` field to release the reference. The test method uses `@Test` annotation, the setup method throws `Exception`, the teardown method is declared public and throws `Exception`, and assertions are performed using JUnit 5 Assertions.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testConvertDayOfWeek()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest1",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.apache.commons.beanutils2.Converter;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.time.DayOfWeek;\n\npublic class EnumConverterTest1 {\n\n    private Converter<Enum<PizzaStatus>> converter;\n\n    // Define PizzaStatus enum within the test class scope as requested\n    private enum PizzaStatus {\n        ORDERED,\n        READY,\n        DELIVERED\n    }\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        converter = new EnumConverter<>();\n    }\n\n    @Test\n    public void testConvertDayOfWeekEnum() {\n        assertEquals(DayOfWeek.MONDAY, converter.convert(DayOfWeek.class, \"java.time.DayOfWeek#MONDAY\"));\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception {\n        converter = null;\n    }\n}",
      "method_signature": "testConvertDayOfWeek()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 3,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 46837,
    "output_tokens": 2153,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 249,
      "description": "Define a test method that validates the default security behavior of BeanUtilsBean when attempting to access nested class metadata properties through property path expressions. Instantiate a test fixture object that contains an enum property, then create a new BeanUtilsBean instance using its default constructor. Invoke the getProperty method on the BeanUtilsBean instance with the fixture object and a nested property path expression that traverses from the enum property through its declaring class to the class loader, and verify that this operation throws a NoSuchMethodException indicating the property path is blocked. Next, retrieve the PropertyUtilsBean from the BeanUtilsBean instance and invoke its getNestedProperty method with the same fixture object and identical nested property path expression, then verify that this invocation also throws a NoSuchMethodException, confirming that both the high-level and low-level property access mechanisms consistently suppress access to the declaring class metadata. This test validates that the framework prevents potentially unsafe reflective access to class loader information through property expressions by default, ensuring that property traversal operations cannot reach sensitive class metadata even when valid JavaBeans property paths would technically allow such navigation. The test uses JUnit 5 for test execution and assertions.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.bugs.EnumDeclaringClassTest",
      "method_signature": "testSuppressClassPropertyByDefaultFromBeanUtilsBean()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.for",
      "code": "package org.apache.commons.beanutils2;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for validating the security behavior of BeanUtilsBean\n * regarding access to nested class metadata properties.\n */\npublic class for {\n\n    /**\n     * A simple test fixture class holding an enum property.\n     */\n    public static class EnumHolder {\n        private TestEnum enumProperty = TestEnum.A;\n\n        public TestEnum getEnumProperty() {\n            return enumProperty;\n        }\n\n        public void setEnumProperty(final TestEnum enumProperty) {\n            this.enumProperty = enumProperty;\n        }\n    }\n\n    @Test\n    void testClassMetadataBlocked() {\n        final EnumHolder fixture = new EnumHolder();\n        final BeanUtilsBean beanUtils = new BeanUtilsBean();\n        final PropertyUtilsBean propertyUtils = beanUtils.getPropertyUtils();\n\n        final String sensitivePropertyPath = \"enumProperty.declaringClass.classLoader\";\n\n        // Verify that BeanUtilsBean.getProperty blocks access\n        assertThrows(NoSuchMethodException.class, () -> {\n            beanUtils.getProperty(fixture, sensitivePropertyPath);\n        }, \"BeanUtilsBean.getProperty should block access to classLoader through declaringClass.\");\n\n        // Verify that PropertyUtilsBean.getNestedProperty also blocks access\n        assertThrows(NoSuchMethodException.class, () -> {\n            propertyUtils.getNestedProperty(fixture, sensitivePropertyPath);\n        }, \"PropertyUtilsBean.getNestedProperty should block access to classLoader through declaringClass.\");\n    }\n}",
      "method_signature": "testSuppressClassPropertyByDefaultFromBeanUtilsBean()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6622,
    "output_tokens": 1348,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 251,
      "description": "Create a test case to validate that the system can be configured to permit access to metadata about enumeration types that would normally be restricted for security purposes, specifically allowing retrieval of type information and runtime environment details from enumerated values. Begin by establishing a property access system and explicitly removing the security restriction that normally prevents access to enumeration type declarations. Prepare a business object containing an enumerated value, then retrieve the fully qualified name of the enumeration type through the property access system and confirm it matches the expected type designation. Next, access the type declaration itself through nested property navigation and verify it returns the correct enumeration type, then obtain the runtime environment loader associated with this type and confirm it exists. Finally, retrieve the runtime environment loader information through the property access system as a text representation, verify it is present, and confirm through nested property navigation that the loader can be accessed as its proper type. Use JUnit 5 for test execution and AssertJ-style assertions for validation, verifying outcomes through standard equality checks and type confirmations.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.bugs.EnumDeclaringClassTest",
      "method_signature": "testAllowAccessToClassPropertyFromBeanUtilsBean()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.for",
      "code": "package org.apache.commons.beanutils2;\n\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n// Helper class for the test to hold an enumerated value\nclass for {\n    private TestEnum myEnumField = TestEnum.A;\n\n    public TestEnum getMyEnumField() {\n        return myEnumField;\n    }\n\n    public void setMyEnumField(TestEnum myEnumField) {\n        this.myEnumField = myEnumField;\n    }\n}\n\n/**\n * Test case to validate that the system can be configured to permit access to\n * metadata about enumeration types that would normally be restricted for security purposes.\n * This includes allowing retrieval of type information and runtime environment details\n * from enumerated values through PropertyUtilsBean.\n */\npublic class PropertyUtilsBeanEnumMetadataAccessTest {\n\n    @Test\n    void testEnumMetadataAccessAfterRemovingSecurityRestriction() throws Exception {\n        // 1. Establish a property access system and explicitly remove the security restriction\n        // We create a new PropertyUtilsBean instance and configure its BeanIntrospectors\n        // to only include the DefaultBeanIntrospector. This implicitly removes any\n        // other introspectors (e.g., SuppressPropertiesBeanIntrospector) that might\n        // be restricting access to Class and ClassLoader properties by default.\n        PropertyUtilsBean propertyUtilsBean = new PropertyUtilsBean();\n        List<BeanIntrospector> introspectors = Arrays.asList(new DefaultBeanIntrospector());\n        propertyUtilsBean.setBeanIntrospectors(introspectors);\n\n        // 2. Prepare a business object containing an enumerated value\n        MyBusinessObject businessObject = new MyBusinessObject();\n        businessObject.setMyEnumField(TestEnum.B);\n\n        // 3. Retrieve the fully qualified name of the enumeration type through the property access system\n        // and confirm it matches the expected type designation.\n        String enumTypeName = (String) propertyUtilsBean.getProperty(businessObject, \"myEnumField.class.name\");\n        assertThat(enumTypeName).isEqualTo(TestEnum.class.getName());\n\n        // 4. Access the type declaration itself through nested property navigation\n        // and verify it returns the correct enumeration type.\n        Class<?> enumType = (Class<?>) propertyUtilsBean.getProperty(businessObject, \"myEnumField.class\");\n        assertThat(enumType).isNotNull();\n        assertThat(enumType).isEqualTo(TestEnum.class);\n\n        // 5. Obtain the runtime environment loader associated with this type and confirm it exists.\n        ClassLoader classLoader = (ClassLoader) propertyUtilsBean.getProperty(businessObject, \"myEnumField.class.classLoader\");\n        assertThat(classLoader).isNotNull();\n\n        // 6. Retrieve the runtime environment loader information through the property access system\n        // as a text representation, verify it is present.\n        String classLoaderText = (String) propertyUtilsBean.getProperty(businessObject, \"myEnumField.class.classLoader.toString\");\n        assertThat(classLoaderText).isNotNull();\n        assertThat(classLoaderText).isNotEmpty();\n\n        // 7. Confirm through nested property navigation that the loader can be accessed as its proper type.\n        // We access the 'parent' property of the ClassLoader to demonstrate further nested navigation.\n        Object parentClassLoader = propertyUtilsBean.getProperty(businessObject, \"myEnumField.class.classLoader.parent\");\n        // The parent ClassLoader might be null for the bootstrap class loader, so we assert it's either a ClassLoader or null.\n        assertThat(parentClassLoader).isInstanceOfAny(ClassLoader.class, null);\n    }\n}",
      "method_signature": "testAllowAccessToClassPropertyFromBeanUtilsBean()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6601,
    "output_tokens": 6969,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 252,
      "description": "Define a test method annotated with `@Test` that declares it throws `ReflectiveOperationException`, then instantiate a new `Fixture` object using its no-argument constructor and assign it to a variable named `fixture`, followed by instantiating a new `BeanUtilsBean` object using its no-argument constructor and assigning it to a variable named `bub`. Immediately invoke `assertThrows` with `NoSuchMethodException.class` as the first argument and a lambda expression as the second argument that calls `getProperty` on `bub` with arguments `fixture` and the String literal `\"testEnum.declaringClass.classLoader\"`, verifying that this invocation throws the expected exception. Next, invoke `assertThrows` again with `NoSuchMethodException.class` as the first argument and a lambda expression as the second argument that chains method calls by first invoking `getPropertyUtils()` on `bub` to obtain a `PropertyUtilsBean` instance, then immediately calling `getNestedProperty` on that returned instance with arguments `fixture` and the String literal `\"testEnum.declaringClass.classLoader\"`, verifying that this chained invocation also throws the expected exception. The test uses JUnit 5 Assertions via `assertThrows` and validates that both direct property access through `BeanUtilsBean.getProperty` and nested property access through `PropertyUtilsBean.getNestedProperty` correctly suppress access to the class property path by throwing `NoSuchMethodException` when attempting to traverse the property expression `\"testEnum.declaringClass.classLoader\"` on the fixture object.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.bugs.EnumDeclaringClassTest",
      "method_signature": "testSuppressClassPropertyByDefaultFromBeanUtilsBean()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.BeanUtilsBeanClassPropertyAccessTest",
      "code": "package org.apache.commons.beanutils2;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.lang.NoSuchMethodException;\nimport java.lang.reflect.ReflectiveOperationException;\n\npublic class BeanUtilsBeanClassPropertyAccessTest {\n\n    /**\n     * A test fixture class used to hold an instance of TestEnum.\n     * This class provides a no-argument constructor and a getter for 'testEnum'.\n     */\n    static class Fixture {\n        private final TestEnum testEnum;\n\n        public Fixture() {\n            this.testEnum = TestEnum.A; // Initialize with a concrete enum value\n        }\n\n        public TestEnum getTestEnum() {\n            return testEnum;\n        }\n    }\n\n    @Test\n    void testClassPropertyAccessSuppression() throws ReflectiveOperationException {\n        Fixture fixture = new Fixture();\n        BeanUtilsBean bub = new BeanUtilsBean();\n\n        // Verify that BeanUtilsBean.getProperty throws NoSuchMethodException when\n        // attempting to access the 'classLoader' property through 'declaringClass' on an enum.\n        assertThrows(NoSuchMethodException.class, () ->\n            bub.getProperty(fixture, \"testEnum.declaringClass.classLoader\")\n        );\n\n        // Verify that PropertyUtilsBean.getNestedProperty also throws NoSuchMethodException\n        // for the same class property path.\n        assertThrows(NoSuchMethodException.class, () ->\n            bub.getPropertyUtils().getNestedProperty(fixture, \"testEnum.declaringClass.classLoader\")\n        );\n    }\n}",
      "method_signature": "testSuppressClassPropertyByDefaultFromBeanUtilsBean()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6712,
    "output_tokens": 2592,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 254,
      "description": "Create a test case to validate that the system's property access mechanism enforces security restrictions by default, specifically preventing access to internal class metadata through nested property paths. Begin by establishing a test scenario with a business object that contains enumerated type information, then configure the system's property utility to operate under its default security settings. Verify that when attempting to retrieve deeply nested class loader information through the property path traversing from an enumeration value to its declaring class and then to the class loader, the system correctly rejects this access attempt by signaling that no such property retrieval method exists. Confirm this security behavior through two separate validation approaches: first by attempting direct property retrieval through the main utility interface, and second by attempting the same operation through the underlying property access mechanism. Both attempts must demonstrate that the system properly blocks access to sensitive internal class structures, ensuring that business applications cannot inadvertently expose or manipulate underlying framework internals through property navigation. This test employs JUnit 5 as the testing framework and uses standard assertion capabilities to verify that the expected security exceptions occur when attempting unauthorized property access.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.bugs.EnumDeclaringClassTest",
      "method_signature": "testSuppressClassPropertyByDefaultFromBeanUtilsBean()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.PropertyAccessSecurityTest",
      "code": "package org.apache.commons.beanutils2;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.apache.commons.beanutils2.PropertyUtils;\nimport org.apache.commons.beanutils2.PropertyUtilsBean;\nimport org.junit.jupiter.api.Test;\n\npublic class PropertyAccessSecurityTest {\n\n    /**\n     * A simple business object containing an enumerated type for testing property access.\n     */\n    public static class MyBusinessObject {\n        private TestEnum myEnum;\n\n        public MyBusinessObject(final TestEnum myEnum) {\n            this.myEnum = myEnum;\n        }\n\n        public TestEnum getMyEnum() {\n            return myEnum;\n        }\n\n        public void setMyEnum(final TestEnum myEnum) {\n            this.myEnum = myEnum;\n        }\n    }\n\n    @Test\n    void testClassLoaderAccessIsPrevented() {\n        final MyBusinessObject businessObject = new MyBusinessObject(TestEnum.A);\n        // This sensitive property path attempts to traverse from an enum instance to its class's ClassLoader.\n        // myEnum -> declaringClass (method does not exist on enum instance) -> classLoader (method exists on Class)\n        // The core security relies on 'declaringClass' not being directly accessible via a getter on the enum instance.\n        final String sensitivePropertyPath = \"myEnum.declaringClass.classLoader\";\n\n        // First validation approach: using the main static utility interface (PropertyUtils)\n        assertThrows(\n            NoSuchMethodException.class,\n            () -> PropertyUtils.getProperty(businessObject, sensitivePropertyPath),\n            \"Access to internal class metadata (classLoader) via PropertyUtils should be prevented by NoSuchMethodException for path: \" + sensitivePropertyPath\n        );\n\n        // Second validation approach: using the underlying property access mechanism (PropertyUtilsBean instance)\n        final PropertyUtilsBean propertyUtilsBean = PropertyUtilsBean.getInstance();\n        assertThrows(\n            NoSuchMethodException.class,\n            () -> propertyUtilsBean.getProperty(businessObject, sensitivePropertyPath),\n            \"Access to internal class metadata (classLoader) via PropertyUtilsBean should be prevented by NoSuchMethodException for path: \" + sensitivePropertyPath\n        );\n    }\n}",
      "method_signature": "testSuppressClassPropertyByDefaultFromBeanUtilsBean()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.4,
      "callable_precision": 0.5,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6602,
    "output_tokens": 3477,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 257,
      "description": "Define a test method that throws `ReflectiveOperationException` and begins by instantiating a `BeanUtilsBean` using the no-argument constructor, assigning the result to variable `bub`. Invoke `getPropertyUtils()` on `bub` and assign the returned `PropertyUtilsBean` to variable `propertyUtilsBean`. On `propertyUtilsBean`, invoke `removeBeanIntrospector` passing the static field `SuppressPropertiesBeanIntrospector.SUPPRESS_DECLARING_CLASS` as the argument. Create a new instance of the nested test class `Fixture` using its no-argument constructor and assign it to variable `fixture`. Invoke `getProperty` on `bub` with arguments `fixture` and the String literal `\"testEnum.declaringClass\"`, assigning the returned String to variable `string`. Assert equality between `string` and the result of invoking `TestEnum.class.getName()` using `assertEquals`. Invoke `getNestedProperty` on `propertyUtilsBean` with arguments `fixture` and String literal `\"testEnum.declaringClass\"`, wrap this invocation in `assertInstanceOf(Class.class, ...)` to verify the returned object is of type `Class`, and assign the result (cast to `Class<TestEnum>`) to variable `teClass`. Invoke `getClassLoader()` on `teClass` and assign the returned `ClassLoader` to variable `classLoader`. Assert that `classLoader` is not null using `assertNotNull(classLoader)`. Invoke `getProperty` on `bub` with arguments `fixture` and String literal `\"testEnum.declaringClass.classLoader\"`, and assert that the returned value is not null using `assertNotNull`. Finally, invoke `getNestedProperty` on `propertyUtilsBean` with arguments `fixture` and String literal `\"testEnum.declaringClass.classLoader\"`, and assert that the returned object is an instance of `ClassLoader` using `assertInstanceOf(ClassLoader.class, ...)`. The test uses JUnit 5 Assertions and is annotated with `@Test` at the method level.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.bugs.EnumDeclaringClassTest",
      "method_signature": "testAllowAccessToClassPropertyFromBeanUtilsBean()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.BeanUtilsBeanPropertyUtilsClassLoaderTest",
      "code": "package org.apache.commons.beanutils2;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertInstanceOf;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport org.apache.commons.beanutils2.BeanUtilsBean;\nimport org.apache.commons.beanutils2.PropertyUtilsBean;\nimport org.apache.commons.beanutils2.SuppressPropertiesBeanIntrospector;\nimport org.junit.jupiter.api.Test;\n\npublic class BeanUtilsBeanPropertyUtilsClassLoaderTest {\n\n    @Test\n    void testClassLoaderProperties() throws ReflectiveOperationException {\n        // Instantiate a BeanUtilsBean using the no-argument constructor\n        BeanUtilsBean bub = new BeanUtilsBean();\n\n        // Invoke getPropertyUtils() on bub and assign the returned PropertyUtilsBean to variable propertyUtilsBean\n        PropertyUtilsBean propertyUtilsBean = bub.getPropertyUtils();\n\n        // On propertyUtilsBean, invoke removeBeanIntrospector passing the static field\n        // SuppressPropertiesBeanIntrospector.SUPPRESS_DECLARING_CLASS as the argument\n        propertyUtilsBean.removeBeanIntrospector(SuppressPropertiesBeanIntrospector.SUPPRESS_DECLARING_CLASS);\n\n        // Create a new instance of the nested test class Fixture using its no-argument constructor and assign it to variable fixture\n        Fixture fixture = new Fixture();\n\n        // Invoke getProperty on bub with arguments fixture and the String literal \"testEnum.declaringClass\",\n        // assigning the returned String to variable string\n        String string = (String) bub.getProperty(fixture, \"testEnum.declaringClass\");\n\n        // Assert equality between string and the result of invoking TestEnum.class.getName() using assertEquals\n        assertEquals(TestEnum.class.getName(), string);\n\n        // Invoke getNestedProperty on propertyUtilsBean with arguments fixture and String literal \"testEnum.declaringClass\",\n        // wrap this invocation in assertInstanceOf(Class.class, ...) to verify the returned object is of type Class,\n        // and assign the result (cast to Class<TestEnum>) to variable teClass\n        @SuppressWarnings(\"unchecked\") // Cast is safe due to assertInstanceOf check\n        Class<TestEnum> teClass = (Class<TestEnum>) assertInstanceOf(Class.class, propertyUtilsBean.getNestedProperty(fixture, \"testEnum.declaringClass\"));\n\n        // Invoke getClassLoader() on teClass and assign the returned ClassLoader to variable classLoader\n        ClassLoader classLoader = teClass.getClassLoader();\n\n        // Assert that classLoader is not null using assertNotNull(classLoader)\n        assertNotNull(classLoader);\n\n        // Invoke getProperty on bub with arguments fixture and String literal \"testEnum.declaringClass.classLoader\",\n        // and assert that the returned value is not null using assertNotNull\n        assertNotNull(bub.getProperty(fixture, \"testEnum.declaringClass.classLoader\"));\n\n        // Finally, invoke getNestedProperty on propertyUtilsBean with arguments fixture and String literal\n        // \"testEnum.declaringClass.classLoader\", and assert that the returned object is an instance of\n        // ClassLoader using assertInstanceOf(ClassLoader.class, ...)\n        assertInstanceOf(ClassLoader.class, propertyUtilsBean.getNestedProperty(fixture, \"testEnum.declaringClass.classLoader\"));\n    }\n\n    // Nested test class Fixture as required by the test description\n    private static class Fixture {\n        private TestEnum testEnum = TestEnum.A; // Initialize with an enum value\n\n        public TestEnum getTestEnum() {\n            return testEnum;\n        }\n\n        public void setTestEnum(TestEnum testEnum) {\n            this.testEnum = testEnum;\n        }\n    }\n}",
      "method_signature": "testAllowAccessToClassPropertyFromBeanUtilsBean()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.5,
      "obj_creation_precision": 0.5,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.9359,
      "line_coverage": 0.9177,
      "branch_coverage": 0.8647
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6821,
    "output_tokens": 2898,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 261,
      "description": "Define a test method that validates property access to class-related metadata on enum types when the default introspection suppression is explicitly removed from the property utilities configuration. Instantiate a BeanUtilsBean to serve as the primary property access facade, then retrieve its PropertyUtilsBean component to configure introspection behavior. Remove the bean introspector that suppresses access to the declaring class property, allowing the test to access normally restricted class metadata. Create a test fixture object that holds an enum value, then invoke the property retrieval method on the BeanUtilsBean to access the nested property path targeting the enum's declaring class, obtaining this value as a string representation. Assert that the returned string matches the fully qualified name of the enum class. Next, invoke the nested property accessor on the PropertyUtilsBean to retrieve the same declaring class property, but this time as an object, and assert that the returned object is an instance of Class typed to the enum. Extract the class loader from the retrieved class object and validate that it is not null. Invoke the property retrieval method again on the BeanUtilsBean to access a deeper nested property path that traverses from the enum through its declaring class to the class loader, obtaining this as a string, and assert that the result is not null. Finally, invoke the nested property accessor on the PropertyUtilsBean to retrieve the same class loader property path as an object and assert that the returned object is an instance of ClassLoader, confirming that the removal of the introspection suppressor enables full traversal of class metadata properties that would otherwise be restricted for security reasons. This test uses JUnit 5 for test execution and assertions.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.bugs.EnumDeclaringClassTest",
      "method_signature": "testAllowAccessToClassPropertyFromBeanUtilsBean()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.PropertyUtilsBeanEnumClassMetadataTest",
      "code": "package org.apache.commons.beanutils2;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.apache.commons.beanutils2.BeanUtilsBean;\nimport org.apache.commons.beanutils2.PropertyUtilsBean;\nimport org.apache.commons.beanutils2.SuppressPropertiesBeanIntrospector;\nimport org.apache.commons.beanutils2.TestEnum;\n\npublic class PropertyUtilsBeanEnumClassMetadataTest {\n\n    /**\n     * A simple holder class to provide a property for the TestEnum.\n     */\n    public static class EnumHolder {\n        private TestEnum enumValue = TestEnum.A;\n\n        public TestEnum getEnumValue() {\n            return enumValue;\n        }\n\n        public void setEnumValue(TestEnum enumValue) {\n            this.enumValue = enumValue;\n        }\n    }\n\n    @Test\n    void testEnumClassMetadataAccessAfterRemovingSuppression() throws Exception {\n        // Instantiate a BeanUtilsBean to serve as the primary property access facade,\n        // then retrieve its PropertyUtilsBean component to configure introspection behavior.\n        BeanUtilsBean beanUtils = BeanUtilsBean.getInstance();\n        PropertyUtilsBean propertyUtils = beanUtils.getPropertyUtils();\n\n        // Remove the bean introspector that suppresses access to the declaring class property,\n        // allowing the test to access normally restricted class metadata.\n        propertyUtils.removeBeanIntrospector(SuppressPropertiesBeanIntrospector.class);\n\n        // Create a test fixture object that holds an enum value.\n        EnumHolder holder = new EnumHolder();\n\n        // Invoke the property retrieval method on the BeanUtilsBean to access the nested property path\n        // targeting the enum's declaring class, obtaining this value as a string representation.\n        String declaringClassName = (String) beanUtils.getProperty(holder, \"enumValue.declaringClass\");\n        assertNotNull(declaringClassName, \"Declaring class name should not be null.\");\n        assertEquals(TestEnum.class.getName(), declaringClassName,\n                     \"The retrieved string should match the fully qualified name of the enum class.\");\n\n        // Invoke the nested property accessor on the PropertyUtilsBean to retrieve the same declaring class\n        // property, but this time as an object.\n        Object declaringClassObject = propertyUtils.getNestedProperty(holder, \"enumValue.declaringClass\");\n        assertNotNull(declaringClassObject, \"Declaring class object should not be null.\");\n        assertTrue(declaringClassObject instanceof Class, \"The retrieved object should be an instance of Class.\");\n        assertEquals(TestEnum.class, declaringClassObject,\n                     \"The retrieved object should be the Class instance of TestEnum.\");\n\n        // Extract the class loader from the retrieved class object and validate that it is not null.\n        Class<?> enumClass = (Class<?>) declaringClassObject;\n        ClassLoader classLoader = enumClass.getClassLoader();\n        assertNotNull(classLoader, \"Class loader should not be null.\");\n\n        // Invoke the property retrieval method again on the BeanUtilsBean to access a deeper nested property path\n        // that traverses from the enum through its declaring class to the class loader,\n        // obtaining this as a string, and assert that the result is not null.\n        String classLoaderString = (String) beanUtils.getProperty(holder, \"enumValue.declaringClass.classLoader\");\n        assertNotNull(classLoaderString,\n                      \"The string representation of the class loader should not be null.\");\n\n        // Finally, invoke the nested property accessor on the PropertyUtilsBean to retrieve the same class loader\n        // property path as an object and assert that the returned object is an instance of ClassLoader,\n        // confirming that the removal of the introspection suppressor enables full traversal of class metadata\n        // properties that would otherwise be restricted for security reasons.\n        Object classLoaderObject = propertyUtils.getNestedProperty(holder, \"enumValue.declaringClass.classLoader\");\n        assertNotNull(classLoaderObject, \"Class loader object should not be null.\");\n        assertTrue(classLoaderObject instanceof ClassLoader,\n                   \"The retrieved object should be an instance of ClassLoader.\");\n    }\n}",
      "method_signature": "testAllowAccessToClassPropertyFromBeanUtilsBean()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6715,
    "output_tokens": 5087,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 28,
      "description": "Create a test case to validate that the conversion system properly rejects attempts to transform text references into enumerated values when the referenced business category does not exist in the system. Begin by establishing a conversion capability configured to handle enumerated business status values. Once the conversion mechanism is in place, attempt to convert a text reference that specifies a non-existent business category path, simulating a scenario where a user or external system provides an invalid category identifier. Ensure the system responds by rejecting this invalid conversion request with a clear failure indication, confirming that the conversion logic validates the existence of referenced categories before attempting transformation. After verifying the system's protective behavior against invalid category references, release the conversion resources to maintain a clean testing environment. Use JUnit 5 for the testing framework and standard assertion capabilities to verify that the system properly signals conversion failures when encountering references to non-existent business categories.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testNonExistingClasses()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.EnumConversionInvalidCategoryTest",
      "code": "package org.apache.commons.beanutils2;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.apache.commons.beanutils2.converters.EnumConverter;\n\npublic class EnumConversionInvalidCategoryTest {\n\n    @Test\n    void testInvalidEnumConversionRejectsNonExistentCategory() {\n        // Establish a conversion capability configured to handle enumerated business status values.\n        // Using a local instance of ConvertUtilsBean to isolate the test from global state.\n        ConvertUtilsBean convertUtilsBean = new ConvertUtilsBean();\n        EnumConverter<TestEnum> enumConverter = new EnumConverter<>(TestEnum.class);\n        convertUtilsBean.register(enumConverter, TestEnum.class);\n\n        // Attempt to convert a text reference that specifies a non-existent business category path.\n        String nonExistentCategory = \"NON_EXISTENT_CATEGORY\";\n\n        // Ensure the system responds by rejecting this invalid conversion request with a clear failure indication,\n        // confirming that the conversion logic validates the existence of referenced categories.\n        assertThrows(ConversionException.class, () -> {\n            convertUtilsBean.convert(nonExistentCategory, TestEnum.class);\n        }, \"Expected ConversionException when converting a non-existent enum value to TestEnum.\");\n\n        // Release the conversion resources to maintain a clean testing environment.\n        // No explicit cleanup is required for convertUtilsBean as it is a local instance\n        // within this test method and will be garbage collected after the test completes.\n    }\n}",
      "method_signature": "testNonExistingClasses()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6570,
    "output_tokens": 2609,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 29,
      "description": "Define a test class containing a private field `converter` of type `Converter<Enum<PizzaStatus>>` where `PizzaStatus` is an enum type defined within the test class scope. Implement a setup method annotated with `@BeforeEach` that instantiates `converter` by creating a new `EnumConverter<>()` using the no-argument constructor and assigns it to the field. Write a test method annotated with `@Test` that verifies exception handling by invoking `assertThrows` with `ConversionException.class` as the first argument and a lambda expression as the second argument, where the lambda calls `converter.convert(Enum.class, \"java.lang.String#MONDAY\")` passing the raw `Enum.class` type as the first parameter and the String literal `\"java.lang.String#MONDAY\"` as the second parameter, expecting the conversion to throw a `ConversionException` due to the non-enum class reference. Implement a teardown method annotated with `@AfterEach` that assigns `null` to the `converter` field to release the resource. The test uses JUnit 5 Assertions with method-level annotation `@Test`, and the setup/teardown methods throw `Exception` in their signatures.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testNonEnumClasses()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.EnumConverterExceptionTest",
      "code": "package org.apache.commons.beanutils2;\n\nimport org.apache.commons.beanutils2.ConversionException;\nimport org.apache.commons.beanutils2.Converter;\nimport org.apache.commons.beanutils2.converters.EnumConverter;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class EnumConverterExceptionTest {\n\n    private enum PizzaStatus {\n        ORDERED,\n        BAKING,\n        READY,\n        DELIVERED\n    }\n\n    private Converter<Enum<PizzaStatus>> converter;\n\n    @BeforeEach\n    void setUp() throws Exception {\n        converter = new EnumConverter<>();\n    }\n\n    @Test\n    void testConversionExceptionHandling() {\n        assertThrows(ConversionException.class, () -> converter.convert(Enum.class, \"java.lang.String#MONDAY\"));\n    }\n\n    @AfterEach\n    void tearDown() throws Exception {\n        converter = null;\n    }\n}",
      "method_signature": "testNonEnumClasses()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14365,
    "output_tokens": 1279,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 36,
      "description": "Define a test class containing a private field `converter` of type `Converter<Enum<PizzaStatus>>` where `PizzaStatus` is an enum type defined within the test class scope. Implement a setup method annotated with `@BeforeEach` that assigns to `converter` a new instance of `EnumConverter` constructed using the no-argument constructor `new EnumConverter<>()`, ensuring the generic type parameter matches `Enum<PizzaStatus>`. Write a test method annotated with `@Test` that verifies exception handling for non-existent class references by invoking `assertThrows` with `ConversionException.class` as the first argument and a lambda expression as the second argument, where the lambda calls `converter.convert(Enum.class, \"java.lang.does.not.exist#MONDAY\")` passing `Enum.class` as the target type and the String literal `\"java.lang.does.not.exist#MONDAY\"` as the value to convert, thereby asserting that this invocation throws a `ConversionException` due to the invalid class name in the string. Implement a teardown method annotated with `@AfterEach` that assigns `null` to the `converter` field to release the reference. The test uses JUnit 5 Assertions with method-level annotation `@Test` and relies on the `EnumConverter` class from the Apache Commons BeanUtils2 library.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testNonExistingClasses()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.EnumConverterExceptionHandlingTest",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.apache.commons.beanutils2.Converter;\nimport org.apache.commons.beanutils2.ConversionException;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class EnumConverterExceptionHandlingTest {\n\n    private Converter<Enum<PizzaStatus>> converter;\n\n    private enum PizzaStatus {\n        ORDERED,\n        READY,\n        DELIVERED;\n    }\n\n    @BeforeEach\n    void setUp() {\n        converter = new EnumConverter<>();\n    }\n\n    @Test\n    void testConvertNonExistentClassThrowsConversionException() {\n        assertThrows(ConversionException.class, () ->\n            converter.convert(Enum.class, \"java.lang.does.not.exist#MONDAY\")\n        );\n    }\n\n    @AfterEach\n    void tearDown() {\n        converter = null;\n    }\n}",
      "method_signature": "testNonExistingClasses()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 2
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22692,
    "output_tokens": 2158,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 75,
      "description": "Define a test class containing a private field `converter` of type `Converter<Enum<PizzaStatus>>`, then implement a setup method annotated with `@BeforeEach` that instantiates a new `EnumConverter<>` using its no-argument constructor and assigns it to the `converter` field. Within the test method annotated with `@Test`, invoke `convert` on the `converter` field passing two arguments: the class literal `Enum.class` and the String literal `\"java.util.concurrent.TimeUnit.NANOSECONDS\"`, then immediately assert using `assertEquals` that the returned value equals the enum constant `TimeUnit.NANOSECONDS`. After the test completes, implement a teardown method annotated with `@AfterEach` that assigns `null` to the `converter` field. The test uses JUnit 5 Assertions with method-level annotation `@Test`.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testConvertTimeUnit()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.EnumConverterGeneralConversionTest",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.apache.commons.beanutils2.Converter;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class EnumConverterGeneralConversionTest {\n\n    /**\n     * Dummy enum to satisfy the generic type parameter requirement\n     * {@code Converter<Enum<PizzaStatus>>} as specified in the test description.\n     * This enum is not actively used in the conversion logic itself.\n     */\n    private enum PizzaStatus {\n        ORDERED, BAKING, DELIVERED\n    }\n\n    private Converter<Enum<PizzaStatus>> converter;\n\n    @BeforeEach\n    void setUp() {\n        // Instantiates a new EnumConverter using its no-argument constructor\n        // and assigns it to the converter field.\n        // This assumes EnumConverter has a no-argument constructor and that\n        // its generic type can be inferred or handled as a raw type compatible\n        // with Converter<Enum<PizzaStatus>> via unchecked assignment for compilation.\n        converter = new EnumConverter<>();\n    }\n\n    @Test\n    void testConvertStringToTimeUnitEnum() {\n        // Invokes convert on the converter field, passing the class literal Enum.class\n        // and the String literal \"java.util.concurrent.TimeUnit.NANOSECONDS\".\n        // The return type is cast to Object because a raw or loosely typed Converter's\n        // convert method typically returns Object, especially when dealing with\n        // dynamically determined enum types.\n        Object result = converter.convert(Enum.class, \"java.util.concurrent.TimeUnit.NANOSECONDS\");\n\n        // Asserts that the returned value equals the enum constant TimeUnit.NANOSECONDS.\n        Assertions.assertEquals(TimeUnit.NANOSECONDS, result);\n    }\n\n    @AfterEach\n    void tearDown() {\n        // Assigns null to the converter field after the test completes\n        // to release resources and clean up for subsequent tests.\n        converter = null;\n    }\n}",
      "method_signature": "testConvertTimeUnit()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6573,
    "output_tokens": 8168,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 77,
      "description": "Create a test case to validate that the system's conversion capability can accurately transform a fully-qualified textual representation of a standard time measurement unit into its corresponding enumerated constant. Before executing the test, establish a conversion utility configured to handle enumerated type transformations without default fallback behavior. Once the converter is in place, instruct it to process the text value representing nanoseconds from the standard time unit enumeration and verify that the system correctly produces the nanosecond time unit constant as the result, confirming the converter properly interprets both the enumeration class context and the specific constant name. After validation completes, release the converter resource to ensure a clean test environment. Use JUnit 5 as the testing framework with standard equality assertions to verify the conversion outcome matches the expected time unit constant.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testConvertTimeUnit()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.TimeUnitEnumConverterTest",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.apache.commons.beanutils2.ConvertUtilsBean;\nimport org.apache.commons.beanutils2.Converter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport java.util.concurrent.TimeUnit;\n\npublic class TimeUnitEnumConverterTest {\n\n    @Test\n    void testTimeUnitConversionWithoutDefaultFallback() {\n        // Establish a conversion utility\n        ConvertUtilsBean convertUtilsBean = new ConvertUtilsBean();\n\n        // Configure to handle enumerated type transformations without default fallback behavior\n        // EnumConverter(Class enumClass) is the constructor for no default value.\n        Converter enumConverter = new EnumConverter(TimeUnit.class);\n        convertUtilsBean.register(enumConverter, TimeUnit.class);\n\n        try {\n            // Instruct it to process the text value representing nanoseconds\n            // from the standard time unit enumeration\n            Object convertedValue = convertUtilsBean.convert(\"NANOSECONDS\", TimeUnit.class);\n\n            // Verify that the system correctly produces the nanosecond time unit constant\n            assertEquals(TimeUnit.NANOSECONDS, convertedValue,\n                         \"The converted value should be TimeUnit.NANOSECONDS\");\n        } finally {\n            // Release the converter resource to ensure a clean test environment\n            convertUtilsBean.deregister(TimeUnit.class);\n        }\n    }\n}",
      "method_signature": "testConvertTimeUnit()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 15684,
    "output_tokens": 2530,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 78,
      "description": "Create a test case to validate that the system's time conversion capability correctly transforms textual timestamp representations into their corresponding point-in-time values. Begin by establishing a conversion service that handles timestamp transformations, ensuring it is ready to process incoming data. Define the expected outcome as a specific point in time representing early December 2007, calculated from a known millisecond offset. Submit a standardized timestamp string in ISO-8601 format to the conversion service, requesting transformation into the system's internal time representation. Verify that the converted result precisely matches the expected point in time, confirming the conversion service accurately interprets the textual format and produces the correct temporal value. After validation completes, release the conversion service resources to maintain a clean testing environment. Use JUnit 5 as the testing framework with standard equality assertions to confirm the conversion accuracy.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest",
      "method_signature": "testConvertingInstantString()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.DateIso8601ConversionTest",
      "code": "package org.apache.commons.beanutils2;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.Date;\nimport java.util.TimeZone;\n\nimport org.apache.commons.beanutils2.converters.DateConverter;\nimport org.junit.jupiter.api.Test;\n\npublic class DateIso8601ConversionTest {\n\n    @Test\n    void testIso8601TimestampConversion() {\n        // 1. Establish a conversion service\n        // Instantiate ConvertUtilsBean, which manages various type converters.\n        ConvertUtilsBean convertUtilsBean = new ConvertUtilsBean();\n\n        // Create a DateConverter configured to handle ISO-8601 formatted strings.\n        // The pattern \"yyyy-MM-dd'T'HH:mm:ssX\" explicitly supports the 'Z' (Zulu time, i.e., UTC)\n        // or other ISO-8601 timezone offsets.\n        // Set the TimeZone of the converter to UTC to ensure that the 'Z' in the input string\n        // is correctly interpreted and the resulting Date object represents the exact UTC instant.\n        DateConverter dateConverter = new DateConverter(null, \"yyyy-MM-dd'T'HH:mm:ssX\");\n        dateConverter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n\n        // Register the custom DateConverter for java.util.Date type with the ConvertUtilsBean.\n        convertUtilsBean.register(dateConverter, Date.class);\n\n        // 2. Define the expected outcome\n        // The target point in time is early December 2007, specifically December 1, 2007, 00:00:00 UTC.\n        // This is calculated from its known millisecond offset from the Unix epoch.\n        long expectedMillis = 1196467200000L; // Milliseconds for 2007-12-01T00:00:00.000Z\n        Date expectedDate = new Date(expectedMillis);\n\n        // 3. Submit a standardized timestamp string in ISO-8601 format to the conversion service\n        String isoTimestamp = \"2007-12-01T00:00:00Z\";\n\n        // Perform the conversion from the ISO-8601 string to a java.util.Date object.\n        // The convert method returns Object, so a cast to Date is necessary.\n        Date actualDate = (Date) convertUtilsBean.convert(isoTimestamp, Date.class);\n\n        // 4. Verify that the converted result precisely matches the expected point in time\n        // Use standard JUnit 5 equality assertion to confirm the conversion accuracy.\n        assertEquals(expectedDate, actualDate,\n            \"The converted date from the ISO-8601 string should precisely match the expected UTC date.\");\n\n        // 5. Release the conversion service resources\n        // For ConvertUtilsBean and DateConverter, which do not hold unmanaged external\n        // resources, simply allowing them to go out of scope at the end of the test method\n        // is sufficient for resource release. No explicit close/dispose calls are needed.\n    }\n}",
      "method_signature": "testConvertingInstantString()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6562,
    "output_tokens": 5678,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 79,
      "description": "Define a test class that validates the Enum Converter's ability to convert fully qualified enum constant strings into their corresponding enum instances, beginning by declaring a field to hold the converter instance and creating a helper method that instantiates and returns a new Enum Converter configured for a specific enum type. In the setup phase, invoke this helper to initialize the converter field, establishing the component under test. Within the test method, invoke the converter's convert method with the Enum base class as the target type and provide a fully qualified string representation of a TimeUnit enum constant (package name, class name, and constant name concatenated), then immediately assert that the returned value equals the expected TimeUnit enum constant to verify the converter correctly parsed and resolved the string to the actual enum instance. After test execution completes, nullify the converter field in the teardown phase to release the reference and ensure test isolation. This test uses JUnit for test execution and standard assertion methods for validation.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testConvertTimeUnit()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.EnumConverterFullyQualifiedStringTest",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class EnumConverterFullyQualifiedStringTest {\n\n    private EnumConverter converter;\n\n    /**\n     * Helper method to create a new EnumConverter.\n     */\n    private <E extends Enum<E>> EnumConverter createEnumConverter(final Class<E> enumClass) {\n        return new EnumConverter(enumClass);\n    }\n\n    @BeforeEach\n    public void setUp() {\n        // Configure the converter for TimeUnit enum\n        converter = createEnumConverter(TimeUnit.class);\n    }\n\n    @AfterEach\n    public void tearDown() {\n        converter = null;\n    }\n\n    @Test\n    public void testConvertFullyQualifiedTimeUnitString() {\n        final String fullyQualifiedEnumString = \"java.util.concurrent.TimeUnit.SECONDS\";\n        final TimeUnit expected = TimeUnit.SECONDS;\n\n        // The convert method signature is convert(Class<T> type, Object value)\n        final Object result = converter.convert(TimeUnit.class, fullyQualifiedEnumString);\n\n        Assertions.assertNotNull(result, \"Converted value should not be null\");\n        Assertions.assertEquals(expected, result, \"Converted value should match expected TimeUnit enum constant\");\n        Assertions.assertTrue(result instanceof TimeUnit, \"Converted value should be an instance of TimeUnit\");\n    }\n}",
      "method_signature": "testConvertTimeUnit()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "run_shell_command": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 31527,
    "output_tokens": 2528,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 81,
      "description": "Define a test class that validates the Enum Converter's handling of malformed input strings that violate the expected naming convention format. Before each test execution, initialize a private Converter field by creating a helper method that instantiates an Enum Converter configured to throw exceptions on conversion failures. Within the test method, invoke the converter's convert method with the Enum base class as the target type and provide an input string that uses an invalid delimiter format (a hyphen-separated qualified enum name instead of the expected format). Assert that this conversion attempt throws a Conversion Exception, confirming that the converter properly rejects inputs that do not conform to the standard enum naming pattern. After test completion, release the converter reference by nullifying the field to ensure clean state between test executions. This test uses JUnit 5 for assertions.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testBrokenNamingConvention()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.EnumConverterMalformedInputTest",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.apache.commons.beanutils2.ConversionException;\nimport org.apache.commons.beanutils2.Converter;\nimport org.apache.commons.beanutils2.TestEnum;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class EnumConverterMalformedInputTest {\n\n    private Converter converter;\n\n    /**\n     * Initializes the Enum Converter before each test execution, configuring it\n     * to throw exceptions on conversion failures by providing a null default value.\n     */\n    @BeforeEach\n    void setUp() {\n        // The EnumConverter typically extends AbstractConverter.\n        // Passing null as the default value in the constructor usually configures\n        // the converter to throw a ConversionException when conversion fails\n        // and no valid default value can be returned.\n        converter = new EnumConverter(TestEnum.class, null);\n    }\n\n    /**\n     * Tests that the EnumConverter throws a ConversionException when attempting\n     * to convert a malformed input string that violates the expected enum\n     * naming convention (e.g., using a hyphen as a delimiter).\n     */\n    @Test\n    void testMalformedEnumStringThrowsConversionException() {\n        // An input string that does not conform to the simple enum name pattern.\n        // TestEnum has constants like A, B, C. \"A-B\" is malformed.\n        final String malformedInput = \"A-B\";\n        final Class<TestEnum> targetType = TestEnum.class;\n\n        // Assert that calling convert with the malformed input throws ConversionException.\n        Assertions.assertThrows(ConversionException.class, () -> {\n            converter.convert(targetType, malformedInput);\n        });\n    }\n\n    /**\n     * Releases the converter reference after each test to ensure a clean state.\n     */\n    @AfterEach\n    void tearDown() {\n        converter = null;\n    }\n}",
      "method_signature": "testBrokenNamingConvention()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6553,
    "output_tokens": 2741,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 82,
      "description": "Define a test class that validates the conversion capability of an Instant Converter component by first establishing a converter field and creating a private helper method that instantiates the converter implementation, then invoking this helper during setup to initialize the field. Within the test method, construct a reference Instant object from a known epoch millisecond value representing a specific timestamp, then invoke the converter's conversion method with the Instant class type and an ISO-8601 formatted string representation of the same timestamp to obtain the converted result. Assert that the converted Instant matches the reference Instant created from the epoch value, confirming the converter correctly parses the string format into the temporal object. After test execution, release the converter reference by nullifying the field to ensure clean state between test runs. This test uses JUnit for test execution and assertions.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest",
      "method_signature": "testConvertingInstantString()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest1",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.time.Instant;\n\npublic class InstantConverterTest1 {\n\n    private InstantConverter instantConverter;\n\n    @Before\n    public void setUp() {\n        instantiateConverter();\n    }\n\n    private void instantiateConverter() {\n        instantConverter = new InstantConverter();\n    }\n\n    @Test\n    public void testInstantConversionFromIso8601String() {\n        // Construct a reference Instant object from a known epoch millisecond value\n        // 1678886400000L corresponds to 2023-03-15T00:00:00Z\n        Instant referenceInstant = Instant.ofEpochMilli(1678886400000L);\n\n        // ISO-8601 formatted string representation of the same timestamp\n        String iso8601String = \"2023-03-15T00:00:00Z\";\n\n        // Invoke the converter's conversion method with the Instant class type and the string\n        Instant convertedInstant = (Instant) instantConverter.convert(Instant.class, iso8601String);\n\n        // Assert that the converted Instant matches the reference Instant\n        assertEquals(referenceInstant, convertedInstant);\n    }\n\n    @After\n    public void tearDown() {\n        // Release the converter reference by nullifying the field\n        instantConverter = null;\n    }\n}",
      "method_signature": "testConvertingInstantString()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 13631,
    "output_tokens": 1827,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 84,
      "description": "Create a test case to validate that the system properly rejects conversion requests when presented with input that violates the expected naming format for enumeration values. Before executing the scenario, ensure a conversion utility is configured to handle enumeration transformations without any default fallback behavior, so that invalid inputs trigger immediate failures rather than silent substitutions. Once the utility is ready, attempt to convert a text value that deliberately uses an incorrect separator convention\u2014specifically a hyphen-based format instead of the standard dot-based package notation\u2014while requesting conversion to a generic enumeration type. Verify that the system recognizes this malformed input as invalid and responds by signaling a conversion failure, preventing any partial or incorrect transformation from proceeding. After confirming the rejection behavior, release the conversion utility to free any held resources. Use JUnit 5 as the testing framework and verify the expected failure condition using standard exception assertion capabilities.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testBrokenNamingConvention()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.EnumConversionRejectionTest",
      "code": "package org.apache.commons.beanutils2;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport org.apache.commons.beanutils2.converters.EnumConverter;\n\npublic class EnumConversionRejectionTest {\n\n    @Test\n    void testInvalidEnumConversionRejection() {\n        // Setup a new ConvertUtilsBean instance to ensure local configuration.\n        ConvertUtilsBean convertUtilsBean = new ConvertUtilsBean();\n\n        // Configure an EnumConverter for TestEnum without a default fallback value.\n        // This ensures that invalid inputs will trigger a ConversionException.\n        EnumConverter<TestEnum> enumConverter = new EnumConverter<>(TestEnum.class);\n        convertUtilsBean.register(enumConverter, TestEnum.class);\n\n        // Define an invalid enumeration value string that uses a hyphen instead of a dot.\n        String invalidEnumValue = \"A-B\";\n\n        // Verify that attempting to convert the malformed input string to TestEnum.class\n        // results in a ConversionException, indicating proper rejection.\n        assertThrows(ConversionException.class, () ->\n            convertUtilsBean.convert(invalidEnumValue, TestEnum.class)\n        );\n\n        // The ConvertUtilsBean and EnumConverter instances are local to this method\n        // and will be garbage collected, thus releasing any associated resources.\n    }\n}",
      "method_signature": "testBrokenNamingConvention()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6564,
    "output_tokens": 2315,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 85,
      "description": "Define a test class that validates the Instant Converter's ability to transform millisecond epoch values into Instant objects, beginning by declaring a field to hold the converter instance and implementing a setup method that creates a private helper to instantiate the converter implementation. Within the test method, construct an expected Instant by converting a specific millisecond epoch value using the standard Instant factory method, then invoke the converter's convert method with the target Instant class type and the same millisecond epoch value as a long integer to produce the actual result. Assert that the actual Instant matches the expected Instant to confirm the converter correctly interprets millisecond epoch inputs. After test execution, implement a teardown method that nullifies the converter field to release resources. The test uses JUnit for test execution and assertions.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest",
      "method_signature": "testConvertingMilliseconds()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.beanutils2.converters;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\nimport java.time.Instant;\n\npublic class InstantConverterTest1 {\n\n    private InstantConverter converter;\n\n    @Before\n    public void setUp() {\n        converter = createConverter();\n    }\n\n    @After\n    public void tearDown() {\n        converter = null;\n    }\n\n    @Test\n    public void testConvertMillisecondEpochToInstant() {\n        final long epochMilliValue = 1678886400000L; // March 15, 2023 12:00:00 PM GMT\n        final Instant expectedInstant = Instant.ofEpochMilli(epochMilliValue);\n        final Instant actualInstant = converter.convert(Instant.class, epochMilliValue);\n        assertEquals(\"The converter should correctly convert millisecond epoch to Instant\", expectedInstant, actualInstant);\n    }\n\n    private InstantConverter createConverter() {\n        return new InstantConverter();\n    }\n}",
      "method_signature": "testConvertingMilliseconds()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 21212,
    "output_tokens": 1523,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 87,
      "description": "Define a test class containing a private field `converter` of type `Converter<Instant>`, then implement a setup method annotated with `@BeforeEach` that assigns to `converter` a new instance of `InstantConverter` created by invoking its no-argument constructor. Within the test method annotated with `@Test`, begin by creating a local variable `expected` of type `Instant` by invoking the static method `Instant.ofEpochMilli` with the long literal `1196676930000L`, then immediately invoke the `convert` method on the `converter` field passing two arguments: the class literal `Instant.class` and the string literal `\"2007-12-03T10:15:30.00Z\"`, assigning the returned `Instant` to a local variable `actual`. Following this conversion, assert equality by invoking `assertEquals` with `expected` as the first argument and `actual` as the second argument to verify that the converter produces the correct `Instant` representation of the ISO-8601 timestamp. After the test completes, implement a teardown method annotated with `@AfterEach` that explicitly assigns `null` to the `converter` field to release the resource. The test uses JUnit 5 assertions with method-level annotation `@Test`.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest",
      "method_signature": "testConvertingInstantString()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest1",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport java.time.Instant;\nimport org.apache.commons.beanutils2.Converter;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class InstantConverterTest1 {\n\n    private Converter<Instant> converter;\n\n    @BeforeEach\n    public void setUp() {\n        converter = new InstantConverter();\n    }\n\n    @Test\n    public void testConvertInstantFromString() {\n        final Instant expected = Instant.ofEpochMilli(1196676930000L);\n        final Instant actual = converter.convert(Instant.class, \"2007-12-03T10:15:30.00Z\");\n        assertEquals(expected, actual);\n    }\n\n    @AfterEach\n    public void tearDown() {\n        converter = null;\n    }\n}",
      "method_signature": "testConvertingInstantString()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6671,
    "output_tokens": 1069,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 89,
      "description": "Create a test case to validate that the time conversion system correctly transforms a numeric timestamp representing milliseconds since the epoch into a standardized point-in-time representation. Begin by establishing a conversion capability within the system that can handle temporal data transformations. Prepare a reference point-in-time corresponding to a specific millisecond timestamp to serve as the expected business outcome. Submit the numeric millisecond value to the conversion system and request transformation into a point-in-time format. Verify that the converted temporal result matches the expected reference point exactly, confirming the system accurately interprets millisecond timestamps and produces consistent temporal representations. After validation completes, release the conversion capability to ensure no resources remain allocated. Use JUnit 5 as the testing framework with standard equality assertions to confirm the temporal values align precisely.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest",
      "method_signature": "testConvertingMilliseconds()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.MillisecondToInstantConversionTest",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.apache.commons.beanutils2.ConvertUtilsBean;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.time.Instant;\n\npublic class MillisecondToInstantConversionTest {\n\n    @Test\n    void testConvertMillisecondsToInstant() {\n        // Establish a conversion capability within the system that can handle temporal data transformations.\n        ConvertUtilsBean convertUtilsBean = new ConvertUtilsBean();\n        InstantConverter instantConverter = new InstantConverter();\n        convertUtilsBean.register(instantConverter, Instant.class);\n\n        try {\n            // Prepare a reference point-in-time corresponding to a specific millisecond timestamp\n            // to serve as the expected business outcome.\n            long millisecondTimestamp = 1672531200000L; // January 1, 2023, 00:00:00 UTC\n            Instant expectedInstant = Instant.ofEpochMilli(millisecondTimestamp);\n\n            // Submit the numeric millisecond value to the conversion system and request transformation\n            // into a point-in-time format.\n            Object convertedValue = convertUtilsBean.convert(millisecondTimestamp, Instant.class);\n\n            // Verify that the converted temporal result matches the expected reference point exactly,\n            // confirming the system accurately interprets millisecond timestamps and produces consistent\n            // temporal representations.\n            assertEquals(expectedInstant, convertedValue, \"The converted Instant should accurately represent the millisecond timestamp.\");\n        } finally {\n            // After validation completes, release the conversion capability to ensure no resources remain allocated.\n            // For a locally scoped ConvertUtilsBean, deregistration primarily serves to explicitly fulfill this requirement.\n            convertUtilsBean.deregister(Instant.class);\n        }\n    }\n}",
      "method_signature": "testConvertingMilliseconds()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.6667,
      "callable_precision": 0.2857,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 26425,
    "output_tokens": 3357,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 91,
      "description": "Define a test class containing a private field `converter` of type `Converter<Enum<PizzaStatus>>`, where `PizzaStatus` is an enum type defined within the test class scope. In a setup method annotated with `@BeforeEach`, instantiate a new `EnumConverter<>` using its no-argument constructor and assign it to the `converter` field. Write a test method annotated with `@Test` that verifies exception handling for malformed enum naming conventions by invoking `assertThrows` with `ConversionException.class` as the first argument and a lambda expression as the second argument, where the lambda calls `converter.convert(Enum.class, \"JAVA-TIME-DAYOFWEEK#MONDAY\")` passing `Enum.class` as the target type and the String literal `\"JAVA-TIME-DAYOFWEEK#MONDAY\"` as the value to convert, expecting the conversion to fail and throw a `ConversionException` due to the invalid delimiter character. In a teardown method annotated with `@AfterEach` and throwing `Exception`, assign `null` to the `converter` field to release the reference. The test uses JUnit 5 Assertions with method-level annotation `@Test` and setup/teardown annotations `@BeforeEach` and `@AfterEach`.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.EnumConverterTest",
      "method_signature": "testBrokenNamingConvention()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.EnumConverterMalformedInputTest",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.apache.commons.beanutils2.ConversionException;\nimport org.apache.commons.beanutils2.Converter;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class EnumConverterMalformedInputTest {\n\n    private Converter<Enum<PizzaStatus>> converter;\n\n    /**\n     * An enum type defined within the test class scope for testing purposes.\n     */\n    enum PizzaStatus {\n        ORDERED, PREPARING, BAKING, DELIVERED\n    }\n\n    @BeforeEach\n    void setUp() {\n        // Instantiate EnumConverter using its no-argument constructor as per the test description.\n        // The specific enum type for the field Converter<Enum<PizzaStatus>> is handled by the generic type.\n        converter = new EnumConverter<>();\n    }\n\n    @Test\n    void testConversionExceptionForMalformedEnumName() {\n        // Verify that converting a malformed enum string with an invalid delimiter\n        // results in a ConversionException.\n        assertThrows(ConversionException.class, () ->\n            converter.convert(Enum.class, \"JAVA-TIME-DAYOFWEEK#MONDAY\")\n        );\n    }\n\n    @AfterEach\n    void tearDown() throws Exception {\n        // Release the converter reference.\n        converter = null;\n    }\n}",
      "method_signature": "testBrokenNamingConvention()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6658,
    "output_tokens": 1842,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 92,
      "description": "Define a test class containing a private field `converter` of type `Converter<Instant>`, then implement a setup method annotated with `@BeforeEach` that assigns to `converter` the result of instantiating a new `InstantConverter` using its no-argument constructor. Within the test method annotated with `@Test`, begin by creating an `Instant` named `expected` by invoking the static method `Instant.ofEpochMilli` with the long literal `1596500083605L`, then invoke the `convert` method on `converter` passing `Instant.class` as the first argument and the long literal `1596500083605L` as the second argument, assigning the returned `Instant` to a variable named `actual`. Immediately assert equality by calling `assertEquals` with `expected` as the first argument and `actual` as the second argument. Implement a teardown method annotated with `@AfterEach` that assigns `null` to the `converter` field. The test uses JUnit 5 Assertions with method-level annotation `@Test`, setup annotation `@BeforeEach`, and teardown annotation `@AfterEach`.",
      "project_name": "commons-beanutils",
      "qualified_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest",
      "method_signature": "testConvertingMilliseconds()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.beanutils2.converters.InstantConverterTest1",
      "code": "package org.apache.commons.beanutils2.converters;\n\nimport org.apache.commons.beanutils2.Converter;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.time.Instant;\n\npublic class InstantConverterTest1 {\n\n    private Converter<Instant> converter;\n\n    @BeforeEach\n    public void setUp() {\n        converter = new InstantConverter();\n    }\n\n    @Test\n    public void testConvertLongToInstant() {\n        final Instant expected = Instant.ofEpochMilli(1596500083605L);\n        final Instant actual = converter.convert(Instant.class, 1596500083605L);\n        Assertions.assertEquals(expected, actual);\n    }\n\n    @AfterEach\n    public void tearDown() {\n        converter = null;\n    }\n}",
      "method_signature": "testConvertingMilliseconds()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 2
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 34187,
    "output_tokens": 1083,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  }
]