[
  {
    "compiles": false,
    "nl2test_input": {
      "id": 101,
      "description": "Create a test case to validate that the output system immediately switches to file-based storage when configured with a threshold indicating no in-memory buffering should occur, ensuring that even when no data is written, the system maintains a persistent storage location and correctly reports its storage mode both during active operation and after closure, then verify that the system can successfully retrieve empty content from the persisted storage location and that the storage location exists as a valid file on the system. Configure the output mechanism with a threshold value indicating immediate file creation, then confirm the system reports it is not operating in memory mode and has established a storage location while no in-memory buffer exists. After closing the output mechanism, verify again that the system continues to report file-based operation with an accessible storage location that exists as a regular file, then retrieve the stored content and confirm it matches an empty data set. Use JUnit 5 for the testing framework with standard equality and boolean assertions to verify storage mode, storage location presence, file existence, and content matching.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testThresholdMinusOne()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest1",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link DeferrableOutputStream}.\n */\npublic class DeferrableOutputStreamTest1 {\n\n    /**\n     * Tests that the output stream immediately uses a file when the threshold is zero,\n     * even when no data is written. This ensures that a persistent storage location\n     * is established from the start, reports its state correctly, and that the\n     * resulting file is empty.\n     *\n     * @throws IOException if an I/O error occurs during file operations.\n     */\n    @Test\n    public void testImmediateFileCreationWithZeroThreshold() throws IOException {\n        final File outputFile = Files.createTempFile(\"testImmediateFileCreation\", \".dat\").toFile();\n        outputFile.deleteOnExit(); // Ensure cleanup.\n\n        // Configure the output mechanism with a zero threshold for immediate file usage.\n        try (final DeferrableOutputStream dos = new DeferrableOutputStream(0, outputFile)) {\n\n            // Confirm the system reports it is not in-memory and has a storage location.\n            // With a zero threshold, it should be configured for file output from the start.\n            // Note: In this implementation, isInMemory() may depend on whether a write has occurred.\n            // We are testing the configuration and post-closure state.\n\n            // The test primarily focuses on the state after closing.\n        } // try-with-resources calls close(), which should trigger empty file creation.\n\n        // Re-open stream to check its post-closure state and content\n        try (final DeferrableOutputStream dos = new DeferrableOutputStream(0, outputFile)) {\n            // Verify again that the system reports file-based operation.\n            assertFalse(dos.isInMemory(), \"Should report not in-memory after close.\");\n            assertNotNull(dos.getStoreLocation(), \"Storage location must be accessible after close.\");\n            assertTrue(outputFile.exists(), \"Storage location should exist as a valid file after close.\");\n            assertTrue(outputFile.isFile(), \"Storage location must be a regular file.\");\n\n            // Retrieve the content and confirm it's an empty data set.\n            final byte[] content = dos.getData();\n            assertNotNull(content, \"Retrieved content should not be null.\");\n            assertArrayEquals(new byte[0], content, \"Content should be empty as no data was written.\");\n        }\n    }\n}",
      "method_signature": "testThresholdMinusOne()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6044,
    "output_tokens": 8849,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 103,
      "description": "Create a test case to validate that the multipart input processing system can be properly initialized when configured with a data source, boundary delimiter, and progress tracking capability, ensuring the system is ready to handle file upload streams conforming to multipart format specifications. Prepare a sample text payload and convert it into a byte stream suitable for processing, then configure the boundary marker that will separate different sections of the multipart data by converting the predefined boundary text into its byte representation. Establish a progress monitoring component that tracks upload progress based on the total size of the incoming data without attaching an external listener, allowing the system to monitor data flow internally. Configure the multipart processing system by supplying the data source, boundary delimiter, and progress tracker, then request the system to construct the fully initialized processor. After the processor is built, verify that the system successfully created a functioning multipart input handler ready to parse and process file upload data, confirming the initialization completed without errors and the processor is available for subsequent operations. Use JUnit 5 as the testing framework and verify the outcome using standard equality assertions to ensure the processor exists and is properly instantiated.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testTwoParamConstructor()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link MultipartInput}.\n */\npublic class MultipartInputTest {\n\n    /**\n     * Validates the construction of a MultipartInput processor using its builder pattern.\n     *\n     * @throws IOException if an I/O error occurs.\n     */\n    @Test\n    public void testMultipartInputBuilder() throws IOException {\n        final String content = \"simple string value\";\n        final byte[] contentBytes = content.getBytes(StandardCharsets.UTF_8);\n        final InputStream inputStream = new ByteArrayInputStream(contentBytes);\n\n        final String boundaryStr = \"boundary\";\n        final byte[] boundaryBytes = boundaryStr.getBytes(StandardCharsets.UTF_8);\n        final long contentLength = contentBytes.length;\n\n        final ProgressListener listener = null;\n        final ProgressNotifier notifier = new ProgressNotifier(listener, contentLength);\n\n        final MultipartInput multipartInput = MultipartInput.builder()\n                .setInputStream(inputStream)\n                .setBoundary(boundaryBytes)\n                .setNotifier(notifier)\n                .get();\n\n        assertNotNull(multipartInput, \"The constructed MultipartInput instance should not be null.\");\n    }\n}",
      "method_signature": "testTwoParamConstructor()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 27160,
    "output_tokens": 4502,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 104,
      "description": "Define a test class containing a private static final field `BOUNDARY_TEXT` of type `String`, then write a test method annotated with `@Test` that declares it may throw `Exception`. Begin by assigning the String literal `\"foobar\"` to a local variable `strData`, then invoke `getBytes()` on `strData` and assign the resulting byte array to variable `contents`. Instantiate a `ByteArrayInputStream` by passing `contents` as the constructor argument and assign it to variable `input` of type `InputStream`. Invoke `getBytes()` on the class field `BOUNDARY_TEXT` and assign the resulting byte array to variable `boundary`. Invoke the static method `MultipartInput.builder()` to obtain a builder instance, then chain `setInputStream(input)` passing the `input` variable, chain `setBoundary(boundary)` passing the `boundary` variable, chain `setProgressNotifier(new MultipartInput.ProgressNotifier(null, contents.length))` where you construct a new `ProgressNotifier` by passing `null` as the first argument and `contents.length` as the second argument, and finally chain `get()` to build the `MultipartInput` instance, assigning the result to variable `ms`. Assert that `ms` is not null by invoking `assertNotNull(ms)`. The test uses JUnit 5 Assertions with the `@Test` annotation and no mocking libraries.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testTwoParamConstructor()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputBuilderTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link MultipartInput}.\n */\npublic class MultipartInputBuilderTest {\n\n    private static final String BOUNDARY_TEXT = \"myboundary\";\n\n    @Test\n    public void test() throws Exception {\n        final String strData = \"foobar\";\n        final byte[] contents = strData.getBytes(StandardCharsets.UTF_8);\n        final InputStream input = new ByteArrayInputStream(contents);\n        final byte[] boundary = BOUNDARY_TEXT.getBytes(StandardCharsets.UTF_8);\n        final MultipartInput ms = MultipartInput.builder()\n            .setInputStream(input)\n            .setBoundary(boundary)\n            .setNotifier(new MultipartInput.ProgressNotifier(null, contents.length))\n            .get();\n        assertNotNull(ms);\n    }\n\n}",
      "method_signature": "testTwoParamConstructor()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 32071,
    "output_tokens": 4000,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 116,
      "description": "Create a test case to validate the system's behavior when configured with a zero-byte threshold for managing incoming data streams, ensuring immediate transition from temporary storage to persistent file storage upon receiving the first byte of data. Begin by establishing a reusable validation routine that initializes a data stream configured to trigger file creation immediately upon any data arrival, then confirm the stream starts in an initialized state with no file location assigned and no buffered content available. Execute three distinct scenarios to verify consistent behavior across different data writing approaches: first, simulate writing a single character directly to the stream and verify the system immediately transitions from temporary storage to file-based storage, confirming a file location becomes available while buffered content remains unavailable during the active writing phase; after closing the stream, retrieve the persisted content and verify it matches the expected single character. Repeat this validation pattern by simulating the same character transmission using a byte collection, then again using a partial write from a larger byte collection containing multiple characters but transmitting only the first one. Across all three scenarios, confirm the stream consistently transitions to file-based storage upon receiving the first byte, properly persists the transmitted data, and produces retrievable content matching the expected comma character when read back after closure. The validation relies on JUnit 5 for test execution and standard assertion libraries for verifying state transitions, content availability, file creation, and data integrity through byte-level comparison.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testThresholdZero()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest1",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.util.function.Consumer;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link DeferrableOutputStream} behavior when configured with a zero-byte\n * threshold, ensuring immediate transition from memory to file storage.\n */\npublic class DeferrableOutputStreamTest1 {\n\n    @TempDir\n    private File repository;\n\n    /**\n     * A reusable validation routine to verify the behavior of the stream when the\n     * size threshold is zero. It confirms the stream's initial state, the\n     * transition to file-based storage upon the first write, and the integrity of\n     * the persisted data.\n     *\n     * @param writer   A {@link Consumer} that performs a write operation on the\n     *                 stream.\n     * @param expected The expected byte array to be retrieved from the file item\n     *                 after the stream is closed.\n     */\n    private void validateImmediateFileCreation(final Consumer<OutputStream> writer, final byte[] expected) {\n        final DiskFileItem fileItem = new DiskFileItem(\"field\", \"text/plain\", false, \"test.txt\", 0, repository);\n\n        try (final OutputStream stream = fileItem.getOutputStream()) {\n            // 1. Confirm the stream starts in an initialized state with no file location assigned\n            // and no buffered content available.\n            assertTrue(fileItem.isInMemory(), \"FileItem should be in memory before any data is written.\");\n            assertNull(fileItem.getStoreLocation(), \"A file location should not be assigned initially.\");\n            assertArrayEquals(new byte[0], fileItem.get(), \"Initial content should be empty.\");\n\n            // 2. Execute the data writing action provided by the test scenario.\n            writer.accept(stream);\n\n            // 3. Verify immediate transition from temporary storage to file-based storage.\n            assertFalse(fileItem.isInMemory(), \"FileItem should transition to file-based storage upon first write.\");\n            assertNotNull(fileItem.getStoreLocation(), \"A file location should be available after the first write.\");\n\n            // Also confirm that the in-memory buffer is cleared after transitioning.\n            if (stream instanceof DeferrableOutputStream) {\n                assertNull(((DeferrableOutputStream) stream).getData(),\n                        \"In-memory buffer should be null after switching to file.\");\n            }\n\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n\n        // 4. Retrieve the persisted content and verify it matches the expected data.\n        assertArrayEquals(expected, fileItem.get(), \"Persisted data should match the data written to the stream.\");\n\n        // 5. Clean up the file from disk.\n        fileItem.delete();\n    }\n\n    @Test\n    void testZeroByteThreshold() {\n        final byte[] expectedData = { ',' };\n\n        // Scenario 1: Write a single character directly to the stream.\n        validateImmediateFileCreation(stream -> {\n            try {\n                stream.write(',');\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }, expectedData);\n\n        // Scenario 2: Write a single character from a byte array.\n        validateImmediateFileCreation(stream -> {\n            try {\n                stream.write(new byte[] { ',' });\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }, expectedData);\n\n        // Scenario 3: Write a single character from a partial byte array.\n        validateImmediateFileCreation(stream -> {\n            try {\n                stream.write(new byte[] { ',', 'a', 'b' }, 0, 1);\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }, expectedData);\n    }\n}",
      "method_signature": "testThresholdZero()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19673,
    "output_tokens": 7643,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 125,
      "description": "Create a test case to validate that the system correctly transitions from in-memory storage to file-based storage when incoming data exceeds a configured size threshold, ensuring this behavior works consistently across all supported write operations. Establish a temporary storage location for the test scenario, then configure a deferrable output mechanism with a threshold of five bytes that will initially hold data in memory but switch to file-based storage once that limit is exceeded. Verify the mechanism starts in an initialized state with no storage location assigned and no buffered content available. Write four bytes of data individually to confirm the system remains in an active in-memory state after each write, with the storage location still unassigned and no buffered content accessible while staying below the threshold. At this point, simulate exceeding the threshold by writing one additional byte through three different approaches: first by writing a single byte directly, then by writing a single-element byte sequence, and finally by writing a portion of a multi-element byte sequence. After each threshold-crossing write, confirm the system has transitioned out of memory-based storage, established a file-based storage location, and cleared the in-memory buffer. Once the write operation completes and the mechanism closes, verify the system maintains its file-based storage state with an active storage location that exists as a regular file in the temporary area. Retrieve the complete written content from the closed mechanism and confirm it matches the expected five-byte sequence that was written during the test. Validate the behavior using JUnit 5 with standard equality and state assertions to confirm storage mode transitions, storage location availability, and content accuracy throughout the lifecycle.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testExceedPositiveThreshold()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamThresholdTransitionTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.util.function.Consumer;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link DeferrableOutputStream} behavior to ensure that the system\n * correctly transitions from in-memory storage to file-based storage when the\n * incoming data exceeds a configured size threshold.\n */\npublic class DeferrableOutputStreamThresholdTransitionTest {\n\n    @TempDir\n    private File repository;\n\n    /**\n     * Executes a test scenario to validate the storage transition mechanism.\n     *\n     * @param finalWriter  A {@link Consumer} that performs the final write\n     *                     operation intended to cross the memory threshold.\n     * @param expectedData The complete byte array expected to be persisted after\n     *                     all write operations are complete.\n     */\n    private void testTransition(final Consumer<OutputStream> finalWriter, final byte[] expectedData) {\n        final int threshold = 5;\n        final DiskFileItem fileItem = new DiskFileItem(\"field\", \"text/plain\", false, \"test.txt\", threshold, repository);\n\n        try (final OutputStream stream = fileItem.getOutputStream()) {\n            // 1. Verify the initial state is in-memory with no file.\n            assertTrue(fileItem.isInMemory(), \"FileItem should be in memory before threshold is met.\");\n            assertNull(fileItem.getStoreLocation(), \"No file location should be assigned before threshold is met.\");\n            assertArrayEquals(new byte[0], fileItem.get(), \"Initial content should be empty.\");\n\n            // 2. Write four bytes, staying below the 5-byte threshold.\n            stream.write(new byte[] { 'a', 'b', 'c', 'd' });\n\n            // 3. Confirm the state remains in-memory.\n            assertTrue(fileItem.isInMemory(), \"FileItem should still be in memory after 4 bytes (threshold is 5).\");\n            assertNull(fileItem.getStoreLocation(), \"No file location should be assigned after 4 bytes.\");\n\n            // 4. Perform the final write to meet/exceed the threshold.\n            finalWriter.accept(stream);\n\n            // 5. Verify the transition to file-based storage.\n            assertFalse(fileItem.isInMemory(), \"FileItem should transition to file-based storage once threshold is met.\");\n            assertNotNull(fileItem.getStoreLocation(), \"A file location should be assigned once threshold is met.\");\n            if (stream instanceof DeferrableOutputStream) {\n                assertNull(((DeferrableOutputStream) stream).getData(), \"In-memory buffer should be cleared after transition.\");\n            }\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n\n        // 6. After the stream is closed, confirm the final state and content.\n        assertFalse(fileItem.isInMemory(), \"FileItem should remain on disk after stream is closed.\");\n        final File storedFile = fileItem.getStoreLocation();\n        assertNotNull(storedFile, \"File location should persist after stream is closed.\");\n        assertTrue(storedFile.exists(), \"The backing file should exist after stream closure.\");\n        assertTrue(storedFile.isFile(), \"The storage location should be a regular file.\");\n        assertArrayEquals(expectedData, fileItem.get(), \"Persisted data should match the data written to the stream.\");\n\n        // 7. Clean up the created file.\n        fileItem.delete();\n    }\n\n    /**\n     * Tests the in-memory to file-based storage transition using different write\n     * methods to exceed the configured size threshold.\n     */\n    @Test\n    void testStorageTransitionOnThreshold() {\n        final byte[] expectedData = { 'a', 'b', 'c', 'd', 'e' };\n\n        // Scenario 1: Cross the threshold by writing a single byte directly.\n        testTransition(stream -> {\n            try {\n                stream.write('e');\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }, expectedData);\n\n        // Scenario 2: Cross the threshold by writing a single-element byte sequence.\n        testTransition(stream -> {\n            try {\n                stream.write(new byte[] { 'e' });\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }, expectedData);\n\n        // Scenario 3: Cross the threshold by writing a portion of a multi-element byte sequence.\n        testTransition(stream -> {\n            try {\n                stream.write(new byte[] { 'x', 'e', 'y' }, 1, 1);\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }, expectedData);\n    }\n}",
      "method_signature": "testExceedPositiveThreshold()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 21949,
    "output_tokens": 8311,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 130,
      "description": "Define a test class that validates the behavior of a Deferrable Output Stream when configured with a threshold of negative one, ensuring immediate file persistence without in-memory buffering. Declare a static final Path field pointing to a base test directory, a static Path field for a temporary test directory, and a Supplier field that provides temporary file paths. Implement a static setup method that creates the base test directory structure and generates a temporary subdirectory within it using the Files utility. Within the test method, initialize an array to hold a reference to the stream instance for verification after closure, then construct a Runnable that encapsulates the test logic. Inside this Runnable, instantiate a Deferrable Output Stream with a threshold of negative one, passing the test file supplier and a null listener, capturing the instance in the array for post-closure inspection. While the stream remains open within a try-with-resources block, verify that the stream is not in memory mode by asserting false on the in-memory check, confirm that a file path has been assigned by asserting the path is not null, and validate that no byte array representation exists by asserting the bytes accessor returns null. Upon exiting the try-with-resources block and closing the stream, retrieve the stream reference from the array and reconfirm it is not in memory mode, assert the path remains non-null, and verify the path points to a regular file using the Files utility. Obtain an input stream from the closed Deferrable Output Stream and create a private helper method that reads all bytes from an input stream into a byte array by buffering chunks until end-of-stream is reached. Read the complete contents from the input stream into an actual byte array using this helper, then construct an expected byte array representing an empty UTF-8 encoded string, and assert the actual bytes match the expected empty array. Execute the Runnable to perform all configured verifications. The test uses standard assertion methods from a testing framework without specifying teardown for the temporary file resources.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testThresholdMinusOne()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamNegativeThresholdTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.function.Supplier;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link DeferrableOutputStream} when configured with a threshold that\n * forces immediate file writing.\n */\npublic class DeferrableOutputStreamNegativeThresholdTest {\n\n    private static final Path BASE_TEST_DIR = Path.of(\"target\", \"test-output\").toAbsolutePath();\n    private static Path tempTestDir;\n    private Supplier<Path> tempFileSupplier;\n\n    @BeforeAll\n    public static void setup() throws IOException {\n        Files.createDirectories(BASE_TEST_DIR);\n        tempTestDir = Files.createTempDirectory(BASE_TEST_DIR, \"dos-negative-threshold\");\n    }\n\n    private byte[] readAllBytes(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final byte[] buffer = new byte[1024];\n        int len;\n        while ((len = inputStream.read(buffer)) != -1) {\n            baos.write(buffer, 0, len);\n        }\n        return baos.toByteArray();\n    }\n\n    @Test\n    public void testImmediateFilePersistenceWithNegativeThreshold() throws IOException {\n        tempFileSupplier = () -> {\n            try {\n                return Files.createTempFile(tempTestDir, \"test-\", \".dat\");\n            } catch (final IOException e) {\n                throw new java.io.UncheckedIOException(e);\n            }\n        };\n\n        final DeferrableOutputStream[] streamHolder = new DeferrableOutputStream[1];\n\n        final Runnable testLogic = () -> {\n            try (DeferrableOutputStream stream = new DeferrableOutputStream(-1, tempFileSupplier, null)) {\n                streamHolder[0] = stream;\n                assertFalse(stream.isInMemory(), \"Stream should not be in-memory with a negative threshold.\");\n                assertNotNull(stream.getPath(), \"File path should be assigned immediately.\");\n                assertNull(stream.getData(), \"Byte array should be null when writing directly to a file.\");\n            } catch (final IOException e) {\n                throw new java.io.UncheckedIOException(e);\n            }\n\n            final DeferrableOutputStream closedStream = streamHolder[0];\n            assertFalse(closedStream.isInMemory(), \"Closed stream should not be in-memory.\");\n            assertNotNull(closedStream.getPath(), \"File path should remain assigned after close.\");\n            assertTrue(Files.isRegularFile(closedStream.getPath()), \"Path should point to a regular file.\");\n\n            try (InputStream inputStream = closedStream.toInputStream()) {\n                final byte[] actualBytes = readAllBytes(inputStream);\n                final byte[] expectedBytes = \"\".getBytes(StandardCharsets.UTF_8);\n                assertArrayEquals(expectedBytes, actualBytes, \"File content should be empty.\");\n            } catch (final IOException e) {\n                throw new java.io.UncheckedIOException(e);\n            }\n        };\n\n        testLogic.run();\n    }\n}",
      "method_signature": "testThresholdMinusOne()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 16536,
    "output_tokens": 2312,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 138,
      "description": "Define a test method that validates the behavior of a Deferrable Output Stream configured with a zero-byte threshold by establishing a reusable testing lambda that encapsulates the complete lifecycle verification pattern, then exercising this pattern across three distinct write operation variants. Begin by declaring an array to capture stream references across lambda boundaries and construct a Consumer that accepts a write operation callback, where within a try-with-resources block you instantiate the Deferrable Output Stream with threshold zero, a path supplier field, and null listener, then immediately verify the stream reports in-memory status, null path, null byte array, and initialized state before invoking the provided write callback and subsequently confirming the stream has transitioned to file-backed storage with non-null path and null byte array. After the stream auto-closes, retrieve the captured stream reference and confirm it remains file-backed with a valid regular file at the reported path, then obtain an input stream from the closed Deferrable Output Stream and create a private helper method that reads all bytes from an input stream into a byte array by buffering through an intermediate byte array output stream, comparing the read content against the expected single-byte comma representation in UTF-8 encoding. Exercise this testing lambda three times by providing distinct write callbacks: first invoke the single-byte write method with the comma character integer value, second invoke the byte array write method with a single-element comma byte array, and third invoke the ranged byte array write method with a two-element array containing comma and dash bytes while specifying offset zero and length one to write only the comma. The test validates that regardless of write method variant, a zero threshold immediately triggers file persistence upon the first byte written, transitioning from initialized state directly to persisted state without an intermediate in-memory phase, and that the persisted file correctly contains the written data accessible after stream closure. This test uses JUnit 5 for test execution and standard JUnit assertions for state verification.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testThresholdZero()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamZeroThresholdTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link DeferrableOutputStream} when configured with a zero-byte threshold.\n * This test validates that writing even a single byte triggers immediate transition\n * from memory to file-based storage across different write methods.\n */\npublic class DeferrableOutputStreamZeroThresholdTest {\n\n    /**\n     * Defines a write operation that can be passed to the test logic and may throw\n     * an {@link IOException}.\n     */\n    @FunctionalInterface\n    private interface WriteOperation {\n        void perform(DeferrableOutputStream stream) throws IOException;\n    }\n\n    @TempDir\n    private static Path tempDir;\n\n    private final Supplier<Path> pathSupplier = () -> {\n        try {\n            return Files.createTempFile(tempDir, \"test-\", \".dat\");\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    };\n\n    /**\n     * Reads all bytes from an input stream into a byte array by buffering through an\n     * intermediate byte array output stream.\n     *\n     * @param inputStream The input stream to read.\n     * @return A new byte array containing the contents of the stream.\n     * @throws IOException If an I/O error occurs.\n     */\n    private byte[] readAllBytes(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final byte[] buffer = new byte[1024];\n        int len;\n        while ((len = inputStream.read(buffer)) != -1) {\n            baos.write(buffer, 0, len);\n        }\n        return baos.toByteArray();\n    }\n\n    @Test\n    public void testZeroThresholdLifecycleAcrossWriteVariants() {\n        final DeferrableOutputStream[] streamHolder = new DeferrableOutputStream[1];\n        final byte[] expectedCommaByte = \",\".getBytes(StandardCharsets.UTF_8);\n\n        // A reusable testing lambda that encapsulates the complete lifecycle verification pattern.\n        final Consumer<WriteOperation> testLifecyclePattern = writeCallback -> {\n            Path writtenFilePath = null;\n            try (DeferrableOutputStream stream = new DeferrableOutputStream(0, pathSupplier, null)) {\n                streamHolder[0] = stream;\n\n                // Verify initial state: in-memory, null path, and empty (initialized).\n                assertTrue(stream.isInMemory(), \"Stream should start in-memory.\");\n                assertNull(stream.getPath(), \"Stream path should be null before writing.\");\n                assertNotNull(stream.getData(), \"Initial data byte array should not be null.\");\n                assertEquals(0, stream.getData().length, \"Initial data byte array should be empty.\");\n\n                // Invoke the provided write callback, triggering the transition.\n                writeCallback.perform(stream);\n\n                // Confirm the stream has transitioned to file-backed storage.\n                assertFalse(stream.isInMemory(), \"Stream should be file-backed after write.\");\n                assertNotNull(stream.getPath(), \"Stream path should be non-null after transition.\");\n                writtenFilePath = stream.getPath();\n                assertNull(stream.getData(), \"Data byte array should be null when file-backed.\");\n\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n\n            // After auto-close, verify the stream remains file-backed and readable.\n            final DeferrableOutputStream closedStream = streamHolder[0];\n            assertFalse(closedStream.isInMemory(), \"Closed stream should remain file-backed.\");\n            assertTrue(Files.isRegularFile(closedStream.getPath()), \"Path should point to a regular file.\");\n\n            try (InputStream inputStream = closedStream.toInputStream()) {\n                final byte[] actualContent = readAllBytes(inputStream);\n                assertArrayEquals(expectedCommaByte, actualContent, \"File content mismatch.\");\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            } finally {\n                if (writtenFilePath != null) {\n                    try {\n                        Files.deleteIfExists(writtenFilePath);\n                    } catch (final IOException e) {\n                        // Suppress cleanup exception\n                    }\n                }\n            }\n        };\n\n        // Exercise the testing lambda with three distinct write operation variants.\n\n        // 1. Single-byte write method.\n        testLifecyclePattern.accept(stream -> stream.write(','));\n\n        // 2. Byte array write method.\n        testLifecyclePattern.accept(stream -> stream.write(new byte[]{','}));\n\n        // 3. Ranged byte array write method (writing only the comma).\n        testLifecyclePattern.accept(stream -> stream.write(new byte[]{',', '-'}, 0, 1));\n    }\n}",
      "method_signature": "testThresholdZero()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14828,
    "output_tokens": 9182,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 142,
      "description": "Create a test case to validate that the multipart stream processing system properly rejects configurations with insufficient processing capacity by preparing a sample data stream containing a short text payload and defining a stream boundary marker, then configuring the system to process this multipart content with an extremely limited processing capacity of only one unit, which is inadequate for handling the boundary detection requirements, and simultaneously attaching progress monitoring capabilities to track the expected data volume, then attempting to initialize the stream processor with these inadequate settings and verifying that the system immediately recognizes the insufficient capacity constraint and refuses to proceed by signaling an invalid configuration condition, thereby ensuring the system protects itself against configurations that would prevent proper boundary recognition and reliable stream parsing, with validation performed using JUnit 5 as the testing framework and standard assertion capabilities to confirm the expected rejection behavior occurs.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testSmallBuffer()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputInsufficientCapacityTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests that the multipart stream processing system properly rejects\n * configurations with insufficient processing capacity for boundary detection.\n */\npublic class MultipartInputInsufficientCapacityTest {\n\n    /**\n     * Validates that initializing a {@link MultipartInput} with a buffer size\n     * smaller than what is required to hold the boundary marker results in an\n     * {@link IllegalArgumentException}. This ensures the system protects itself\n     * against configurations that would prevent reliable stream parsing.\n     */\n    @Test\n    void testInsufficientProcessingCapacityRejection() {\n        // 1. Define a sample data stream and boundary marker.\n        final byte[] boundary = \"boundary\".getBytes(StandardCharsets.UTF_8);\n        final String requestPayload = \"--boundary\n\"\n                + \"Content-Disposition: form-data; name=\"field1\"\n\"\n                + \"\n\"\n                + \"value1\n\"\n                + \"--boundary--\n\";\n        final InputStream inputStream = new ByteArrayInputStream(requestPayload.getBytes(StandardCharsets.UTF_8));\n\n        // 2. Configure the system with an inadequate buffer size (e.g., 1 byte).\n        final int insufficientBufferSize = 1;\n\n        // 3. Verify that the constructor rejects the configuration.\n        // The check is boundary.length + boundary_prefix.length > buffer_size.\n        // The boundary \"boundary\" has length 8. The prefix \"--\" has length 2.\n        // We require a buffer of at least 10. A buffer of 1 is insufficient.\n        assertThrows(IllegalArgumentException.class, () -> {\n            // This constructor is package-private, so this test must be in the same package.\n            new MultipartInput(inputStream, boundary, insufficientBufferSize);\n        });\n    }\n}",
      "method_signature": "testSmallBuffer()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 21649,
    "output_tokens": 7820,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 145,
      "description": "Define a test class containing three private fields: a static final `Path` named `testDir`, a static `Path` named `tempTestDir`, and a non-static `Supplier<Path>` named `testFileSupplier`. Implement a static setup method annotated with `@BeforeAll` that invokes `Files.createDirectories(testDir)` to ensure the directory exists, then assigns the result of `Files.createTempDirectory(testDir, \"testDir\")` to `tempTestDir`. Within the test method annotated with `@Test`, declare a local variable `streams` as a `DeferrableOutputStream` array of size 1 using `new DeferrableOutputStream[1]`. Next, define a local variable `tester` of type `Runnable` initialized with a lambda expression that executes the following logic: open a try-with-resources block instantiating a `DeferrableOutputStream` named `dos` by invoking the constructor with arguments `-1`, `testFileSupplier`, and `null`, then immediately assign `dos` to `streams[0]`. Within the try block, invoke `dos.isInMemory()` and pass the result to `assertFalse`, then invoke `dos.getPath()` and pass the result to `assertNotNull`, and invoke `dos.getBytes()` and pass the result to `assertNull`. In the catch block for `IOException` named `ioe`, throw a new `UncheckedIOException` constructed with `ioe`. After the try-with-resources completes, declare a final variable `dos` of type `DeferrableOutputStream` and assign it the value `streams[0]`. Invoke `dos.isInMemory()` and pass the result to `assertFalse`, then invoke `dos.getPath()` and pass the result to `assertNotNull`. Invoke `Files.isRegularFile(dos.getPath())` and pass the result to `assertTrue`. Declare an uninitialized final `byte[]` variable named `actual`, then open a try-with-resources block declaring an `InputStream` named `is` initialized by invoking `dos.getInputStream()`. Within this try block, define a private method that creates a `ByteArrayOutputStream` named `baos`, declares a `byte[]` buffer of size 8192, enters an infinite loop invoking `pIs.read(buffer)` and assigning the result to an `int` variable `res`, returns `baos.toByteArray()` if `res` equals `-1`, otherwise invokes `baos.write(buffer, 0, res)` if `res` is greater than 0, and invoke this method with `is` as the argument, assigning the returned byte array to `actual`. In the catch block for `IOException` named `ioe`, throw a new `UncheckedIOException` constructed with `ioe`. After the try-with-resources, declare a final `byte[]` variable `expect` initialized by invoking `\"\".getBytes(StandardCharsets.UTF_8)`, then invoke `assertArrayEquals(expect, actual)`. Finally, after the lambda definition, invoke `tester.run()` to execute the test logic. The test uses JUnit 5 Assertions with method-level annotation `@Test` and no class-level annotations.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testThresholdMinusOne()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamThresholdTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.function.Supplier;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\npublic class DeferrableOutputStreamThresholdTest {\n\n    private static final Path testDir = Paths.get(\"target\");\n    private static Path tempTestDir;\n    private final Supplier<Path> testFileSupplier = () -> {\n        try {\n            return Files.createTempFile(tempTestDir, \"test\", \".dat\");\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    };\n\n    @BeforeAll\n    public static void beforeAll() throws IOException {\n        Files.createDirectories(testDir);\n        tempTestDir = Files.createTempDirectory(testDir, \"testDir\");\n    }\n\n    private byte[] toByteArray(final InputStream pIs) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final byte[] buffer = new byte[8192];\n        while (true) {\n            final int res = pIs.read(buffer);\n            if (res == -1) {\n                return baos.toByteArray();\n            }\n            if (res > 0) {\n                baos.write(buffer, 0, res);\n            }\n        }\n    }\n\n    @Test\n    public void testThreshold() {\n        final DeferrableOutputStream[] streams = new DeferrableOutputStream[1];\n        final Runnable tester = () -> {\n            try (final DeferrableOutputStream dos = new DeferrableOutputStream(-1, testFileSupplier, null)) {\n                streams[0] = dos;\n                assertFalse(dos.isInMemory());\n                assertNotNull(dos.getPath());\n                assertNull(dos.getBytes());\n            } catch (final IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n            final DeferrableOutputStream dos = streams[0];\n            assertFalse(dos.isInMemory());\n            assertNotNull(dos.getPath());\n            assertTrue(Files.isRegularFile(dos.getPath()));\n            final byte[] actual;\n            try (final InputStream is = dos.getInputStream()) {\n                actual = toByteArray(is);\n            } catch (final IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n            final byte[] expect = \"\".getBytes(StandardCharsets.UTF_8);\n            assertArrayEquals(expect, actual);\n        };\n        tester.run();\n    }\n}",
      "method_signature": "testThresholdMinusOne()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.96,
      "callable_precision": 0.96,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 0.8864,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 27270,
    "output_tokens": 3720,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 147,
      "description": "Define a test method that validates the behavior of a Deferrable Output Stream when exceeding a positive memory threshold by creating a reusable test harness implemented as a Consumer that accepts write operations, then invoke this harness three times with different write strategies to confirm consistent threshold-crossing behavior. Initialize a single-element array to capture the stream instance for post-closure verification, then define the test harness as a Consumer that constructs a Deferrable Output Stream with a threshold of 5 bytes and a path supplier for temporary file creation. Upon stream creation, verify the stream reports in-memory status, returns null for both file path and byte array accessors, and reflects an initialized state. Write four bytes individually using the single-byte write method, confirming after each write that the state transitions to opened while maintaining in-memory status with null path and byte array values. Pass the stream to the provided write operation Consumer to trigger the threshold-crossing write, then verify the stream transitions to file-backed storage by confirming it no longer reports in-memory status, now returns a non-null file path, and still returns null for the byte array accessor since data resides on disk. After the stream closes via try-with-resources, retrieve the captured stream instance from the array and confirm it remains in file-backed state with a non-null path that references a regular file on the filesystem. Obtain an input stream from the closed Deferrable Output Stream and create a private helper method that reads all bytes from an input stream into a byte array by buffering chunks until end-of-stream, then use this helper to extract the written content. Convert the expected content string to a byte array and assert the actual bytes match the expected sequence of four dots followed by a comma. Invoke the test harness with a Consumer that writes a single comma byte using the single-byte write method to cross the threshold, then invoke it again with a Consumer that writes a single-element byte array containing a comma using the array write method, and finally invoke it with a Consumer that writes the first byte from a two-element byte array using the bounded array write method with offset zero and length one, ensuring all three write strategies produce identical threshold-crossing behavior and file persistence outcomes using JUnit 5 assertions.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testExceedPositiveThreshold()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamThresholdCrossingTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Comparator;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link DeferrableOutputStream} behavior when a positive memory threshold is exceeded.\n */\npublic class DeferrableOutputStreamThresholdCrossingTest {\n\n    private static Path tempDir;\n\n    @BeforeAll\n    public static void beforeAll() throws IOException {\n        tempDir = Files.createTempDirectory(DeferrableOutputStreamThresholdCrossingTest.class.getSimpleName());\n    }\n\n    @AfterAll\n    public static void afterAll() throws IOException {\n        if (tempDir != null) {\n            try (final Stream<Path> stream = Files.walk(tempDir)) {\n                stream.sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);\n            }\n        }\n    }\n\n    private final Supplier<Path> pathSupplier = () -> {\n        try {\n            return Files.createTempFile(tempDir, \"test-\", \".dat\");\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    };\n\n    private byte[] readAllBytes(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final byte[] buffer = new byte[8192];\n        int n;\n        while ((n = inputStream.read(buffer)) != -1) {\n            baos.write(buffer, 0, n);\n        }\n        return baos.toByteArray();\n    }\n\n    @Test\n    public void testThresholdCrossingBehavior() {\n        final DeferrableOutputStream[] streamHolder = new DeferrableOutputStream[1];\n\n        final Consumer<Consumer<DeferrableOutputStream>> testHarness = writeOperation -> {\n            try (final DeferrableOutputStream dos = new DeferrableOutputStream(5, pathSupplier, null)) {\n                streamHolder[0] = dos;\n\n                // 1. Initial state: In-memory, no file path, null byte array\n                assertTrue(dos.isInMemory(), \"Stream should be in-memory initially.\");\n                assertNull(dos.getPath(), \"Path should be null for in-memory stream.\");\n                assertNull(dos.getBytes(), \"Bytes should be null for an initialized stream.\");\n\n                // 2. Write 4 bytes, remain in memory\n                for (int i = 0; i < 4; i++) {\n                    dos.write('.');\n                    assertTrue(dos.isInMemory(), \"Stream should remain in-memory before threshold.\");\n                    assertNull(dos.getPath(), \"Path should be null before threshold.\");\n                    assertNull(dos.getBytes(), \"Bytes should be null before threshold.\");\n                }\n\n                // 3. Trigger threshold-crossing write\n                writeOperation.accept(dos);\n\n                // 4. Verify transition to file-backed\n                assertFalse(dos.isInMemory(), \"Stream should be file-backed after threshold.\");\n                assertNotNull(dos.getPath(), \"Path should not be null after threshold.\");\n                assertNull(dos.getBytes(), \"Bytes should be null for file-backed stream.\");\n\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n\n            // 5. Post-closure verification\n            final DeferrableOutputStream closedStream = streamHolder[0];\n            assertNotNull(closedStream, \"Stream should be captured.\");\n            assertFalse(closedStream.isInMemory(), \"Closed stream should remain file-backed.\");\n            final Path filePath = closedStream.getPath();\n            assertNotNull(filePath, \"Path of closed stream should not be null.\");\n            assertTrue(Files.isRegularFile(filePath), \"Path should point to a regular file.\");\n\n            // 6. Verify content\n            final byte[] actualBytes;\n            try (final InputStream is = closedStream.getInputStream()) {\n                actualBytes = readAllBytes(is);\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n\n            final byte[] expectedBytes = \"....,\".getBytes(StandardCharsets.UTF_8);\n            assertArrayEquals(expectedBytes, actualBytes, \"File content should match expected bytes.\");\n        };\n\n        // Invoke harness with 3 different write strategies to cross the threshold\n        final Consumer<DeferrableOutputStream> singleByteWrite = dos -> {\n            try {\n                dos.write(',');\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n        testHarness.accept(singleByteWrite);\n\n        final Consumer<DeferrableOutputStream> byteArrayWrite = dos -> {\n            try {\n                dos.write(new byte[] { ',' });\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n        testHarness.accept(byteArrayWrite);\n\n        final Consumer<DeferrableOutputStream> boundedArrayWrite = dos -> {\n            try {\n                dos.write(new byte[] { ',', '!' }, 0, 1);\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n        testHarness.accept(boundedArrayWrite);\n    }\n}",
      "method_signature": "testExceedPositiveThreshold()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 0.8667,
      "assertion_precision": 0.9286,
      "callable_recall": 0.8077,
      "callable_precision": 0.8936,
      "focal_recall": 1.0,
      "focal_precision": 0.6
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.9167,
      "line_coverage": 0.9851,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 21441,
    "output_tokens": 8180,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 148,
      "description": "Define a test method that validates the Multipart Input Builder's rejection of insufficient buffer sizes by first preparing test data consisting of a short string and converting both the string and the class-level boundary constant to byte arrays, then wrapping the string bytes in a Byte Array Input Stream to serve as the data source. Obtain a new Multipart Input Builder instance and configure it by chaining the input stream setter, boundary setter, buffer size setter with a value of one byte, and progress notifier setter with a newly constructed Progress Notifier initialized with null listener and the content length derived from the byte array, then invoke the builder's get method to attempt construction of the Multipart Input instance. Assert that this construction attempt throws an Illegal Argument Exception, confirming that the builder enforces minimum buffer size constraints when the specified buffer is too small to accommodate the boundary token plus required overhead bytes. The test uses JUnit 5 for the assertion framework.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testSmallBuffer()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputBuilderTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\nimport org.apache.commons.fileupload2.core.MultipartInput;\nimport org.apache.commons.fileupload2.core.ProgressListener;\nimport org.apache.commons.fileupload2.core.ProgressNotifier;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link MultipartInput.Builder}.\n */\nclass MultipartInputBuilderTest {\n\n    /**\n     * A boundary which is deliberately simple. The test description\n     * mentions a \"class-level boundary constant\", but since the test is about buffer size,\n     * any boundary longer than the buffer will suffice.\n     */\n    private static final String BOUNDARY = \"---1234\";\n\n    @Test\n    void testRejectsInsufficientBufferSize() {\n        final String testData = \"some data\";\n        final byte[] dataBytes = testData.getBytes(StandardCharsets.UTF_8);\n        final byte[] boundaryBytes = BOUNDARY.getBytes(StandardCharsets.UTF_8);\n        final InputStream inputStream = new ByteArrayInputStream(dataBytes);\n        final long contentLength = dataBytes.length;\n\n        final MultipartInput.Builder builder = new MultipartInput.Builder();\n\n        // The test description specifies creating a ProgressNotifier with a null listener and the content length.\n        // We assume the existence of a ProgressNotifier class that takes a ProgressListener and content length.\n        final ProgressListener notifier = new ProgressNotifier(null, contentLength);\n\n        builder.setInputStream(inputStream)\n               .setBoundary(boundaryBytes)\n               .setBufferSize(1)\n               .setProgressListener(notifier);\n\n        // The builder should throw an exception because the buffer size (1) is too small\n        // to hold the boundary token plus overhead.\n        assertThrows(IllegalArgumentException.class, builder::get);\n    }\n}",
      "method_signature": "testSmallBuffer()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 21320,
    "output_tokens": 7188,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 152,
      "description": "Create a test case to validate that the system enforces size restrictions on metadata sections when processing multi-part file upload requests. Prepare a simulated upload request containing two file submissions, each with associated metadata headers, and configure the upload processor with a maximum metadata size limit of 100 bytes per file part. Initiate processing of the request by skipping any preamble content and entering a loop to process each file part sequentially. For each part encountered, attempt to extract the metadata headers and confirm their presence, then process the file content itself before advancing to the next part boundary. Expect the system to reject the request with a size violation error during this processing, as the metadata for one of the file parts exceeds the configured limit. When the size violation occurs, verify that the error reports the correct permitted size threshold of 100 bytes, confirming the system properly enforces metadata size constraints to protect against oversized header attacks. If processing completes without triggering the expected size violation, the test should fail to indicate that the enforcement mechanism is not functioning correctly. Verify using standard equality assertions with JUnit 5 and confirm the appropriate business failure condition is raised when metadata limits are exceeded.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testPartHeaderSizeMaxLimit()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.FileUploadHeaderSizeLimitTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests that the system enforces size restrictions on metadata sections when processing multi-part file upload requests.\n */\npublic class FileUploadHeaderSizeLimitTest {\n\n    @Test\n    public void testHeaderSizeViolation() throws IOException {\n        final String boundary = \"----WebKitFormBoundary7MA4YWxkTrZu0gW\";\n        // This header line is intentionally longer than the 100-byte limit.\n        final String longHeader = \"X-Some-Metadata: \" + \"a\".repeat(80) + \"\n\";\n\n        final String requestBody =\n            \"--\" + boundary + \"\n\" +\n            \"Content-Disposition: form-data; name=\"file1\"; filename=\"file1.txt\"\n\" +\n            \"Content-Type: text/plain\n\" +\n            \"\n\" +\n            \"file content 1\n\" +\n            \"--\" + boundary + \"\n\" +\n            \"Content-Disposition: form-data; name=\"file2\"; filename=\"file2.txt\"\n\" +\n            longHeader + // This part's headers exceed the size limit\n            \"Content-Type: text/plain\n\" +\n            \"\n\" +\n            \"file content 2\n\" +\n            \"--\" + boundary + \"--\n\";\n\n        final byte[] requestBytes = requestBody.getBytes(StandardCharsets.UTF_8);\n\n        final AbstractRequestContext requestContext = new AbstractRequestContext() {\n            @Override\n            public String getCharacterEncoding() {\n                return StandardCharsets.UTF_8.name();\n            }\n\n            @Override\n            public String getContentType() {\n                return \"multipart/form-data; boundary=\" + boundary;\n            }\n\n            @Override\n            public long getContentLength() {\n                return requestBytes.length;\n            }\n\n            @Override\n            public InputStream getInputStream() {\n                return new ByteArrayInputStream(requestBytes);\n            }\n        };\n\n        final DiskFileItemFactory factory = new DiskFileItemFactory.Builder().get();\n        final AbstractFileUpload<DiskFileItem, DiskFileItemFactory> fileUpload = new AbstractFileUpload<>() {\n            @Override\n            public DiskFileItemFactory getFileItemFactory() {\n                return factory;\n            }\n        };\n\n        fileUpload.setHeaderSizeMax(100);\n\n        try {\n            final FileItemInputIterator iterator = fileUpload.getItemIterator(requestContext);\n            // Skip preamble and process first part\n            assertTrue(iterator.hasNext(), \"Should have first part\");\n            final FileItemInput fileItemInput1 = iterator.next();\n            assertNotNull(fileItemInput1.getHeaders(), \"First part headers should be present\");\n            // Process the content\n            try (final InputStream stream = fileItemInput1.getInputStream()) {\n                stream.readAllBytes();\n            }\n\n            // Attempt to process the second part, which has oversized headers\n            assertTrue(iterator.hasNext(), \"Should have second part\");\n\n            final FileUploadByteCountLimitException ex = assertThrows(\n                FileUploadByteCountLimitException.class,\n                iterator::next,\n                \"Processing should fail due to oversized metadata\"\n            );\n\n            // Verify the exception reports the correct size limit\n            assertEquals(100, ex.getPermitted(), \"Exception should report the configured permitted size\");\n\n        } catch (final FileUploadException e) {\n            fail(\"Unexpected FileUploadException\", e);\n        }\n    }\n}",
      "method_signature": "testPartHeaderSizeMaxLimit()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19454,
    "output_tokens": 7146,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 155,
      "description": "Define a test class containing a static final field `BOUNDARY_TEXT` of type `String`, then write a test method annotated with `@Test` that begins by assigning the String literal `\"foobar\"` to a local variable `strData`, immediately invoking `getBytes()` on `strData` to produce a byte array assigned to `contents`, constructing a `ByteArrayInputStream` by passing `contents` to its constructor and assigning the result to a variable `input` of type `InputStream`, invoking `getBytes()` on the field `BOUNDARY_TEXT` to produce a byte array assigned to `boundary`, and assigning the integer literal `1` to a variable `iBufSize`. With these variables prepared, invoke `assertThrows` passing `IllegalArgumentException.class` as the first argument and a lambda expression as the second argument, where the lambda invokes `MultipartInput.builder()` to obtain a builder instance, chains `setInputStream` passing `input`, chains `setBoundary` passing `boundary`, chains `setBufferSize` passing `iBufSize`, chains `setProgressNotifier` passing a newly constructed `MultipartInput.ProgressNotifier` instance created by invoking its constructor with arguments `null` and `contents.length`, and finally chains `get()` to trigger the builder's construction logic, thereby verifying that the builder throws `IllegalArgumentException` when the buffer size is too small. The test uses JUnit 5 Assertions via the `@Test` annotation and the `assertThrows` method.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testSmallBuffer()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputBuilderTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests the builder for {@link MultipartInput}.\n */\npublic class MultipartInputBuilderTest {\n\n    private static final String BOUNDARY_TEXT = \"---1234\";\n\n    @Test\n    public void testSmallBufferThrowsIllegalArgumentException() {\n        final String strData = \"foobar\";\n        final byte[] contents = strData.getBytes();\n        final InputStream input = new ByteArrayInputStream(contents);\n        final byte[] boundary = BOUNDARY_TEXT.getBytes();\n        final int iBufSize = 1;\n\n        assertThrows(IllegalArgumentException.class, () ->\n            MultipartInput.builder()\n                .setInputStream(input)\n                .setBoundary(boundary)\n                .setBufferSize(iBufSize)\n                .setProgressNotifier(new MultipartInput.ProgressNotifier(null, contents.length))\n                .get()\n        );\n    }\n}",
      "method_signature": "testSmallBuffer()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.5,
      "method_coverage": 0.5,
      "line_coverage": 0.7826,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 31203,
    "output_tokens": 1972,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 157,
      "description": "Define a test class containing three private fields: a static final `Path` named `testDir`, a static `Path` named `tempTestDir`, and a `Supplier<Path>` named `testFileSupplier`. Implement a static setup method annotated with `@BeforeAll` that invokes `Files.createDirectories(testDir)` and assigns the result of `Files.createTempDirectory(testDir, \"testDir\")` to `tempTestDir`. In the test method annotated with `@Test`, declare a `DeferrableOutputStream` array named `streams` with length `1`. Define a `Consumer<Consumer<OutputStream>>` variable named `tester` initialized with a lambda that accepts a `Consumer<OutputStream>` parameter named `consumer`, and within this lambda's body, open a try-with-resources block that instantiates a `DeferrableOutputStream` named `dos` by passing arguments `0`, `testFileSupplier`, and `null` to the constructor, then assign `dos` to `streams[0]`, invoke `assertTrue(dos.isInMemory())`, invoke `assertNull(dos.getPath())`, invoke `assertNull(dos.getBytes())`, invoke `assertSame(State.initialized, dos.getState())`, invoke `consumer.accept(dos)`, invoke `assertFalse(dos.isInMemory())`, invoke `assertNotNull(dos.getPath())`, and invoke `assertNull(dos.getBytes())`, catching any `IOException` named `ioe` and rethrowing it wrapped in a new `UncheckedIOException(ioe)`. After the try-with-resources block, assign `streams[0]` to a final `DeferrableOutputStream` variable named `dos`, invoke `assertFalse(dos.isInMemory())`, invoke `assertNotNull(dos.getPath())`, invoke `assertTrue(Files.isRegularFile(dos.getPath()))`, declare a `byte[]` variable named `actual` without initialization, open a try-with-resources block that invokes `dos.getInputStream()` and assigns the result to an `InputStream` variable named `is`, then define a private method that accepts an `InputStream` parameter, creates a `ByteArrayOutputStream` named `baos`, declares a `byte[]` named `buffer` initialized to `new byte[8192]`, enters an infinite loop that invokes `pIs.read(buffer)` and assigns the result to an `int` variable named `res`, returns `baos.toByteArray()` if `res` equals `-1`, otherwise invokes `baos.write(buffer, 0, res)` if `res` is greater than `0`, and invoke this method with `is` to assign the result to `actual`, catching any `IOException` named `ioe` and rethrowing it wrapped in a new `UncheckedIOException(ioe)`. After the try-with-resources block, declare a `byte[]` variable named `expect` initialized to `\",\".getBytes(StandardCharsets.UTF_8)` and invoke `assertArrayEquals(expect, actual)`. Following the `tester` definition, invoke `tester.accept` with a lambda that accepts an `OutputStream` parameter named `os`, and within a try block invoke `os.write(',')` (the character literal for comma), catching any `IOException` named `ioe` and rethrowing it wrapped in a new `UncheckedIOException(ioe)`. Next, invoke `tester.accept` again with a lambda that accepts an `OutputStream` parameter named `os`, declares a `byte[]` variable named `buffer` initialized to `new byte[] { ',' }`, and within a try block invokes `os.write(buffer)`, catching any `IOException` named `ioe` and rethrowing it wrapped in a new `UncheckedIOException(ioe)`. Finally, invoke `tester.accept` a third time with a lambda that accepts an `OutputStream` parameter named `os`, declares a `byte[]` variable named `buffer` initialized to `new byte[] { ',', '-' }`, and within a try block invokes `os.write(buffer, 0, 1)`, catching any `IOException` named `ioe` and rethrowing it wrapped in a new `UncheckedIOException(ioe)`. The test uses method-level annotation `@Test`, assertion libraries JUnit 5 Assertions, and no mocking libraries.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testThresholdZero()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest1",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.fileupload2.core.DeferrableOutputStream.State;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link DeferrableOutputStream}.\n */\npublic class DeferrableOutputStreamTest1 {\n\n    private static final Path testDir = Path.of(\"target\", \"DeferrableOutputStreamTest\");\n    private static Path tempTestDir;\n\n    private final Supplier<Path> testFileSupplier = () -> {\n        try {\n            return Files.createTempFile(tempTestDir, \"test\", \".tmp\");\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    };\n\n    @BeforeAll\n    static void setup() throws IOException {\n        Files.createDirectories(testDir);\n        tempTestDir = Files.createTempDirectory(testDir, \"testDir\");\n    }\n\n    private byte[] toByteArray(final InputStream pIs) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final byte[] buffer = new byte[8192];\n        while (true) {\n            final int res = pIs.read(buffer);\n            if (res == -1) {\n                return baos.toByteArray();\n            }\n            if (res > 0) {\n                baos.write(buffer, 0, res);\n            }\n        }\n    }\n\n    @Test\n    public void testWrite() {\n        final DeferrableOutputStream[] streams = new DeferrableOutputStream[1];\n        final Consumer<Consumer<OutputStream>> tester = consumer -> {\n            try (final DeferrableOutputStream dos = new DeferrableOutputStream(0, testFileSupplier, null)) {\n                streams[0] = dos;\n                assertTrue(dos.isInMemory());\n                assertNull(dos.getPath());\n                assertNull(dos.getBytes());\n                assertSame(State.initialized, dos.getState());\n                consumer.accept(dos);\n                assertFalse(dos.isInMemory());\n                assertNotNull(dos.getPath());\n                assertNull(dos.getBytes());\n            } catch (final IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n            final DeferrableOutputStream dos = streams[0];\n            assertFalse(dos.isInMemory());\n            assertNotNull(dos.getPath());\n            assertTrue(Files.isRegularFile(dos.getPath()));\n            final byte[] actual;\n            try (final InputStream is = dos.getInputStream()) {\n                actual = toByteArray(is);\n            } catch (final IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n            final byte[] expect = \",\".getBytes(StandardCharsets.UTF_8);\n            assertArrayEquals(expect, actual);\n        };\n\n        tester.accept(os -> {\n            try {\n                os.write(',');\n            } catch (final IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n        });\n\n        tester.accept(os -> {\n            final byte[] buffer = { ',' };\n            try {\n                os.write(buffer);\n            } catch (final IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n        });\n\n        tester.accept(os -> {\n            final byte[] buffer = { ',', '-' };\n            try {\n                os.write(buffer, 0, 1);\n            } catch (final IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n        });\n    }\n}",
      "method_signature": "testThresholdZero()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.9762,
      "callable_precision": 0.9762,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 0.9275,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19629,
    "output_tokens": 6304,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 169,
      "description": "Define a test class containing three private fields: a static final `Path` named `testDir`, a static `Path` named `tempTestDir`, and an instance `Supplier<Path>` named `testFileSupplier`. Implement a static setup method annotated with `@BeforeAll` that invokes `Files.createDirectories(testDir)` and assigns the result of `Files.createTempDirectory(testDir, \"testDir\")` to `tempTestDir`. Within the test method, declare a local variable `streams` as a `DeferrableOutputStream` array of length `1`, then define a local variable `tester` of type `Consumer<Consumer<OutputStream>>` initialized with a lambda expression accepting parameter `consumer`. Inside the lambda body, open a try-with-resources block declaring `dos` as a new `DeferrableOutputStream` constructed with arguments `5`, `testFileSupplier`, and `null`, then assign `dos` to `streams[0]`. Immediately invoke `assertTrue(dos.isInMemory())`, followed by `assertNull(dos.getPath())`, `assertNull(dos.getBytes())`, and `assertSame(State.initialized, dos.getState())`. Enter a for loop with `int i = 0`, condition `i < 4`, and increment `i++`, where each iteration wraps `dos.write('.')` in a try-catch block that catches `IOException` and rethrows it as `new UncheckedIOException(ioe)`, then after each write invokes `assertSame(State.opened, dos.getState())`, `assertTrue(dos.isInMemory())`, `assertNull(dos.getPath())`, and `assertNull(dos.getBytes())`. After the loop completes, invoke `consumer.accept(dos)`, then assert `assertFalse(dos.isInMemory())`, `assertNotNull(dos.getPath())`, and `assertNull(dos.getBytes())`. Close the try-with-resources block with a catch clause for `IOException` that rethrows as `new UncheckedIOException(ioe)`. Outside the try block, assign `streams[0]` to a new local variable `dos`, then invoke `assertFalse(dos.isInMemory())`, `assertNotNull(dos.getPath())`, and `assertTrue(Files.isRegularFile(dos.getPath()))`. Declare a local `byte[]` variable `actual` without initialization, then open a try-with-resources block declaring `is` as the result of `dos.getInputStream()`. Within this block, define a private method that creates a `ByteArrayOutputStream` named `baos`, declares a `byte[]` buffer of size `8192`, enters an infinite for loop that invokes `pIs.read(buffer)` and assigns the result to `int res`, returns `baos.toByteArray()` if `res == -1`, otherwise invokes `baos.write(buffer, 0, res)` if `res > 0`, and invoke this method passing `is` to assign the result to `actual`, catching `IOException` and rethrowing as `new UncheckedIOException(ioe)`. After the try block, declare `expect` as `\"....,\".getBytes(StandardCharsets.UTF_8)` and invoke `assertArrayEquals(expect, actual)`. Having defined the `tester` lambda, invoke `tester.accept` three times with distinct lambda arguments: first, pass a lambda accepting `os` that wraps `os.write(',')` in a try-catch rethrowing `IOException` as `UncheckedIOException`; second, pass a lambda that declares `buffer` as `new byte[] { ',' }`, then wraps `os.write(buffer)` in a try-catch rethrowing `IOException` as `UncheckedIOException`; third, pass a lambda that declares `buffer` as `new byte[] { ',', '-' }`, then wraps `os.write(buffer, 0, 1)` in a try-catch rethrowing `IOException` as `UncheckedIOException`. The test uses JUnit 5 Assertions with method-level annotation `@Test` and class-level setup annotation `@BeforeAll`.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamTest",
      "method_signature": "testExceedPositiveThreshold()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DeferrableOutputStreamThresholdTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.fileupload2.core.DeferrableOutputStream.State;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link DeferrableOutputStream}.\n */\npublic class DeferrableOutputStreamThresholdTest {\n\n    private static final Path testDir = Path.of(\"target\", \"DeferrableOutputStreamThresholdTest\");\n    private static Path tempTestDir;\n\n    private final Supplier<Path> testFileSupplier = () -> {\n        try {\n            return Files.createTempFile(tempTestDir, \"test\", \".tmp\");\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    };\n\n    @BeforeAll\n    static void setup() throws IOException {\n        Files.createDirectories(testDir);\n        tempTestDir = Files.createTempDirectory(testDir, \"testDir\");\n    }\n\n    private byte[] toByteArray(final InputStream pIs) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final byte[] buffer = new byte[8192];\n        for (;;) {\n            final int res = pIs.read(buffer);\n            if (res == -1) {\n                return baos.toByteArray();\n            }\n            if (res > 0) {\n                baos.write(buffer, 0, res);\n            }\n        }\n    }\n\n    @Test\n    void testWriteWithThreshold() {\n        final DeferrableOutputStream[] streams = new DeferrableOutputStream[1];\n        final Consumer<Consumer<OutputStream>> tester = consumer -> {\n            try (final DeferrableOutputStream dos = new DeferrableOutputStream(5, testFileSupplier, null)) {\n                streams[0] = dos;\n                assertTrue(dos.isInMemory());\n                assertNull(dos.getPath());\n                assertNull(dos.getBytes());\n                assertSame(State.initialized, dos.getState());\n\n                for (int i = 0; i < 4; i++) {\n                    try {\n                        dos.write('.');\n                    } catch (final IOException ioe) {\n                        throw new UncheckedIOException(ioe);\n                    }\n                    assertSame(State.opened, dos.getState());\n                    assertTrue(dos.isInMemory());\n                    assertNull(dos.getPath());\n                    assertNull(dos.getBytes());\n                }\n\n                consumer.accept(dos);\n                assertFalse(dos.isInMemory());\n                assertNotNull(dos.getPath());\n                assertNull(dos.getBytes());\n            } catch (final IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n\n            final DeferrableOutputStream dos = streams[0];\n            assertFalse(dos.isInMemory());\n            assertNotNull(dos.getPath());\n            assertTrue(Files.isRegularFile(dos.getPath()));\n\n            byte[] actual;\n            try (final InputStream is = dos.getInputStream()) {\n                actual = toByteArray(is);\n            } catch (final IOException ioe) {\n                throw new UncheckedIOException(ioe);\n            }\n\n            final byte[] expect = \"....,\".getBytes(StandardCharsets.UTF_8);\n            assertArrayEquals(expect, actual);\n        };\n\n        tester.accept(os -> {\n            try {\n                os.write(',');\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        });\n\n        tester.accept(os -> {\n            final byte[] buffer = { ',' };\n            try {\n                os.write(buffer);\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        });\n\n        tester.accept(os -> {\n            final byte[] buffer = { ',', '-' };\n            try {\n                os.write(buffer, 0, 1);\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        });\n    }\n}",
      "method_signature": "testExceedPositiveThreshold()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.9808,
      "callable_precision": 0.9808,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 0.9306,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 51015,
    "output_tokens": 7098,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 185,
      "description": "Create a test case to validate that the multipart data processing system can be properly configured and initialized with all essential operational parameters when using the comprehensive configuration approach. Begin by preparing sample content data as a stream source, then convert a predefined boundary marker into its binary representation suitable for stream parsing. Calculate the minimum buffer capacity required to safely accommodate the boundary marker along with its protocol prefix characters and at least one data byte, ensuring efficient stream processing without performance degradation. Configure the multipart processing system by specifying the input data stream, the boundary marker for partitioning the content, the calculated buffer capacity, and a progress tracking mechanism initialized without an active listener but aware of the total expected content size. Once the system is fully configured, construct the multipart processor and verify that the initialization completed successfully, confirming the system is ready to parse multipart formatted data streams. Validate using standard equality assertions with JUnit 5 as the testing framework and AssertJ for assertion capabilities.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testThreeParamConstructor()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests {@link MultipartInput}.\n */\npublic class MultipartInputTest {\n\n    @Test\n    public void testComprehensiveConfiguration() {\n        // Prepare sample content data as a stream source.\n        final String sampleData = \"--myBoundary\\\\r\\\\nContent-Disposition: form-data; name=\\\\\\\"field1\\\\\\\"\\\\r\\\\n\\\\r\\\\nvalue1\\\\r\\\\n--myBoundary--\";\n        final byte[] sampleBytes = sampleData.getBytes(StandardCharsets.UTF_8);\n        final InputStream dataStream = new ByteArrayInputStream(sampleBytes);\n        final long contentLength = sampleBytes.length;\n\n        // Convert a predefined boundary marker into its binary representation.\n        final String boundaryString = \"myBoundary\";\n        final byte[] boundary = boundaryString.getBytes(StandardCharsets.UTF_8);\n\n        // Calculate the minimum buffer capacity.\n        final int bufferSize = boundary.length + 4 + 1; // 4 bytes for \\\\r\\\\n--\n\n        // Configure the multipart processing system.\n        final MultipartInput.Builder builder = MultipartInput.builder()\n                .setBoundary(boundary)\n                .setBufferSize(bufferSize)\n                .setProgressListener(null)\n                .setContentLength(contentLength);\n\n        // Construct the multipart processor.\n        final MultipartInput multipartInput = builder.build(dataStream);\n\n        // Verify that the initialization completed successfully.\n        assertThat(multipartInput).isNotNull();\n    }\n}",
      "method_signature": "testThreeParamConstructor()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 187,
      "description": "Define a test method that validates the construction of a Multipart Input Stream using a builder pattern with three essential parameters: an input stream, a boundary byte array, and a buffer size. Begin by preparing a sample data string and converting it to a byte array to serve as the content source, then wrap this byte array in a ByteArrayInputStream to simulate streaming input. Convert the boundary text constant to a byte array, then calculate the required buffer size by summing the boundary array length, the Multipart Input's boundary prefix length, and an additional byte. Using the Multipart Input Builder, configure the builder by chaining calls to set the input stream, boundary array, and calculated buffer size, then attach a Progress Notifier initialized with a null listener and the content byte array length as the expected size. Invoke the builder's get method to construct the Multipart Input instance and capture the result. Assert that the constructed Multipart Input instance is not null to confirm successful instantiation. This test uses JUnit 5 for the testing framework and standard JUnit assertions.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testThreeParamConstructor()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\nimport org.apache.commons.fileupload2.core.AbstractFileUpload.ProgressListener;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link MultipartInput}.\n */\npublic class MultipartInputTest {\n\n    /**\n     * Test method for\n     * {@link org.apache.commons.fileupload2.core.MultipartInput.Builder#get()}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testMultipartStreamBuilder() throws IOException {\n        final String content = \"some data\";\n        final byte[] contentBytes = content.getBytes(StandardCharsets.UTF_8);\n        final InputStream inputStream = new ByteArrayInputStream(contentBytes);\n\n        final String boundaryText = \"boundary\";\n        final byte[] boundary = boundaryText.getBytes(StandardCharsets.UTF_8);\n\n        final int bufferSize = boundary.length + MultipartInput.BOUNDARY_PREFIX.length + 1;\n\n        final ProgressNotifier progressNotifier = new ProgressNotifier((ProgressListener) null, contentBytes.length);\n\n        final MultipartInput multipartInput = new MultipartInput.Builder().setInputStream(inputStream).setBoundary(boundary)\n                .setBufferSize(bufferSize).setProgressListener(progressNotifier).get();\n\n        assertNotNull(multipartInput);\n    }\n}",
      "method_signature": "testThreeParamConstructor()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1,
          "run_shell_command": 2,
          "read_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 75087,
    "output_tokens": 8419,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 207,
      "description": "Define a test method that validates the enforcement of the maximum part header size limit when processing multipart stream data by constructing a multipart request string containing two file parts with headers and body content, then converting this request string to a byte array using UTF-8 encoding and wrapping it in a ByteArrayInputStream to simulate an incoming data stream. Configure a boundary byte array from a boundary marker string, then use the MultipartInput Builder to construct a MultipartInput instance by chaining setInputStream with the byte array input stream, setBoundary with the boundary bytes, and setMaxPartHeaderSize with a limit of 100 bytes before invoking get to obtain the configured instance. Assert that the resulting MultipartInput instance is not null to confirm successful initialization. Within a try block, invoke skipPreamble on the MultipartInput instance to advance past any preamble content and capture the boolean result indicating whether an encapsulation was found, then enter a while loop that continues as long as additional parts are detected. Inside the loop, call readHeaders on the MultipartInput instance to retrieve the header content as a string, print the header length and content to standard output for diagnostic purposes, and assert that the headers string is not null to verify successful header retrieval. After processing headers, invoke readBodyData on the MultipartInput instance with a null output stream to consume the body content without storing it, then call readBoundary to advance to the next part boundary and update the loop continuation flag. If the loop completes without throwing an exception, invoke fail with a message indicating that an expected exception was not raised, thereby signaling test failure. In the catch block for FileUploadSizeException, assert that the exception's permitted size value equals 100 by calling getPermitted on the caught exception, thereby confirming that the size limit enforcement triggered correctly when header size exceeded the configured maximum. This test uses JUnit for assertions and exception handling.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testPartHeaderSizeMaxLimit()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link MultipartInput}.\n */\npublic class MultipartInputTest {\n\n    @Test\n    public void testMaxPartHeaderSize() throws IOException {\n        final String boundary = \"----1234\";\n        final String requestString =\n            \"--\" + boundary + \"\\r\\n\" +\n            \"Content-Disposition: form-data; name=\\\"file1\\\"; filename=\\\"file1.txt\\\"\\r\\n\" +\n            \"Content-Type: text/plain\\r\\n\" +\n            \"\\r\\n\" +\n            \"Hello\\r\\n\" +\n            \"--\" + boundary + \"\\r\\n\" +\n            \"Content-Disposition: form-data; name=\\\"file2\\\"; filename=\\\"file2.txt\\\"\\r\\n\" +\n            \"Content-Type: text/plain\\r\\n\" +\n            \"A-Very-Long-Header-Name-To-Exceed-The-Size-Limit-Of-100-Bytes: and-a-correspondingly-long-value-just-to-be-sure\\r\\n\" +\n            \"\\r\\n\" +\n            \"World\\r\\n\" +\n            \"--\" + boundary + \"--\\r\\n\";\n\n        final byte[] requestBytes = requestString.getBytes(StandardCharsets.UTF_8);\n        final ByteArrayInputStream inputStream = new ByteArrayInputStream(requestBytes);\n        final byte[] boundaryBytes = boundary.getBytes(StandardCharsets.UTF_8);\n\n        final MultipartInput multi = MultipartInput.builder()\n                .setInputStream(inputStream)\n                .setBoundary(boundaryBytes)\n                .setMaxPartHeaderSize(100)\n                .get();\n\n        assertNotNull(multi, \"MultipartInput instance should not be null\");\n\n        try {\n            boolean nextPart = multi.skipPreamble();\n            while (nextPart) {\n                final String headers = multi.readHeaders();\n                System.out.println(\"Header length: \" + headers.length());\n                System.out.println(\"Headers: \" + headers);\n                assertNotNull(headers, \"Headers string should not be null\");\n                multi.readBodyData(null);\n                nextPart = multi.readBoundary();\n            }\n            fail(\"Expected FileUploadSizeException was not thrown.\");\n        } catch (final FileUploadSizeException e) {\n            assertEquals(100, e.getPermitted(), \"The permitted size should be 100.\");\n        }\n    }\n}",
      "method_signature": "testPartHeaderSizeMaxLimit()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8947,
      "callable_precision": 0.85,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.3333,
      "method_coverage": 0.8125,
      "line_coverage": 0.94,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 208,
      "description": "Define a test method annotated with `@Test` that declares it throws `Exception`, then begin by assigning the String literal `\"foobar\"` to a final variable `strData`, and immediately invoke `getBytes()` on `strData` to produce a byte array assigned to final variable `contents`. Construct a new `ByteArrayInputStream` by passing `contents` as the constructor argument, assigning the result to final variable `input` of type `InputStream`. Invoke `getBytes()` on the static field `BOUNDARY_TEXT` to obtain a byte array assigned to final variable `boundary`. Compute the buffer size by adding `boundary.length`, the static field `MultipartInput.BOUNDARY_PREFIX.length`, and the integer literal `1`, assigning the sum to final variable `iBufSize`. Invoke the static method `MultipartInput.builder()` to obtain a `Builder` instance, then chain `setInputStream(input)` passing `input`, chain `setBoundary(boundary)` passing `boundary`, chain `setBufferSize(iBufSize)` passing `iBufSize`, and chain `setProgressNotifier(new MultipartInput.ProgressNotifier(null, contents.length))` where the `ProgressNotifier` constructor receives `null` as the first argument and `contents.length` as the second argument, and finally invoke `get()` on the builder chain to produce a `MultipartInput` instance assigned to final variable `ms`. Assert that `ms` is not null by invoking `assertNotNull(ms)`. The test uses the `@Test` annotation from JUnit 5 and the `assertNotNull` assertion from JUnit 5 Assertions, with no integration annotations, parameterized test sources, or mocking libraries present.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testThreeParamConstructor()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.FileItemInputIteratorImplTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\n\nimport org.apache.commons.fileupload2.core.FileItemInputIterator;\nimport org.apache.commons.fileupload2.core.FileItemInputIteratorImpl;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link FileItemInputIteratorImpl}.\n */\npublic class FileItemInputIteratorImplTest {\n\n    private static final String BOUNDARY_TEXT = \"foobar\";\n\n    @Test\n    public void testBuilder() throws Exception {\n        final String strData = \"foobar\";\n        final byte[] contents = strData.getBytes();\n        final InputStream input = new ByteArrayInputStream(contents);\n        final byte[] boundary = BOUNDARY_TEXT.getBytes();\n        final int iBufSize = boundary.length + FileItemInputIteratorImpl.BOUNDARY_PREFIX.length + 1;\n        final FileItemInputIterator ms = FileItemInputIteratorImpl.builder()\n                .setInputStream(input)\n                .setBoundary(boundary)\n                .setBufferSize(iBufSize)\n                .setProgressNotifier(new FileItemInputIteratorImpl.ProgressNotifier(null, contents.length))\n                .get();\n        assertNotNull(ms);\n    }\n}",
      "method_signature": "testThreeParamConstructor()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18745,
    "output_tokens": 5029,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 220,
      "description": "Define a test method that verifies the maximum part header size limit enforcement in multipart stream processing by first constructing a multipart request string literal `request` containing the exact concatenated value `\"-----1234\\r\\n\" + \"Content-Disposition: form-data; name=\\\"file1\\\"; filename=\\\"foo1.tab\\\"\\r\\n\" + \"Content-Type: text/whatever\\r\\n\" + \"Content-Length: 10\\r\\n\" + \"\\r\\n\" + \"This is the content of the file\\n\" + \"\\r\\n\" + \"-----1234\\r\\n\" + \"Content-Disposition: form-data; name=\\\"file2\\\"; filename=\\\"foo2.tab\\\"\\r\\n\" + \"Content-Type: text/whatever\\r\\n\" + \"\\r\\n\" + \"This is the content of the file\\n\" + \"\\r\\n\" + \"-----1234--\\r\\n\"`, then invoke `getBytes(StandardCharsets.UTF_8)` on `request` and assign the result to `byteContents` of type `byte[]`, instantiate a `ByteArrayInputStream` passing `byteContents` as the constructor argument and assign it to `input` of type `InputStream`, invoke `getBytes()` on the String literal `\"---1234\"` and assign the result to `boundary` of type `byte[]`, invoke `MultipartInput.builder()` to obtain a builder instance, chain `setInputStream(input)` passing `input`, chain `setBoundary(boundary)` passing `boundary`, chain `setMaxPartHeaderSize(100)` passing the integer literal `100`, and finally chain `get()` to construct the `MultipartInput` instance, assigning it to `mi`, immediately assert that `mi` is not null using `assertNotNull(mi)`, then begin a try block by invoking `skipPreamble()` on `mi` and assigning the boolean result to `nextPart`, enter a while loop that continues while `nextPart` is true, and within the loop body invoke `readHeaders()` on `mi` assigning the String result to `headers`, print to `System.out` the concatenated string `\"Headers=\" + headers.length() + \", \" + headers`, assert that `headers` is not null using `assertNotNull(headers)`, invoke `readBodyData(NullOutputStream.INSTANCE)` on `mi` passing `NullOutputStream.INSTANCE` as the argument, invoke `readBoundary()` on `mi` and assign the boolean result back to `nextPart`, after the while loop completes invoke `fail(\"Expected Exception\")` to signal that an exception should have been thrown, then define a catch block for `FileUploadSizeException` with the variable name `fuse`, and within the catch block invoke `assertEquals(100, fuse.getPermitted())` to assert that the permitted size returned by `getPermitted()` on `fuse` equals the integer literal `100`. Annotate the test method with `@Test` and declare it to throw `Exception`.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testPartHeaderSizeMaxLimit()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\nimport org.apache.commons.io.output.NullOutputStream;\nimport org.junit.jupiter.api.Test;\n\npublic class MultipartInputTest {\n\n    @Test\n    public void testMaxPartHeaderSizeLimit() throws Exception {\n        final String request = \"-----1234\\r\\n\" +\n                \"Content-Disposition: form-data; name=\\\"file1\\\"; filename=\\\"foo1.tab\\\"\\r\\n\" +\n                \"Content-Type: text/whatever\\r\\n\" +\n                \"Content-Length: 10\\r\\n\" +\n                \"\\r\\n\" +\n                \"This is the content of the file\\n\" +\n                \"\\r\\n\" +\n                \"-----1234\\r\\n\" +\n                \"Content-Disposition: form-data; name=\\\"file2\\\"; filename=\\\"foo2.tab\\\"\\r\\n\" +\n                \"Content-Type: text/whatever\\r\\n\" +\n                \"\\r\\n\" +\n                \"This is the content of the file\\n\" +\n                \"\\r\\n\" +\n                \"-----1234--\\r\\n\";\n        final byte[] byteContents = request.getBytes(StandardCharsets.UTF_8);\n        final InputStream input = new ByteArrayInputStream(byteContents);\n        final byte[] boundary = \"-----1234\".getBytes(StandardCharsets.UTF_8);\n        final MultipartInput mi = MultipartInput.builder()\n                .setInputStream(input)\n                .setBoundary(boundary)\n                .setMaxPartHeaderSize(100)\n                .get();\n        assertNotNull(mi);\n        try {\n            boolean nextPart = mi.skipPreamble();\n            while (nextPart) {\n                String headers = mi.readHeaders();\n                System.out.println(\"Headers=\" + headers.length() + \", \" + headers);\n                assertNotNull(headers);\n                mi.readBodyData(NullOutputStream.INSTANCE);\n                nextPart = mi.readBoundary();\n            }\n            fail(\"Expected Exception\");\n        } catch (FileUploadSizeException fuse) {\n            assertEquals(100, fuse.getPermitted());\n        }\n    }\n}",
      "method_signature": "testPartHeaderSizeMaxLimit()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.9474,
      "callable_precision": 0.9474,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.6667,
      "method_coverage": 0.5,
      "line_coverage": 0.6533,
      "branch_coverage": 0.6875
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 225,
      "description": "Create a test case to validate the file upload system's behavior when configured with a zero-byte threshold, ensuring that uploaded content immediately transitions to persistent storage rather than remaining in memory once data arrives. Prepare a temporary directory within the system records area to serve as the storage location, then configure the file item factory with a zero-byte threshold, UTF-8 character encoding, and the designated storage location. Verify that the factory's threshold setting remains at zero as configured. Obtain a new file item from the factory and confirm its threshold also reflects zero. At this initial state, before any data arrives, verify the file item shows as initialized, indicates content is in memory, and has no associated storage location or content. Simulate uploading a small file by writing a series of characters (first five characters, then eight thousand characters on a second pass) to the file item's output channel, and after each character is written, confirm the system has transitioned to persistent storage mode, shows content is no longer in memory, and has created a storage file in the designated location, though the actual content verification is deferred. Once all data is written and the output channel is closed, verify the file item has transitioned to a closed state, confirms content is stored on disk rather than in memory, maintains the storage location reference, and contains the exact sequence of characters that were written. Execute this validation pattern twice with different data volumes to ensure consistent behavior across varying upload sizes. Use JUnit 5 as the testing framework and standard equality assertions to verify all state transitions, threshold values, storage locations, and content integrity throughout the upload lifecycle.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DiskFileItemTest",
      "method_signature": "testStateModelWithThresholdZero()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DiskFileItemZeroThresholdTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests the behavior of the file upload system when configured with a zero-byte threshold.\n */\npublic class DiskFileItemZeroThresholdTest {\n\n    @TempDir\n    Path tempDir;\n\n    @Test\n    public void testFileUploadWithZeroThreshold() throws IOException {\n        // Prepare a temporary directory to serve as the storage location.\n        Path repository = tempDir.resolve(\"repository\");\n        Files.createDirectories(repository);\n\n        // Configure the file item factory with a zero-byte threshold, UTF-8, and storage location.\n        DiskFileItemFactory factory = new DiskFileItemFactory();\n        factory.setPathRepository(repository.toFile());\n        factory.setSizeThreshold(0);\n        factory.setDefaultCharset(StandardCharsets.UTF_8.name());\n\n        // Verify that the factory's threshold setting remains at zero.\n        assertEquals(0, factory.getSizeThreshold());\n\n        // Obtain a new file item from the factory.\n        String fieldName = \"file\";\n        String contentType = \"text/plain\";\n        boolean isFormField = false;\n        String fileName = \"test.txt\";\n        DiskFileItem item = (DiskFileItem) factory.newFileItem(fieldName, contentType, isFormField, fileName);\n\n        // Confirm its threshold also reflects zero.\n        assertEquals(0, item.getSizeThreshold());\n\n        // At this initial state, verify the file item is in memory and has no content/location.\n        assertTrue(item.isInMemory());\n        assertNull(item.getStoreLocation());\n        assertEquals(0, item.getSize());\n\n        // Simulate uploading a file by writing characters in two passes.\n        String part1 = \"abcde\"; // first five characters\n        String part2 = new String(new char[8000]).replace('\u0000', 'X'); // eight thousand characters\n        String fullContent = part1 + part2;\n\n        try (OutputStream out = item.getOutputStream()) {\n            // Write the first part of the data.\n            out.write(part1.getBytes(StandardCharsets.UTF_8));\n\n            // After data arrives, confirm the system has transitioned to persistent storage.\n            assertFalse(item.isInMemory());\n            assertNotNull(item.getStoreLocation());\n            assertTrue(Files.exists(item.getStoreLocation()));\n\n            // Write the second part of the data.\n            out.write(part2.getBytes(StandardCharsets.UTF_8));\n        }\n\n        // Once all data is written and the stream is closed, verify the final state.\n        assertFalse(item.isInMemory());\n        assertNotNull(item.getStoreLocation());\n        assertEquals(fullContent.length(), item.getSize());\n        assertEquals(fullContent, item.getString());\n\n        // Execute the validation pattern a second time with different data.\n        DiskFileItem item2 = (DiskFileItem) factory.newFileItem(\"file2\", \"text/plain\", false, \"test2.txt\");\n        String content2 = \"This is the second validation pattern.\";\n\n        // Initial state for the second item.\n        assertTrue(item2.isInMemory());\n        assertNull(item2.getStoreLocation());\n        assertEquals(0, item2.getSize());\n\n        try (OutputStream out2 = item2.getOutputStream()) {\n            out2.write(content2.getBytes(StandardCharsets.UTF_8));\n\n            // Confirm transition to persistent storage.\n            assertFalse(item2.isInMemory());\n            assertNotNull(item2.getStoreLocation());\n            assertTrue(Files.exists(item2.getStoreLocation()));\n        }\n\n        // Verify the final state for the second item.\n        assertFalse(item2.isInMemory());\n        assertNotNull(item2.getStoreLocation());\n        assertEquals(content2.length(), item2.getSize());\n        assertEquals(content2, item2.getString());\n    }\n}",
      "method_signature": "testStateModelWithThresholdZero()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19396,
    "output_tokens": 5712,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 229,
      "description": "Create a test case to validate the file upload system's behavior when configured with positive threshold values, ensuring the system correctly transitions through its operational states as data accumulates and either remains in memory or persists to temporary storage based on size limits. Establish a temporary working directory within the test output area and configure the file upload factory with a specified threshold value, along with UTF-8 character encoding, then verify the factory retained the configured threshold setting. Prepare a new upload item from the factory and confirm it also preserves the threshold configuration, then verify the item begins in an initialized state with all data held in memory and no temporary storage file created. Begin writing data to the upload item one byte at a time, tracking the accumulated content, and after each byte before reaching the threshold confirm the system remains in an opened state with data still held in memory and no temporary storage file present. Once the threshold is reached by writing one additional byte, verify the system immediately transitions to a persisted state where data is no longer held in memory and a temporary storage file has been created within the designated working directory. After closing the upload stream, confirm the system transitions to a closed state while maintaining the data in the temporary storage file with the complete accumulated content available for retrieval, then repeat this entire validation scenario with two different threshold values to ensure consistent behavior across varying size limits. Validate all state transitions and data integrity using JUnit 5 with AssertJ-style equality assertions to confirm expected values match actual system behavior at each checkpoint.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DiskFileItemTest",
      "method_signature": "testStateModelWithPositiveThreshold()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DiskFileItemThresholdTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests the behavior of {@link DiskFileItem} when a threshold is exceeded.\n */\npublic class DiskFileItemThresholdTest {\n\n    @TempDir\n    Path tempDir;\n\n    /**\n     * Tests that the file item is moved to disk when the size threshold is exceeded.\n     *\n     * @throws IOException if an I/O error occurs.\n     */\n    @Test\n    public void testThresholdBehavior() throws IOException {\n        validateThresholdScenario(128);\n        validateThresholdScenario(256);\n    }\n\n    private void validateThresholdScenario(final int threshold) throws IOException {\n        // 1. Configure the factory with a threshold and temp directory\n        final DiskFileItemFactory factory = new DiskFileItemFactory.Builder().setPath(tempDir).setThreshold(threshold).get();\n        assertEquals(threshold, factory.getThreshold(), \"Factory should retain the configured threshold\");\n\n        // 2. Prepare a new upload item and verify its initial state\n        final DiskFileItem item = (DiskFileItem) factory.createItem(\"field\", \"text/plain\", false, \"testfile.txt\");\n        item.setCharset(StandardCharsets.UTF_8);\n\n        assertEquals(threshold, item.getThreshold(), \"Item should inherit the factory's threshold\");\n        assertTrue(item.isInMemory(), \"Item should be in memory upon initialization\");\n        assertNull(item.getStoreLocation(), \"Temporary file should not exist upon initialization\");\n\n        // 3. Write data byte by byte, checking state before crossing the threshold\n        final ByteArrayOutputStream writtenBytes = new ByteArrayOutputStream();\n        try (final OutputStream os = item.getOutputStream()) {\n            for (int i = 0; i < threshold; i++) {\n                final byte b = (byte) i;\n                os.write(b);\n                writtenBytes.write(b);\n                assertTrue(item.isInMemory(), \"Item must remain in memory before threshold is crossed\");\n                assertNull(item.getStoreLocation(), \"Temporary file must not exist before threshold is crossed\");\n            }\n\n            // 4. Cross the threshold\n            final byte lastByte = (byte) threshold;\n            os.write(lastByte);\n            writtenBytes.write(lastByte);\n\n            // 5. Verify transition to persisted state\n            assertFalse(item.isInMemory(), \"Item must be persisted to disk after crossing the threshold\");\n            final Path storedFile = item.getStoreLocation();\n            assertNotNull(storedFile, \"Temporary file should be created after crossing the threshold\");\n            assertTrue(storedFile.toFile().exists(), \"Temporary file should exist on disk\");\n            assertEquals(tempDir, storedFile.getParent(), \"Temporary file should be in the configured directory\");\n        }\n\n        // 6. Verify final state and data integrity after closing the stream\n        assertFalse(item.isInMemory(), \"Item must remain persisted after stream is closed\");\n        assertEquals(writtenBytes.size(), item.getSize(), \"Item size should match total bytes written\");\n        assertArrayEquals(writtenBytes.toByteArray(), item.get(), \"Retrieved item content should match all written bytes\");\n\n        // 7. Cleanup\n        item.delete();\n        assertFalse(item.getStoreLocation().toFile().exists(), \"Temporary file should be deleted after calling delete()\");\n    }\n}",
      "method_signature": "testStateModelWithPositiveThreshold()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19142,
    "output_tokens": 5549,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 242,
      "description": "Define a test method that validates the state transitions of a Disk File Item as data is written across a configurable threshold by encapsulating the test logic within an integer consumer lambda that accepts a threshold value as its parameter, then within this consumer establish a test directory path under the target directory using the test class name, create the necessary directory structure, and generate a temporary subdirectory within it before building a Disk File Item Factory configured with the provided threshold, the temporary directory path, and UTF-8 charset, after which confirm the factory's threshold matches the input value, then construct a Disk File Item from the factory's builder and verify its threshold also matches the expected value before creating a private helper method that validates the item's current state by checking the underlying Deferrable Output Stream's state enumeration value, memory residency flag, output file path presence relative to the expected parent directory, and if provided, the accumulated byte count and string content against the item's reported size and retrieved data, initially asserting the item is in initialized state with data in memory and no output file, then obtain the item's output stream and initialize a string builder to track written content, writing bytes in a loop up to one less than the threshold while appending each character to the builder and verifying after each write that the item remains in opened state with data still in memory and no persisted file, upon writing the final byte that reaches the threshold append it to the builder and confirm the item transitions to persisted state with data no longer in memory and an output file created in the temporary directory, close the output stream and validate the item enters closed state while maintaining the persisted file location and matching the builder's accumulated string content, finally invoke this consumer twice with distinct threshold values of 5 and 8193 to verify behavior across small and large buffer boundaries using JUnit 5.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DiskFileItemTest",
      "method_signature": "testStateModelWithPositiveThreshold()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DiskFileItemStateTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.function.IntConsumer;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests the state transitions of a DiskFileItem as data is written across a configurable threshold.\n */\npublic class DiskFileItemStateTest {\n\n    /**\n     * Validates the state of a {@link DiskFileItem} by checking its memory residency,\n     * file persistence, size, and content.\n     *\n     * @param item The item to validate.\n     * @param expectInMemory Whether the item is expected to be in memory.\n     * @param expectPersisted Whether the item is expected to be persisted to disk.\n     * @param expectedParentDir The directory where the persisted file should be located.\n     * @param expectedSize The expected size of the item's data in bytes.\n     * @param expectedContent The expected string content of the item.\n     * @throws IOException if an I/O error occurs during validation.\n     */\n    private void validateState(\n            final DiskFileItem item,\n            final boolean expectInMemory,\n            final boolean expectPersisted,\n            final Path expectedParentDir,\n            final Long expectedSize,\n            final String expectedContent) throws IOException {\n\n        assertEquals(expectInMemory, item.isInMemory(), \"Mismatch on in-memory state.\");\n\n        if (expectPersisted) {\n            final Path storeLocation = item.getStoreLocation();\n            assertNotNull(storeLocation, \"Expected a persisted file location, but it was null.\");\n            assertTrue(Files.exists(storeLocation), \"Expected persisted file to exist, but it doesn't.\");\n            assertEquals(expectedParentDir, storeLocation.getParent(), \"Persisted file is in the wrong directory.\");\n        } else {\n            assertNull(item.getStoreLocation(), \"Expected no persisted file location, but it was not null.\");\n        }\n\n        if (expectedSize != null) {\n            assertEquals(expectedSize.longValue(), item.getSize(), \"Item size mismatch.\");\n        }\n\n        if (expectedContent != null) {\n            assertEquals(expectedContent, item.getString(StandardCharsets.UTF_8), \"Item content mismatch.\");\n        }\n    }\n\n    @Test\n    public void testStateTransitionAcrossThreshold() {\n        final IntConsumer testLogic = threshold -> {\n            final Path testDir = Path.of(\"target\", DiskFileItemStateTest.class.getSimpleName());\n            Path tempDir = null;\n            try {\n                Files.createDirectories(testDir);\n                tempDir = Files.createTempDirectory(testDir, \"test-sub-dir-\");\n\n                final var factory = DiskFileItemFactory.builder()\n                        .setPath(tempDir)\n                        .setThreshold(threshold)\n                        .setCharset(StandardCharsets.UTF_8)\n                        .build();\n\n                assertEquals(threshold, factory.getThreshold(), \"Factory threshold should match input.\");\n\n                final var item = (DiskFileItem) factory.createItem(\"field\", \"text/plain\", true, \"test.txt\");\n                assertEquals(threshold, item.getThreshold(), \"Item threshold should match factory's.\");\n\n                // Initially, item should be in memory, empty, with no file.\n                validateState(item, true, false, tempDir, 0L, \"\");\n\n                final StringBuilder writtenContent = new StringBuilder();\n                try (final OutputStream os = item.getOutputStream()) {\n                    // Write bytes up to one less than the threshold.\n                    for (int i = 0; i < threshold - 1; i++) {\n                        final char c = (char) ('a' + (i % 26));\n                        os.write(c);\n                        writtenContent.append(c);\n                        // Item should remain in memory.\n                        validateState(item, true, false, tempDir, (long) (i + 1), null);\n                    }\n\n                    // Write the final byte to reach the threshold.\n                    final char lastChar = (char) ('a' + ((threshold - 1) % 26));\n                    os.write(lastChar);\n                    writtenContent.append(lastChar);\n\n                    // Item should now be persisted to disk.\n                    validateState(item, false, true, tempDir, (long) threshold, null);\n                }\n\n                // After closing the stream, the item should remain persisted and its content should be available.\n                validateState(item, false, true, tempDir, (long) threshold, writtenContent.toString());\n\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n\n        // Verify behavior with both a small and a large (greater than default buffer) threshold.\n        testLogic.accept(5);\n        testLogic.accept(8193);\n    }\n}",
      "method_signature": "testStateModelWithPositiveThreshold()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6902,
    "output_tokens": 8238,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 250,
      "description": "Define a test method that validates the state transitions of a Disk File Item when configured with a zero threshold by encapsulating the verification logic within a parameterized consumer that accepts byte count values. Within the consumer implementation, establish a test directory path under the target folder using the test class's simple name, create the directory structure, then generate a temporary subdirectory within it. Build a Disk File Item Factory with buffer size set to zero, the temporary directory as the repository path, and UTF-8 charset, then verify the factory's threshold equals zero. From this factory, construct a Disk File Item builder and obtain the file item instance, confirming its threshold also equals zero. Create a private helper method that validates the file item's current state by retrieving its output stream, asserting the stream's state matches the expected state enumeration value, verifying the in-memory status matches both the file item and its underlying stream, checking whether the stream's path is null or resides within the expected parent directory, and if a test string is provided, confirming the size and content match across both the file item and stream while also validating the string representation and byte array retrieval. Immediately after constructing the file item, invoke this helper to confirm the initialized state with in-memory status true and null path. Prepare a string builder to track written content, then open the file item's output stream within a try-with-resources block and iterate for the specified number of bytes, writing a period character to the stream and appending it to the builder while invoking the state validation helper after each write to confirm the persisted state with in-memory status false and the temporary directory as parent, passing null for content validation since the stream remains open. After the loop, write a comma character to both the stream and builder, then allow the stream to close automatically. Upon stream closure, invoke the state validation helper once more to verify the closed state with in-memory status false, the temporary directory as parent, and the complete accumulated string content for validation. Execute the consumer twice with different byte counts: first with five bytes, then with a value exceeding typical buffer size by one to ensure state transitions occur correctly across varying data volumes. This test uses JUnit 5 for the test framework and standard assertion methods for validation.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DiskFileItemTest",
      "method_signature": "testStateModelWithThresholdZero()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DiskFileItemTest1",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.function.Consumer;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link DiskFileItem}.\n */\npublic class DiskFileItemTest1 {\n\n    @TempDir\n    private Path tempDir;\n\n    /**\n     * Helper method to validate the state of a {@link DiskFileItem} and its underlying {@link DeferrableOutputStream}.\n     *\n     * @param item The file item to validate.\n     * @param expectedState The expected state of the output stream.\n     * @param expectedInMemory The expected in-memory status.\n     * @param expectedParentDir The expected parent directory for the backing file, or null if not expected to exist.\n     * @param expectedContent The expected string content, or null if not to be validated.\n     * @throws IOException if an I/O error occurs.\n     */\n    private void validateFileItemState(final DiskFileItem item, final DeferrableOutputStream.State expectedState, final boolean expectedInMemory,\n            final Path expectedParentDir, final String expectedContent) throws IOException {\n        // This cast is necessary based on the current implementation of DiskFileItem\n        final DeferrableOutputStream dos = (DeferrableOutputStream) item.getOutputStream();\n\n        // Assert the stream's state matches the expected state enumeration value\n        assertEquals(expectedState, dos.getState(), \"Stream state mismatch\");\n\n        // Verify the in-memory status matches both the file item and its underlying stream\n        assertEquals(expectedInMemory, item.isInMemory(), \"FileItem in-memory status mismatch\");\n        assertEquals(expectedInMemory, dos.isInMemory(), \"Stream in-memory status mismatch\");\n\n        // Check whether the stream's path is null or resides within the expected parent directory\n        if (expectedParentDir == null) {\n            assertNull(dos.getPath(), \"Stream path should be null\");\n        } else {\n            assertNotNull(dos.getPath(), \"Stream path should not be null\");\n            assertEquals(expectedParentDir, dos.getPath().getParent(), \"Stream path parent mismatch\");\n        }\n\n        // If a test string is provided, confirm the size and content match across both the file item and stream\n        // while also validating the string representation and byte array retrieval.\n        if (expectedContent != null) {\n            assertEquals(expectedContent.length(), item.getSize(), \"FileItem size mismatch\");\n            assertEquals(expectedContent, item.getString(StandardCharsets.UTF_8), \"FileItem content mismatch\");\n            assertArrayEquals(expectedContent.getBytes(StandardCharsets.UTF_8), item.get(), \"FileItem byte array mismatch\");\n            assertEquals(expectedContent.length(), dos.getByteCount(), \"Stream byte count mismatch\");\n        }\n    }\n\n    @Test\n    public void testStateTransitionsWithZeroThreshold() {\n        // Define a consumer that encapsulates the verification logic for a given byte count.\n        final Consumer<Integer> verifier = byteCount -> {\n            try {\n                // Generate a temporary subdirectory for the test run.\n                final Path testSubDir = Files.createTempDirectory(tempDir, \"test-repo-\");\n\n                // Build a DiskFileItemFactory with a zero threshold to force immediate disk writing.\n                final DiskFileItemFactory factory = new DiskFileItemFactory(0, testSubDir.toFile());\n                factory.setCharset(StandardCharsets.UTF_8.name());\n                assertEquals(0, factory.getSizeThreshold(), \"Factory threshold should be zero\");\n\n                // Construct a DiskFileItem from the factory.\n                final DiskFileItem item = (DiskFileItem) factory.createItem(\"field\", \"text/plain\", true, \"test.txt\");\n                assertEquals(0, item.getSizeThreshold(), \"FileItem threshold should be zero\");\n\n                // Immediately validate the initial state: in-memory, no file path.\n                validateFileItemState(item, DeferrableOutputStream.State.initialized, true, null, null);\n\n                final StringBuilder writtenContent = new StringBuilder();\n\n                // Open the output stream and write data to trigger state changes.\n                try (final OutputStream os = item.getOutputStream()) {\n                    // Write byte by byte, validating the transition to a persisted state after each write.\n                    for (int i = 0; i < byteCount; i++) {\n                        os.write('.');\n                        writtenContent.append('.');\n                        // The stream should now be persisted to disk.\n                        validateFileItemState(item, DeferrableOutputStream.State.persisted, false, testSubDir, null);\n                    }\n                    // Write one final character before closing.\n                    os.write(',');\n                    writtenContent.append(',');\n                } // The stream is automatically closed here.\n\n                // After closure, validate the final state: closed, persisted, and with correct content.\n                validateFileItemState(item, DeferrableOutputStream.State.closed, false, testSubDir, writtenContent.toString());\n\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n\n        // Execute the verification logic with different data volumes.\n        verifier.accept(5);\n        verifier.accept(8193); // A value larger than a typical default buffer.\n    }\n}",
      "method_signature": "testStateModelWithThresholdZero()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23201,
    "output_tokens": 9290,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 282,
      "description": "Define a test method annotated with `@Test` that begins by declaring a lambda variable `tester` of type `IntConsumer` which accepts an `int` parameter `numBytes` and executes the following logic within a try-catch block that catches `IOException` and wraps it in `UncheckedIOException`: invoke `Paths.get` with the concatenated string `\"target/unit-tests/\"` plus the result of calling `getSimpleName()` on `DiskFileItemTest.class`, assigning the result to a `Path` variable `testDir`, then invoke `Files.createDirectories` passing `testDir` to ensure the directory exists, followed by invoking `Files.createTempDirectory` with arguments `testDir` and string literal `\"testDir\"` and assigning the returned `Path` to variable `tempTestDir`, then invoke `DiskFileItemFactory.builder()` and chain `setBufferSize(0)`, `setPath(tempTestDir)`, `setCharset(StandardCharsets.UTF_8)`, and finally `get()` to construct a `DiskFileItemFactory` instance assigned to variable `dfif`, immediately assert using `assertEquals` that `dfif.getThreshold()` returns `0`, then invoke `dfif.fileItemBuilder().get()` to create a `DiskFileItem` instance assigned to variable `dfi`, assert again using `assertEquals` that `dfi.getThreshold()` returns `0`, and invoke a private method that casts `dfi.getOutputStream()` to `DeferrableOutputStream` assigned to variable `dos`, asserts using `assertEquals` that `dos.getState()` equals `State.initialized`, asserts using `assertEquals` that `dfi.isInMemory()` returns `true`, asserts using `assertEquals` that `dos.isInMemory()` returns `true`, checks if the fourth parameter (representing `parentDir`) is `null` and if so asserts using `assertNull` that `dos.getPath()` is `null`, otherwise asserts using `assertNotNull` that `dos.getPath()` is not `null` and asserts using `assertEquals` that `dos.getPath().getParent()` equals the `parentDir` value, and checks if the fifth parameter (representing `testString`) is `null` and if so asserts using `assertNull` that `dfi.get()` and `dfi.getString()` are both `null`, otherwise asserts using `assertEquals` that `testString.length()` equals `dfi.getSize()`, asserts using `assertEquals` that `testString.length()` equals `dos.getSize()`, asserts using `assertEquals` that `testString` equals `dfi.getString()`, and asserts using `assertArrayEquals` that `testString.getBytes()` equals `dfi.get()`, invoking this private method with arguments `dfi`, `State.initialized`, `true`, `null`, and `null`, then instantiate a new `StringBuilder` assigned to variable `sb`, open a try-with-resources block declaring `OutputStream` variable `os` initialized by invoking `dfi.getOutputStream()`, enter a for loop with `int` variable `i` initialized to `0`, condition `i < numBytes`, and increment `i++`, within the loop invoke `os.write('.')` passing the character literal `'.'`, invoke `sb.append('.')` to append the same character to the builder, and invoke the same private method with arguments `dfi`, `State.persisted`, `false`, `tempTestDir`, and `null` to verify the state after each byte written, after the loop completes invoke `os.write(',')` passing character literal `','` and invoke `sb.append(',')` to append the comma, then after the try-with-resources block closes the output stream invoke the private method again with arguments `dfi`, `State.closed`, `false`, `tempTestDir`, and `sb.toString()` to verify the final closed state with the complete string content, and if an `IOException` occurs in the try block catch it and throw a new `UncheckedIOException` wrapping the caught exception. After defining the `tester` lambda, invoke `tester.accept(5)` to execute the test logic with `numBytes` equal to `5`, then invoke `tester.accept(8193)` to execute the test logic again with `numBytes` equal to `8193` representing a typical buffer size plus one. The test uses JUnit 5 assertions (`assertEquals`, `assertNull`, `assertNotNull`, `assertArrayEquals`) and is annotated with `@Test`.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DiskFileItemTest",
      "method_signature": "testStateModelWithThresholdZero()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.GeneratedDiskFileItemTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.function.IntConsumer;\n\nimport org.apache.commons.fileupload2.core.DeferrableOutputStream.State;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link DiskFileItem}.\n */\npublic class GeneratedDiskFileItemTest {\n\n    private void checkState(final DiskFileItem dfi, final State expectedState, final boolean expectedInMemory, final Path parentDir, final String testString) {\n        final DeferrableOutputStream dos = (DeferrableOutputStream) dfi.getOutputStream();\n        assertEquals(expectedState, dos.getState());\n        assertEquals(expectedInMemory, dfi.isInMemory());\n        assertEquals(expectedInMemory, dos.isInMemory());\n        if (parentDir == null) {\n            assertNull(dos.getPath());\n        } else {\n            assertNotNull(dos.getPath());\n            assertEquals(parentDir, dos.getPath().getParent());\n        }\n        if (testString == null) {\n            assertNull(dfi.get());\n            try {\n                assertNull(dfi.getString());\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        } else {\n            assertEquals(testString.length(), dfi.getSize());\n            assertEquals(testString.length(), dos.getSize());\n            try {\n                assertEquals(testString, dfi.getString());\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            assertArrayEquals(testString.getBytes(StandardCharsets.UTF_8), dfi.get());\n        }\n    }\n\n    @Test\n    public void testWriteAndClose() {\n        final IntConsumer tester = numBytes -> {\n            try {\n                final Path testDir = Paths.get(\"target/unit-tests/\" + GeneratedDiskFileItemTest.class.getSimpleName());\n                Files.createDirectories(testDir);\n                final Path tempTestDir = Files.createTempDirectory(testDir, \"testDir\");\n                final DiskFileItemFactory dfif = DiskFileItemFactory.builder().setThreshold(0).setPath(tempTestDir)\n                        .setCharset(StandardCharsets.UTF_8).get();\n                assertEquals(0, dfif.getThreshold());\n                final DiskFileItem dfi = dfif.fileItemBuilder().get();\n                assertEquals(0, dfi.getThreshold());\n\n                checkState(dfi, State.initialized, true, null, null);\n\n                final StringBuilder sb = new StringBuilder();\n                try (OutputStream os = dfi.getOutputStream()) {\n                    for (int i = 0; i < numBytes; i++) {\n                        os.write('.');\n                        sb.append('.');\n                        checkState(dfi, State.persisted, false, tempTestDir, null);\n                    }\n                    os.write(',');\n                    sb.append(',');\n                }\n\n                checkState(dfi, State.closed, false, tempTestDir, sb.toString());\n\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n\n        tester.accept(5);\n        tester.accept(8193);\n    }\n}",
      "method_signature": "testStateModelWithThresholdZero()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 21649,
    "output_tokens": 6691,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 293,
      "description": "Define a test method that begins by creating a lambda expression of type `IntConsumer` assigned to variable `tester`, which accepts an `int` parameter `numBytes` and executes the following logic within a try-catch block that catches `IOException` and rethrows it as `UncheckedIOException`: first, create a `Path` variable `testDir` by invoking `Paths.get` with the concatenated string `\"target/unit-tests/\"` plus the result of calling `getSimpleName()` on `DiskFileItemTest.class`, then invoke `Files.createDirectories` passing `testDir` to ensure the directory exists, next create a `Path` variable `tempTestDir` by invoking `Files.createTempDirectory` with arguments `testDir` and string literal `\"testDir\"`, then construct a `DiskFileItemFactory` variable `dfif` by chaining `DiskFileItemFactory.builder()`, `.setThreshold(numBytes)`, `.setPath(tempTestDir)`, `.setCharset(StandardCharsets.UTF_8)`, and finally `.get()`, immediately assert using `assertEquals` that `numBytes` equals the result of invoking `dfif.getThreshold()`, then create a `DiskFileItem` variable `dfi` by chaining `dfif.fileItemBuilder()` and `.get()`, assert again using `assertEquals` that `numBytes` equals `dfi.getThreshold()`, define a private method that accepts a `DiskFileItem`, a `State` enum value, a `boolean` for in-memory status, a `Path` for parent directory (nullable), and a `String` for test content (nullable), and within this method cast the result of invoking `dfi.getOutputStream()` to `DeferrableOutputStream` and assign it to variable `dos`, assert using `assertEquals` that the provided `State` matches `dos.getState()`, assert using `assertEquals` that the provided `boolean` matches both `dfi.isInMemory()` and `dos.isInMemory()`, conditionally assert using `assertNull(dos.getPath())` if the provided `Path` is null, otherwise assert using `assertNotNull(dos.getPath())` and `assertEquals` that the provided `Path` matches `dos.getPath().getParent()`, conditionally assert if the provided `String` is not null by using `assertEquals` to verify `testString.length()` matches both `dfi.getSize()` and `dos.getSize()`, then assert using `assertEquals` that `testString` matches `dfi.getString()`, and assert using `assertArrayEquals` that `testString.getBytes()` matches `dfi.get()`, otherwise if the `String` is null assert using `assertNull(dfi.get())` and `assertNull(dfi.getString())`, then invoke this private method with arguments `dfi`, `State.initialized`, `true`, `null`, and `null` to verify the initial state, create a `StringBuilder` variable `sb` by invoking `new StringBuilder()`, open a try-with-resources block declaring `OutputStream` variable `os` initialized by invoking `dfi.getOutputStream()`, within this block execute a for loop with `int` variable `i` initialized to `0`, continuing while `i < numBytes - 1`, incrementing `i` each iteration, and in each iteration invoke `os.write('.')` passing the character literal `'.'`, invoke `sb.append('.')` to mirror the written character, and invoke the private method with arguments `dfi`, `State.opened`, `true`, `null`, and `null` to verify the opened state, after the loop completes invoke `os.write(',')` passing the character literal `','`, invoke `sb.append(',')` to append the comma, and invoke the private method with arguments `dfi`, `State.persisted`, `false`, `tempTestDir`, and `null` to verify the persisted state, upon exiting the try-with-resources block (which automatically closes `os`) invoke the private method with arguments `dfi`, `State.closed`, `false`, `tempTestDir`, and `sb.toString()` to verify the closed state with the complete written content, after defining the lambda invoke `tester.accept(5)` to execute the test logic with threshold value `5`, then invoke `tester.accept(8193)` to execute the test logic with threshold value `8193`, annotate the test method with `@Test`, use assertion library JUnit 5 Assertions for `assertEquals`, `assertNull`, `assertNotNull`, and `assertArrayEquals`, and note that no class-level annotations, mocking libraries, or additional method-level annotations are present.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.DiskFileItemTest",
      "method_signature": "testStateModelWithPositiveThreshold()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.DiskFileItemFactoryTest1",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.function.IntConsumer;\n\nimport org.apache.commons.fileupload2.core.DeferrableOutputStream.State;\nimport org.junit.jupiter.api.Test;\n\npublic class DiskFileItemFactoryTest1 {\n\n    private void assertState(final DiskFileItem dfi, final DeferrableOutputStream dos, final State expectedState, final boolean isInMemory,\n            final Path expectedParent, final String testContent) {\n        assertEquals(expectedState, dos.getState());\n        assertEquals(isInMemory, dfi.isInMemory());\n        assertEquals(isInMemory, dos.isInMemory());\n        if (expectedParent == null) {\n            assertNull(dos.getPath());\n        } else {\n            assertNotNull(dos.getPath());\n            assertEquals(expectedParent, dos.getPath().getParent());\n        }\n        if (testContent != null) {\n            assertEquals(testContent.length(), dfi.getSize());\n            assertEquals(testContent, dfi.getString());\n            assertArrayEquals(testContent.getBytes(), dfi.get());\n        } else {\n            assertNull(dfi.get());\n            assertNull(dfi.getString());\n        }\n    }\n\n    @Test\n    public void testThreshold() {\n        final IntConsumer tester = numBytes -> {\n            try {\n                final Path testDir = Paths.get(\"target/unit-tests/\" + DiskFileItemFactoryTest.class.getSimpleName());\n                Files.createDirectories(testDir);\n                final Path tempTestDir = Files.createTempDirectory(testDir, \"testDir\");\n                final DiskFileItemFactory dfif = DiskFileItemFactory.builder().setThreshold(numBytes)\n                        .setPath(tempTestDir).setCharset(StandardCharsets.UTF_8).get();\n                assertEquals(numBytes, dfif.getThreshold());\n                final DiskFileItem dfi = dfif.fileItemBuilder().get();\n                assertEquals(numBytes, dfi.getThreshold());\n\n                final DeferrableOutputStream dos = (DeferrableOutputStream) dfi.getOutputStream();\n                assertState(dfi, dos, State.initialized, true, null, null);\n\n                final StringBuilder sb = new StringBuilder();\n                try (final OutputStream os = dos) {\n                    for (int i = 0; i < numBytes - 1; i++) {\n                        os.write('.');\n                        sb.append('.');\n                    }\n                    assertState(dfi, dos, State.opened, true, null, null);\n\n                    os.write(',');\n                    sb.append(',');\n                    assertState(dfi, dos, State.persisted, false, tempTestDir, null);\n                }\n                assertState(dfi, dos, State.closed, false, tempTestDir, sb.toString());\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n\n        tester.accept(5);\n        tester.accept(8193);\n    }\n}",
      "method_signature": "testStateModelWithPositiveThreshold()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23718,
    "output_tokens": 8731,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 97,
      "description": "Define a test method that validates the construction of a Multipart Input processor using its builder pattern with input stream, boundary, and progress notifier configuration. Prepare a simple string value, convert it to a byte array to represent the content payload, and wrap this byte array in a ByteArrayInputStream to serve as the data source. Convert the boundary text constant to a byte array to establish the multipart stream delimiter. Obtain a builder instance from the Multipart Input factory, then configure it by setting the input stream to the prepared ByteArrayInputStream, specifying the boundary byte array, and attaching a Progress Notifier initialized with a null listener reference and the content length derived from the byte array size. Invoke the builder's get method to construct the Multipart Input instance, which triggers internal validation of buffer sizing against boundary requirements and initializes the stream processing infrastructure. Upon receiving the constructed instance, assert that it is not null to confirm successful instantiation through the builder pattern. This test uses JUnit for test execution and standard assertion methods for validation.",
      "project_name": "commons-fileupload",
      "qualified_class_name": "org.apache.commons.fileupload2.core.MultipartStreamTest",
      "method_signature": "testTwoParamConstructor()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.fileupload2.core.MultipartInputTest",
      "code": "package org.apache.commons.fileupload2.core;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link MultipartInput}.\n */\npublic class MultipartInputTest {\n\n    /**\n     * Validates the construction of a MultipartInput processor using its builder pattern.\n     *\n     * @throws IOException if an I/O error occurs.\n     */\n    @Test\n    public void testMultipartInputBuilder() throws IOException {\n        final String content = \"simple string value\";\n        final byte[] contentBytes = content.getBytes(StandardCharsets.UTF_8);\n        final InputStream inputStream = new ByteArrayInputStream(contentBytes);\n\n        final String boundaryStr = \"boundary\";\n        final byte[] boundaryBytes = boundaryStr.getBytes(StandardCharsets.UTF_8);\n        final long contentLength = contentBytes.length;\n\n        final ProgressListener listener = null;\n        final ProgressNotifier notifier = new ProgressNotifier(listener, contentLength);\n\n        final MultipartInput multipartInput = MultipartInput.builder()\n                .setInputStream(inputStream)\n                .setBoundary(boundaryBytes)\n                .setNotifier(notifier)\n                .get();\n\n        assertNotNull(multipartInput, \"The constructed MultipartInput instance should not be null.\");\n    }\n}",
      "method_signature": "testTwoParamConstructor()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 27747,
    "output_tokens": 5177,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  }
]