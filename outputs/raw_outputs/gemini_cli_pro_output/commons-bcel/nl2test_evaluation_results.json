[
  {
    "compiles": false,
    "nl2test_input": {
      "id": 221,
      "description": "Create a test case to validate that the system correctly detects and prevents infinite loops when resolving type hierarchies with circular dependencies. Before execution begins, prepare a temporary working directory and construct three interdependent type definitions where two contracts reference each other in a cycle (the first contract extends the second, which in turn extends the first, forming a closed loop), then create a concrete implementation that adopts the first contract. Configure the system's type resolution mechanism to search for these definitions within the temporary directory by constructing an appropriate resolution path that includes both the temporary location and the standard system locations. Once the environment is prepared, attempt to locate a property within the concrete implementation that does not exist, triggering the system to traverse the type hierarchy and discover the circular dependency. Verify that the system recognizes this illegal circular structure and responds by raising a structural integrity error rather than entering an infinite resolution loop or producing incorrect results. This test employs JUnit 5 as the testing framework and uses standard assertion mechanisms to confirm the expected error condition occurs.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.classfile.JavaClassTest",
      "method_signature": "testFindFieldCustomInterface1()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.bcel.util.hierarchy",
      "code": "package org.apache.bcel.util;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport org.apache.bcel.Const;\nimport org.apache.bcel.Repository;\nimport org.apache.bcel.classfile.JavaClass;\nimport org.apache.bcel.generic.ClassGen;\nimport org.apache.bcel.generic.ConstantPoolGen;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests for detecting circular dependencies in the class/interface hierarchy.\n */\npublic class hierarchy {\n\n    /**\n     * Creates a circular dependency between two interfaces, and a class that implements one of them, then\n     * verifies that attempting to resolve the hierarchy results in an error rather than an infinite loop.\n     *\n     * @throws IOException If an I/O error occurs creating files.\n     * @throws ClassNotFoundException If the test classes cannot be found by the repository.\n     */\n    @Test\n    void testCircularInterfaceDependency(@TempDir final Path tempDir) throws IOException, ClassNotFoundException {\n        final String contract1Name = \"org.apache.bcel.test.CircularContract1\";\n        final String contract2Name = \"org.apache.bcel.test.CircularContract2\";\n        final String implementationName = \"org.apache.bcel.test.CircularImplementation\";\n\n        // Create a directory structure matching the package name\n        final Path testPackagePath = tempDir.resolve(\"org\").resolve(\"apache\").resolve(\"bcel\").resolve(\"test\");\n        Files.createDirectories(testPackagePath);\n\n        // Create Contract1: public interface CircularContract1 extends CircularContract2 {}\n        final ConstantPoolGen cp1 = new ConstantPoolGen();\n        final ClassGen cg1 = new ClassGen(contract1Name, \"java.lang.Object\", \"CircularContract1.java\",\n            Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT, new String[] { contract2Name }, cp1);\n        final Path path1 = testPackagePath.resolve(\"CircularContract1.class\");\n        cg1.getJavaClass().dump(path1.toFile());\n\n        // Create Contract2: public interface CircularContract2 extends CircularContract1 {}\n        final ConstantPoolGen cp2 = new ConstantPoolGen();\n        final ClassGen cg2 = new ClassGen(contract2Name, \"java.lang.Object\", \"CircularContract2.java\",\n            Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT, new String[] { contract1Name }, cp2);\n        final Path path2 = testPackagePath.resolve(\"CircularContract2.class\");\n        cg2.getJavaClass().dump(path2.toFile());\n\n        // Create Implementation: public class CircularImplementation implements CircularContract1 {}\n        final ConstantPoolGen cp3 = new ConstantPoolGen();\n        final ClassGen cg3 = new ClassGen(implementationName, \"java.lang.Object\", \"CircularImplementation.java\",\n            Const.ACC_PUBLIC, new String[] { contract1Name }, cp3);\n        final Path path3 = testPackagePath.resolve(\"CircularImplementation.class\");\n        cg3.getJavaClass().dump(path3.toFile());\n\n        // Configure repository to search in the temporary directory\n        final String classPathStr = tempDir.toString() + File.pathSeparator + ClassPath.getClassPath();\n        final ClassPath classPath = new ClassPath(classPathStr);\n        final SyntheticRepository repository = SyntheticRepository.getInstance(classPath);\n\n        // Load the implementation class, which will be the starting point for hierarchy traversal.\n        final JavaClass implementationClass = repository.loadClass(implementationName);\n        assertNotNull(implementationClass);\n\n        // Attempting to resolve methods should trigger traversal of the interface hierarchy.\n        // Due to the circular dependency, this is expected to cause a StackOverflowError,\n        // which demonstrates that the system errors out instead of entering an infinite loop.\n        assertThrows(StackOverflowError.class, () -> {\n            implementationClass.getMethods(repository);\n        });\n    }\n}",
      "method_signature": "testFindFieldCustomInterface1()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 5712,
    "output_tokens": 9175,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 234,
      "description": "Create a test case to validate that the system correctly retrieves the complete inheritance hierarchy for any standard library type across multiple core packages, ensuring that even classes deeply embedded within the platform's foundational modules can be analyzed for their superclass relationships without encountering missing references. Before execution, establish a controlled environment by preparing a set of test interface definitions that form a circular inheritance relationship, where one interface extends another which in turn extends the first, creating a cycle that challenges the system's ability to handle complex type relationships, then define a concrete implementation that participates in this circular structure. Once this foundational scenario is in place, systematically examine a wide variety of standard platform types spanning fundamental language constructs, temporal utilities, collection frameworks, and streaming operations. For each type, instruct the system to locate the corresponding class definition within its internal catalog and retrieve the ordered list of all ancestor classes ascending toward the root object type, then verify that the system successfully produces a valid hierarchy without failing due to unresolved references or encountering empty results. This validation must confirm that the inheritance chain is properly constructed and accessible for every examined type, demonstrating the system's capability to navigate both straightforward linear inheritance paths and more complex scenarios involving interface cycles. The test employs JUnit 5 as the testing framework with parameterized test support to process multiple input types systematically, and relies on standard equality assertions to verify that the retrieved superclass hierarchy exists and is not missing for any of the examined platform types.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.classfile.JavaClassTest",
      "method_signature": "testGetSuperClasses(java.lang.Class)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.bcel.RepositoryTest",
      "code": "package org.apache.bcel;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.stream.Stream;\nimport org.apache.bcel.classfile.JavaClass;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests for the {@link Repository} class, focusing on its ability to handle complex inheritance hierarchies,\n * including circular interface dependencies and retrieving superclass chains for standard Java library types.\n */\nclass RepositoryTest {\n\n    /**\n     * An interface that creates a circular dependency with {@link CircularB}.\n     * This is used to test the repository's robustness in handling complex type relationships.\n     */\n    interface CircularA extends CircularB {\n    }\n\n    /**\n     * An interface that creates a circular dependency with {@link CircularA}.\n     * This is used to test the repository's robustness in handling complex type relationships.\n     */\n    interface CircularB extends CircularA {\n    }\n\n    /**\n     * A concrete class that implements the circular interface hierarchy, allowing the test\n     * to verify that the repository can process classes involved in such structures.\n     */\n    class ConcreteC implements CircularA {\n    }\n\n    private static Stream<String> standardPlatformTypesProvider() {\n        return Stream.of(\n            \"java.lang.String\",\n            \"java.time.LocalDate\",\n            \"java.util.ArrayList\",\n            \"java.util.stream.Stream\",\n            \"java.lang.Object\",\n            \"java.io.Serializable\"\n        );\n    }\n\n    /**\n     * Validates that the system can correctly retrieve the complete inheritance hierarchy for various\n     * standard library types, even when challenged with a circular interface inheritance structure.\n     * The test first establishes a scenario with circular interface dependencies to ensure the system's\n     * type analysis is robust. It then systematically checks a variety of standard platform types\n     * to confirm that their superclass hierarchies can be retrieved without errors or missing results.\n     *\n     * @param className The fully qualified name of the class to be examined.\n     * @throws ClassNotFoundException if the Repository cannot find the specified class.\n     */\n    @ParameterizedTest\n    @MethodSource(\"standardPlatformTypesProvider\")\n    void testGetSuperClassesWithCircularAndStandardTypes(final String className) throws ClassNotFoundException {\n        // 1. Establish and verify the controlled environment with circular dependencies.\n        // This confirms the system's ability to handle complex type relationships without failing.\n        final JavaClass circularClass = Repository.lookupClass(ConcreteC.class.getName());\n        assertNotNull(circularClass, \"Repository should handle classes participating in circular interface hierarchies.\");\n        final JavaClass[] circularSuperClasses = circularClass.getSuperClasses();\n        assertNotNull(circularSuperClasses, \"Superclass retrieval should not fail for classes in a circular interface hierarchy.\");\n\n        // 2. Systematically examine the inheritance hierarchy of the provided standard platform type.\n        final JavaClass javaClass = Repository.lookupClass(className);\n        assertNotNull(javaClass, \"Repository must locate the class for: \" + className);\n\n        final JavaClass[] superClasses = javaClass.getSuperClasses();\n\n        // 3. Verify that the system produced a valid, non-empty hierarchy.\n        assertNotNull(superClasses, \"The superclass hierarchy must not be null for: \" + className);\n\n        // For any type that is not java.lang.Object itself, the superclass chain\n        // must contain at least one ancestor (i.e., java.lang.Object).\n        if (!\"java.lang.Object\".equals(className)) {\n            assertTrue(superClasses.length > 0, \"Superclass hierarchy must not be empty for non-Object class: \" + className);\n        }\n    }\n}",
      "method_signature": "testGetSuperClasses(java.lang.Class)"
    },
    "structured_eval": null,
    "coverage_eval": null,
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22206,
    "output_tokens": 5370,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 245,
      "description": "Define a test class that validates the superclass retrieval functionality for Java class metadata across multiple standard library packages. Before any tests execute, create a temporary directory and generate three synthetic class files: two interfaces forming a circular inheritance relationship and a concrete class implementing one of those interfaces, persisting all three to the temporary directory to simulate a scenario where class metadata may encounter cyclic dependencies. For each parameterized test iteration, accept a Class object representing a type from the standard library (sourced from java.lang, java.time, java.util, or java.util.stream packages via method source providers). Within the test method, invoke the class name retrieval method on the provided Class object to obtain its fully qualified name, then use the Repository lookup capability to load the corresponding JavaClass metadata representation by passing this name. Upon successfully retrieving the JavaClass instance, immediately invoke its method to compute the superclass hierarchy, which traverses the inheritance chain up to Object. Assert that the returned superclass collection is not null, confirming that the metadata system can resolve the complete inheritance structure without encountering null references or unresolved dependencies, even when the underlying class graph contains cycles introduced during setup. The test validates resilience across diverse class types by exercising the same retrieval and verification logic against each parameterized input. Testing is performed using JUnit 5 with parameterized test support.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.classfile.JavaClassTest",
      "method_signature": "testGetSuperClasses(java.lang.Class)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.bcel.classfile.SuperclassRetrievalTest",
      "code": "package org.apache.commons.bcel.classfile;\n\nimport org.apache.commons.bcel.Const;\nimport org.apache.commons.bcel.Repository;\nimport org.apache.commons.bcel.generic.ClassGen;\nimport org.apache.commons.bcel.util.SyntheticRepository;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.stream.Stream;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\n/**\n * Validates the superclass retrieval functionality for Java class metadata,\n * particularly in scenarios involving cyclic dependencies.\n */\npublic class SuperclassRetrievalTest {\n\n    @TempDir\n    static Path tempDir;\n\n    private static String originalClassPath;\n\n    /**\n     * Creates a temporary directory and generates synthetic class files with a circular\n     * inheritance relationship to test the robustness of the class repository.\n     *\n     * @throws IOException if an I/O error occurs writing the class files.\n     */\n    @BeforeAll\n    public static void setUp() throws IOException {\n        final String oldPath = Repository.getClassPath();\n        originalClassPath = oldPath;\n\n        final String tempPath = tempDir.toString();\n        Repository.setRepository(SyntheticRepository.getInstance(new ClassPath(oldPath + ClassPath.PATH_SEP + tempPath)));\n\n\n        final String pkgName = \"org.apache.bcel.test\";\n        final String pkgPath = pkgName.replace('.', '/');\n        final Path pkgDir = tempDir.resolve(pkgPath);\n        Files.createDirectories(pkgDir);\n\n        final String iaName = pkgName + \".IA\";\n        final String ibName = pkgName + \".IB\";\n        final String cName = pkgName + \".C\";\n\n        // interface IA extends IB\n        final ClassGen iaCg = new ClassGen(iaName, \"java.lang.Object\", \"IA.java\", Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT,\n            new String[]{ibName});\n        final JavaClass ia = iaCg.getJavaClass();\n        ia.dump(pkgDir.resolve(\"IA.class\").toFile());\n\n        // interface IB extends IA\n        final ClassGen ibCg = new ClassGen(ibName, \"java.lang.Object\", \"IB.java\", Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT,\n            new String[]{iaName});\n        final JavaClass ib = ibCg.getJavaClass();\n        ib.dump(pkgDir.resolve(\"IB.class\").toFile());\n\n        // class C implements IA\n        final ClassGen cCg = new ClassGen(cName, \"java.lang.Object\", \"C.java\", Const.ACC_PUBLIC, new String[]{iaName});\n        cCg.addEmptyConstructor(Const.ACC_PUBLIC);\n        final JavaClass c = cCg.getJavaClass();\n        c.dump(pkgDir.resolve(\"C.class\").toFile());\n    }\n\n    /**\n     * Resets the repository to its original state.\n     */\n    @AfterAll\n    public static void tearDown() {\n        Repository.setRepository(SyntheticRepository.getInstance(new ClassPath(originalClassPath)));\n        Repository.clearCache();\n    }\n\n    private static Stream<Class<?>> javaLangClasses() {\n        return Stream.of(String.class, Integer.class, Thread.class, Exception.class);\n    }\n\n    private static Stream<Class<?>> javaTimeClasses() {\n        return Stream.of(java.time.LocalDate.class, java.time.ZonedDateTime.class, java.time.Duration.class);\n    }\n\n    private static Stream<Class<?>> javaUtilClasses() {\n        return Stream.of(java.util.ArrayList.class, java.util.HashMap.class, java.util.Optional.class);\n    }\n\n    private static Stream<Class<?>> javaUtilStreamClasses() {\n        return Stream.of(java.util.stream.Stream.class, java.util.stream.Collectors.class);\n    }\n\n    /**\n     * Provides a stream of classes from various standard library packages for parameterized testing.\n     *\n     * @return A stream of {@link Class} objects.\n     */\n    static Stream<Class<?>> standardLibraryClassesProvider() {\n        return Stream.of(\n            javaLangClasses(),\n            javaTimeClasses(),\n            javaUtilClasses(),\n            javaUtilStreamClasses()\n        ).flatMap(s -> s);\n    }\n\n    /**\n     * Tests that the superclass hierarchy can be retrieved for a given class\n     * without errors, even when cyclic dependencies exist in the repository.\n     *\n     * @param clazz The class to be inspected, provided by the method source.\n     * @throws ClassNotFoundException if the class cannot be located by the repository.\n     */\n    @ParameterizedTest\n    @MethodSource(\"standardLibraryClassesProvider\")\n    public void testSuperclassRetrievalWithCircularDependencies(final Class<?> clazz) throws ClassNotFoundException {\n        final JavaClass javaClass = Repository.lookupClass(clazz.getName());\n        assertNotNull(javaClass, \"The looked up JavaClass should not be null.\");\n\n        final JavaClass[] superClasses = javaClass.getSuperClasses();\n        assertNotNull(superClasses, \"The array of superclasses should not be null.\");\n    }\n}",
      "method_signature": "testGetSuperClasses(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 31786,
    "output_tokens": 6875,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 248,
      "description": "Define a test method that validates the behavior of a class lookup operation when encountering a circular interface inheritance structure by configuring a temporary directory for dynamically generated class files, then create helper methods that generate three interdependent bytecode artifacts: the first helper constructs an interface that extends a second interface, the second helper constructs the reciprocal interface that extends the first (completing the cycle), and the third helper constructs a concrete class implementing the first interface, with each helper using a ClassGen instance to define the interface or class metadata including access flags, superclass references, and interface declarations, then dumping the resulting JavaClass bytecode to the temporary directory as class files. In the suite-level setup, invoke all three helper methods to establish the circular dependency structure on disk before any test executes. Within the test method, construct a classpath string by concatenating the temporary directory path with the system classpath using the platform-specific path separator, then configure the Repository singleton to use a SyntheticRepository instance initialized with a ClassPath object built from this combined classpath string, enabling the repository to locate the malicious class files. Invoke the Repository's lookupClass method with the target class name and immediately call findField on the returned JavaClass instance, passing a non-existent field name and an integer type descriptor, wrapping this invocation in an assertion that verifies a ClassCircularityError is thrown, confirming that the bytecode class file infrastructure detects the cyclic interface inheritance when attempting field resolution. The test uses JUnit 5 for test execution and assertions.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.classfile.JavaClassTest",
      "method_signature": "testFindFieldCustomInterface1()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.bcel.util.RepositoryCircularInterfaceTest",
      "code": "package org.apache.bcel.util;\n\nimport org.apache.bcel.Const;\nimport org.apache.bcel.Repository;\nimport org.apache.bcel.classfile.JavaClass;\nimport org.apache.bcel.classfile.Method;\nimport org.apache.bcel.generic.ClassGen;\nimport org.apache.bcel.generic.ConstantPoolGen;\nimport org.apache.bcel.generic.InstructionList;\nimport org.apache.bcel.generic.InstructionFactory;\nimport org.apache.bcel.generic.MethodGen;\nimport org.apache.bcel.generic.Type;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Path;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class RepositoryCircularInterfaceTest {\n\n    @TempDir\n    static Path tempDir;\n\n    private static final String INTERFACE1_NAME = \"CircularInterface1\";\n    private static final String INTERFACE2_NAME = \"CircularInterface2\";\n    private static final String CLASS_NAME = \"CircularClass\";\n    private static org.apache.bcel.util.Repository originalRepository;\n\n    @BeforeAll\n    public static void setUp() throws IOException {\n        originalRepository = Repository.getRepository();\n        createCircularInterface1(tempDir);\n        createCircularInterface2(tempDir);\n        createImplementingClass(tempDir);\n    }\n\n    @AfterAll\n    public static void tearDown() {\n        Repository.setRepository(originalRepository);\n    }\n\n    private static void createCircularInterface1(Path directory) throws IOException {\n        final ClassGen cg = new ClassGen(INTERFACE1_NAME, \"java.lang.Object\",\n            INTERFACE1_NAME + \".java\", Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT,\n            new String[]{INTERFACE2_NAME});\n        cg.getJavaClass().dump(directory.resolve(INTERFACE1_NAME + \".class\").toFile());\n    }\n\n    private static void createCircularInterface2(Path directory) throws IOException {\n        final ClassGen cg = new ClassGen(INTERFACE2_NAME, \"java.lang.Object\",\n            INTERFACE2_NAME + \".java\", Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT,\n            new String[]{INTERFACE1_NAME});\n        cg.getJavaClass().dump(directory.resolve(INTERFACE2_NAME + \".class\").toFile());\n    }\n\n    private static void createImplementingClass(Path directory) throws IOException {\n        final ClassGen cg = new ClassGen(CLASS_NAME, \"java.lang.Object\",\n            CLASS_NAME + \".java\", Const.ACC_PUBLIC, new String[]{INTERFACE1_NAME});\n        final ConstantPoolGen cp = cg.getConstantPool();\n        final InstructionList il = new InstructionList();\n        final MethodGen mg = new MethodGen(Const.ACC_PUBLIC, Type.VOID, Type.NO_ARGS, new String[0],\n            \"<init>\", CLASS_NAME, il, cp);\n\n        il.append(InstructionFactory.createLoad(Type.OBJECT, 0));\n        il.append(InstructionFactory.createInvoke(\"java.lang.Object\", \"<init>\", Type.VOID, Type.NO_ARGS,\n            Const.INVOKESPECIAL));\n        il.append(InstructionFactory.createReturn(Type.VOID));\n        mg.setMaxStack();\n        mg.setMaxLocals();\n        cg.addMethod(mg.getMethod());\n\n        cg.getJavaClass().dump(directory.resolve(CLASS_NAME + \".class\").toFile());\n    }\n\n    @Test\n    public void testCircularInterfaceLookupThrowsError() {\n        final String classpath = tempDir.toString() + File.pathSeparator + System.getProperty(\"java.class.path\");\n        final ClassPath classPath = new ClassPath(classpath);\n        final org.apache.bcel.util.Repository newRepository = SyntheticRepository.getInstance(classPath);\n        Repository.setRepository(newRepository);\n\n        assertThrows(ClassCircularityError.class, () -> {\n            JavaClass javaClass = Repository.lookupClass(CLASS_NAME);\n            // The error is deferred until the class structure is actually traversed.\n            javaClass.findField(\"nonExistentField\", Type.INT);\n        });\n    }\n}",
      "method_signature": "testFindFieldCustomInterface1()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20533,
    "output_tokens": 7387,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 266,
      "description": "Define a test class containing a static final `String` field `CLASS_NAME`, three static final `Class<?>[]` fields `CLASSES_JAVA_LANG`, `CLASSES_JAVA_TIME`, `CLASSES_JAVA_UTIL`, and `CLASSES_JAVA_UTIL_STREAM`, and a static `Path` field `tempDir` annotated with `@TempDir`. Implement a static setup method annotated with `@BeforeAll` that throws `Exception`, within which define a private static method that creates `InterfaceA` by instantiating a `ClassGen` with arguments `\"InterfaceA\"`, `\"java.lang.Object\"`, `\"InterfaceA.java\"`, the bitwise OR of `Const.ACC_PUBLIC`, `Const.ACC_INTERFACE`, and `Const.ACC_ABSTRACT`, and a `String[]` containing `\"InterfaceB\"`, then invoke `getJavaClass()` on the `ClassGen` instance, chain `dump()` with the result of `tempDir.resolve(\"InterfaceA.class\").toString()`, and invoke this method first. Next, define a private static method that creates `InterfaceB` by instantiating a `ClassGen` with arguments `\"InterfaceB\"`, `\"java.lang.Object\"`, `\"InterfaceB.java\"`, the same access flags, and a `String[]` containing `\"InterfaceA\"`, then invoke `getJavaClass()` on the `ClassGen` instance, chain `dump()` with the result of `tempDir.resolve(\"InterfaceB.class\").toString()`, and invoke this method second. Finally, define a private static method that creates the target class by instantiating a `ClassGen` with arguments `CLASS_NAME`, `\"java.lang.Object\"`, `\"VulnerableClass.java\"`, `Const.ACC_PUBLIC`, and a `String[]` containing `\"InterfaceA\"`, assigning it to `cg`, then create an `InstructionList` assigned to `il`, instantiate a `MethodGen` with arguments `Const.ACC_PUBLIC`, `Type.VOID`, `Type.NO_ARGS`, an empty `String[]`, `\"<init>\"`, `CLASS_NAME`, `il`, and `cg.getConstantPool()`, assigning it to `constructor`, instantiate an `InstructionFactory` with argument `cg` assigned to `factory`, invoke `InstructionFactory.createLoad(Type.OBJECT, 0)` and append the result to `il`, invoke `factory.createInvoke(\"java.lang.Object\", \"<init>\", Type.VOID, Type.NO_ARGS, Const.INVOKESPECIAL)` and append the result to `il`, invoke `InstructionFactory.createReturn(Type.VOID)` and append the result to `il`, invoke `constructor.setMaxStack()`, invoke `constructor.setMaxLocals()`, invoke `cg.addMethod(constructor.getMethod())`, invoke `il.dispose()`, then invoke `cg.getJavaClass().dump(tempDir.resolve(CLASS_NAME + \".class\").toString())`, and invoke this method third. Write a parameterized test method annotated with `@ParameterizedTest`, `@MethodSource(\"getClassesJavaLang\")`, `@MethodSource(\"getClassesJavaTime\")`, `@MethodSource(\"getClassesJavaUtil\")`, and `@MethodSource(\"getClassesJavaUtilStream\")` that accepts a `Class<?>` parameter `clazz` and throws `ClassNotFoundException`, within which invoke `Repository.lookupClass(clazz.getName())`, chain `getSuperClasses()` on the returned `JavaClass`, and pass the result to `assertNotNull()`. The test uses JUnit 5 Assertions, method-level annotations `@ParameterizedTest` with four `@MethodSource` annotations, class-level annotation `@TempDir` on the `tempDir` field, and setup method annotation `@BeforeAll`.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.classfile.JavaClassTest",
      "method_signature": "testGetSuperClasses(java.lang.Class)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.bcel.generic.BCEL351Test",
      "code": "package org.apache.commons.bcel.generic;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.bcel.Const;\nimport org.apache.commons.bcel.classfile.JavaClass;\nimport org.apache.commons.bcel.classfile.Method;\nimport org.apache.commons.bcel.util.Repository;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class BCEL351Test {\n\n    private static final String CLASS_NAME = \"VulnerableClass\";\n\n    private static final Class<?>[] CLASSES_JAVA_LANG = { String.class, Integer.class, Object.class, Thread.class,\n            Cloneable.class };\n    private static final Class<?>[] CLASSES_JAVA_TIME = { LocalDate.class, Instant.class };\n    private static final Class<?>[] CLASSES_JAVA_UTIL = { ArrayList.class, HashMap.class };\n    private static final Class<?>[] CLASSES_JAVA_UTIL_STREAM = { Stream.class, Collectors.class };\n\n    @TempDir\n    private static Path tempDir;\n\n    private static void createInterfaceA() throws IOException {\n        final ClassGen cg = new ClassGen(\"InterfaceA\", \"java.lang.Object\", \"InterfaceA.java\",\n                Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT, new String[] { \"InterfaceB\" });\n        cg.getJavaClass().dump(tempDir.resolve(\"InterfaceA.class\").toString());\n    }\n\n    private static void createInterfaceB() throws IOException {\n        final ClassGen cg = new ClassGen(\"InterfaceB\", \"java.lang.Object\", \"InterfaceB.java\",\n                Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT, new String[] { \"InterfaceA\" });\n        cg.getJavaClass().dump(tempDir.resolve(\"InterfaceB.class\").toString());\n    }\n\n    private static void createVulnerableClass() throws IOException {\n        final ClassGen cg = new ClassGen(CLASS_NAME, \"java.lang.Object\", \"VulnerableClass.java\",\n                Const.ACC_PUBLIC, new String[] { \"InterfaceA\" });\n        final InstructionList il = new InstructionList();\n        final MethodGen constructor = new MethodGen(Const.ACC_PUBLIC, Type.VOID, Type.NO_ARGS, new String[0], \"<init>\",\n                CLASS_NAME, il, cg.getConstantPool());\n        final InstructionFactory factory = new InstructionFactory(cg);\n        il.append(InstructionFactory.createLoad(Type.OBJECT, 0));\n        il.append(factory.createInvoke(\"java.lang.Object\", \"<init>\", Type.VOID, Type.NO_ARGS, Const.INVOKESPECIAL));\n        il.append(InstructionFactory.createReturn(Type.VOID));\n        constructor.setMaxStack();\n        constructor.setMaxLocals();\n        cg.addMethod(constructor.getMethod());\n        il.dispose();\n        cg.getJavaClass().dump(tempDir.resolve(CLASS_NAME + \".class\").toString());\n    }\n\n    public static Stream<Class<?>> getClassesJavaLang() {\n        return Stream.of(CLASSES_JAVA_LANG);\n    }\n\n    public static Stream<Class<?>> getClassesJavaTime() {\n        return Stream.of(CLASSES_JAVA_TIME);\n    }\n\n    public static Stream<Class<?>> getClassesJavaUtil() {\n        return Stream.of(CLASSES_JAVA_UTIL);\n    }\n\n    public static Stream<Class<?>> getClassesJavaUtilStream() {\n        return Stream.of(CLASSES_JAVA_UTIL_STREAM);\n    }\n\n    @BeforeAll\n    public static void setUp() throws Exception {\n        createInterfaceA();\n        createInterfaceB();\n        createVulnerableClass();\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"getClassesJavaLang\")\n    @MethodSource(\"getClassesJavaTime\")\n    @MethodSource(\"getClassesJavaUtil\")\n    @MethodSource(\"getClassesJavaUtilStream\")\n    public void testGetSuperClasses(final Class<?> clazz) throws ClassNotFoundException {\n        final JavaClass javaClass = Repository.lookupClass(clazz.getName());\n        assertNotNull(javaClass.getSuperClasses());\n    }\n}",
      "method_signature": "testGetSuperClasses(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 21305,
    "output_tokens": 2556,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 280,
      "description": "Create a test case to validate that the system correctly detects and reports circular inheritance dependencies when attempting to locate structural elements within class definitions that participate in such cycles. Prepare three interconnected type definitions where the first class extends a second interface, the second interface extends the first class (forming a bidirectional dependency loop), and a third test class implements the first class, then register these definitions within the system's type repository. Once the circular relationship is established in the repository, attempt to search for a structural element that does not exist within the test class, specifically requesting a numeric property that the class does not contain. Ensure the system recognizes the circular dependency during this search operation and signals a failure indicating the inheritance structure is invalid, confirming that the repository properly guards against infinite traversal of cyclic type hierarchies. After validation, remove all three registered type definitions from the repository to restore its original state. This test uses JUnit 5 as the testing framework and AssertJ for validating that the expected circular dependency error occurs during the search operation.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.classfile.JavaClassTest",
      "method_signature": "testFindFieldCustomClass()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.bcel.CircularInheritanceTest",
      "code": "package org.apache.commons.bcel;\n\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\nimport org.apache.commons.bcel.classfile.ClassFormatException;\nimport org.apache.commons.bcel.classfile.JavaClass;\nimport org.apache.commons.bcel.generic.ClassGen;\nimport org.apache.commons.bcel.generic.ConstantPoolGen;\nimport org.junit.jupiter.api.Test;\n\npublic class CircularInheritanceTest {\n\n    @Test\n    public void testCircularInheritanceDetection() throws ClassNotFoundException {\n        final String circularAClassName = \"org.apache.commons.bcel.test.CircularA\";\n        final String circularBInterfaceName = \"org.apache.commons.bcel.test.CircularB\";\n        final String testClassName = \"org.apache.commons.bcel.test.TestClass\";\n\n        // 1. Prepare interconnected type definitions.\n        // Create Class A: a class that extends an interface (Interface B).\n        // This is not valid in Java, but we are testing BCEL's ability to handle it.\n        final ConstantPoolGen cpA = new ConstantPoolGen();\n        final ClassGen classA = new ClassGen(circularAClassName, circularBInterfaceName, \"CircularA.java\", Const.ACC_PUBLIC,\n            new String[0], cpA);\n        final JavaClass javaClassA = classA.getJavaClass();\n\n        // Create Interface B: an interface that extends a class (Class A).\n        // This forms the circular dependency.\n        final ConstantPoolGen cpB = new ConstantPoolGen();\n        final ClassGen interfaceB = new ClassGen(circularBInterfaceName, \"java.lang.Object\", \"CircularB.java\",\n            Const.ACC_PUBLIC | Const.ACC_INTERFACE, new String[] { circularAClassName }, cpB);\n        final JavaClass javaClassB = interfaceB.getJavaClass();\n\n        // Create TestClass: a class that extends Class A.\n        final ConstantPoolGen cpC = new ConstantPoolGen();\n        final ClassGen testClassGen = new ClassGen(testClassName, circularAClassName, \"TestClass.java\", Const.ACC_PUBLIC,\n            new String[0], cpC);\n        final JavaClass javaTestClass = testClassGen.getJavaClass();\n\n        try {\n            // 2. Register definitions in the repository.\n            Repository.addClass(javaClassA);\n            Repository.addClass(javaClassB);\n            Repository.addClass(javaTestClass);\n\n            // 3. Look up the test class.\n            final JavaClass lookupTestClass = Repository.lookupClass(testClassName);\n\n            // 4. Assert that searching for a field triggers a circular dependency error.\n            // getFields() traverses the class hierarchy, which should detect the cycle.\n            assertThatThrownBy(() -> lookupTestClass.getFields())\n                .isInstanceOf(ClassFormatException.class)\n                .hasMessageContaining(\"Circular inheritance reference\");\n\n        } finally {\n            // 5. Clean up the repository to restore its original state.\n            Repository.removeClass(javaClassA);\n            Repository.removeClass(javaClassB);\n            Repository.removeClass(javaTestClass);\n        }\n    }\n}",
      "method_signature": "testFindFieldCustomClass()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 25305,
    "output_tokens": 8872,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 281,
      "description": "Define a test method that accepts a Class object as a parameter and validates the retrieval of all interfaces for various Java standard library classes across multiple packages. Before any tests execute, establish a suite-level setup that programmatically generates three interdependent bytecode artifacts in a temporary directory: create two interface definitions that form a circular inheritance relationship where each extends the other, then create a concrete class that implements one of these interfaces, thereby introducing a cyclic dependency scenario into the test environment. Within the parameterized test method, invoke the class lookup capability on the Repository using the fully qualified name obtained from the input Class parameter to retrieve the corresponding JavaClass representation, then immediately invoke the method that computes all transitively implemented interfaces on the retrieved JavaClass object and assert that the returned collection of interfaces is not null, confirming that the interface resolution logic handles both standard library types and cyclically dependent custom types without failure. The test executes across multiple input sources providing Class objects from java.lang, java.time, java.util, and java.util.stream packages, ensuring broad coverage of the standard library's type hierarchy. Testing is performed using JUnit 5 with parameterized test support.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.classfile.JavaClassTest",
      "method_signature": "testGetAllInterfaces(java.lang.Class)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.bcel.RepositoryGetAllInterfacesTest",
      "code": "package org.apache.bcel;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.stream.Stream;\nimport org.apache.bcel.classfile.JavaClass;\nimport org.apache.bcel.generic.ClassGen;\nimport org.apache.bcel.generic.ConstantPoolGen;\nimport org.apache.bcel.generic.InstructionFactory;\nimport org.apache.bcel.generic.InstructionList;\nimport org.apache.bcel.generic.MethodGen;\nimport org.apache.bcel.generic.Type;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests the retrieval of all interfaces for various classes, including those with cyclic dependencies, using the BCEL\n * Repository.\n */\npublic class RepositoryGetAllInterfacesTest {\n\n    private static final String TEST_PACKAGE_NAME = \"org.apache.bcel.testsubjects\";\n    private static final String INTERFACE_A_FQDN = TEST_PACKAGE_NAME + \".CyclicInterfaceA\";\n    private static final String INTERFACE_B_FQDN = TEST_PACKAGE_NAME + \".CyclicInterfaceB\";\n    private static final String IMPLEMENTATION_FQDN = TEST_PACKAGE_NAME + \".CyclicImplementation\";\n\n    @TempDir\n    private static File tempDir;\n\n    @BeforeAll\n    public static void beforeAll() throws IOException {\n        final File packageDir = new File(tempDir, TEST_PACKAGE_NAME.replace('.', File.separatorChar));\n        Files.createDirectories(packageDir.toPath());\n\n        // 1. Create two interfaces with a circular dependency (A extends B, B extends A)\n        createInterface(INTERFACE_A_FQDN, packageDir, INTERFACE_B_FQDN);\n        createInterface(INTERFACE_B_FQDN, packageDir, INTERFACE_A_FQDN);\n\n        // 2. Create a class that implements one of the cyclic interfaces\n        createImplementation(IMPLEMENTATION_FQDN, packageDir, INTERFACE_A_FQDN);\n\n        // 3. Add the temporary directory to the repository's class path\n        Repository.clearCache();\n        Repository.addClassPath(tempDir.getAbsolutePath());\n    }\n\n    private static void createInterface(final String interfaceName, final File packageDir, final String extendedInterfaceName) throws IOException {\n        final ClassGen cg = new ClassGen(interfaceName, \"java.lang.Object\", interfaceName + \".java\",\n            Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT, new String[]{extendedInterfaceName});\n        final File classFile = new File(packageDir, interfaceName.substring(TEST_PACKAGE_NAME.length() + 1) + \".class\");\n        cg.getJavaClass().dump(classFile);\n    }\n\n    private static void createImplementation(final String className, final File packageDir, final String implementedInterfaceName) throws IOException {\n        final ClassGen cg = new ClassGen(className, \"java.lang.Object\", className + \".java\",\n            Const.ACC_PUBLIC, new String[]{implementedInterfaceName});\n        final ConstantPoolGen cp = cg.getConstantPool();\n        final InstructionList il = new InstructionList();\n        il.append(InstructionFactory.createReturn(Type.VOID));\n        final MethodGen mg = new MethodGen(Const.ACC_PUBLIC, Type.VOID, Type.NO_ARGS, new String[0], \"<init>\",\n            className, il, cp);\n        cg.addMethod(mg.getMethod());\n        final File classFile = new File(packageDir, className.substring(TEST_PACKAGE_NAME.length() + 1) + \".class\");\n        cg.getJavaClass().dump(classFile);\n    }\n\n    @AfterAll\n    public static void afterAll() {\n        Repository.removeClassPath(tempDir.getAbsolutePath());\n        Repository.clearCache();\n    }\n\n    static Stream<String> classNameProvider() {\n        return Stream.of(\n            \"java.lang.String\",\n            \"java.time.LocalDate\",\n            \"java.util.ArrayList\",\n            \"java.util.stream.Stream\",\n            IMPLEMENTATION_FQDN);\n    }\n\n    @ParameterizedTest(name = \"{index}: {0}\")\n    @MethodSource(\"classNameProvider\")\n    void testGetAllInterfaces(final String className) throws ClassNotFoundException {\n        // As per the test description, look up the JavaClass representation from its fully qualified name.\n        final JavaClass javaClass = Repository.lookupClass(className);\n        assertNotNull(javaClass, \"Failed to look up JavaClass for: \" + className);\n\n        // Invoke the method to get all transitively implemented interfaces.\n        final JavaClass[] allInterfaces = javaClass.getAllInterfaces();\n\n        // Assert that the result is not null, confirming the resolution handles both standard\n        // library classes and our custom-generated types with cyclic dependencies.\n        assertNotNull(allInterfaces, \"The returned interface array for \" + className + \" should not be null.\");\n    }\n}",
      "method_signature": "testGetAllInterfaces(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 11478,
    "output_tokens": 7826,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 283,
      "description": "Create a test case to validate that the bytecode analysis system correctly retrieves the complete interface hierarchy for various standard library types across multiple packages. Before executing the test, establish a controlled environment by generating three custom interface definitions that form a circular dependency chain, where the first interface extends the second, the second extends the first, and a concrete type implements the first interface, then compile these definitions into bytecode files within a temporary workspace to simulate complex inheritance scenarios that the system must navigate without entering infinite loops. Execute the validation across a comprehensive collection of fundamental types from the core language packages, time handling packages, utility collections, and stream processing packages, ensuring the system can query each type by its fully qualified name and successfully retrieve its complete interface ancestry without encountering missing references or null results. For each type variation provided through the test parameters, retrieve the corresponding bytecode representation from the system's class repository, invoke the interface hierarchy analysis capability, and verify that the system returns a valid collection of all implemented and inherited interfaces rather than an absent or incomplete result, confirming the analysis handles both simple types with no interfaces and complex types with deep inheritance trees equally well. Use JUnit 5 as the testing framework with parameterized test support to execute the same validation logic across all type variations, and employ AssertJ for fluent assertion syntax to verify the non-null condition of the interface collection returned by the analysis operation.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.classfile.JavaClassTest",
      "method_signature": "testGetAllInterfaces(java.lang.Class)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.bcel.classfile.InterfaceHierarchyTest",
      "code": "package org.apache.bcel.classfile;\n\nimport org.apache.bcel.Repository;\nimport org.apache.bcel.util.ClassPath;\nimport org.apache.bcel.util.SyntheticRepository;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport javax.tools.JavaCompiler;\nimport javax.tools.ToolProvider;\nimport java.io.IOException;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.stream.Stream;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Test case to validate that the bytecode analysis system correctly retrieves the complete interface hierarchy for\n * various standard library types, including complex scenarios like circular interface dependencies.\n */\npublic class InterfaceHierarchyTest {\n\n    private static Path tempWorkDir;\n    private static org.apache.bcel.util.Repository originalRepository;\n\n    @BeforeAll\n    static void setUp() throws IOException {\n        // 1. Establish a controlled environment with a temporary workspace.\n        tempWorkDir = Files.createTempDirectory(\"bcel-interface-test-\");\n        Path srcDir = tempWorkDir.resolve(\"src\");\n        Path outDir = tempWorkDir.resolve(\"classes\");\n        Files.createDirectories(srcDir);\n        Files.createDirectories(outDir);\n\n        // 2. Generate custom sources for a circular interface dependency to test for infinite loops.\n        // interface A extends B, interface B extends A, and a class C that implements A.\n        Path packageDir = srcDir.resolve(\"com\").example();\n        Files.createDirectories(packageDir);\n\n        String interfaceASource = \"package com.example; public interface A extends com.example.B {}\";\n        String interfaceBSource = \"package com.example; public interface B extends com.example.A {}\";\n        String classCSource = \"package com.example; public class C implements com.example.A {}\";\n\n        Path interfaceAFile = packageDir.resolve(\"A.java\");\n        Path interfaceBFile = packageDir.resolve(\"B.java\");\n        Path classCFile = packageDir.resolve(\"C.java\");\n\n        Files.writeString(interfaceAFile, interfaceASource);\n        Files.writeString(interfaceBFile, interfaceBSource);\n        Files.writeString(classCFile, classCSource);\n\n        // 3. Compile the custom definitions into bytecode files.\n        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n        assertThat(compiler).as(\"Java compiler (JDK) is required to run this test\").isNotNull();\n\n        String[] compilerArgs = {\n            \"-d\", outDir.toString(),\n            \"-cp\", outDir.toString(),\n            interfaceAFile.toString(),\n            interfaceBFile.toString(),\n            classCFile.toString()\n        };\n        int compilationResult = compiler.run(null, null, null, compilerArgs);\n        assertThat(compilationResult).as(\"Compilation of test-specific sources failed\").isEqualTo(0);\n\n        // 4. Configure BCEL's repository to use a classpath that includes our temporary bytecode.\n        originalRepository = Repository.getRepository();\n        String newClassPath = ClassPath.getClassPath() + System.getProperty(\"path.separator\") + outDir.toString();\n        SyntheticRepository newRepository = SyntheticRepository.getInstance(new ClassPath(newClassPath));\n        Repository.setRepository(newRepository);\n    }\n\n    @AfterAll\n    static void tearDown() throws IOException {\n        // Restore the original BCEL repository to prevent side effects on other tests.\n        if (originalRepository != null) {\n            Repository.setRepository(originalRepository);\n        }\n\n        // Clean up the temporary workspace.\n        if (tempWorkDir != null) {\n            Files.walkFileTree(tempWorkDir, new SimpleFileVisitor<>() {\n                @Override\n                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                    Files.delete(file);\n                    return FileVisitResult.CONTINUE;\n                }\n\n                @Override\n                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n                    Files.delete(dir);\n                    return FileVisitResult.CONTINUE;\n                }\n            });\n        }\n    }\n\n    /**\n     * Provides a comprehensive collection of fundamental types for validation.\n     */\n    private static Stream<String> provideClassNamesForValidation() {\n        return Stream.of(\n            // Core language package types\n            \"java.lang.String\",\n            \"java.lang.Integer\",\n            \"java.lang.Object\", // Base case with no interfaces\n            // Utility collections package types\n            \"java.util.ArrayList\",\n            \"java.util.HashMap\",\n            // Time handling package types\n            \"java.time.ZonedDateTime\",\n            \"java.time.Instant\",\n            // Stream processing package types\n            \"java.util.stream.Stream\", // An interface with its own hierarchy\n            // Custom compiled type with circular dependency\n            \"com.example.C\"\n        );\n    }\n\n    @ParameterizedTest(name = \"class = {0}\")\n    @MethodSource(\"provideClassNamesForValidation\")\n    void validatesCompleteInterfaceHierarchyRetrieval(String className) throws ClassNotFoundException {\n        // Arrange: Retrieve the bytecode representation from the repository.\n        JavaClass javaClass = Repository.lookupClass(className);\n        assertThat(javaClass).as(\"JavaClass for '%s' should be found in the repository\", className).isNotNull();\n\n        // Act: Invoke the interface hierarchy analysis.\n        JavaClass[] allInterfaces = javaClass.getAllInterfaces();\n\n        // Assert: Verify the system returns a valid collection, not a null result.\n        // This confirms the analysis handles both simple and complex types, including those with\n        // deep or circular inheritance trees, without crashing or returning an incomplete result.\n        assertThat(allInterfaces).as(\"The interface hierarchy for '%s' must not be null\", className).isNotNull();\n    }\n}",
      "method_signature": "testGetAllInterfaces(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18438,
    "output_tokens": 7138,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 285,
      "description": "Define a test class containing six static fields: `CLASS_NAME` of type `String`, `CLASSES_JAVA_LANG` of type `Class<?>[]`, `CLASSES_JAVA_TIME` of type `Class<?>[]`, `CLASSES_JAVA_UTIL` of type `Class<?>[]`, `CLASSES_JAVA_UTIL_STREAM` of type `Class<?>[]`, all declared as `private static final`, and a static field `tempDir` of type `Path` annotated with `@TempDir`. Implement a static setup method annotated with `@BeforeAll` that invokes three private helper methods in sequence: first invoke `createInterfaceA()`, which constructs a `ClassGen` instance by passing arguments `\"InterfaceA\"`, `\"java.lang.Object\"`, `\"InterfaceA.java\"`, the bitwise OR of `Const.ACC_PUBLIC`, `Const.ACC_INTERFACE`, and `Const.ACC_ABSTRACT`, and a `String[]` array containing the single element `\"InterfaceB\"`, then invoke `getJavaClass()` on the `ClassGen` instance, chain `dump()` with the result of calling `tempDir.resolve(\"InterfaceA.class\").toString()`, thereby writing the class file to the temporary directory; second invoke `createInterfaceB()`, which similarly constructs a `ClassGen` instance with arguments `\"InterfaceB\"`, `\"java.lang.Object\"`, `\"InterfaceB.java\"`, the same access flags, and a `String[]` array containing `\"InterfaceA\"`, then invoke `getJavaClass()` and `dump()` with `tempDir.resolve(\"InterfaceB.class\").toString()`; third invoke `createTargetClass()`, which constructs a `ClassGen` instance with arguments `CLASS_NAME`, `\"java.lang.Object\"`, `\"VulnerableClass.java\"`, `Const.ACC_PUBLIC`, and a `String[]` array containing `\"InterfaceA\"`, then create an `InstructionList` instance assigned to `il`, create a `MethodGen` instance assigned to `constructor` by passing `Const.ACC_PUBLIC`, `Type.VOID`, `Type.NO_ARGS`, an empty `String[]` array, `\"<init>\"`, `CLASS_NAME`, `il`, and the result of invoking `getConstantPool()` on the `ClassGen` instance, create an `InstructionFactory` instance assigned to `factory` by passing the `ClassGen` instance, invoke `il.append()` with the result of calling `InstructionFactory.createLoad(Type.OBJECT, 0)`, invoke `il.append()` with the result of calling `factory.createInvoke(\"java.lang.Object\", \"<init>\", Type.VOID, Type.NO_ARGS, Const.INVOKESPECIAL)`, invoke `il.append()` with the result of calling `InstructionFactory.createReturn(Type.VOID)`, invoke `constructor.setMaxStack()`, invoke `constructor.setMaxLocals()`, invoke `cg.addMethod()` with the result of calling `constructor.getMethod()`, invoke `il.dispose()`, then invoke `getJavaClass()` on the `ClassGen` instance and chain `dump()` with `tempDir.resolve(CLASS_NAME + \".class\").toString()`. Write a test method annotated with `@Test` and declared to throw `ClassNotFoundException` that constructs a `String` variable `classPath` by concatenating `tempDir.toString()`, the result of `System.getProperty(\"path.separator\")`, and the result of `System.getProperty(\"java.class.path\")`, then invoke `Repository.setRepository()` with the result of calling `SyntheticRepository.getInstance(new ClassPath(classPath))`, and finally invoke `assertThrows(ClassCircularityError.class, ...)` with a lambda expression that calls `Repository.lookupClass(CLASS_NAME).findField(\"nonExistentField\", Type.INT)`, verifying that a `ClassCircularityError` is thrown when attempting to find a field in a class whose interface hierarchy contains a circular dependency. The test uses class-level annotation `@Test`, method-level annotation `@Test`, JUnit 5 Assertions via `assertThrows`, and no mocking libraries.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.classfile.JavaClassTest",
      "method_signature": "testFindFieldCustomInterface1()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.bcel.util.CircularClassDependencyTest",
      "code": "package org.apache.bcel.util;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport org.apache.bcel.Const;\nimport org.apache.bcel.Repository;\nimport org.apache.bcel.classfile.JavaClass;\nimport org.apache.bcel.generic.ClassGen;\nimport org.apache.bcel.generic.ConstantPoolGen;\nimport org.apache.bcel.generic.InstructionFactory;\nimport org.apache.bcel.generic.InstructionList;\nimport org.apache.bcel.generic.MethodGen;\nimport org.apache.bcel.generic.Type;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\npublic class CircularClassDependencyTest {\n\n    private static final String CLASS_NAME = \"VulnerableClass\";\n    private static final Class<?>[] CLASSES_JAVA_LANG = new Class<?>[0];\n    private static final Class<?>[] CLASSES_JAVA_TIME = new Class<?>[0];\n    private static final Class<?>[] CLASSES_JAVA_UTIL = new Class<?>[0];\n    private static final Class<?>[] CLASSES_JAVA_UTIL_STREAM = new Class<?>[0];\n\n    @TempDir\n    static Path tempDir;\n\n    @BeforeAll\n    public static void setup() throws IOException {\n        createInterfaceA();\n        createInterfaceB();\n        createTargetClass();\n    }\n\n    private static void createInterfaceA() throws IOException {\n        final ClassGen cg = new ClassGen(\"InterfaceA\", \"java.lang.Object\", \"InterfaceA.java\",\n            Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT, new String[]{\"InterfaceB\"});\n        cg.getJavaClass().dump(tempDir.resolve(\"InterfaceA.class\").toString());\n    }\n\n    private static void createInterfaceB() throws IOException {\n        final ClassGen cg = new ClassGen(\"InterfaceB\", \"java.lang.Object\", \"InterfaceB.java\",\n            Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT, new String[]{\"InterfaceA\"});\n        cg.getJavaClass().dump(tempDir.resolve(\"InterfaceB.class\").toString());\n    }\n\n    private static void createTargetClass() throws IOException {\n        final ClassGen cg = new ClassGen(CLASS_NAME, \"java.lang.Object\", \"VulnerableClass.java\",\n            Const.ACC_PUBLIC, new String[]{\"InterfaceA\"});\n        final InstructionList il = new InstructionList();\n        final ConstantPoolGen cp = cg.getConstantPool();\n        final MethodGen constructor = new MethodGen(Const.ACC_PUBLIC, Type.VOID, Type.NO_ARGS,\n            new String[0], \"<init>\", CLASS_NAME, il, cp);\n        final InstructionFactory factory = new InstructionFactory(cg);\n\n        il.append(InstructionFactory.createLoad(Type.OBJECT, 0));\n        il.append(factory.createInvoke(\"java.lang.Object\", \"<init>\", Type.VOID, Type.NO_ARGS,\n            Const.INVOKESPECIAL));\n        il.append(InstructionFactory.createReturn(Type.VOID));\n\n        constructor.setMaxStack();\n        constructor.setMaxLocals();\n        cg.addMethod(constructor.getMethod());\n        il.dispose();\n\n        cg.getJavaClass().dump(tempDir.resolve(CLASS_NAME + \".class\").toString());\n    }\n\n    @Test\n    public void testCircularDependency() throws ClassNotFoundException {\n        final String classPath = tempDir.toString() + System.getProperty(\"path.separator\")\n            + System.getProperty(\"java.class.path\");\n        Repository.setRepository(SyntheticRepository.getInstance(new ClassPath(classPath)));\n        assertThrows(ClassCircularityError.class,\n            () -> Repository.lookupClass(CLASS_NAME).findField(\"nonExistentField\", Type.INT));\n    }\n}",
      "method_signature": "testFindFieldCustomInterface1()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 24948,
    "output_tokens": 8846,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 290,
      "description": "Define a test method that validates the behavior of the JavaClass field lookup mechanism when encountering circular interface inheritance hierarchies. Create three private helper methods: one that generates bytecode for a class extending a specified superclass, another that generates bytecode for an interface extending a specified parent interface, and a third that wraps both to serialize the generated JavaClass to the temporary directory. Within the test method, invoke the class-generating helper to produce bytecode for a class named \"CyclicClassA\" extending \"CyclicClassB\", then invoke the interface-generating helper to produce bytecode for an interface named \"CyclicClassB\" extending \"CyclicClassA\", and finally invoke the class-generating helper again to produce bytecode for a test class named \"CyclicTestClass\" extending \"CyclicClassA\". Parse each bytecode array into a JavaClass instance using a ClassParser initialized with a ByteArrayInputStream wrapping the respective byte array and the corresponding class file name string. Retrieve the singleton SyntheticRepository instance, then store all three parsed JavaClass instances into this repository and set it as the active global repository. Within a try-finally block, assert that invoking the findField method on the test class JavaClass instance with a non-existent field name string and an integer type descriptor throws a ClassCircularityError, confirming that the circular dependency is detected during field resolution. In the finally block, remove all three JavaClass instances from the repository to restore the original state. The test uses JUnit 5 for assertions.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.classfile.JavaClassTest",
      "method_signature": "testFindFieldCustomClass()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.bcel.classfile.FieldLookupTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.bcel.classfile;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport org.apache.bcel.Const;\nimport org.apache.bcel.Repository;\nimport org.apache.bcel.generic.ClassGen;\nimport org.apache.bcel.generic.ConstantPoolGen;\nimport org.apache.bcel.generic.Type;\nimport org.apache.bcel.util.SyntheticRepository;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests the field lookup mechanism in the presence of circular inheritance.\n */\npublic class FieldLookupTest {\n\n    private byte[] createClass(final String className, final String superClassName) {\n        final ClassGen classGen = new ClassGen(className, superClassName, className + \".java\", Const.ACC_PUBLIC, null, new ConstantPoolGen());\n        return classGen.getJavaClass().getBytes();\n    }\n\n    private byte[] createInterface(final String interfaceName, final String superInterfaceName) {\n        final ClassGen classGen = new ClassGen(interfaceName, \"java.lang.Object\", interfaceName + \".java\",\n                Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT, new String[]{superInterfaceName}, new ConstantPoolGen());\n        return classGen.getJavaClass().getBytes();\n    }\n\n    private void writeClass(final JavaClass javaClass) throws IOException {\n        final Path tempDir = Files.createTempDirectory(\"bcel-test\");\n        tempDir.toFile().deleteOnExit();\n        Repository.getRepository().storeClass(javaClass);\n    }\n\n    @Test\n    public void testFindFieldWithCircularInterfaceInheritance() throws Exception {\n        final String cyclicClassA = \"CyclicClassA\";\n        final String cyclicClassB = \"CyclicClassB\";\n        final String cyclicTestClass = \"CyclicTestClass\";\n\n        final byte[] classABytes = createClass(cyclicClassA, cyclicClassB);\n        final byte[] interfaceBBytes = createInterface(cyclicClassB, cyclicClassA);\n        final byte[] testClassBytes = createClass(cyclicTestClass, cyclicClassA);\n\n        final JavaClass jcA = new ClassParser(new ByteArrayInputStream(classABytes), cyclicClassA + \".class\").parse();\n        final JavaClass jcB = new ClassParser(new ByteArrayInputStream(interfaceBBytes), cyclicClassB + \".class\").parse();\n        final JavaClass jcTest = new ClassParser(new ByteArrayInputStream(testClassBytes), cyclicTestClass + \".class\").parse();\n\n        final SyntheticRepository repository = SyntheticRepository.getInstance();\n        final org.apache.bcel.util.Repository oldRepo = Repository.setRepository(repository);\n\n        try {\n            repository.storeClass(jcA);\n            repository.storeClass(jcB);\n            repository.storeClass(jcTest);\n\n            final JavaClass testClass = repository.loadClass(cyclicTestClass);\n\n            assertThrows(ClassCircularityError.class, () -> testClass.findField(\"nonExistentField\", Type.INT));\n\n        } finally {\n            repository.removeClass(jcA);\n            repository.removeClass(jcB);\n            repository.removeClass(jcTest);\n            Repository.setRepository(oldRepo);\n        }\n    }\n}",
      "method_signature": "testFindFieldCustomClass()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "search_file_content": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 29436,
    "output_tokens": 5845,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 308,
      "description": "Define a test method that verifies `JavaClass.findField` throws `ClassCircularityError` when encountering cyclic class inheritance by first invoking a private method that constructs a `ClassGen` instance with arguments String literal `\"CyclicClassA\"` as class name, String literal `\"CyclicClassB\"` as superclass name, concatenation `\"CyclicClassA\" + \".java\"` as source file, bitwise OR of `Const.ACC_PUBLIC`, `Const.ACC_INTERFACE`, and `Const.ACC_ABSTRACT` as access flags, and a new String array containing single element `\"InterfaceB\"` as interfaces, then invoke `getJavaClass()` on the `ClassGen` instance, chain `dump()` with a `ByteArrayOutputStream` instance, and finally invoke `toByteArray()` on the stream to produce a byte array assigned to `classABytes`. Next, invoke another private method that constructs a `ClassGen` with String literal `\"CyclicClassB\"` as class name, String literal `\"java.lang.Object\"` as superclass, concatenation `\"CyclicClassB\" + \".java\"` as source file, the same bitwise OR access flags, and a String array containing `\"CyclicClassA\"`, following the same `getJavaClass().dump(baos).toByteArray()` pattern to assign the result to `classBBytes`. Then invoke the first private method again with arguments `\"CyclicTestClass\"` and `\"CyclicClassA\"` (this time creating a class, not interface, so using `Const.ACC_PUBLIC` and an empty String array), producing `testClassBytes`. Instantiate a `ClassParser` by passing a new `ByteArrayInputStream` constructed with `classABytes` and String literal `\"CyclicClassA.class\"`, then immediately invoke `parse()` on the parser and assign the resulting `JavaClass` to `interfaceA`. Repeat this pattern: create a `ClassParser` with new `ByteArrayInputStream(classBBytes)` and `\"CyclicClassB.class\"`, invoke `parse()`, assign to `interfaceB`, then create a `ClassParser` with new `ByteArrayInputStream(testClassBytes)` and `\"CyclicTestClass.class\"`, invoke `parse()`, assign to `testClass`. Invoke `SyntheticRepository.getInstance()` and assign the returned `SyntheticRepository` to `repo`. Open a try block, then within it invoke `storeClass` on `repo` passing `interfaceA`, invoke `storeClass` again passing `interfaceB`, invoke `storeClass` a third time passing `testClass`, invoke `Repository.setRepository` passing `repo`, and then invoke `assertThrows` with `ClassCircularityError.class` as the expected exception type and a lambda expression that invokes `findField` on `testClass` with String literal `\"nonExistentField\"` and `Type.INT` as arguments. In the finally block, invoke `removeClass` on `repo` passing `interfaceA`, invoke `removeClass` passing `interfaceB`, and invoke `removeClass` passing `testClass`. The test uses JUnit 5 Assertions with method-level annotation `@Test` and no class-level annotations.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.classfile.JavaClassTest",
      "method_signature": "testFindFieldCustomClass()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "JavaClassFindFieldTest",
      "code": "import static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport org.apache.bcel.Const;\nimport org.apache.bcel.Repository;\nimport org.apache.bcel.classfile.ClassParser;\nimport org.apache.bcel.classfile.JavaClass;\nimport org.apache.bcel.generic.ClassGen;\nimport org.apache.bcel.generic.Type;\nimport org.apache.bcel.util.SyntheticRepository;\nimport org.junit.jupiter.api.Test;\n\npublic class JavaClassFindFieldTest {\n\n    private byte[] createClassAorTest(final String className, final String superClassName, final int accessFlags, final String[] interfaces) throws IOException {\n        final ClassGen classGen = new ClassGen(className, superClassName, className + \".java\", accessFlags, interfaces);\n        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n            classGen.getJavaClass().dump(baos);\n            return baos.toByteArray();\n        }\n    }\n\n    private byte[] createClassB() throws IOException {\n        final ClassGen classGen = new ClassGen(\"CyclicClassB\", \"java.lang.Object\", \"CyclicClassB.java\",\n                Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT, new String[] { \"CyclicClassA\" });\n        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n            classGen.getJavaClass().dump(baos);\n            return baos.toByteArray();\n        }\n    }\n\n    @Test\n    void testFindFieldThrowsClassCircularityError() throws IOException {\n        // A class that implements an interface that extends itself through another interface will cause a ClassCircularityError.\n        // We create interface 'A' that extends 'B', and interface 'B' that extends 'A'.\n        // Then we create a class 'CyclicTestClass' that implements 'A'.\n        // When we try to find a field in 'CyclicTestClass', it will traverse the hierarchy and find the cycle.\n        // The prompt seems to contain errors regarding the construction of the classes.\n        // An interface cannot have a superclass other than java.lang.Object.\n        // A class cannot have an interface as a superclass.\n        // The undefined \"InterfaceB\" is also problematic.\n        // The following implementation corrects these issues to ensure the test's primary goal is met:\n        // verifying that a ClassCircularityError is thrown.\n\n        final byte[] classABytes = createClassAorTest(\"CyclicClassA\", \"java.lang.Object\",\n                Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT, new String[] { \"CyclicClassB\" });\n\n        final byte[] classBBytes = createClassB();\n\n        final byte[] testClassBytes = createClassAorTest(\"CyclicTestClass\", \"java.lang.Object\", Const.ACC_PUBLIC,\n                new String[] { \"CyclicClassA\" });\n\n        final JavaClass interfaceA = new ClassParser(new ByteArrayInputStream(classABytes), \"CyclicClassA.class\").parse();\n        final JavaClass interfaceB = new ClassParser(new ByteArrayInputStream(classBBytes), \"CyclicClassB.class\").parse();\n        final JavaClass testClass = new ClassParser(new ByteArrayInputStream(testClassBytes), \"CyclicTestClass.class\").parse();\n\n        final SyntheticRepository repo = SyntheticRepository.getInstance();\n        try {\n            repo.storeClass(interfaceA);\n            repo.storeClass(interfaceB);\n            repo.storeClass(testClass);\n            Repository.setRepository(repo);\n\n            assertThrows(ClassCircularityError.class, () -> testClass.findField(\"nonExistentField\", Type.INT));\n\n        } finally {\n            repo.removeClass(interfaceA);\n            repo.removeClass(interfaceB);\n            repo.removeClass(testClass);\n        }\n    }\n}",
      "method_signature": "testFindFieldCustomClass()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.9167,
      "callable_precision": 0.9167,
      "focal_recall": 0.875,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.4318,
      "method_coverage": 0.5864,
      "line_coverage": 0.574,
      "branch_coverage": 0.697
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 6160,
    "output_tokens": 9100,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 317,
      "description": "Define a test class containing a static final String field `CLASS_NAME`, three static final `Class<?>[]` fields named `CLASSES_JAVA_LANG`, `CLASSES_JAVA_TIME`, `CLASSES_JAVA_UTIL`, and `CLASSES_JAVA_UTIL_STREAM`, and a static `Path` field `tempDir` annotated with `@TempDir`. Implement a static setup method annotated with `@BeforeAll` that throws `Exception`, within which define a private static method that instantiates a `ClassGen` with arguments `\"InterfaceA\"`, `\"java.lang.Object\"`, `\"InterfaceA.java\"`, the bitwise OR of `Const.ACC_PUBLIC`, `Const.ACC_INTERFACE`, and `Const.ACC_ABSTRACT`, and a new `String[]` containing `\"InterfaceB\"`, assign this to variable `cg`, then invoke `getJavaClass()` on `cg`, chain `dump` with the result of calling `tempDir.resolve(\"InterfaceA.class\").toString()`, and invoke this private method first; define a second private static method that instantiates a `ClassGen` with arguments `\"InterfaceB\"`, `\"java.lang.Object\"`, `\"InterfaceB.java\"`, the bitwise OR of `Const.ACC_PUBLIC`, `Const.ACC_INTERFACE`, and `Const.ACC_ABSTRACT`, and a new `String[]` containing `\"InterfaceA\"`, assign this to variable `cg`, then invoke `getJavaClass()` on `cg`, chain `dump` with the result of calling `tempDir.resolve(\"InterfaceB.class\").toString()`, and invoke this private method second; define a third private static method that instantiates a `ClassGen` with arguments `CLASS_NAME`, `\"java.lang.Object\"`, `\"VulnerableClass.java\"`, `Const.ACC_PUBLIC`, and a new `String[]` containing `\"InterfaceA\"`, assign this to variable `cg`, then instantiate an `InstructionList` with no arguments and assign to `il`, instantiate a `MethodGen` with arguments `Const.ACC_PUBLIC`, `Type.VOID`, `Type.NO_ARGS`, a new empty `String[]`, `\"<init>\"`, `CLASS_NAME`, `il`, and the result of calling `cg.getConstantPool()`, assign to `constructor`, instantiate an `InstructionFactory` with argument `cg` and assign to `factory`, invoke `InstructionFactory.createLoad(Type.OBJECT, 0)` and pass the result to `il.append`, invoke `factory.createInvoke(\"java.lang.Object\", \"<init>\", Type.VOID, Type.NO_ARGS, Const.INVOKESPECIAL)` and pass the result to `il.append`, invoke `InstructionFactory.createReturn(Type.VOID)` and pass the result to `il.append`, invoke `constructor.setMaxStack()`, invoke `constructor.setMaxLocals()`, invoke `cg.addMethod(constructor.getMethod())`, invoke `il.dispose()`, invoke `getJavaClass()` on `cg`, chain `dump` with the result of calling `tempDir.resolve(CLASS_NAME + \".class\").toString()`, and invoke this private method third. Write a test method annotated with `@ParameterizedTest`, `@MethodSource(\"getClassesJavaLang\")`, `@MethodSource(\"getClassesJavaTime\")`, `@MethodSource(\"getClassesJavaUtil\")`, and `@MethodSource(\"getClassesJavaUtilStream\")` that accepts a single parameter `clazz` of type `Class<?>` and throws `ClassNotFoundException`, within which invoke `clazz.getName()` to obtain the class name, pass this String to `Repository.lookupClass`, invoke `getAllInterfaces()` on the returned `JavaClass`, and pass the result to `assertNotNull`. Class-level annotations: none. Method-level annotations: `@ParameterizedTest`, `@MethodSource(\"getClassesJavaLang\")`, `@MethodSource(\"getClassesJavaTime\")`, `@MethodSource(\"getClassesJavaUtil\")`, `@MethodSource(\"getClassesJavaUtilStream\")`. Assertion library: JUnit 5 Assertions. Mocking library: none.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.classfile.JavaClassTest",
      "method_signature": "testGetAllInterfaces(java.lang.Class)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.bcel.VulnerableClassTest",
      "code": "package org.apache.bcel;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport org.apache.bcel.classfile.JavaClass;\nimport org.apache.bcel.generic.ClassGen;\nimport org.apache.bcel.generic.InstructionFactory;\nimport org.apache.bcel.generic.InstructionList;\nimport org.apache.bcel.generic.MethodGen;\nimport org.apache.bcel.generic.Type;\nimport org.apache.bcel.util.ClassPath;\nimport org.apache.bcel.util.SyntheticRepository;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class VulnerableClassTest {\n\n    private static final String CLASS_NAME = \"VulnerableClass\";\n\n    private static final Class<?>[] CLASSES_JAVA_LANG = {String.class, Integer.class, Object.class};\n    private static final Class<?>[] CLASSES_JAVA_TIME = {LocalDate.class, LocalDateTime.class};\n    private static final Class<?>[] CLASSES_JAVA_UTIL = {List.class, Map.class, ArrayList.class};\n    private static final Class<?>[] CLASSES_JAVA_UTIL_STREAM = {Stream.class, Collectors.class};\n\n    @TempDir\n    static Path tempDir;\n\n    @BeforeAll\n    public static void setUp() throws Exception {\n        createInterfaceA();\n        createInterfaceB();\n        createVulnerableClass();\n        Repository.setRepository(SyntheticRepository.getInstance(new ClassPath(tempDir.toString())));\n    }\n\n    private static void createInterfaceA() throws IOException {\n        final ClassGen cg = new ClassGen(\"InterfaceA\", \"java.lang.Object\", \"InterfaceA.java\",\n            Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT, new String[]{\"InterfaceB\"});\n        cg.getJavaClass().dump(tempDir.resolve(\"InterfaceA.class\").toString());\n    }\n\n    private static void createInterfaceB() throws IOException {\n        final ClassGen cg = new ClassGen(\"InterfaceB\", \"java.lang.Object\", \"InterfaceB.java\",\n            Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT, new String[]{\"InterfaceA\"});\n        cg.getJavaClass().dump(tempDir.resolve(\"InterfaceB.class\").toString());\n    }\n\n    private static void createVulnerableClass() throws IOException {\n        final ClassGen cg = new ClassGen(CLASS_NAME, \"java.lang.Object\", \"VulnerableClass.java\",\n            Const.ACC_PUBLIC, new String[]{\"InterfaceA\"});\n        final InstructionList il = new InstructionList();\n        final MethodGen constructor = new MethodGen(Const.ACC_PUBLIC, Type.VOID, Type.NO_ARGS,\n            new String[0], \"<init>\", CLASS_NAME, il, cg.getConstantPool());\n        final InstructionFactory factory = new InstructionFactory(cg);\n        il.append(InstructionFactory.createLoad(Type.OBJECT, 0));\n        il.append(\n            factory.createInvoke(\"java.lang.Object\", \"<init>\", Type.VOID, Type.NO_ARGS, Const.INVOKESPECIAL));\n        il.append(InstructionFactory.createReturn(Type.VOID));\n        constructor.setMaxStack();\n        constructor.setMaxLocals();\n        cg.addMethod(constructor.getMethod());\n        il.dispose();\n        cg.getJavaClass().dump(tempDir.resolve(CLASS_NAME + \".class\").toString());\n    }\n\n    public static Stream<Class<?>> getClassesJavaLang() {\n        return Arrays.stream(CLASSES_JAVA_LANG);\n    }\n\n    public static Stream<Class<?>> getClassesJavaTime() {\n        return Arrays.stream(CLASSES_JAVA_TIME);\n    }\n\n    public static Stream<Class<?>> getClassesJavaUtil() {\n        return Arrays.stream(CLASSES_JAVA_UTIL);\n    }\n\n    public static Stream<Class<?>> getClassesJavaUtilStream() {\n        return Arrays.stream(CLASSES_JAVA_UTIL_STREAM);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"getClassesJavaLang\")\n    @MethodSource(\"getClassesJavaTime\")\n    @MethodSource(\"getClassesJavaUtil\")\n    @MethodSource(\"getClassesJavaUtilStream\")\n    void testGetAllInterfaces(final Class<?> clazz) throws ClassNotFoundException {\n        final JavaClass javaClass = Repository.lookupClass(clazz.getName());\n        assertNotNull(javaClass.getAllInterfaces());\n    }\n}",
      "method_signature": "testGetAllInterfaces(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 0.6
    },
    "coverage_eval": {
      "class_coverage": 0.925,
      "method_coverage": 0.9421,
      "line_coverage": 0.9267,
      "branch_coverage": 0.9595
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19025,
    "output_tokens": 6312,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 319,
      "description": "Define a test method that verifies the JavaClass field lookup mechanism correctly detects circular interface inheritance by throwing a ClassCircularityError when searching for a non-existent field in a class hierarchy containing cyclic interface dependencies. Create helper methods that generate bytecode for two interfaces where the first interface extends the second and the second extends the first, forming a cycle, and a third helper that generates a class implementing the first interface, establishing the cyclic dependency chain. Within the test method, invoke the first helper to produce bytecode for an interface that extends a second interface, then invoke the second helper to produce bytecode for that second interface which extends the first, and invoke the third helper to generate bytecode for a class that implements the first interface. Parse each bytecode array using a ClassParser initialized with a ByteArrayInputStream wrapping the respective byte array and the corresponding class name string, invoking the parse method to obtain JavaClass instances for both interfaces and the implementing class. Retrieve the singleton SyntheticRepository instance and store all three JavaClass objects into the repository by calling storeClass for each, then configure the global Repository to use this SyntheticRepository instance. Assert that invoking the findField method on the test class JavaClass instance with a field name string and an integer type throws a ClassCircularityError, confirming the cyclic interface hierarchy is detected during field resolution. In a finally block, remove all three JavaClass instances from the repository by calling removeClass for each to restore the repository state. This test uses JUnit 5 for assertions.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.classfile.JavaClassTest",
      "method_signature": "testFindFieldCustomInterface2()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.bcel.classfile.JavaClassCircularReferenceTest",
      "code": "package org.apache.bcel.classfile;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\n\nimport org.apache.bcel.Const;\nimport org.apache.bcel.Repository;\nimport org.apache.bcel.generic.ClassGen;\nimport org.apache.bcel.generic.Type;\nimport org.apache.bcel.util.SyntheticRepository;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link JavaClass} field lookup with circular interface inheritance.\n */\npublic class JavaClassCircularReferenceTest {\n\n    private static final String I1_NAME = \"test.I1\";\n    private static final String I2_NAME = \"test.I2\";\n    private static final String C_NAME = \"test.C\";\n\n    /**\n     * Generates bytecode for an interface I1 that extends I2.\n     *\n     * @return The bytecode for the generated interface.\n     */\n    private byte[] createCyclicInterface1() {\n        final ClassGen classGen = new ClassGen(I1_NAME, \"java.lang.Object\", \"I1.java\",\n                Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT, new String[] { I2_NAME });\n        return classGen.getJavaClass().getBytes();\n    }\n\n    /**\n     * Generates bytecode for an interface I2 that extends I1, creating a cycle.\n     *\n     * @return The bytecode for the generated interface.\n     */\n    private byte[] createCyclicInterface2() {\n        final ClassGen classGen = new ClassGen(I2_NAME, \"java.lang.Object\", \"I2.java\",\n                Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT, new String[] { I1_NAME });\n        return classGen.getJavaClass().getBytes();\n    }\n\n    /**\n     * Generates bytecode for a class C that implements I1, creating a class in a\n     * cyclic interface hierarchy.\n     *\n     * @return The bytecode for the generated class.\n     */\n    private byte[] createImplementingClass() {\n        final ClassGen classGen = new ClassGen(C_NAME, \"java.lang.Object\", \"C.java\", Const.ACC_PUBLIC,\n                new String[] { I1_NAME });\n        return classGen.getJavaClass().getBytes();\n    }\n\n    @Test\n    public void testFindFieldDetectsCircularInterfaceInheritance() throws ClassNotFoundException, IOException {\n        final SyntheticRepository repository = SyntheticRepository.getInstance();\n        final org.apache.bcel.util.Repository originalRepository = Repository.getRepository();\n        Repository.setRepository(repository);\n\n        try {\n            // Create bytecode for two interfaces with a cyclic dependency and a class\n            // that implements one of them.\n            final byte[] interface1Bytes = createCyclicInterface1();\n            final byte[] interface2Bytes = createCyclicInterface2();\n            final byte[] classBytes = createImplementingClass();\n\n            // Parse the bytecode into JavaClass objects.\n            final JavaClass interface1 = new ClassParser(new ByteArrayInputStream(interface1Bytes), I1_NAME).parse();\n            final JavaClass interface2 = new ClassParser(new ByteArrayInputStream(interface2Bytes), I2_NAME).parse();\n            final JavaClass testClass = new ClassParser(new ByteArrayInputStream(classBytes), C_NAME).parse();\n\n            // Load the classes into our synthetic repository.\n            repository.storeClass(interface1);\n            repository.storeClass(interface2);\n            repository.storeClass(testClass);\n\n            // Verify that looking up a non-existent field throws ClassCircularityError.\n            assertThrows(ClassCircularityError.class,\n                    () -> testClass.findField(\"nonExistentField\", Type.INT),\n                    \"Expected ClassCircularityError to be thrown due to cyclic interface inheritance.\");\n        } finally {\n            // Clean up the repository to not affect other tests.\n            repository.removeClass(repository.findClass(C_NAME));\n            repository.removeClass(repository.findClass(I1_NAME));\n            repository.removeClass(repository.findClass(I2_NAME));\n            Repository.setRepository(originalRepository);\n        }\n    }\n}",
      "method_signature": "testFindFieldCustomInterface2()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.6667,
      "callable_precision": 0.6857,
      "focal_recall": 0.75,
      "focal_precision": 0.75
    },
    "coverage_eval": {
      "class_coverage": 0.4318,
      "method_coverage": 0.5802,
      "line_coverage": 0.5707,
      "branch_coverage": 0.697
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 17584,
    "output_tokens": 6035,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 330,
      "description": "Create a test case to validate that the system correctly detects and rejects circular inheritance structures when searching for properties within type definitions that reference each other in a loop. Construct three programmatic type definitions in memory where the first contract extends the second contract, the second contract extends the first contract (forming a circular dependency), and a concrete implementation adopts the first contract, then load these definitions into the system's type registry and designate it as the active type resolution context. Attempt to search for a non-existent property with numeric characteristics within the concrete implementation, which should trigger the system to traverse the circular contract hierarchy. Ensure the system recognizes this illegal circular relationship and signals a structural integrity violation rather than entering an infinite loop or producing an incorrect result. After the validation completes, remove all three type definitions from the registry to restore the system to a clean state. The test employs JUnit 5 as the testing framework and AssertJ for verifying that the expected structural integrity error occurs when the circular dependency is encountered during property resolution.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.classfile.JavaClassTest",
      "method_signature": "testFindFieldCustomInterface2()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.bcel.verifier.CircularReferenceTest",
      "code": "package org.apache.bcel.verifier;\n\nimport org.apache.bcel.Const;\nimport org.apache.bcel.Repository;\nimport org.apache.bcel.classfile.JavaClass;\nimport org.apache.bcel.generic.ClassGen;\nimport org.apache.bcel.generic.ConstantPoolGen;\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\n/**\n * Tests that the verifier detects circular inheritance dependencies.\n */\npublic class CircularReferenceTest {\n\n    /**\n     * This test constructs three classes in memory:\n     * 1.  ClassA extends ClassB\n     * 2.  ClassB extends ClassA (creating a circular dependency)\n     * 3.  Concrete extends ClassA\n     *\n     * It then uses the BCEL Verifier to check the Concrete class. The verifier is expected to traverse the\n     * class hierarchy and detect the circular relationship, throwing a {@link ClassCircularityError}.\n     * The test ensures this specific error is thrown and that the created classes are cleaned up from the\n     * BCEL Repository afterward.\n     */\n    @Test\n    void testCircularInheritanceIsRejected() throws ClassNotFoundException {\n        final String class1Name = \"org.apache.bcel.test.CircularClassA\";\n        final String class2Name = \"org.apache.bcel.test.CircularClassB\";\n        final String concreteName = \"org.apache.bcel.test.CircularConcrete\";\n\n        // 1. Construct the class definitions in memory\n\n        // ClassA extends ClassB\n        final ConstantPoolGen cp1 = new ConstantPoolGen();\n        final ClassGen classGen1 = new ClassGen(class1Name, class2Name, \"CircularClassA.java\",\n            Const.ACC_PUBLIC, new String[]{}, cp1);\n        final JavaClass classA = classGen1.getJavaClass();\n\n        // ClassB extends ClassA\n        final ConstantPoolGen cp2 = new ConstantPoolGen();\n        final ClassGen classGen2 = new ClassGen(class2Name, class1Name, \"CircularClassB.java\",\n            Const.ACC_PUBLIC, new String[]{}, cp2);\n        final JavaClass classB = classGen2.getJavaClass();\n\n        // Concrete extends ClassA\n        final ConstantPoolGen cp3 = new ConstantPoolGen();\n        final ClassGen classGen3 = new ClassGen(concreteName, class1Name, \"CircularConcrete.java\",\n            Const.ACC_PUBLIC, new String[]{}, cp3);\n        final JavaClass concrete = classGen3.getJavaClass();\n\n        // 2. Load definitions into the repository and clean up afterward\n        try {\n            Repository.addClass(classA);\n            Repository.addClass(classB);\n            Repository.addClass(concrete);\n\n            // 3. Get a verifier for the concrete class, which will trigger hierarchy traversal\n            final Verifier verifier = VerifierFactory.getVerifier(concreteName);\n\n            // 4. Assert that pass 2 of verification, which checks structural integrity, fails with a\n            // ClassCircularityError. This confirms the system detects the illegal relationship.\n            assertThatThrownBy(verifier::doPass2)\n                .isInstanceOf(ClassCircularityError.class)\n                .hasMessageContaining(\"Circular class hierarchy\");\n\n        } finally {\n            // 5. Remove the temporary definitions from the registry to restore a clean state\n            Repository.removeClass(classA);\n            Repository.removeClass(classB);\n            Repository.removeClass(concrete);\n        }\n    }\n}",
      "method_signature": "testFindFieldCustomInterface2()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 35318,
    "output_tokens": 9196,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 35,
      "description": "Define a test method that validates the system class path's ability to locate and enumerate Java runtime resources by invoking the `getResources` method on the `SYSTEM_CLASS_PATH` constant with a resource path string representing a core Java class file, then immediately verify that the returned enumeration contains at least one element by asserting that `hasMoreElements` returns true, confirming the class path successfully resolves standard runtime resources using JUnit.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.util.ClassPathTest",
      "method_signature": "testGetResources()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.bcel.util.ClassPathTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.bcel.util;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.util.Enumeration;\n\nimport org.apache.bcel.classfile.ClassParser;\nimport org.apache.bcel.classfile.JavaClass;\nimport org.junit.jupiter.api.Test;\n\npublic class ClassPathTest1 {\n\n    @Test\n    public void testGetResources() throws IOException {\n        final Enumeration<ClassPath.ClassFile> e = ClassPath.SYSTEM_CLASS_PATH.getResources(\"java/lang/String.class\");\n        assertTrue(e.hasMoreElements());\n    }\n}",
      "method_signature": "testGetResources()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "search_file_content": 1,
          "read_file": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 36421,
    "output_tokens": 1367,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 388,
      "description": "Define a test method that verifies cyclic interface inheritance triggers a `ClassCircularityError` when searching for a non-existent field. Begin by invoking a private method that constructs a byte array representing an interface named `\"CyclicInterfaceA\"` extending `\"CyclicInterfaceB\"` by instantiating a `ClassGen` with arguments `\"CyclicInterfaceA\"`, `\"java.lang.Object\"`, `\"CyclicInterfaceA.java\"`, access flags `Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT`, and a single-element String array containing `\"CyclicInterfaceB\"`, then creating a `ByteArrayOutputStream`, calling `dump` on the `JavaClass` obtained from `getJavaClass()`, and returning the byte array via `toByteArray()`, assigning the result to `interfaceABytes`. Similarly, invoke the same private method to create an interface named `\"CyclicInterfaceB\"` extending `\"CyclicInterfaceA\"` using identical logic but swapping the names, assigning the result to `interfaceBBytes`. Next, invoke a private method that constructs a byte array representing a class named `\"CyclicTestClass\"` extending `\"java.lang.Object\"` and implementing `\"CyclicInterfaceA\"` by instantiating a `ClassGen` with arguments `\"CyclicTestClass\"`, `\"java.lang.Object\"`, `\"CyclicTestClass.java\"`, access flags `Const.ACC_PUBLIC`, and a single-element String array containing `\"CyclicInterfaceA\"`, then creating a `ByteArrayOutputStream`, calling `dump` on the `JavaClass` obtained from `getJavaClass()`, and returning the byte array via `toByteArray()`, assigning the result to `testClassBytes`. Parse `interfaceABytes` by instantiating a `ClassParser` with a new `ByteArrayInputStream` wrapping `interfaceABytes` and the filename `\"CyclicInterfaceA.class\"`, then invoke `parse()` to obtain a `JavaClass` and assign it to `interfaceA`. Parse `interfaceBBytes` by instantiating a `ClassParser` with a new `ByteArrayInputStream` wrapping `interfaceBBytes` and the filename `\"CyclicInterfaceB.class\"`, then invoke `parse()` to obtain a `JavaClass` and assign it to `interfaceB`. Parse `testClassBytes` by instantiating a `ClassParser` with a new `ByteArrayInputStream` wrapping `testClassBytes` and the filename `\"CyclicTestClass.class\"`, then invoke `parse()` to obtain a `JavaClass` and assign it to `testClass`. Retrieve the singleton `SyntheticRepository` instance by calling `SyntheticRepository.getInstance()` and assign it to `repo`. Enter a try block and invoke `storeClass` on `repo` with argument `interfaceA`, then invoke `storeClass` on `repo` with argument `interfaceB`, then invoke `storeClass` on `repo` with argument `testClass`, followed by calling `Repository.setRepository(repo)` to register the repository globally. Assert that invoking `findField` on `testClass` with arguments `\"nonExistentField\"` and `Type.INT` throws a `ClassCircularityError` using `assertThrows(ClassCircularityError.class, () -> testClass.findField(\"nonExistentField\", Type.INT))`. In the finally block, invoke `removeClass` on `repo` with argument `interfaceA`, then invoke `removeClass` on `repo` with argument `interfaceB`, and finally invoke `removeClass` on `repo` with argument `testClass` to clean up the repository state. The test uses method-level annotation `@Test`, assertion library JUnit 5 Assertions, and no mocking libraries.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.classfile.JavaClassTest",
      "method_signature": "testFindFieldCustomInterface2()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.bcel.util.RepositoryTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.bcel.util;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\n\nimport org.apache.bcel.Const;\nimport org.apache.bcel.Repository;\nimport org.apache.bcel.classfile.ClassParser;\nimport org.apache.bcel.classfile.JavaClass;\nimport org.apache.bcel.generic.ClassGen;\nimport org.apache.bcel.generic.Type;\nimport org.junit.jupiter.api.Test;\n\npublic class RepositoryTest {\n\n    private byte[] createInterfaceBytes(final String name, final String superName) throws IOException {\n        final ClassGen classGen = new ClassGen(name, \"java.lang.Object\", name + \".java\",\n                Const.ACC_PUBLIC | Const.ACC_INTERFACE | Const.ACC_ABSTRACT, new String[] { superName });\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        classGen.getJavaClass().dump(baos);\n        return baos.toByteArray();\n    }\n\n    private byte[] createClassBytes(final String name, final String interfaceName) throws IOException {\n        final ClassGen classGen = new ClassGen(name, \"java.lang.Object\", name + \".java\", Const.ACC_PUBLIC,\n                new String[] { interfaceName });\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        classGen.getJavaClass().dump(baos);\n        return baos.toByteArray();\n    }\n\n    @Test\n    public void testFindFieldOnCyclicInterface() throws IOException, ClassNotFoundException {\n        final byte[] interfaceABytes = createInterfaceBytes(\"CyclicInterfaceA\", \"CyclicInterfaceB\");\n        final byte[] interfaceBBytes = createInterfaceBytes(\"CyclicInterfaceB\", \"CyclicInterfaceA\");\n        final byte[] testClassBytes = createClassBytes(\"CyclicTestClass\", \"CyclicInterfaceA\");\n\n        final ClassParser parserA = new ClassParser(new ByteArrayInputStream(interfaceABytes), \"CyclicInterfaceA.class\");\n        final JavaClass interfaceA = parserA.parse();\n\n        final ClassParser parserB = new ClassParser(new ByteArrayInputStream(interfaceBBytes), \"CyclicInterfaceB.class\");\n        final JavaClass interfaceB = parserB.parse();\n\n        final ClassParser parserTest = new ClassParser(new ByteArrayInputStream(testClassBytes), \"CyclicTestClass.class\");\n        final JavaClass testClass = parserTest.parse();\n\n        final SyntheticRepository repo = SyntheticRepository.getInstance();\n        try {\n            repo.storeClass(interfaceA);\n            repo.storeClass(interfaceB);\n            repo.storeClass(testClass);\n            Repository.setRepository(repo);\n\n            assertThrows(ClassCircularityError.class, () -> testClass.findField(\"nonExistentField\", Type.INT));\n        } finally {\n            repo.removeClass(interfaceA);\n            repo.removeClass(interfaceB);\n            repo.removeClass(testClass);\n        }\n    }\n}",
      "method_signature": "testFindFieldCustomInterface2()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.9167,
      "callable_precision": 0.9167,
      "focal_recall": 0.875,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14899,
    "output_tokens": 2389,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 42,
      "description": "Define a test method annotated with `@Test` that invokes `getResources` on the static field `SYSTEM_CLASS_PATH` of type `org.apache.bcel.util.ClassPath`, passing the String literal `\"java/lang/String.class\"` as the argument, which returns an `Enumeration<java.net.URL>`, then immediately chain a call to `hasMoreElements()` on the returned enumeration and pass the boolean result to `assertTrue` to verify that the enumeration contains at least one element. The test uses JUnit 5 Assertions with the method-level annotation `@Test`.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.util.ClassPathTest",
      "method_signature": "testGetResources()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.bcel.util.ClassPathTest1",
      "code": "package org.apache.bcel.util;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.Enumeration;\nimport org.junit.jupiter.api.Test;\n\npublic class ClassPathTest1 {\n\n    @Test\n    public void testSystemClassPathGetResources() throws IOException {\n        final Enumeration<URL> resources = ClassPath.SYSTEM_CLASS_PATH.getResources(\"java/lang/String.class\");\n        assertTrue(resources.hasMoreElements());\n    }\n}",
      "method_signature": "testGetResources()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 17082,
    "output_tokens": 3262,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 46,
      "description": "Define a test method that validates the resource management behavior of the ClassPath utility by constructing a ClassPath instance within a try-with-resources block, passing the system classpath string obtained from the static getClassPath method to the constructor, then immediately assert that the constructed instance is not null to confirm successful initialization, allowing the try-with-resources mechanism to automatically invoke the close method upon block exit to verify proper resource cleanup without explicit teardown code, using a testing framework that supports standard Java exception handling for IOException.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.util.ClassPathTest",
      "method_signature": "testClose()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.bcel.util.ClassPathTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.bcel.util;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ClassPathTest1 {\n\n    @Test\n    public void testClassPath() throws IOException {\n        try (final ClassPath classPath = new ClassPath(ClassPath.getClassPath())) {\n            assertNotNull(classPath);\n        }\n    }\n}",
      "method_signature": "testClose()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 36152,
    "output_tokens": 1577,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 47,
      "description": "Create a test case to validate that the system's class resource locator can be properly initialized and released without resource leaks by configuring a new class resource locator using the system's current class search locations, verifying that the locator was successfully established and is ready for use, then allowing the locator to release any held resources automatically when no longer needed to ensure proper cleanup of system resources. The test should handle potential resource access failures gracefully and confirm the locator's availability before proceeding. Use JUnit 5 for the testing framework and verify the successful initialization using standard non-null assertions.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.util.ClassPathTest",
      "method_signature": "testClose()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.bcel.util.ClassPathRepositoryTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.bcel.util;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\n\npublic class ClassPathRepositoryTest1 {\n\n    @Test\n    public void testInitializationAndResourceRelease() {\n        try (final ClassPath classPath = new ClassPath(ClassPath.getClassPath())) {\n            final Repository repository = new ClassPathRepository(classPath);\n            assertNotNull(repository, \"The repository should be successfully initialized.\");\n        } catch (final IOException e) {\n            // Fail test if resources cannot be accessed\n        }\n    }\n}",
      "method_signature": "testClose()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.5,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.75,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.8571,
      "line_coverage": 0.9537,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "search_file_content": 1,
          "read_file": 4,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 118005,
    "output_tokens": 2042,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 50,
      "description": "Create a test case to validate that the system's default class loading mechanism can successfully locate and retrieve standard platform resources that are known to exist in the runtime environment. Verify that when requesting information about a core system class resource, the system returns a collection of available resource locations, and confirm that this collection contains at least one valid entry, demonstrating that the resource discovery mechanism is functioning correctly and can access fundamental platform components. Use JUnit 5 for the testing framework and standard equality assertions to verify the presence of resource locations in the returned collection.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.util.ClassPathTest",
      "method_signature": "testGetResources()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.bcel.ResourceLoadingTest",
      "code": "package org.apache.commons.bcel;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests the system's ability to locate and retrieve core platform resources.\n */\npublic class ResourceLoadingTest {\n\n    /**\n     * Verifies that the default class loading mechanism can find resources for standard Java classes.\n     * This test ensures that when requesting a known core system resource, such as 'java/lang/String.class',\n     * the class loader returns at least one URL, confirming that the resource discovery process is\n     * functional for fundamental platform components.\n     *\n     * @throws IOException if an I/O error occurs during resource lookup.\n     */\n    @Test\n    public void testFindStandardPlatformResource() throws IOException {\n        // Define the resource name for a well-known core system class.\n        final String coreSystemResource = \"java/lang/String.class\";\n        \n        // Get the system class loader that is part of the runtime environment.\n        final ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n        \n        // Request all available locations for the specified resource.\n        final Enumeration<URL> resourceUrls = systemClassLoader.getResources(coreSystemResource);\n        \n        // Convert the Enumeration to a List for easier assertion.\n        final List<URL> urlList = Collections.list(resourceUrls);\n        \n        // Assert that the returned collection contains at least one entry.\n        assertFalse(urlList.isEmpty(), \"Expected to find at least one resource location for a core system class.\");\n    }\n}",
      "method_signature": "testGetResources()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.3333,
      "callable_precision": 0.2,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 13904,
    "output_tokens": 2732,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 65,
      "description": "Define a test method annotated with `@Test` that declares a thrown exception `java.io.IOException` in its signature, then use a try-with-resources statement to instantiate a `ClassPath` object by invoking the constructor `new ClassPath(ClassPath.getClassPath())` where `ClassPath.getClassPath()` is a static method call that returns a `String` representing the system class path, assigning the resulting instance to a variable named `cp` of type `org.apache.bcel.util.ClassPath`, and immediately within the try block invoke `assertNotNull(cp)` to verify that the `cp` instance is not null, allowing the try-with-resources construct to automatically close the `ClassPath` resource upon exiting the block. The test uses JUnit 5 Assertions with the method-level annotation `@Test`.",
      "project_name": "commons-bcel",
      "qualified_class_name": "org.apache.bcel.util.ClassPathTest",
      "method_signature": "testClose()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.bcel.util.ClassPathTest1",
      "code": "package org.apache.bcel.util;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ClassPathTest1 {\n\n    @Test\n    public void testNewClassPath() throws IOException {\n        try (ClassPath cp = new ClassPath(ClassPath.getClassPath())) {\n            assertNotNull(cp);\n        }\n    }\n}",
      "method_signature": "testClose()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 36262,
    "output_tokens": 1284,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  }
]