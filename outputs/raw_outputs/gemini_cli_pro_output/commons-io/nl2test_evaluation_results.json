[
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1006,
      "description": "Define a parameterized test method that validates argument constraints for the read operation on an input stream with offset and length parameters, accepting an input stream, a byte buffer, an offset integer, a length integer, and an expected exception class as parameters. Before all tests execute, invoke a static cleanup operation on the IO utility class to reset any thread-local state, ensuring test isolation. For each test iteration, configure a temporary directory using a test framework annotation to manage file lifecycle, then within the setup method construct a test file within this directory and populate it with generated test data by opening a buffered output stream to the file path and invoking a utility that writes a sequence of bytes based on a specified size, after which initialize a byte array filled with a sentinel value and overwrite a portion with sequential byte values, and similarly prepare a character array with sentinel characters and sequential character values. Within the test method itself, invoke the read method on IOUtils with the provided input stream, byte buffer, offset, and length parameters, and assert that the invocation throws an exception matching the expected exception class, thereby confirming that invalid argument combinations such as negative offsets, negative lengths, or buffer overruns are properly rejected. After all tests complete, execute the same static cleanup operation on the IO utility class to release any thread-local resources. The test suite employs JUnit 5 for parameterized testing and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testRead_InputStream_Offset_ArgumentsValidation(java.io.InputStream, byte[], int, int, java.lang.Class)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsReadArgumentValidationTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests argument validation for {@link IOUtils} read methods.\n */\npublic class IOUtilsReadArgumentValidationTest {\n\n    @TempDir\n    private Path tempDir;\n\n    private File testFile;\n    private byte[] byteBuffer;\n\n    /**\n     * Per the test description, a static cleanup operation on the IO utility class should be invoked before and after all tests.\n     * {@link IOUtils} does not provide a public static method for this purpose.\n     */\n    @BeforeAll\n    public static void beforeAll() {\n        // IOUtils.cleanup(); // No such method exists\n    }\n\n    /**\n     * Per the test description, a static cleanup operation on the IO utility class should be invoked before and after all tests.\n     * {@link IOUtils} does not provide a public static method for this purpose.\n     */\n    @AfterAll\n    public static void afterAll() {\n        // IOUtils.cleanup(); // No such method exists\n    }\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        testFile = tempDir.resolve(\"test.txt\").toFile();\n        try (final BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(testFile.toPath()))) {\n            final byte[] data = new byte[128];\n            Arrays.fill(data, (byte) 'X');\n            out.write(data);\n        }\n\n        byteBuffer = new byte[20];\n        Arrays.fill(byteBuffer, (byte) 0xCC); // sentinel value\n        for (int i = 0; i < 10; i++) {\n            byteBuffer[i] = (byte) i; // sequential values\n        }\n    }\n\n    static Stream<Arguments> invalidReadArguments() {\n        final byte[] buffer = new byte[10];\n        // The InputStream is created here as a dummy stream because the tested error conditions\n        // should be thrown before any data is read from the stream.\n        return Stream.of(\n            Arguments.of(new ByteArrayInputStream(new byte[0]), buffer, -1, 1, IndexOutOfBoundsException.class),\n            Arguments.of(new ByteArrayInputStream(new byte[0]), buffer, 0, -1, IllegalArgumentException.class),\n            Arguments.of(new ByteArrayInputStream(new byte[0]), buffer, buffer.length + 1, 0, IndexOutOfBoundsException.class),\n            Arguments.of(new ByteArrayInputStream(new byte[0]), buffer, 5, buffer.length, IndexOutOfBoundsException.class)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"invalidReadArguments\")\n    public void testReadWithInvalidArgumentsThrowsException(final InputStream inputStream, final byte[] buffer, final int offset, final int length,\n        final Class<? extends Throwable> expectedException) {\n        assertThrows(expectedException, () -> IOUtils.read(inputStream, buffer, offset, length));\n    }\n}",
      "method_signature": "testRead_InputStream_Offset_ArgumentsValidation(java.io.InputStream, byte[], int, int, java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 16031,
    "output_tokens": 9523,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1007,
      "description": "Create a test case to validate that the system correctly compares byte streams for equality when one stream is composed of multiple sequential segments, ensuring the comparison logic handles both matching and mismatching content scenarios accurately, including cases where segments are empty, have differing lengths, or contain different data, and also verify the behavior when comparing a simple stream against a complex multi-segment stream that combines a prefix array, the contents of a stored file, and a suffix array to confirm the system recognizes identical content regardless of how the stream is structured. Begin by confirming the system rejects equality when comparing a simple two-character stream against a multi-segment stream where the first segment matches but the second segment contains extra characters, then verify rejection when the extra characters appear in the first segment instead, followed by confirming rejection when the simple stream has trailing characters not present in the multi-segment stream, and ensure the system rejects equality when an empty stream is compared against a multi-segment stream containing data or when an empty stream is compared against a multi-segment stream where only the second segment has data, and also confirm rejection when a populated stream is compared against a multi-segment stream composed entirely of empty segments. After establishing these negative cases, verify the system correctly identifies equality when both streams are empty multi-segment streams, when the simple stream matches the combined content of the multi-segment stream, when all content is concentrated in the first segment with the second being empty, and when all content is in the second segment with the first being empty. Having confirmed basic equality checks, prepare test data consisting of a prefix array of specific length, a suffix array, and text content, then write this text to the previously prepared file in the temporary workspace, construct an expected result by concatenating the prefix, the file's text content, and the suffix into a single byte sequence, and verify the system recognizes equality when comparing a stream of this expected sequence against a multi-segment stream that reads the prefix from one source, the file content from another, and the suffix from a third source, confirming the comparison correctly handles streams assembled from multiple distinct origins. Use JUnit 5 as the testing framework with standard boolean assertions to verify equality and inequality outcomes.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testContentEqualsSequenceInputStream()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsMultiSegmentInputStreamTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.SequenceInputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.Collections;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link IOUtils} content equality with multi-segment streams.\n */\npublic class IOUtilsMultiSegmentInputStreamTest {\n\n    @TempDir\n    private Path tempDir;\n\n    @Test\n    public void testContentEqualsWithMultiSegmentStream() throws IOException {\n        // Negative case: simple stream vs multi-segment stream with extra chars in second segment\n        try (InputStream s1 = new ByteArrayInputStream(\"AB\".getBytes(StandardCharsets.UTF_8));\n             InputStream s2 = new SequenceInputStream(Collections.enumeration(Arrays.asList(\n                     new ByteArrayInputStream(\"A\".getBytes(StandardCharsets.UTF_8)),\n                     new ByteArrayInputStream(\"BC\".getBytes(StandardCharsets.UTF_8)))))) {\n            assertFalse(IOUtils.contentEquals(s1, s2));\n        }\n\n        // Negative case: simple stream vs multi-segment stream with extra chars in first segment\n        try (InputStream s1 = new ByteArrayInputStream(\"AB\".getBytes(StandardCharsets.UTF_8));\n             InputStream s2 = new SequenceInputStream(Collections.enumeration(Arrays.asList(\n                     new ByteArrayInputStream(\"AC\".getBytes(StandardCharsets.UTF_8)),\n                     new ByteArrayInputStream(\"B\".getBytes(StandardCharsets.UTF_8)))))) {\n            assertFalse(IOUtils.contentEquals(s1, s2));\n        }\n\n        // Negative case: simple stream has trailing characters\n        try (InputStream s1 = new ByteArrayInputStream(\"ABC\".getBytes(StandardCharsets.UTF_8));\n             InputStream s2 = new SequenceInputStream(Collections.enumeration(Arrays.asList(\n                     new ByteArrayInputStream(\"A\".getBytes(StandardCharsets.UTF_8)),\n                     new ByteArrayInputStream(\"B\".getBytes(StandardCharsets.UTF_8)))))) {\n            assertFalse(IOUtils.contentEquals(s1, s2));\n        }\n\n        // Negative case: empty stream vs multi-segment stream with data\n        try (InputStream s1 = NullInputStream.nullInputStream();\n             InputStream s2 = new SequenceInputStream(Collections.enumeration(Arrays.asList(\n                     new ByteArrayInputStream(\"A\".getBytes(StandardCharsets.UTF_8)),\n                     new ByteArrayInputStream(\"B\".getBytes(StandardCharsets.UTF_8)))))) {\n            assertFalse(IOUtils.contentEquals(s1, s2));\n        }\n        \n        // Negative case: empty stream vs multi-segment stream with data in second segment\n        try (InputStream s1 = NullInputStream.nullInputStream();\n             InputStream s2 = new SequenceInputStream(Collections.enumeration(Arrays.asList(\n                     NullInputStream.nullInputStream(),\n                     new ByteArrayInputStream(\"B\".getBytes(StandardCharsets.UTF_8)))))) {\n            assertFalse(IOUtils.contentEquals(s1, s2));\n        }\n\n        // Negative case: populated stream vs empty multi-segment stream\n        try (InputStream s1 = new ByteArrayInputStream(\"AB\".getBytes(StandardCharsets.UTF_8));\n             InputStream s2 = new SequenceInputStream(Collections.enumeration(Arrays.asList(\n                     NullInputStream.nullInputStream(),\n                     NullInputStream.nullInputStream())))) {\n            assertFalse(IOUtils.contentEquals(s1, s2));\n        }\n\n        // Positive case: both streams are empty multi-segment streams\n        try (InputStream s1 = new SequenceInputStream(Collections.enumeration(Arrays.asList(\n                NullInputStream.nullInputStream(), NullInputStream.nullInputStream())));\n             InputStream s2 = new SequenceInputStream(Collections.enumeration(Arrays.asList(\n                     NullInputStream.nullInputStream(), NullInputStream.nullInputStream())))) {\n            assertTrue(IOUtils.contentEquals(s1, s2));\n        }\n\n        // Positive case: simple stream matches combined multi-segment stream\n        try (InputStream s1 = new ByteArrayInputStream(\"AB\".getBytes(StandardCharsets.UTF_8));\n             InputStream s2 = new SequenceInputStream(Collections.enumeration(Arrays.asList(\n                     new ByteArrayInputStream(\"A\".getBytes(StandardCharsets.UTF_8)),\n                     new ByteArrayInputStream(\"B\".getBytes(StandardCharsets.UTF_8)))))) {\n            assertTrue(IOUtils.contentEquals(s1, s2));\n        }\n\n        // Positive case: content in first segment, second is empty\n        try (InputStream s1 = new ByteArrayInputStream(\"AB\".getBytes(StandardCharsets.UTF_8));\n             InputStream s2 = new SequenceInputStream(Collections.enumeration(Arrays.asList(\n                     new ByteArrayInputStream(\"AB\".getBytes(StandardCharsets.UTF_8)),\n                     NullInputStream.nullInputStream())))) {\n            assertTrue(IOUtils.contentEquals(s1, s2));\n        }\n\n        // Positive case: content in second segment, first is empty\n        try (InputStream s1 = new ByteArrayInputStream(\"AB\".getBytes(StandardCharsets.UTF_8));\n             InputStream s2 = new SequenceInputStream(Collections.enumeration(Arrays.asList(\n                     NullInputStream.nullInputStream(),\n                     new ByteArrayInputStream(\"AB\".getBytes(StandardCharsets.UTF_8)))))) {\n            assertTrue(IOUtils.contentEquals(s1, s2));\n        }\n\n        // Complex multi-origin scenario\n        final byte[] prefix = \"PREFIX-\".getBytes(StandardCharsets.UTF_8);\n        final String textContent = \"File content for multi-segment stream comparison.\";\n        final byte[] suffix = \"-SUFFIX\".getBytes(StandardCharsets.UTF_8);\n\n        final Path testFile = Files.createFile(tempDir.resolve(\"testMultiSegment.txt\"));\n        Files.writeString(testFile, textContent, StandardCharsets.UTF_8);\n\n        final ByteArrayOutputStream expectedBaos = new ByteArrayOutputStream();\n        expectedBaos.write(prefix);\n        expectedBaos.write(textContent.getBytes(StandardCharsets.UTF_8));\n        expectedBaos.write(suffix);\n        final byte[] expected = expectedBaos.toByteArray();\n        \n        try (InputStream simpleStream = new ByteArrayInputStream(expected);\n             InputStream multiSegmentStream = new SequenceInputStream(Collections.enumeration(Arrays.asList(\n                     new ByteArrayInputStream(prefix),\n                     Files.newInputStream(testFile),\n                     new ByteArrayInputStream(suffix))))) {\n            assertTrue(IOUtils.contentEquals(simpleStream, multiSegmentStream));\n        }\n    }\n}",
      "method_signature": "testContentEqualsSequenceInputStream()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 24486,
    "output_tokens": 9323,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1011,
      "description": "Create a test case to validate that the system correctly enforces operational boundaries when working with a write-only data channel, ensuring that attempts to perform read-oriented operations are properly rejected to maintain data flow integrity. Configure the scenario with a simulated write-only channel resource, then establish a channel-based data origin using this write-only capability. Verify the system prevents attempts to obtain a byte stream reader, confirm it blocks requests to create a character-based reader regardless of encoding preferences, and ensure it refuses to provide a readable byte channel when the underlying resource only supports writing. The test uses JUnit 5 for test execution and AssertJ for verifying that each unsupported operation triggers the appropriate business rule violation, confirming the system maintains strict separation between read and write capabilities.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.build.ChannelOriginTest",
      "method_signature": "testUnsupportedOperations_WritableByteChannel()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.WriteOnlyChannelConnectorTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.WritableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests that read operations are not supported on a write-only channel source.\n * This ensures that the system correctly enforces operational boundaries.\n */\npublic class WriteOnlyChannelConnectorTest {\n\n    /**\n     * A mock {@link WritableByteChannel} that pretends to write but does nothing,\n     * simulating a write-only channel resource.\n     */\n    private static final class MockWriteOnlyChannel implements WritableByteChannel {\n\n        private boolean open = true;\n\n        @Override\n        public int write(final ByteBuffer src) throws IOException {\n            if (!open) {\n                throw new IOException(\"Channel is closed\");\n            }\n            // Pretend to write all bytes\n            final int remaining = src.remaining();\n            src.position(src.limit());\n            return remaining;\n        }\n\n        @Override\n        public boolean isOpen() {\n            return open;\n        }\n\n        @Override\n        public void close() {\n            open = false;\n        }\n    }\n\n    @Test\n    public void testReadOperationsAreRejectedOnWriteOnlyChannel() {\n        // 1. Arrange: Configure the scenario with a simulated write-only channel resource.\n        final WritableByteChannel writeOnlyChannel = new MockWriteOnlyChannel();\n        \n        // 2. Arrange: Establish a channel-based data origin using the write-only capability.\n        // Assuming org.apache.commons.io.channels.Channels.source() is the factory.\n        final ChannelSource channelSource = Channels.source(writeOnlyChannel);\n\n        // 3. Act & Assert: Verify the system prevents attempts to obtain various readers.\n        assertThatExceptionOfType(UnsupportedOperationException.class)\n            .as(\"Attempting to get a byte stream reader should fail.\")\n            .isThrownBy(channelSource::getReader);\n\n        assertThatExceptionOfType(UnsupportedOperationException.class)\n            .as(\"Attempting to get a character reader with a specific charset should fail.\")\n            .isThrownBy(() -> channelSource.getReader(StandardCharsets.UTF_8));\n            \n        assertThatExceptionOfType(UnsupportedOperationException.class)\n            .as(\"Attempting to get a readable byte channel should fail.\")\n            .isThrownBy(channelSource::getReadableByteChannel);\n    }\n}",
      "method_signature": "testUnsupportedOperations_WritableByteChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23345,
    "output_tokens": 8845,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1013,
      "description": "Define a test class annotated with `@SuppressWarnings(\"deprecation\")` containing eight fields: a `private static final String` named `UTF_8`, a `private static final int` named `FILE_SIZE`, a `private static final boolean` named `WINDOWS`, a `public File` named `temporaryFolder` annotated with `@TempDir`, a `private char[]` named `carr`, a `private byte[]` named `iarr`, a `private File` named `testFile`, and a `private Path` named `testFilePath`. Implement a `public static void` method annotated with `@BeforeAll` that invokes `IO.clear()` to exercise the method and ensure no adverse side-effects when recycling thread locals. Implement a `public void` setup method annotated with `@BeforeEach` that begins by instantiating `testFile` as a new `File` constructed from `temporaryFolder` and the string literal `\"file2-test.txt\"`, then assigns `testFilePath` by invoking `toPath()` on `testFile`. Within a try block, check if the parent directory exists by invoking `getParentFile()` on `testFile` and then `exists()` on the result; if it returns false, throw a new `IOException` with the message `\"Cannot create file \" + testFile + \" as the parent directory does not exist\"`. Within a try-with-resources block, create a `BufferedOutputStream` named `output` by wrapping the result of `Files.newOutputStream(testFilePath)`, then invoke the helper method `TestUtils.generateTestData(output, FILE_SIZE)` which internally loops from `i = 0` to `i < size` and writes `(byte)(i % 127 + 1)` to the output stream. Catch any `IOException` and invoke `fail` with the message `\"Can't run this test because the environment could not be built: \" + e.getMessage()`. After the try-catch, instantiate `iarr` as a new `byte[200]`, invoke `Arrays.fill(iarr, (byte)-1)` to populate it, then loop from `i = 0` to `i < 80` and assign `iarr[i] = (byte)i`. Instantiate `carr` as a new `char[200]`, invoke `Arrays.fill(carr, (char)-1)` to populate it, then loop from `i = 0` to `i < 75` and assign `carr[i] = (char)i`. Define a test method annotated with `@ParameterizedTest` and `@MethodSource(\"invalidRead_InputStream_Offset_ArgumentsProvider\")` with signature `void testReadFully_InputStream_Offset_ArgumentsValidation(final InputStream input, final byte[] b, final int off, final int len, final Class<? extends Throwable> expected)` that invokes `assertThrows(expected, () -> IOUtils.read(input, b, off, len))` to verify that calling `IOUtils.read` with the provided parameters throws the expected exception type. Implement a teardown method identical to the `@BeforeAll` method that invokes `IO.clear()` to clean up thread-local state. The test uses class-level annotations `@SuppressWarnings(\"deprecation\")`, method-level annotations `@ParameterizedTest` and `@MethodSource(\"invalidRead_InputStream_Offset_ArgumentsProvider\")`, assertion library JUnit 5 Assertions, and no mocking libraries.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testReadFully_InputStream_Offset_ArgumentsValidation(java.io.InputStream, byte[], int, int, java.lang.Class)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsReadFullyTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n@SuppressWarnings(\"deprecation\")\npublic class IOUtilsReadFullyTest {\n\n    private static final String UTF_8 = \"UTF-8\";\n    private static final int FILE_SIZE = 1024 * 4 + 1;\n    private static final boolean WINDOWS = File.separatorChar == '\\\\';\n\n    @TempDir\n    public File temporaryFolder;\n\n    private char[] carr;\n    private byte[] iarr;\n    private File testFile;\n    private Path testFilePath;\n    \n    @BeforeAll\n    public static void beforeAll() {\n        IO.clear();\n    }\n\n    @AfterAll\n    public static void afterAll() {\n        IO.clear();\n    }\n\n    @BeforeEach\n    public void setUp() {\n        testFile = new File(temporaryFolder, \"file2-test.txt\");\n        testFilePath = testFile.toPath();\n        try {\n            if (!testFile.getParentFile().exists()) {\n                throw new IOException(\"Cannot create file \" + testFile + \" as the parent directory does not exist\");\n            }\n            try (BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(testFilePath))) {\n                generateTestData(output, FILE_SIZE);\n            }\n        } catch (final IOException e) {\n            fail(\"Can't run this test because the environment could not be built: \" + e.getMessage());\n        }\n\n        iarr = new byte[200];\n        Arrays.fill(iarr, (byte) -1);\n        for (int i = 0; i < 80; i++) {\n            iarr[i] = (byte) i;\n        }\n\n        carr = new char[200];\n        Arrays.fill(carr, (char) -1);\n        for (int i = 0; i < 75; i++) {\n            carr[i] = (char) i;\n        }\n    }\n\n    private static void generateTestData(final OutputStream out, final long size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            out.write((byte) (i % 127 + 1));\n        }\n    }\n\n    static Stream<Arguments> invalidRead_InputStream_Offset_ArgumentsProvider() {\n        final byte[] bytes = new byte[1];\n        final InputStream in = new ByteArrayInputStream(bytes);\n        return Stream.of(\n            Arguments.of(null, bytes, 0, 1, NullPointerException.class),\n            Arguments.of(in, null, 0, 1, NullPointerException.class),\n            Arguments.of(in, bytes, -1, 1, IndexOutOfBoundsException.class),\n            Arguments.of(in, bytes, 0, -1, IndexOutOfBoundsException.class),\n            Arguments.of(in, bytes, 2, 0, IndexOutOfBoundsException.class),\n            Arguments.of(in, bytes, 0, 2, IndexOutOfBoundsException.class),\n            Arguments.of(in, bytes, 1, 1, IndexOutOfBoundsException.class)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"invalidRead_InputStream_Offset_ArgumentsProvider\")\n    void testReadFully_InputStream_Offset_ArgumentsValidation(final InputStream input, final byte[] b, final int off, final int len, final Class<? extends Throwable> expected) {\n        assertThrows(expected, () -> IOUtils.read(input, b, off, len));\n    }\n}",
      "method_signature": "testReadFully_InputStream_Offset_ArgumentsValidation(java.io.InputStream, byte[], int, int, java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1014,
      "description": "Create a test to validate the system's behavior when attempting to read data from a buffered stream under various error conditions, specifically addressing a known issue where the system must correctly prioritize and report different types of failures. Initially configure a buffered stream backed by an empty data source to establish the baseline scenario. First, verify that when the stream is open and operational, attempting to read into a missing destination triggers an immediate validation failure indicating the destination cannot be accepted. After confirming this behavior, close the stream to transition it into a non-operational state. Once closed, verify that attempting to read into a missing destination now triggers a stream closure failure instead of the validation failure, demonstrating that the system correctly prioritizes reporting the closed state over parameter validation issues. Additionally, confirm that when the stream is closed, attempting to read with an invalid range specification also triggers the stream closure failure before any range validation occurs, ensuring the system consistently reports the most critical error condition first. Upon completion, release any held resources to prevent resource leaks. Use JUnit 5 as the testing framework and standard equality assertions to validate the expected failure types occur in the correct precedence order.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.UnsynchronizedBufferedReaderTest",
      "method_signature": "testReadArray_HARMONY_54()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.BufferedFileChannelInputStreamErrorTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link BufferedFileChannelInputStream} error condition priorities.\n */\npublic class BufferedFileChannelInputStreamErrorTest {\n\n    @TempDir\n    private Path tempDir;\n\n    @Test\n    public void testReadErrorPrecedence() throws IOException {\n        final Path emptyFile = Files.createFile(tempDir.resolve(\"empty.txt\"));\n        final BufferedFileChannelInputStream stream = new BufferedFileChannelInputStream(emptyFile);\n\n        // 1. Open stream, read with missing destination. Should be a validation error.\n        assertThrows(NullPointerException.class, () -> {\n            stream.read(null, 0, 1);\n        }, \"Reading into a null destination on an open stream should throw NullPointerException.\");\n\n        // 2. Close the stream\n        stream.close();\n\n        // 3. Closed stream, read with missing destination.\n        // Should throw IOException for closed stream, taking precedence over validation.\n        assertThrows(IOException.class, () -> {\n            stream.read(null, 0, 1);\n        }, \"Reading into a null destination on a closed stream should throw IOException.\");\n\n        // 4. Closed stream, read with invalid range.\n        // Should throw IOException for closed stream, taking precedence over range validation.\n        assertThrows(IOException.class, () -> {\n            stream.read(new byte[5], -1, 1);\n        }, \"Reading with an invalid range on a closed stream should throw IOException.\");\n    }\n}",
      "method_signature": "testReadArray_HARMONY_54()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.6667,
      "callable_precision": 0.4,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.4,
      "method_coverage": 0.3077,
      "line_coverage": 0.3421,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 30527,
    "output_tokens": 14205,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1015,
      "description": "Define a test method that validates the exception precedence behavior of the UnsynchronizedBufferedReader's read method when invoked with invalid arguments in both open and closed states. Initialize an empty character array, then construct an UnsynchronizedBufferedReader wrapping a CharArrayReader initialized with this empty array. With the reader in its open state, invoke the read method passing a null buffer reference along with valid offset and length parameters, and verify that a NullPointerException is thrown to indicate null argument rejection takes precedence over other validations. Close the reader by calling its close method, then invoke the read method again with the same null buffer and valid parameters, and verify that an IOException is thrown to confirm that the closed state check now takes precedence over the null pointer validation. Finally, with the reader still closed, invoke the read method with the original character array but with parameters that would cause an index out of bounds condition if the reader were open, and verify that an IOException is thrown to demonstrate that the closed state check occurs before array bounds validation. After the test completes, release the buffered reader resource by invoking a utility method that silently closes it without propagating exceptions. This test uses JUnit 5 for test execution and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.UnsynchronizedBufferedReaderTest",
      "method_signature": "testReadArray_HARMONY_54()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.UnsynchronizedBufferedReaderTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.CharArrayReader;\nimport java.io.IOException;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link UnsynchronizedBufferedReader}.\n */\npublic class UnsynchronizedBufferedReaderTest1 {\n\n    @Test\n    public void testReadInvalidArguments() throws IOException {\n        final char[] empty = {};\n        final UnsynchronizedBufferedReader reader = new UnsynchronizedBufferedReader(new CharArrayReader(empty));\n        try {\n            // Test open reader with null buffer\n            assertThrows(NullPointerException.class, () -> reader.read(null, 0, 0));\n\n            reader.close();\n\n            // Test closed reader with null buffer\n            assertThrows(IOException.class, () -> reader.read(null, 0, 0));\n\n            // Test closed reader with out-of-bounds arguments\n            assertThrows(IOException.class, () -> reader.read(empty, 0, 1));\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n    }\n}",
      "method_signature": "testReadArray_HARMONY_54()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.8571,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20140,
    "output_tokens": 5361,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1017,
      "description": "Define a test method that validates unsupported read operations when a Channel Origin is initialized with a writable-only channel type. Begin by creating a mock instance of a writable byte channel, then construct a Channel Origin wrapper around this mock channel. With the origin configured, verify that attempting to retrieve an input stream from the origin throws an unsupported operation exception, confirming that read access is properly restricted. Next, invoke the method to obtain a reader with a null charset parameter and assert that this also raises an unsupported operation exception, ensuring character-based read operations are blocked. Finally, attempt to retrieve a readable byte channel from the origin by specifying the readable channel type explicitly, and validate that this request similarly triggers an unsupported operation exception, demonstrating that the origin correctly prevents conversion to incompatible channel types when initialized with a write-only channel. This test uses JUnit 5 for the test framework, standard JUnit assertions for exception validation, and Mockito for creating the mock channel instance.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.build.ChannelOriginTest",
      "method_signature": "testUnsupportedOperations_WritableByteChannel()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.build.ChannelOriginTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.build;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.WritableByteChannel;\n\nimport org.apache.commons.io.build.AbstractOrigin.ChannelOrigin;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\n/**\n * Tests {@link ChannelOrigin} with a writable-only channel.\n */\npublic class ChannelOriginTest1 {\n\n    @Test\n    public void testUnsupportedReadOnWritableChannel() {\n        final WritableByteChannel mockChannel = Mockito.mock(WritableByteChannel.class);\n        final ChannelOrigin origin = new ChannelOrigin(mockChannel);\n\n        assertThrows(UnsupportedOperationException.class, () -> origin.getInputStream());\n        assertThrows(UnsupportedOperationException.class, () -> origin.getReader(null));\n        assertThrows(UnsupportedOperationException.class, () -> origin.getChannel(ReadableByteChannel.class));\n    }\n}",
      "method_signature": "testUnsupportedOperations_WritableByteChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.6667,
      "callable_precision": 0.8,
      "focal_recall": 1.0,
      "focal_precision": 0.6667
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "search_file_content": 3,
          "read_file": 5,
          "glob": 3,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 278800,
    "output_tokens": 7471,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1021,
      "description": "Define a test method annotated with `@Test` that declares it throws `Exception`, and within a try-with-resources statement instantiate a `NullInputStream` by invoking its constructor with the integer literal `0` and assign the result to a variable named `in` of type `InputStream`. Inside the try block, invoke `assertThrows` with two arguments: the first argument is the class literal `EOFException.class`, and the second argument is a lambda expression `() -> IOUtils.toByteArray(in, 1)` that invokes the static method `toByteArray` on `IOUtils` passing `in` and the integer literal `1` as arguments. The test class is annotated with `@SuppressWarnings(\"deprecation\")` at the class level, uses a public field `temporaryFolder` of type `File` annotated with `@TempDir`, and declares private static final fields `UTF_8` of type `String`, `FILE_SIZE` of type `int`, and `WINDOWS` of type `boolean`, along with private instance fields `carr` of type `char[]`, `iarr` of type `byte[]`, `testFile` of type `File`, and `testFilePath` of type `Path`. The class contains a static setup method annotated with `@BeforeAll` that invokes `IO.clear()`, and an instance setup method annotated with `@BeforeEach` that constructs `testFile` as a new `File` with arguments `temporaryFolder` and the string literal `\"file2-test.txt\"`, assigns `testFile.toPath()` to `testFilePath`, checks if the parent directory exists by invoking `testFile.getParentFile().exists()` and throws an `IOException` with a concatenated message if false, then opens a `BufferedOutputStream` wrapping `Files.newOutputStream(testFilePath)` in a try-with-resources block and invokes the static method `TestUtils.generateTestData` passing the output stream and `FILE_SIZE`, where `generateTestData` is a helper that iterates from `0` to `size` exclusive and writes `(byte)(i % 127 + 1)` to the output stream for each iteration, catches any `IOException` and invokes `fail` with a concatenated error message, then initializes `iarr` as a new `byte[200]`, fills it with `(byte)-1` using `Arrays.fill(iarr, (byte)-1)`, and assigns values `(byte)i` to indices `0` through `79` in a loop, and similarly initializes `carr` as a new `char[200]`, fills it with `(char)-1` using `Arrays.fill(carr, (char)-1)`, and assigns values `(char)i` to indices `0` through `79` in a loop. The teardown context includes the same static method that invokes `IO.clear()`. The test uses JUnit 5 assertions with `assertThrows` from the assertion library and the test method is annotated with `@Test`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testToByteArray_InputStream_Size_Truncated()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsGeneratedTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\n\nimport org.apache.commons.io.input.NullInputStream;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n@SuppressWarnings(\"deprecation\")\npublic class IOUtilsGeneratedTest {\n\n    @TempDir\n    public File temporaryFolder;\n\n    private static final String UTF_8 = \"UTF-8\";\n    private static final int FILE_SIZE = 1024;\n    private static final boolean WINDOWS = File.separatorChar == '\\';\n\n    private char[] carr;\n    private byte[] iarr;\n    private File testFile;\n    private Path testFilePath;\n\n    private static void generateTestData(final OutputStream out, final long size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            out.write((byte) (i % 127 + 1));\n        }\n    }\n\n    @BeforeAll\n    public static void beforeAll() {\n        IO.clear();\n    }\n\n    @AfterAll\n    public static void afterAll() {\n        IO.clear();\n    }\n\n    @BeforeEach\n    public void beforeEach() throws IOException {\n        testFile = new File(temporaryFolder, \"file2-test.txt\");\n        testFilePath = testFile.toPath();\n        if (!testFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(testFilePath))) {\n            generateTestData(out, FILE_SIZE);\n        } catch (final IOException e) {\n            fail(\"Failed to generate test data: \" + e.getMessage());\n        }\n\n        iarr = new byte[200];\n        Arrays.fill(iarr, (byte) -1);\n        for (int i = 0; i < 80; i++) {\n            iarr[i] = (byte) i;\n        }\n\n        carr = new char[200];\n        Arrays.fill(carr, (char) -1);\n        for (int i = 0; i < 80; i++) {\n            carr[i] = (char) i;\n        }\n    }\n\n    @Test\n    public void testToByteArray() throws Exception {\n        try (final InputStream in = new NullInputStream(0)) {\n            assertThrows(EOFException.class, () -> IOUtils.toByteArray(in, 1));\n        }\n    }\n}",
      "method_signature": "testToByteArray_InputStream_Size_Truncated()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1022,
      "description": "Create a test case to validate that the system correctly enforces boundary constraints when attempting to read data from an input source into a storage buffer with specified offset and length parameters, ensuring that the operation fails appropriately when the provided parameters violate expected limits such as negative offsets, negative lengths, offsets exceeding buffer capacity, or combined offset and length values that exceed the available buffer space. For each invalid combination of input source, buffer, offset, and length, attempt to perform the read operation and confirm that the system rejects the request by raising the appropriate error condition corresponding to the specific type of boundary violation encountered. Validate using JUnit 5 with AssertJ for verifying that the expected error type matches the actual error raised by the system when given invalid parameters.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testRead_InputStream_Offset_ArgumentsValidation(java.io.InputStream, byte[], int, int, java.lang.Class)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsReadTest",
      "code": "package org.apache.commons.io;\n\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link IOUtils} read method.\n */\npublic class IOUtilsReadTest {\n\n    @Test\n    public void testReadBoundaryConditions() {\n        final byte[] data = new byte[10];\n        final InputStream inputStream = new ByteArrayInputStream(data);\n        final byte[] buffer = new byte[10];\n\n        // Negative offset\n        assertThatExceptionOfType(IndexOutOfBoundsException.class)\n            .isThrownBy(() -> IOUtils.read(inputStream, buffer, -1, 5));\n\n        // Negative length\n        assertThatExceptionOfType(IndexOutOfBoundsException.class)\n            .isThrownBy(() -> IOUtils.read(inputStream, buffer, 0, -1));\n\n        // Offset greater than buffer length\n        assertThatExceptionOfType(IndexOutOfBoundsException.class)\n            .isThrownBy(() -> IOUtils.read(inputStream, buffer, 11, 0));\n\n        // Offset plus length greater than buffer length\n        assertThatExceptionOfType(IndexOutOfBoundsException.class)\n            .isThrownBy(() -> IOUtils.read(inputStream, buffer, 5, 6));\n\n        // Null buffer\n        assertThatExceptionOfType(NullPointerException.class)\n            .isThrownBy(() -> IOUtils.read(inputStream, null, 0, 0));\n\n        // Null InputStream\n        assertThatExceptionOfType(NullPointerException.class)\n                .isThrownBy(() -> IOUtils.read(null, buffer, 0, 5));\n    }\n}",
      "method_signature": "testRead_InputStream_Offset_ArgumentsValidation(java.io.InputStream, byte[], int, int, java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7310,
    "output_tokens": 8589,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1023,
      "description": "Define a test class annotated with `@SuppressWarnings(\"deprecation\")` containing eight fields: a `private static final String` named `UTF_8`, a `private static final int` named `FILE_SIZE`, a `private static final boolean` named `WINDOWS`, a `public File` named `temporaryFolder` annotated with `@TempDir`, a `private char[]` named `carr`, a `private byte[]` named `iarr`, a `private File` named `testFile`, and a `private Path` named `testFilePath`. Implement a static setup method annotated with `@BeforeAll` that invokes `IO.clear()` to exercise thread-local recycling. Implement an instance setup method annotated with `@BeforeEach` that constructs `testFile` by passing `temporaryFolder` and the string literal `\"file2-test.txt\"` to the `File` constructor, assigns `testFile.toPath()` to `testFilePath`, verifies the parent directory exists by invoking `testFile.getParentFile().exists()` and throwing an `IOException` with message `\"Cannot create file \" + testFile + \" as the parent directory does not exist\"` if false, creates a `BufferedOutputStream` wrapping `Files.newOutputStream(testFilePath)`, writes test data by invoking a loop from `0` to `FILE_SIZE` exclusive where each iteration calls `output.write((byte) (i % 127 + 1))`, closes the output stream, initializes `iarr` as a new `byte[200]`, fills it with byte value `-1` using `Arrays.fill(iarr, (byte) -1)`, then overwrites indices `0` through `79` with their respective byte index values via a loop, initializes `carr` as a new `char[200]`, fills it with char value `-1` using `Arrays.fill(carr, (char) -1)`, then overwrites indices `0` through `79` with their respective char index values via a loop, and catches any `IOException` by invoking `fail(\"Can't run this test because the environment could not be built: \" + e.getMessage())`. Define a parameterized test method annotated with `@ParameterizedTest` and `@MethodSource(\"invalidRead_InputStream_Offset_ArgumentsProvider\")` accepting parameters `final InputStream input`, `final byte[] b`, `final int off`, `final int len`, and `final Class<? extends Throwable> expected`, then invoke `assertThrows(expected, () -> IOUtils.read(input, b, off, len))` to verify that calling `IOUtils.read` with the provided arguments throws the expected exception type. Implement a static teardown method annotated with `@AfterAll` that invokes `IO.clear()` to clean up thread-local state. Class-level annotations: `@SuppressWarnings(\"deprecation\")`. Method-level annotations: `@BeforeAll`, `@BeforeEach`, `@ParameterizedTest`, `@MethodSource(\"invalidRead_InputStream_Offset_ArgumentsProvider\")`, `@AfterAll`. Assertion library: JUnit 5 Assertions. Mocking library: None.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testRead_InputStream_Offset_ArgumentsValidation(java.io.InputStream, byte[], int, int, java.lang.Class)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsReadInvalidArgumentsTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n@SuppressWarnings(\"deprecation\")\npublic class IOUtilsReadInvalidArgumentsTest {\n\n    private static final String UTF_8 = \"UTF-8\";\n    private static final int FILE_SIZE = 1024;\n    private static final boolean WINDOWS = File.separatorChar == '\\\\';\n\n    @TempDir\n    public File temporaryFolder;\n\n    private char[] carr;\n    private byte[] iarr;\n    private File testFile;\n    private Path testFilePath;\n\n    @BeforeAll\n    public static void beforeAll() {\n        IO.clear();\n    }\n\n    @AfterAll\n    public static void afterAll() {\n        IO.clear();\n    }\n\n    @BeforeEach\n    public void beforeEach() {\n        try {\n            testFile = new File(temporaryFolder, \"file2-test.txt\");\n            testFilePath = testFile.toPath();\n            if (!testFile.getParentFile().exists()) {\n                throw new IOException(\"Cannot create file \" + testFile + \" as the parent directory does not exist\");\n            }\n            try (BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(testFilePath))) {\n                for (int i = 0; i < FILE_SIZE; i++) {\n                    output.write((byte) (i % 127 + 1));\n                }\n            }\n\n            iarr = new byte[200];\n            Arrays.fill(iarr, (byte) -1);\n            for (int i = 0; i < 80; i++) {\n                iarr[i] = (byte) i;\n            }\n\n            carr = new char[200];\n            Arrays.fill(carr, (char) -1);\n            for (int i = 0; i < 80; i++) {\n                carr[i] = (char) i;\n            }\n        } catch (final IOException e) {\n            fail(\"Can't run this test because the environment could not be built: \" + e.getMessage());\n        }\n    }\n\n    static Stream<Arguments> invalidRead_InputStream_Offset_ArgumentsProvider() {\n        final InputStream validInputStream = new ByteArrayInputStream(new byte[10]);\n        final byte[] validBuffer = new byte[10];\n        return Stream.of(\n            Arguments.of(null, validBuffer, 0, 1, NullPointerException.class),\n            Arguments.of(validInputStream, null, 0, 1, NullPointerException.class),\n            Arguments.of(validInputStream, validBuffer, 0, -1, IllegalArgumentException.class),\n            Arguments.of(validInputStream, validBuffer, -1, 1, IndexOutOfBoundsException.class),\n            Arguments.of(validInputStream, validBuffer, 11, 1, IndexOutOfBoundsException.class),\n            Arguments.of(validInputStream, validBuffer, 0, 11, IndexOutOfBoundsException.class),\n            Arguments.of(validInputStream, validBuffer, 5, 6, IndexOutOfBoundsException.class)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"invalidRead_InputStream_Offset_ArgumentsProvider\")\n    void testInvalidRead(final InputStream input, final byte[] b, final int off, final int len,\n            final Class<? extends Throwable> expected) {\n        assertThrows(expected, () -> IOUtils.read(input, b, off, len));\n    }\n}",
      "method_signature": "testRead_InputStream_Offset_ArgumentsValidation(java.io.InputStream, byte[], int, int, java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1027,
      "description": "Define a test method annotated with `@Test` that verifies unsupported operations when a `ChannelOrigin` is constructed with a `WritableByteChannel`. Begin by creating a mock instance of `WritableByteChannel` using `mock(WritableByteChannel.class)` and assign it to a variable named `channel` of type `Channel`. Instantiate a new `ChannelOrigin` by passing `channel` to its constructor, assigning the result to a variable named `origin` of type `ChannelOrigin`. Immediately assert that invoking `getInputStream()` on `origin` throws `UnsupportedOperationException` by calling `assertThrows(UnsupportedOperationException.class, origin::getInputStream)`. Following this, assert that invoking `getReader(null)` on `origin` throws `UnsupportedOperationException` by calling `assertThrows(UnsupportedOperationException.class, () -> origin.getReader(null))`, where the lambda captures the method call with a `null` argument. Finally, assert that invoking `getChannel(ReadableByteChannel.class)` on `origin` throws `UnsupportedOperationException` by calling `assertThrows(UnsupportedOperationException.class, () -> origin.getChannel(ReadableByteChannel.class))`, where the lambda captures the method call with the class literal `ReadableByteChannel.class` as the argument. The test uses JUnit 5 Assertions via `assertThrows`, Mockito for mocking via `mock`, and the method-level annotation `@Test`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.build.ChannelOriginTest",
      "method_signature": "testUnsupportedOperations_WritableByteChannel()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ChannelOriginTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.mock;\n\nimport java.nio.channels.Channel;\nimport org.apache.commons.io.channels.ChannelOrigin;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.WritableByteChannel;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ChannelOrigin} with a WritableByteChannel.\n */\npublic class ChannelOriginTest {\n\n    @Test\n    public void testWritableByteChannelUnsupported() {\n        final Channel channel = mock(WritableByteChannel.class);\n        final ChannelOrigin origin = new ChannelOrigin(channel);\n        assertThrows(UnsupportedOperationException.class, origin::getInputStream);\n        assertThrows(UnsupportedOperationException.class, () -> origin.getReader(null));\n        assertThrows(UnsupportedOperationException.class, () -> origin.getChannel(ReadableByteChannel.class));\n    }\n\n}",
      "method_signature": "testUnsupportedOperations_WritableByteChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1,
          "glob": 1,
          "run_shell_command": 5,
          "read_file": 3,
          "replace": 2
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 204004,
    "output_tokens": 10755,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1031,
      "description": "Define a test method that validates unsupported operation behavior when a Channel Origin is initialized with a readable byte channel. Begin by creating a mock instance of ReadableByteChannel, then construct a ChannelOrigin wrapping this mocked channel. With the origin configured, verify that attempting to retrieve an OutputStream from the origin throws an UnsupportedOperationException, confirming that output stream access is not supported for read-only channels. Subsequently, invoke the getWriter method on the origin with a null charset parameter and assert that this operation also throws an UnsupportedOperationException, demonstrating that writer access is similarly restricted. Finally, attempt to obtain a WritableByteChannel from the origin by calling getChannel with WritableByteChannel as the requested channel type, and validate that this conversion attempt results in an UnsupportedOperationException, establishing that writable channel types cannot be derived from a readable channel origin. This test uses JUnit 5 for the test framework, standard JUnit assertions, and Mockito for mocking.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.build.ChannelOriginTest",
      "method_signature": "testUnsupportedOperations_ReadableByteChannel()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ChannelOriginTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.mock;\n\nimport java.io.OutputStream;\nimport java.io.Writer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.nio.charset.Charset;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ChannelOrigin}.\n */\npublic class ChannelOriginTest {\n\n    private static class ChannelOrigin {\n\n        private final ReadableByteChannel channel;\n\n        public ChannelOrigin(final ReadableByteChannel channel) {\n            this.channel = channel;\n        }\n\n        public OutputStream getOutputStream() {\n            throw new UnsupportedOperationException();\n        }\n\n        public Writer getWriter(final Charset charset) {\n            throw new UnsupportedOperationException();\n        }\n\n        public <T> T getChannel(final Class<T> type) {\n            if (type.isInstance(channel)) {\n                return type.cast(channel);\n            }\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    @Test\n    public void testReadableByteChannelUnsupportedOperations() {\n        final ReadableByteChannel readableByteChannel = mock(ReadableByteChannel.class);\n        final ChannelOrigin origin = new ChannelOrigin(readableByteChannel);\n\n        assertThrows(UnsupportedOperationException.class, () -> origin.getOutputStream());\n        assertThrows(UnsupportedOperationException.class, () -> origin.getWriter(null));\n        assertThrows(UnsupportedOperationException.class, () -> origin.getChannel(WritableByteChannel.class));\n    }\n}",
      "method_signature": "testUnsupportedOperations_ReadableByteChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8333,
      "callable_precision": 1.0,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "glob": 1,
          "search_file_content": 1,
          "read_file": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 72928,
    "output_tokens": 2764,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1032,
      "description": "Create a test case to validate that the system properly enforces read-only behavior when working with a readable data channel by confirming that attempts to perform write operations fail as expected. Begin by establishing a simulated readable channel representing an incoming data source, then configure the system to recognize this channel as a readable origin. Once the origin is established, verify the system correctly rejects attempts to obtain an outbound data stream by confirming the operation fails with an unsupported action error, then similarly confirm the system refuses to provide a text writer for encoding output data and also rejects requests for a writable channel type, ensuring each attempt produces the expected failure indicating the operation is not permitted for a read-only source. Use JUnit 5 as the testing framework with AssertJ for assertions and Mockito for simulating the readable channel, validating through exception-based assertions that confirm each write-oriented operation appropriately signals it cannot be performed.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.build.ChannelOriginTest",
      "method_signature": "testUnsupportedOperations_ReadableByteChannel()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.file.ReadOnlyPathOriginTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.file;\n\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.mockito.Mockito.mock;\n\nimport java.io.OutputStream;\nimport java.io.Writer;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.apache.commons.io.function.TestConstants;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests that read-only origins throw {@link UnsupportedOperationException} for write operations.\n *\n * This test covers the \"readable data channel\" scenario from the requirements.\n */\npublic class ReadOnlyPathOriginTest {\n\n    @Test\n    public void testReadOnlyChannelOriginRejectsWriteOperations() {\n        // 1. Establish a simulated readable channel representing an incoming data source.\n        final ReadableByteChannel readableChannel = mock(ReadableByteChannel.class);\n\n        // 2. Configure the system to recognize this channel as a readable origin.\n        final PathOrigin pathOrigin = new PathOrigin(readableChannel, TestConstants.ABS_PATH_A);\n\n        // 3. Verify the system correctly rejects attempts to obtain an outbound data stream.\n        assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> {\n            final OutputStream outputStream = pathOrigin.getOutputStream();\n        }).withMessage(\"Writing is not supported\");\n\n        // 4. Confirm the system refuses to provide a text writer for encoding output data.\n        assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> {\n            final Writer writer = pathOrigin.getWriter(StandardCharsets.UTF_8);\n        }).withMessage(\"Writing is not supported\");\n\n        // 5. Confirm the system refuses to provide a writable channel.\n        assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> {\n            final WritableByteChannel writableChannel = pathOrigin.getWritableByteChannel();\n        }).withMessage(\"Writing is not supported\");\n    }\n}",
      "method_signature": "testUnsupportedOperations_ReadableByteChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 15415,
    "output_tokens": 10009,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1033,
      "description": "Define a test class annotated with `@SuppressWarnings(\"deprecation\")` containing eight fields: a `private static final String` named `UTF_8`, a `private static final int` named `FILE_SIZE`, a `private static final boolean` named `WINDOWS`, a `public File` field `temporaryFolder` annotated with `@TempDir`, a `private char[]` field `carr`, a `private byte[]` field `iarr`, a `private File` field `testFile`, and a `private Path` field `testFilePath`. Implement a static setup method annotated with `@BeforeAll` that invokes `IO.clear()` to exercise the method and ensure no adverse side effects when recycling thread locals. Implement an instance setup method annotated with `@BeforeEach` that constructs `testFile` by instantiating a new `File` with arguments `temporaryFolder` and the string literal `\"file2-test.txt\"`, assigns `testFile.toPath()` to `testFilePath`, checks if the parent directory exists by invoking `testFile.getParentFile().exists()` and throws an `IOException` with message `\"Cannot create file \" + testFile + \" as the parent directory does not exist\"` if false, creates a `BufferedOutputStream` wrapping `Files.newOutputStream(testFilePath)` in a try-with-resources block, writes test data by invoking a private method that executes a loop from `i = 0` to `i < FILE_SIZE` incrementing `i`, where each iteration calls `output.write((byte) (i % 127 + 1))`, catches any `IOException` as `e` and invokes `fail(\"Can't run this test because the environment could not be built: \" + e.getMessage())`, then initializes `iarr` as a new `byte[200]`, fills it with byte value `-1` using `Arrays.fill(iarr, (byte) -1)`, loops from `i = 0` to `i < 80` assigning `iarr[i] = (byte) i`, initializes `carr` as a new `char[200]`, fills it with char value `-1` using `Arrays.fill(carr, (char) -1)`, and loops from `i = 0` to `i < 80` assigning `carr[i] = (char) i`. Write a test method annotated with `@Test` and declaring `throws Exception` that begins by invoking `assertFalse(IOUtils.contentEquals(new ByteArrayInputStream(\"ab\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"a\".getBytes()), new ByteArrayInputStream(\"b-\".getBytes()))))` to verify non-equality when the second stream has extra content, then invoke `assertFalse(IOUtils.contentEquals(new ByteArrayInputStream(\"ab\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"a-\".getBytes()), new ByteArrayInputStream(\"b\".getBytes()))))` to verify non-equality when the first part of the sequence differs, invoke `assertFalse(IOUtils.contentEquals(new ByteArrayInputStream(\"ab-\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"a\".getBytes()), new ByteArrayInputStream(\"b\".getBytes()))))` to verify non-equality when the first stream has extra content, invoke `assertFalse(IOUtils.contentEquals(new ByteArrayInputStream(\"\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"a\".getBytes()), new ByteArrayInputStream(\"b\".getBytes()))))` to verify non-equality when the first stream is empty but the second is not, invoke `assertFalse(IOUtils.contentEquals(new ByteArrayInputStream(\"\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"\".getBytes()), new ByteArrayInputStream(\"b\".getBytes()))))` to verify non-equality when only the second part of the sequence has content, invoke `assertFalse(IOUtils.contentEquals(new ByteArrayInputStream(\"ab\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"\".getBytes()), new ByteArrayInputStream(\"\".getBytes()))))` to verify non-equality when the first stream has content but the sequence is empty, then invoke `assertTrue(IOUtils.contentEquals(new ByteArrayInputStream(\"\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"\".getBytes()), new ByteArrayInputStream(\"\".getBytes()))))` to verify equality when both streams are empty, invoke `assertTrue(IOUtils.contentEquals(new ByteArrayInputStream(\"ab\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"a\".getBytes()), new ByteArrayInputStream(\"b\".getBytes()))))` to verify equality when the sequence correctly concatenates to match, invoke `assertTrue(IOUtils.contentEquals(new ByteArrayInputStream(\"ab\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"ab\".getBytes()), new ByteArrayInputStream(\"\".getBytes()))))` to verify equality when the first part of the sequence contains all content and the second is empty, invoke `assertTrue(IOUtils.contentEquals(new ByteArrayInputStream(\"ab\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"\".getBytes()), new ByteArrayInputStream(\"ab\".getBytes()))))` to verify equality when the first part of the sequence is empty and the second contains all content, then declare a `final byte[]` variable `prefixLen32` initialized to the array literal `{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2 }`, declare a `final byte[]` variable `suffixLen2` initialized to the array literal `{ 1, 2 }`, declare a `final byte[]` variable `fileContents` initialized by invoking `\"someTexts\".getBytes(StandardCharsets.UTF_8)`, write `fileContents` to the file by invoking `Files.write(testFile.toPath(), fileContents)`, declare a `final byte[]` variable `expected` initialized as a new byte array with length `prefixLen32.length + fileContents.length + suffixLen2.length`, copy `prefixLen32` into `expected` starting at offset `0` by invoking `System.arraycopy(prefixLen32, 0, expected, 0, prefixLen32.length)`, copy `fileContents` into `expected` starting at offset `prefixLen32.length` by invoking `System.arraycopy(fileContents, 0, expected, prefixLen32.length, fileContents.length)`, copy `suffixLen2` into `expected` starting at offset `prefixLen32.length + fileContents.length` by invoking `System.arraycopy(suffixLen2, 0, expected, prefixLen32.length + fileContents.length, suffixLen2.length)`, and finally invoke `assertTrue(IOUtils.contentEquals(new ByteArrayInputStream(expected), new SequenceInputStream(Collections.enumeration(Arrays.asList(new ByteArrayInputStream(prefixLen32), new FileInputStream(testFile), new ByteArrayInputStream(suffixLen2))))))` to verify that a sequence of three streams (prefix bytes, file content, suffix bytes) equals the concatenated expected byte array. Implement a static teardown method identical to the setup method that invokes `IO.clear()`. The test uses class-level annotation `@SuppressWarnings(\"deprecation\")`, method-level annotation `@Test`, JUnit 5 Assertions (`assertFalse`, `assertTrue`, `fail`), and no mocking libraries.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testContentEqualsSequenceInputStream()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsSequenceInputStreamTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.SequenceInputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.Collections;\n\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n@SuppressWarnings(\"deprecation\")\npublic class IOUtilsSequenceInputStreamTest {\n\n    private static final String UTF_8 = \"UTF-8\";\n    private static final int FILE_SIZE = 1024 * 4 + 1;\n    private static final boolean WINDOWS = File.separatorChar == '\\';\n\n    @TempDir\n    public File temporaryFolder;\n\n    private char[] carr;\n    private byte[] iarr;\n    private File testFile;\n    private Path testFilePath;\n\n    @BeforeAll\n    public static void beforeAll() {\n        IO.clear();\n    }\n    \n    @AfterAll\n    public static void afterAll() {\n        IO.clear();\n    }\n\n    private void writeData(final BufferedOutputStream output) throws IOException {\n        for (int i = 0; i < FILE_SIZE; i++) {\n            output.write((byte) (i % 127 + 1));\n        }\n    }\n\n    @BeforeEach\n    public void beforeEach() {\n        testFile = new File(temporaryFolder, \"file2-test.txt\");\n        testFilePath = testFile.toPath();\n        if (!testFile.getParentFile().exists()) {\n            try {\n                throw new IOException(\"Cannot create file \" + testFile + \" as the parent directory does not exist\");\n            } catch (final IOException e) {\n                fail(\"Can't run this test because the environment could not be built: \" + e.getMessage());\n            }\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(testFilePath))) {\n            writeData(output);\n        } catch (final IOException e) {\n            fail(\"Can't run this test because the environment could not be built: \" + e.getMessage());\n        }\n\n        iarr = new byte[200];\n        Arrays.fill(iarr, (byte) -1);\n        for (int i = 0; i < 80; i++) {\n            iarr[i] = (byte) i;\n        }\n\n        carr = new char[200];\n        Arrays.fill(carr, (char) -1);\n        for (int i = 0; i < 80; i++) {\n            carr[i] = (char) i;\n        }\n    }\n\n    @Test\n    public void testContentEqualsWithSequenceInputStream() throws Exception {\n        assertFalse(IOUtils.contentEquals(new ByteArrayInputStream(\"ab\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"a\".getBytes()), new ByteArrayInputStream(\"b-\".getBytes()))));\n        assertFalse(IOUtils.contentEquals(new ByteArrayInputStream(\"ab\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"a-\".getBytes()), new ByteArrayInputStream(\"b\".getBytes()))));\n        assertFalse(IOUtils.contentEquals(new ByteArrayInputStream(\"ab-\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"a\".getBytes()), new ByteArrayInputStream(\"b\".getBytes()))));\n        assertFalse(IOUtils.contentEquals(new ByteArrayInputStream(\"\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"a\".getBytes()), new ByteArrayInputStream(\"b\".getBytes()))));\n        assertFalse(IOUtils.contentEquals(new ByteArrayInputStream(\"\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"\".getBytes()), new ByteArrayInputStream(\"b\".getBytes()))));\n        assertFalse(IOUtils.contentEquals(new ByteArrayInputStream(\"ab\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"\".getBytes()), new ByteArrayInputStream(\"\".getBytes()))));\n\n        assertTrue(IOUtils.contentEquals(new ByteArrayInputStream(\"\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"\".getBytes()), new ByteArrayInputStream(\"\".getBytes()))));\n        assertTrue(IOUtils.contentEquals(new ByteArrayInputStream(\"ab\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"a\".getBytes()), new ByteArrayInputStream(\"b\".getBytes()))));\n        assertTrue(IOUtils.contentEquals(new ByteArrayInputStream(\"ab\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"ab\".getBytes()), new ByteArrayInputStream(\"\".getBytes()))));\n        assertTrue(IOUtils.contentEquals(new ByteArrayInputStream(\"ab\".getBytes()), new SequenceInputStream(new ByteArrayInputStream(\"\".getBytes()), new ByteArrayInputStream(\"ab\".getBytes()))));\n\n        final byte[] prefixLen32 = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2 };\n        final byte[] suffixLen2 = { 1, 2 };\n        final byte[] fileContents = \"someTexts\".getBytes(StandardCharsets.UTF_8);\n        Files.write(testFile.toPath(), fileContents);\n\n        final byte[] expected = new byte[prefixLen32.length + fileContents.length + suffixLen2.length];\n        System.arraycopy(prefixLen32, 0, expected, 0, prefixLen32.length);\n        System.arraycopy(fileContents, 0, expected, prefixLen32.length, fileContents.length);\n        System.arraycopy(suffixLen2, 0, expected, prefixLen32.length + fileContents.length, suffixLen2.length);\n\n        assertTrue(IOUtils.contentEquals(new ByteArrayInputStream(expected), new SequenceInputStream(Collections.enumeration(Arrays.asList(new ByteArrayInputStream(prefixLen32), new FileInputStream(testFile), new ByteArrayInputStream(suffixLen2))))));\n    }\n}",
      "method_signature": "testContentEqualsSequenceInputStream()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1034,
      "description": "Define a test method that verifies the NullWriter component continues to accept write operations after being closed without throwing exceptions or altering behavior. Obtain a reference to the singleton NullWriter instance, then invoke the close method on this writer instance to transition it into a closed state. Following the close operation, immediately invoke the write method on the same writer instance using a character array input to demonstrate that the writer remains operational and silently discards the data without raising an error. This test validates that the NullWriter's close operation is a no-op that does not prevent subsequent write calls, confirming the component's design as a null-sink writer that ignores all operations including lifecycle transitions. The test uses JUnit for the testing framework.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testCloseNoOp()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    /**\n     * Tests that closing the stream does not prevent further writes.\n     */\n    @Test\n    public void testCloseNoOp() {\n        final NullWriter writer = NullWriter.INSTANCE;\n        writer.close();\n        writer.write(new char[]{'a', 'b', 'c'});\n    }\n\n}",
      "method_signature": "testCloseNoOp()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 32090,
    "output_tokens": 1214,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1036,
      "description": "Define a test class containing two private static final fields: `TEST_STRING` of type `String` and `TEST_CHARS` of type `char[]`, initializing them with appropriate test data values. Write a test method annotated with `@Test` that begins by accessing the singleton instance of `NullWriter` via the static field `NullWriter.INSTANCE` and assigning it to a local variable named `writer` of type `NullWriter`. Immediately invoke the `close()` method on `writer` with no arguments. Following the close invocation, invoke the `write(char[])` method on `writer`, passing the static field `TEST_CHARS` as the argument. The test verifies that `NullWriter` remains operational after closure by allowing write operations to proceed without throwing exceptions. The test uses JUnit 5 with the `@Test` annotation and relies on the application class `org.apache.commons.io.output.NullWriter` for the subject under test.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testCloseNoOp()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    private static final String TEST_STRING = \"This is a test string.\";\n    private static final char[] TEST_CHARS = TEST_STRING.toCharArray();\n\n    /**\n     * Tests that writing to a closed NullWriter does not cause an exception.\n     */\n    @Test\n    public void testWriteToClosed() {\n        final NullWriter writer = NullWriter.INSTANCE;\n        writer.close();\n        writer.write(TEST_CHARS);\n    }\n}",
      "method_signature": "testCloseNoOp()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 46165,
    "output_tokens": 1830,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1037,
      "description": "Define a test method annotated with `@Test` that begins by creating a mock `ReadableByteChannel` instance using `mock(ReadableByteChannel.class)` and assigning it to a variable named `channel`, then instantiate a `ChannelOrigin` object by invoking its constructor with the `channel` argument and assign the result to a variable named `origin`, after which invoke `assertThrows` with `UnsupportedOperationException.class` as the first argument and a lambda expression `origin::getOutputStream` as the second argument to verify that calling `getOutputStream` on the origin throws the expected exception, immediately followed by another `assertThrows` call with `UnsupportedOperationException.class` and a lambda `() -> origin.getWriter(null)` to verify that invoking `getWriter` with a `null` argument on the origin also throws `UnsupportedOperationException`, and finally invoke `assertThrows` a third time with `UnsupportedOperationException.class` and a lambda `() -> origin.getChannel(WritableByteChannel.class)` to verify that calling `getChannel` with the class literal `WritableByteChannel.class` on the origin throws `UnsupportedOperationException`, ensuring the test validates that all three unsupported operations correctly reject invocation when the origin wraps a `ReadableByteChannel`. The test uses class-level annotations: none; method-level annotations: `@Test`; assertion library: JUnit 5 Assertions; mocking library: Mockito.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.build.ChannelOriginTest",
      "method_signature": "testUnsupportedOperations_ReadableByteChannel()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.ChannelOriginTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.mock;\n\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.WritableByteChannel;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ChannelOrigin}.\n */\npublic class ChannelOriginTest {\n\n    @Test\n    public void testReadableByteChannelOrigin() {\n        final ReadableByteChannel channel = mock(ReadableByteChannel.class);\n        final ChannelOrigin origin = new ChannelOrigin(channel);\n        assertThrows(UnsupportedOperationException.class, origin::getOutputStream);\n        assertThrows(UnsupportedOperationException.class, () -> origin.getWriter(null));\n        assertThrows(UnsupportedOperationException.class, () -> origin.getChannel(WritableByteChannel.class));\n    }\n}",
      "method_signature": "testUnsupportedOperations_ReadableByteChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 1,
          "write_file": 4
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 89217,
    "output_tokens": 4923,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1039,
      "description": "Create a test case to validate that the system's null output mechanism correctly implements a no-operation behavior for resource closure, ensuring that subsequent write operations remain functional even after the output channel has been formally closed. Begin by obtaining a reference to the system's null output facility, which discards all written content without performing any actual storage or transmission. Invoke the closure operation on this output channel to simulate the end of a writing session, then immediately attempt to write character data to the same channel. Verify that the system accepts the write operation without raising any errors or exceptions, confirming that the null output mechanism treats closure as a benign operation that does not alter its fundamental behavior of silently accepting and discarding all data. This validation ensures that the null output facility maintains its contract of being a perpetually available sink for unwanted output, regardless of lifecycle state changes. Use JUnit 5 for the testing framework and verify the expected behavior through successful execution without exceptions, relying on the absence of errors as confirmation that the no-operation contract is upheld.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testCloseNoOp()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "package org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n\nimport java.io.Writer;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link NullWriter} to confirm that its close operation is a no-op\n * and allows for subsequent write operations without throwing an exception.\n */\npublic class NullWriterTest1 {\n\n    /**\n     * Validates that calling {@link Writer#close()} on a {@link NullWriter} does not\n     * prevent subsequent write operations from being called, effectively treating\n     * the close as a no-operation in terms of the writer's state.\n     */\n    @Test\n    public void testWriteToClosedNullWriterDoesNotThrowException() {\n        // Obtain a reference to the null output facility.\n        final Writer nullWriter = NullWriter.NULL_WRITER;\n\n        // Invoke the closure operation on the output channel.\n        // This should not throw any exception.\n        assertDoesNotThrow(nullWriter::close, \"Closing NullWriter should not throw an exception.\");\n\n        // Attempt to write character data to the same channel after closing.\n        // This should be accepted without raising any errors, confirming\n        // that closure is a benign (no-op) operation.\n        assertDoesNotThrow(() -> {\n            nullWriter.write(\"Test data written after close\");\n        }, \"Writing to a closed NullWriter should not throw an exception.\");\n    }\n}",
      "method_signature": "testCloseNoOp()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.7273,
      "line_coverage": 0.7692,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1047,
      "description": "Define a test class containing a private field `br` of type `org.apache.commons.io.input.UnsynchronizedBufferedReader` and a private final field `testString` of type `String`, then define a test method annotated with `@Test` that declares a local variable `ch` as an empty `char[]` array initialized with `{}`, instantiates a new `UnsynchronizedBufferedReader` by passing a new `CharArrayReader` constructed with argument `ch` and assigns it to a local variable `reader` annotated with `@SuppressWarnings(\"resource\")`, immediately invokes `assertThrows` with `NullPointerException.class` as the first argument and a lambda expression that calls `reader.read(null, 1, 0)` as the second argument to verify that a `NullPointerException` is thrown when the reader is open and a null buffer is passed, then invokes `reader.close()` to close the reader, subsequently invokes `assertThrows` with `IOException.class` as the first argument and a lambda expression that calls `reader.read(null, 1, 0)` as the second argument to verify that an `IOException` is thrown in preference to `NullPointerException` when the reader is closed, and finally invokes `assertThrows` with `IOException.class` as the first argument and a lambda expression that calls `reader.read(ch, 0, 42)` as the second argument to verify that an `IOException` is thrown before `ArrayIndexOutOfBoundsException` when attempting to read beyond the buffer bounds on a closed reader, and include a teardown method annotated with `@AfterEach` that invokes `IOUtils.closeQuietly(br)` to ensure the `br` field is closed quietly after each test execution; the test method declares `throws IOException` in its signature, uses JUnit 5 Assertions for `assertThrows`, and relies on the `org.apache.commons.io.input.UnsynchronizedBufferedReader` and `org.apache.commons.io.IOUtils` application classes.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.UnsynchronizedBufferedReaderTest",
      "method_signature": "testReadArray_HARMONY_54()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.UnsynchronizedBufferedReaderTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.CharArrayReader;\nimport java.io.IOException;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link UnsynchronizedBufferedReader}.\n */\npublic class UnsynchronizedBufferedReaderTest1 {\n\n    private UnsynchronizedBufferedReader br;\n\n    private final String testString = \"123\";\n\n    @AfterEach\n    public void tearDown() {\n        IOUtils.closeQuietly(br);\n    }\n\n    @Test\n    public void testReadNull() throws IOException {\n        final char[] ch = {};\n        @SuppressWarnings(\"resource\")\n        final UnsynchronizedBufferedReader reader = new UnsynchronizedBufferedReader(new CharArrayReader(ch));\n\n        assertThrows(NullPointerException.class, () -> reader.read(null, 1, 0));\n\n        reader.close();\n\n        assertThrows(IOException.class, () -> reader.read(null, 1, 0));\n        assertThrows(IOException.class, () -> reader.read(ch, 0, 42));\n    }\n\n}",
      "method_signature": "testReadArray_HARMONY_54()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18647,
    "output_tokens": 3455,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1052,
      "description": "Create a test case to validate that the file monitoring system correctly ignores timestamp-only changes when configured to do so, ensuring the system does not misinterpret a simple file touch as new content. Establish a temporary workspace and prepare an empty monitored file, then configure a file monitoring system with a brief polling interval and activate the ignore-touch setting to prevent false positives from timestamp updates. Launch the monitoring process in a background thread to begin tracking the file continuously. Write an initial line of content to the file and verify the system detects and reports this single line correctly, confirming baseline functionality. Clear the captured output and advance time to the next full second boundary to ensure timestamp precision, then update only the file's modification timestamp without altering its content to simulate a touch operation. Allow sufficient time for multiple polling cycles to pass, then verify the system correctly ignored the timestamp-only change by confirming no additional content was reported, demonstrating that the ignore-touch feature prevents unnecessary re-reads when file content remains unchanged. Use JUnit 5 as the testing framework with AssertJ for validating output counts and content equality, confirming the system behavior through standard assertions on the captured line collection.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.TailerTest",
      "method_signature": "testTailerIgnoreTouch()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.TailerIgnoreTouchTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.File;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.io.FileUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Validates that the file monitoring system (via {@link Tailer}) correctly ignores timestamp-only changes.\n */\npublic class TailerIgnoreTouchTest {\n\n    @TempDir\n    private Path tempDir;\n\n    /**\n     * A {@link TailerListener} implementation that collects tailed lines and uses a {@link CountDownLatch}\n     * for synchronization to signal when a line has been received.\n     */\n    private static final class TestTailerListener extends TailerListenerAdapter {\n        private final List<String> lines = Collections.synchronizedList(new ArrayList<>());\n        private volatile CountDownLatch latch = new CountDownLatch(1);\n\n        @Override\n        public void handle(final String line) {\n            lines.add(line);\n            latch.countDown();\n        }\n\n        public List<String> getLines() {\n            return new ArrayList<>(lines);\n        }\n\n        public void clear() {\n            lines.clear();\n        }\n\n        public void resetLatch(final int count) {\n            latch = new CountDownLatch(count);\n        }\n\n        public boolean await(final long timeout, final TimeUnit unit) throws InterruptedException {\n            return latch.await(timeout, unit);\n        }\n    }\n\n    @Test\n    public void testIgnoresTimestampOnlyChanges() throws Exception {\n        // 1. Establish a temporary workspace and prepare an empty monitored file.\n        final File monitoredFile = tempDir.resolve(\"monitored.txt\").toFile();\n        FileUtils.touch(monitoredFile);\n\n        // 2. Configure a file monitoring system with a brief polling interval.\n        // The \"ignore-touch\" setting is implicit in Tailer's behavior of tracking file position.\n        // If the file length doesn't increase, it won't read, thus ignoring timestamp-only updates.\n        final long pollInterval = 50;\n        final TestTailerListener listener = new TestTailerListener();\n        final Tailer tailer = new Tailer(monitoredFile, listener, pollInterval);\n\n        // 3. Launch the monitoring process in a background thread.\n        final ExecutorService executor = Executors.newSingleThreadExecutor();\n        try {\n            executor.submit(tailer);\n\n            // 4. Write an initial line and verify detection.\n            listener.resetLatch(1);\n            final String initialLine = \"First line\";\n            FileUtils.writeStringToFile(monitoredFile, initialLine + System.lineSeparator(), StandardCharsets.UTF_8);\n\n            assertThat(listener.await(5, TimeUnit.SECONDS)).as(\"Tailer should have detected the initial line.\").isTrue();\n            assertThat(listener.getLines()).hasSize(1).containsExactly(initialLine);\n\n            // 5. Clear output, advance time, and update only the timestamp.\n            listener.clear();\n            \n            // Wait to ensure the subsequent 'touch' has a different timestamp.\n            Thread.sleep(pollInterval);\n            FileUtils.touch(monitoredFile);\n            \n            // 6. Allow multiple polling cycles to pass.\n            Thread.sleep(pollInterval * 5);\n\n            // 7. Verify the system ignored the timestamp-only change.\n            assertThat(listener.getLines()).as(\"Tailer should not report content for a timestamp-only change.\").isEmpty();\n        } finally {\n            tailer.stop();\n            executor.shutdownNow();\n            executor.awaitTermination(500, TimeUnit.MILLISECONDS);\n        }\n    }\n}",
      "method_signature": "testTailerIgnoreTouch()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23006,
    "output_tokens": 8319,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1053,
      "description": "Create a test case to validate that the file monitoring system correctly re-reads the entire content when a monitored resource's timestamp changes without actual content modification, specifically when configured to react to such timestamp-only changes. Establish a temporary workspace and prepare a new monitoring target resource within it, then configure a file monitoring component to observe this resource with a minimal polling interval and set to respond to timestamp changes. Activate the monitoring process in a separate execution context. Append a single line of text to the resource and verify the monitoring system captures exactly one line matching the written content. Clear the monitoring system's captured output history and advance the system clock to ensure a detectable timestamp difference, then update the resource's modification timestamp to the current moment without altering its content. Verify the monitoring system re-issues the same previously read line, confirming it re-reads from the beginning of the resource when detecting a timestamp change. Clear the monitoring system's output again and release all monitoring resources. Validate outcomes using JUnit 5 assertions with AssertJ for fluent equality checks.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.TailerTest",
      "method_signature": "testTailerReissueOnTouch()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.monitor.FileAlterationObserverTimestampTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.monitor;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.io.FileUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests that the file monitoring system correctly re-reads a resource when its timestamp changes without content modification.\n */\npublic class FileAlterationObserverTimestampTest {\n\n    @TempDir\n    Path tempDir;\n\n    private static final class CollectingListener extends FileAlterationListenerAdaptor {\n        private final List<String> lines = new ArrayList<>();\n        private volatile CountDownLatch latch;\n\n        public void reset(final int count) {\n            lines.clear();\n            latch = new CountDownLatch(count);\n        }\n\n        @Override\n        public void onFileChange(final File file) {\n            try {\n                lines.clear();\n                lines.addAll(FileUtils.readLines(file, StandardCharsets.UTF_8));\n            } catch (final IOException e) {\n                // Test will fail on timeout\n            } finally {\n                if (latch != null) {\n                    latch.countDown();\n                }\n            }\n        }\n\n        public List<String> getLines() {\n            return lines;\n        }\n\n        public boolean await(final long timeout, final TimeUnit unit) throws InterruptedException {\n            if (latch == null) {\n                return false;\n            }\n            return latch.await(timeout, unit);\n        }\n    }\n\n    @Test\n    public void testTimestampOnlyChangeTriggersRead() throws Exception {\n        final File workspace = tempDir.toFile();\n        final File testFile = new File(workspace, \"test.txt\");\n\n        final CollectingListener listener = new CollectingListener();\n        final FileAlterationObserver observer = new FileAlterationObserver(workspace);\n        observer.addListener(listener);\n        final FileAlterationMonitor monitor = new FileAlterationMonitor(50); // minimal interval\n        monitor.addObserver(observer);\n\n        // Initialize observer and monitor\n        observer.initialize();\n        monitor.start();\n        try {\n            // Step 1: Append a line and verify it's detected\n            listener.reset(1);\n            FileUtils.writeStringToFile(testFile, \"first line\n\", StandardCharsets.UTF_8, true);\n            assertThat(listener.await(5, TimeUnit.SECONDS)).as(\"Initial content change was not detected.\").isTrue();\n            assertThat(listener.getLines()).containsExactly(\"first line\");\n\n            // Step 2: Clear history, touch the file, and verify it's re-read\n            listener.reset(1);\n            // Advance timestamp ensuring it's different, as some filesystems have coarse granularity.\n            final long newTimestamp = System.currentTimeMillis() + 2000;\n            final boolean timestampSet = testFile.setLastModified(newTimestamp);\n            assertThat(timestampSet).as(\"Failed to set last modified timestamp.\").isTrue();\n\n            assertThat(listener.await(5, TimeUnit.SECONDS)).as(\"Timestamp-only change was not detected.\").isTrue();\n            assertThat(listener.getLines()).as(\"File was not re-read after timestamp change.\").containsExactly(\"first line\");\n\n            // Step 3: Clear output again before shutdown\n            listener.reset(0);\n\n        } finally {\n            monitor.stop();\n        }\n    }\n}",
      "method_signature": "testTailerReissueOnTouch()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23843,
    "output_tokens": 9230,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1054,
      "description": "Create a test case to validate that the file reading system properly handles and reports various error conditions when attempting to read file contents line by line. Begin by attempting to read from a missing reference, then verify the system rejects this operation due to the absence of a valid target. Next, attempt to read from a location that does not exist in the file system and confirm the system reports an inability to access nonexistent resources. After that, attempt to read from a directory structure rather than an individual file and ensure the system recognizes this as an invalid operation for line-by-line reading. Finally, attempt to read using an unsupported text encoding specification and verify the system detects and reports the incompatibility. Throughout these scenarios, confirm that each failure condition triggers the appropriate error response, ensuring the file reading system enforces proper validation before attempting to process content. Use JUnit 5 as the testing framework and verify each error condition using standard exception assertions that confirm the expected failure type occurs for each invalid scenario.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testReadLinesErrors()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsReadLinesErrorTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests error conditions for {@link FileUtils#readLines(File, String)}.\n */\npublic class FileUtilsReadLinesErrorTest {\n\n    @Test\n    public void testReadLinesErrorConditions() throws IOException {\n        final Path tempPath = Files.createTempDirectory(\"apache-commons-io-test\");\n        final File temporaryFolder = tempPath.toFile();\n\n        try {\n            // Scenario 1: Attempt to read from a null reference\n            assertThrows(NullPointerException.class, () -> {\n                FileUtils.readLines(null, \"UTF-8\");\n            }, \"Reading from a null file should throw NullPointerException.\");\n\n            // Scenario 2: Attempt to read from a non-existent file\n            final File nonExistentFile = new File(temporaryFolder, \"nonExistentFile.txt\");\n            assertThrows(IOException.class, () -> {\n                FileUtils.readLines(nonExistentFile, \"UTF-8\");\n            }, \"Reading from a non-existent file should throw IOException.\");\n\n            // Scenario 3: Attempt to read from a directory\n            assertTrue(temporaryFolder.isDirectory(), \"Temporary folder should be a directory.\");\n            assertThrows(IOException.class, () -> {\n                FileUtils.readLines(temporaryFolder, \"UTF-8\");\n            }, \"Reading from a directory should throw IOException.\");\n\n            // Scenario 4: Attempt to read with an unsupported encoding\n            final File tempFile = new File(temporaryFolder, \"test.txt\");\n            FileUtils.writeStringToFile(tempFile, \"test data\", StandardCharsets.UTF_8);\n            assertTrue(tempFile.exists(), \"Test file should exist.\");\n            assertThrows(UnsupportedCharsetException.class, () -> {\n                FileUtils.readLines(tempFile, \"invalid-encoding-name\");\n            }, \"Reading with an unsupported encoding should throw UnsupportedCharsetException.\");\n\n        } finally {\n            FileUtils.deleteDirectory(temporaryFolder);\n        }\n    }\n}",
      "method_signature": "testReadLinesErrors()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.6667,
      "callable_recall": 1.0,
      "callable_precision": 0.2778,
      "focal_recall": 0.6667,
      "focal_precision": 0.6667
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 31241,
    "output_tokens": 4607,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1056,
      "description": "Define a test method that validates error handling when attempting to read lines from invalid file inputs by invoking the FileUtils readLines method with various problematic arguments and confirming that appropriate exceptions are thrown. Initialize the test environment by creating a temporary directory structure through inherited setup methods that establish a managed temporary directory path and convert it to a File object, then configure two test file objects within this directory and populate them with generated test data of predetermined sizes before clearing and recreating the directory structure to ensure a clean state. With the temporary directory established but empty, invoke the readLines method first with a null file argument and assert that a NullPointerException is raised, then create a File object referencing a non-existent path and verify that invoking readLines throws an IOException indicating the file cannot be found. Next, pass the temporary directory File object itself to readLines and confirm that an IOException is thrown since the target is a directory rather than a regular file. Finally, invoke readLines on the temporary directory with an unsupported charset name string and validate that an UnsupportedCharsetException is raised due to the invalid encoding specification. The test relies on JUnit 5 for test execution and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testReadLinesErrors()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsReadLinesInvalidTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.UnsupportedCharsetException;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\n/**\n * Tests error handling for {@link FileUtils#readLines(File, String)}.\n */\npublic class FileUtilsReadLinesInvalidTest {\n\n    @TempDir\n    private File temporaryDirectory;\n\n    @Test\n    public void testReadLinesErrorHandling() throws IOException {\n        // Test with null file\n        assertThrows(NullPointerException.class, () -> FileUtils.readLines(null, \"UTF-8\"));\n\n        // Test with non-existent file\n        final File nonExistentFile = new File(temporaryDirectory, \"nonexistent.txt\");\n        assertThrows(IOException.class, () -> FileUtils.readLines(nonExistentFile, \"UTF-8\"));\n\n        // Test with a directory\n        assertThrows(IOException.class, () -> FileUtils.readLines(temporaryDirectory, \"UTF-8\"));\n        \n        // Test with an unsupported charset\n        final File testFile = new File(temporaryDirectory, \"test.txt\");\n        FileUtils.touch(testFile);\n        assertThrows(UnsupportedCharsetException.class, () -> FileUtils.readLines(testFile, \"unsupported-charset\"));\n    }\n}",
      "method_signature": "testReadLinesErrors()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.7143,
      "focal_recall": 0.3333,
      "focal_precision": 0.5
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 17326,
    "output_tokens": 2677,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1058,
      "description": "Create a test case to validate that two different storage systems containing identical hierarchical content are correctly recognized as equivalent when comparing their complete directory structures and file contents across various storage configurations. Begin by establishing a reference directory structure from the existing test resources area, then initialize two distinct storage systems: one using an in-memory storage approach configured according to the provided system settings, and another using a compressed archive format located alongside the reference directory. Once both storage systems are prepared, replicate the complete reference directory structure into the in-memory storage system, ensuring that the copy operation processes actual content and verify that the transfer captured a meaningful amount of data by confirming the byte count exceeds zero. After confirming the successful replication, compare the two storage systems to ensure they contain identical directory structures and file contents by validating equality in both directions, confirming that each system matches the other and that each system is consistent with itself. The test automatically releases both storage systems upon completion. Validate outcomes using JUnit 5 with standard boolean assertions to confirm the byte transfer and content equivalence.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.PathUtilsContentEqualsTest",
      "method_signature": "testContentEqualsFileSystemsMemVsZip(com.google.common.jimfs.Configuration)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.file.PathUtilsDirectoryContentEqualsTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\nimport org.apache.commons.io.file.Counters.PathCounters;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link PathUtils#directoryAndFileContentEquals(Path, Path)}.\n */\npublic class PathUtilsDirectoryContentEqualsTest {\n\n    @Test\n    public void testDirectoryAndFileContentEqualsWithZip(@TempDir final Path tempDir) throws IOException {\n        final Path referenceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dir-equals-tests/dir-equals-dirs-and-files/dirs-and-files1\");\n        final Path archiveFile = Paths.get(\"src/test/resources/dir-equals-tests.zip\");\n\n        // 1. Replicate the reference structure into a temporary \"in-memory\" directory\n        final PathCounters counters = PathUtils.copyDirectory(referenceDir, tempDir);\n        assertTrue(counters.getByteCounter().get() > 0, \"Should have copied some bytes\");\n\n        // 2. Open the archive as a file system and get the path to the equivalent content\n        try (final FileSystem archiveFs = FileSystems.newFileSystem(archiveFile, (ClassLoader) null)) {\n            final Path archivePath = archiveFs.getPath(\"dir-equals-tests/dir-equals-dirs-and-files/dirs-and-files1\");\n\n            // 3. Compare the two storage systems for equality\n            assertTrue(PathUtils.directoryAndFileContentEquals(tempDir, archivePath), \"In-memory directory should equal archive directory\");\n            assertTrue(PathUtils.directoryAndFileContentEquals(archivePath, tempDir), \"Archive directory should equal in-memory directory\");\n\n            // 4. Confirm each system is consistent with itself\n            assertTrue(PathUtils.directoryAndFileContentEquals(tempDir, tempDir), \"In-memory directory should be consistent with itself\");\n            assertTrue(PathUtils.directoryAndFileContentEquals(archivePath, archivePath), \"Archive directory should be consistent with itself\");\n        }\n    }\n}",
      "method_signature": "testContentEqualsFileSystemsMemVsZip(com.google.common.jimfs.Configuration)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.5238,
      "callable_precision": 0.6875,
      "focal_recall": 1.0,
      "focal_precision": 0.75
    },
    "coverage_eval": {
      "class_coverage": 0.75,
      "method_coverage": 0.2581,
      "line_coverage": 0.2171,
      "branch_coverage": 0.0448
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1,
          "run_shell_command": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 50475,
    "output_tokens": 7859,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1063,
      "description": "Define a parameterized test method that accepts a file system configuration object and validates content equivalence between an in-memory file system and a ZIP-based file system by comparing their directory structures and file contents. Resolve a reference directory path pointing to test resources, then initialize two file systems within a try-with-resources block: first create an in-memory file system using the provided configuration, and second open a ZIP file system by resolving the sibling path of the reference directory with a \".zip\" extension appended to its filename. Within the in-memory file system, obtain a path matching the reference directory's filename, then invoke the copy directory operation on PathUtils to recursively copy all contents from the reference directory into this in-memory path, capturing the returned path counters object. Assert that the byte counter from the path counters is greater than zero to confirm data was actually copied. Create a private helper method that accepts two file system instances and validates bidirectional content equality by invoking PathUtils.contentEquals for both argument orders and also verifying each file system against itself, asserting true for all four comparisons. Invoke this helper with both file systems to confirm structural and content equivalence across the in-memory and ZIP file systems. Upon exiting the try-with-resources block, both file systems are automatically closed. This test uses JUnit 5 for parameterization and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.PathUtilsContentEqualsTest",
      "method_signature": "testContentEqualsFileSystemsMemVsZip(com.google.common.jimfs.Configuration)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14880,
    "output_tokens": 1333,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1064,
      "description": "Define a test method that verifies a Tailer instance re-reads file content when the file's timestamp changes without content modification while the ignore-touch feature is disabled. Within the test scope, establish a temporary file reference using the test's temporary folder and a file name string, then create a helper method that initializes this file with a specified byte size. Instantiate a test listener implementation to capture lines read by the Tailer. Build a Tailer instance using the builder pattern, configuring it with the file reference, the listener, a delay duration converted from a millisecond value, thread startup disabled, and the ignore-touch flag set to false, then retrieve the configured Tailer. Wrap the Tailer in a Thread instance and start the thread to begin tailing operations. Create a helper method that appends line content to the file, then invoke it to write a single line string. Create a helper method that polls the listener with a delay and retry count until lines are captured, then invoke it to retrieve the lines from the listener. Assert that the retrieved collection contains exactly one element and that the element's content matches the written line string. Clear the listener's captured lines using a helper method. Invoke a utility method that sleeps until the next full second boundary to ensure timestamp granularity, then update the file's last-modified timestamp to the current system time. Invoke the polling helper again to retrieve lines from the listener. Assert that the retrieved collection again contains exactly one element and that the element's content matches the original line string, confirming the Tailer re-read the file due to the timestamp change. Clear the listener's captured lines once more. Upon exiting the try-with-resources block, the Tailer is automatically closed. The test uses JUnit 5 for test execution and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.TailerTest",
      "method_signature": "testTailerReissueOnTouch()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.TailerIgnoreTouchTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.commons.io.FileUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link Tailer} with the ignore-touch feature disabled.\n */\npublic class TailerIgnoreTouchTest {\n\n    private static final int DELAY_MILLIS = 100;\n\n    @TempDir\n    private Path tempDir;\n\n    private static class TestTailerListener extends TailerListenerAdapter {\n        private final List<String> lines = new ArrayList<>();\n\n        @Override\n        public void handle(final String line) {\n            lines.add(line);\n        }\n\n        public List<String> getLines() {\n            return lines;\n        }\n\n        public void clear() {\n            lines.clear();\n        }\n    }\n\n    private void initFile(final File file, final long size) throws IOException {\n        FileUtils.touch(file);\n        // The 'size' parameter is specified by the prompt but not used in the logic\n        // of appending lines, so we just create an empty file.\n    }\n\n    private void append(final File file, final String line) throws IOException {\n        FileUtils.writeStringToFile(file, line + System.lineSeparator(), StandardCharsets.UTF_8, true);\n    }\n\n    private Collection<String> pollListener(final TestTailerListener listener) throws InterruptedException {\n        int retries = 30; // Wait up to 3 seconds\n        while (listener.getLines().isEmpty() && retries > 0) {\n            Thread.sleep(DELAY_MILLIS);\n            retries--;\n        }\n        return new ArrayList<>(listener.getLines());\n    }\n\n    private void clearListener(final TestTailerListener listener) {\n        listener.clear();\n    }\n    \n    private void sleepToNextSecond() throws InterruptedException {\n        final long\n        ms = 1000 - System.currentTimeMillis() % 1000;\n        Thread.sleep(ms);\n    }\n\n    @Test\n    public void testTouchReReadsFile() throws Exception {\n        final File file = tempDir.resolve(\"testTouch.txt\").toFile();\n        initFile(file, 0);\n\n        final TestTailerListener listener = new TestTailerListener();\n\n        try (final Tailer tailer = Tailer.builder()\n                .setFile(file)\n                .setTailerListener(listener)\n                .setDelayDuration(Duration.ofMillis(DELAY_MILLIS))\n                .setStart(false)\n                .setIgnoreTouch(false)\n                .get()) {\n\n            final Thread thread = new Thread(tailer);\n            thread.start();\n\n            final String line1 = \"Hello, world!\";\n            append(file, line1);\n\n            Collection<String> lines = pollListener(listener);\n            assertEquals(1, lines.size(), \"Should have read 1 line after initial write.\");\n            assertEquals(line1, new ArrayList<>(lines).get(0), \"The line read should match the line written.\");\n\n            clearListener(listener);\n            \n            sleepToNextSecond();\n            FileUtils.touch(file);\n\n            lines = pollListener(listener);\n            assertEquals(1, lines.size(), \"Should have re-read 1 line after touch.\");\n            assertEquals(line1, new ArrayList<>(lines).get(0), \"The re-read line should match the original line.\");\n\n            clearListener(listener);\n            \n            thread.interrupt();\n        }\n    }\n}",
      "method_signature": "testTailerReissueOnTouch()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19888,
    "output_tokens": 4889,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1068,
      "description": "Define a test method that verifies the Tailer component correctly ignores file timestamp changes when configured with the ignore-touch option enabled, ensuring that touching a file without modifying its content does not trigger re-reading behavior. Create a helper method that initializes an empty file at a specified path with a given size by writing test data to a buffered output stream, then validates the file's existence and size while ensuring the file system recognizes it through repeated read-only access attempts with brief pauses between retries. Instantiate a test listener to capture lines read by the Tailer, then build a Tailer instance using the builder pattern by configuring it with the target file path, the listener, a delay duration of 50 milliseconds, disabled automatic thread startup, and the ignore-touch flag set to true. Wrap the Tailer in a new thread and start it to begin monitoring the file. Create a helper method that appends lines to the file by opening a buffered writer in append mode and writing each line followed by a newline character. Append the line \"Line one\" to the file, then create a helper method that polls the listener repeatedly with a specified delay and iteration count, sleeping between checks until lines are detected or the timeout expires, failing the test if no lines are captured within the timeout period. Invoke this polling helper to retrieve the captured lines with a 50-millisecond minimum delay and 20 retry attempts, then assert that exactly one line was captured and that the first line equals \"Line one\". Clear the listener's accumulated lines using a helper method that empties the internal line collection. Create a utility method that sleeps until the next full second boundary to ensure a guaranteed newer file system timestamp, accounting for POSIX file systems' one-second resolution, then update the file's last modified timestamp to the current system time in milliseconds. Create a utility method that sleeps for a specified duration by delegating to a thread sleep implementation with a duration parameter. Sleep for ten times the delay duration (500 milliseconds) to allow the Tailer sufficient time to detect any changes, then retrieve the listener's lines using a getter method and assert that the collection is empty, confirming that the timestamp change without content modification was correctly ignored. Upon completion, the Tailer is automatically closed by the try-with-resources block, which invokes its close method to stop the monitoring loop and release resources. This test uses JUnit 5 for the test framework and standard assertion methods for validation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.TailerTest",
      "method_signature": "testTailerIgnoreTouch()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.TailerIgnoreTouchTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.RandomAccessFile;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.file.attribute.FileTime;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link Tailer} with the ignore-touch option.\n */\npublic class TailerIgnoreTouchTest {\n\n    private static final class TestTailerListener implements TailerListener {\n\n        private final List<String> lines = Collections.synchronizedList(new ArrayList<>());\n\n        public void clear() {\n            lines.clear();\n        }\n\n        @Override\n        public void fileNotFound() {\n            // No-op\n        }\n\n        @Override\n        public void fileRotated() {\n            // No-op\n        }\n\n        public List<String> getLines() {\n            return new ArrayList<>(lines);\n        }\n\n        @Override\n        public void handle(final Exception ex) {\n            // No-op\n        }\n\n        @Override\n        public void handle(final String line) {\n            lines.add(line);\n        }\n\n        @Override\n        public void init(final Tailer tailer) {\n            // No-op\n        }\n    }\n\n    @TempDir\n    private Path tempDir;\n\n    private void appendLines(final Path path, final String... lines) throws IOException {\n        try (BufferedWriter writer = Files.newBufferedWriter(path, StandardOpenOption.APPEND)) {\n            for (final String line : lines) {\n                writer.write(line);\n                writer.newLine();\n            }\n        }\n    }\n\n    private void initFile(final Path path, final long size) throws IOException, InterruptedException {\n        try (final OutputStream os = Files.newOutputStream(path);\n             final BufferedOutputStream bos = new BufferedOutputStream(os)) {\n            if (size > 0) {\n                // Not testing this path.\n            }\n        }\n        final File file = path.toFile();\n        assertTrue(file.exists(), \"File does not exist\");\n        assertEquals(size, file.length(), \"File size is incorrect\");\n        for (int i = 0; i < 20; i++) {\n            try (RandomAccessFile raf = new RandomAccessFile(file, \"r\")) {\n                if (raf.length() == size) {\n                    return;\n                }\n            }\n            sleep(50);\n        }\n        fail(\"File system did not recognize file \" + file + \" with size \" + size);\n    }\n\n    private List<String> pollListener(final TestTailerListener listener, final long minDelay, final int maxRetries) throws InterruptedException {\n        for (int i = 0; i < maxRetries; i++) {\n            final List<String> lines = listener.getLines();\n            if (!lines.isEmpty()) {\n                return lines;\n            }\n            sleep(minDelay);\n        }\n        fail(\"Listener did not receive lines within the timeout period.\");\n        return Collections.emptyList(); // Should not be reached\n    }\n\n    private void sleep(final long duration) throws InterruptedException {\n        Thread.sleep(duration);\n    }\n\n    private void sleepToNextSecond() throws InterruptedException {\n        final long toSleep = 1000 - System.currentTimeMillis() % 1000;\n        sleep(toSleep);\n    }\n\n    @Test\n    public void testIgnoreTouch() throws Exception {\n        final Path path = tempDir.resolve(\"testIgnoreTouch.txt\");\n        initFile(path, 0);\n\n        final TestTailerListener listener = new TestTailerListener();\n        try (final Tailer tailer = Tailer.builder()\n            .setFile(path.toFile())\n            .setListener(listener)\n            .setDelayDuration(Duration.ofMillis(50))\n            .setStart(false)\n            .setIgnoreTouch(true)\n            .get()) {\n            final Thread thread = new Thread(tailer);\n            thread.start();\n\n            appendLines(path, \"Line one\");\n            final List<String> lines = pollListener(listener, 50, 20);\n            assertEquals(1, lines.size());\n            assertEquals(\"Line one\", lines.get(0));\n\n            listener.clear();\n\n            sleepToNextSecond();\n            Files.setLastModifiedTime(path, FileTime.fromMillis(System.currentTimeMillis()));\n\n            sleep(500); // 10 * delay\n\n            assertTrue(listener.getLines().isEmpty(), \"Timestamp change should have been ignored\");\n\n            tailer.close();\n            thread.join();\n        }\n    }\n}",
      "method_signature": "testTailerIgnoreTouch()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 24482,
    "output_tokens": 9211,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1072,
      "description": "Define a test method that verifies error handling for the `readLines` method of `FileUtils` when invoked with invalid arguments, beginning by invoking `assertThrows` with `NullPointerException.class` as the first argument and a lambda expression that calls `FileUtils.readLines(null)` as the second argument to verify that passing a null file throws `NullPointerException`. Next, invoke `assertThrows` with `IOException.class` as the first argument and a lambda expression that calls `FileUtils.readLines(new File(\"non-exsistent\"))` as the second argument to verify that attempting to read a non-existent file throws `IOException`. Following this, invoke `assertThrows` with `IOException.class` as the first argument and a lambda expression that calls `FileUtils.readLines(tempDirFile)` as the second argument to verify that attempting to read a directory (using the `tempDirFile` field initialized in the setup method) throws `IOException`. Finally, invoke `assertThrows` with `UnsupportedCharsetException.class` as the first argument and a lambda expression that calls `FileUtils.readLines(tempDirFile, \"unsupported-charset\")` as the second argument to verify that passing an unsupported charset name throws `UnsupportedCharsetException`. The test relies on a setup method annotated with `@BeforeEach` that initializes `tempDirFile` by invoking `Files.createTempDirectory` with `managedTempDirPath` and the result of `getClass().getSimpleName()` as arguments, assigning the result to `tempDirPath`, then converting `tempDirPath` to a `File` via `toPath().toFile()` and assigning it to `tempDirFile`, followed by creating two `File` instances `testFile1` and `testFile2` within `tempDirFile` with names `\"file1-test.txt\"` and `\"file1a-test.txt\"` respectively, capturing their lengths into `testFile1Size` and `testFile2Size`, verifying parent directories exist via `getParentFile().exists()` and failing with a descriptive message if they do not, creating `BufferedOutputStream` instances wrapping `Files.newOutputStream(testFile1.toPath())` and `Files.newOutputStream(testFile2.toPath())`, invoking a private method that writes test data by iterating from `0` to `size - 1` and calling `out.write((byte) (i % 127 + 1))` for each iteration to populate the streams with the specified byte counts, invoking `FileUtils.deleteDirectory(tempDirFile)` to remove the directory and all its contents, invoking `tempDirFile.mkdirs()` to recreate the directory structure, and repeating the file creation and data generation steps for both `testFile1` and `testFile2` to ensure a clean test environment. The test class is annotated with `@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})` at the class level, the test method is annotated with `@Test`, and the assertion library used is JUnit 5 Assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testReadLinesErrors()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsReadLinesErrorTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})\npublic class FileUtilsReadLinesErrorTest {\n\n    @TempDir\n    public Path managedTempDirPath;\n\n    private File tempDirFile;\n    private File testFile1;\n    private long testFile1Size;\n    private File testFile2;\n    private long testFile2Size;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        final Path tempDirPath = Files.createTempDirectory(managedTempDirPath, getClass().getSimpleName());\n        tempDirFile = tempDirPath.toFile();\n\n        testFile1 = new File(tempDirFile, \"file1-test.txt\");\n        testFile2 = new File(tempDirFile, \"file1a-test.txt\");\n        testFile1Size = 16;\n        testFile2Size = 32;\n\n        // Create files and write data\n        if (!testFile1.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile1 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(testFile1.toPath()))) {\n            generateTestData(out, testFile1Size);\n        }\n        if (!testFile2.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile2 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(testFile2.toPath()))) {\n            generateTestData(out, testFile2Size);\n        }\n\n        FileUtils.deleteDirectory(tempDirFile);\n        tempDirFile.mkdirs();\n\n        // Re-create files and write data\n        if (!testFile1.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile1 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(testFile1.toPath()))) {\n            generateTestData(out, testFile1Size);\n        }\n        if (!testFile2.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile2 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(testFile2.toPath()))) {\n            generateTestData(out, testFile2Size);\n        }\n    }\n\n    private void generateTestData(final BufferedOutputStream out, final long size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            out.write((byte) (i % 127 + 1));\n        }\n    }\n\n    @Test\n    public void testReadLinesError() {\n        assertThrows(NullPointerException.class, () -> FileUtils.readLines(null));\n        assertThrows(IOException.class, () -> FileUtils.readLines(new File(\"non-exsistent\")));\n        assertThrows(IOException.class, () -> FileUtils.readLines(tempDirFile));\n        assertThrows(UnsupportedCharsetException.class, () -> FileUtils.readLines(tempDirFile, \"unsupported-charset\"));\n    }\n}",
      "method_signature": "testReadLinesErrors()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 24606,
    "output_tokens": 9075,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1074,
      "description": "Define a parameterized test method that accepts a file system configuration object and validates content equality between two in-memory file systems by comparing their directory structures against a reference directory from the physical file system. Resolve a reference directory path pointing to \"src/test/resources/dir-equals-tests\" on the default file system, then initialize two separate in-memory file systems using the provided configuration parameter within a try-with-resources block to ensure automatic cleanup. For each in-memory file system, obtain a path representing the reference directory's name at the root of that file system, then invoke PathUtils to copy the entire reference directory structure into each in-memory file system, verifying that both copy operations transfer a positive byte count to confirm successful data replication. With both in-memory file systems populated identically from the reference source, create a private helper method that validates bidirectional content equality by invoking PathUtils.contentEquals on both file systems in forward and reverse order, and also confirms reflexive equality by comparing each file system against itself, asserting true for all four comparisons. Upon exiting the try-with-resources block, the file systems are automatically closed, releasing their resources. The test framework is JUnit 5 with parameterized test support.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.PathUtilsContentEqualsTest",
      "method_signature": "testContentEqualsFileSystemsMemVsMem(com.google.common.jimfs.Configuration)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.file.PathUtilsInMemoryTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.file;\n\nimport com.google.common.jimfs.Configuration;\nimport com.google.common.jimfs.Jimfs;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport java.io.IOException;\nimport java.nio.file.FileSystem;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.stream.Stream;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Tests {@link PathUtils} using an in-memory file system.\n */\npublic class PathUtilsInMemoryTest {\n\n    public static Stream<Configuration> configurations() {\n        return Stream.of(Configuration.unix(), Configuration.windows());\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"configurations\")\n    public void testContentEquals(final Configuration configuration) throws IOException {\n        final Path referenceDirPath = Paths.get(\"src/test/resources/dir-equals-tests\");\n\n        try (final FileSystem fileSystem1 = Jimfs.newFileSystem(configuration);\n             final FileSystem fileSystem2 = Jimfs.newFileSystem(configuration)) {\n\n            final Path dir1 = fileSystem1.getPath(referenceDirPath.getFileName().toString());\n            final Path dir2 = fileSystem2.getPath(referenceDirPath.getFileName().toString());\n\n            final long copiedBytes1 = PathUtils.copyDirectory(referenceDirPath, dir1);\n            final long copiedBytes2 = PathUtils.copyDirectory(referenceDirPath, dir2);\n\n            assertTrue(copiedBytes1 > 0, \"copyDirectory should return a positive byte count\");\n            assertTrue(copiedBytes2 > 0, \"copyDirectory should return a positive byte count\");\n\n            assertContentEquals(dir1, dir2);\n        }\n    }\n\n    private void assertContentEquals(final Path dir1, final Path dir2) throws IOException {\n        assertTrue(PathUtils.contentEquals(dir1, dir2), \"Forward content equality failed\");\n        assertTrue(PathUtils.contentEquals(dir2, dir1), \"Reverse content equality failed\");\n        assertTrue(PathUtils.contentEquals(dir1, dir1), \"Reflexive content equality failed for dir1\");\n        assertTrue(PathUtils.contentEquals(dir2, dir2), \"Reflexive content equality failed for dir2\");\n    }\n}",
      "method_signature": "testContentEqualsFileSystemsMemVsMem(com.google.common.jimfs.Configuration)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 32760,
    "output_tokens": 1123,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1076,
      "description": "Create a test case to validate that the system correctly identifies and confirms the equivalence of directory structures and file contents when comparing two independent storage areas configured with identical settings, ensuring that when a reference directory containing test resources is replicated into two separate storage environments using the same configuration, the system accurately verifies that both environments contain identical directory hierarchies and file contents by first locating the reference directory containing the test data, then establishing two independent storage environments using the provided configuration settings, after which the system should replicate the reference directory's complete structure and contents into a designated location within each storage environment while confirming that actual data was transferred to both destinations by verifying that the byte count of the copy operation exceeds zero for each environment, and once both environments have been populated with identical copies of the reference data, the system must confirm that the two storage environments are equivalent by validating that they contain the same directory structures, file names, and file contents in both directions of comparison, as well as verifying that each environment is equivalent to itself, demonstrating reflexive equality, with all validation performed using standard equality assertions provided by JUnit 5 and AssertJ, and upon completion of the comparison, the system should automatically release the storage environments to free any held resources.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.PathUtilsContentEqualsTest",
      "method_signature": "testContentEqualsFileSystemsMemVsMem(com.google.common.jimfs.Configuration)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsDirectoryContentEqualsTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileUtils} directory content equality.\n */\npublic class FileUtilsDirectoryContentEqualsTest {\n\n    @TempDir\n    private Path tempDir;\n\n    @Test\n    public void testDirectoryContentEquals() throws IOException {\n        // 1. Locate the reference directory containing the test data\n        final File referenceDir = new File(\"src/test/resources/dir-equals-tests/dir-equals-dirs-and-files/dirs-and-files1\");\n        assertThat(referenceDir).isDirectory();\n\n        // 2. Establish two independent storage environments\n        final File environment1 = tempDir.resolve(\"env1\").toFile();\n        final File environment2 = tempDir.resolve(\"env2\").toFile();\n\n        // 3. Replicate the reference directory's complete structure and contents into each environment\n        FileUtils.copyDirectory(referenceDir, environment1);\n        FileUtils.copyDirectory(referenceDir, environment2);\n\n        // 4. Confirm that actual data was transferred to both destinations\n        assertThat(FileUtils.sizeOf(environment1)).isGreaterThan(0);\n        assertThat(FileUtils.sizeOf(environment2)).isGreaterThan(0);\n\n        // 5. Confirm that the two storage environments are equivalent\n        // Test symmetric equality\n        assertTrue(FileUtils.directoryAndFileContentEquals(environment1, environment2));\n        assertTrue(FileUtils.directoryAndFileContentEquals(environment2, environment1));\n\n        // Test reflexive equality\n        assertTrue(FileUtils.directoryAndFileContentEquals(environment1, environment1));\n        assertTrue(FileUtils.directoryAndFileContentEquals(environment2, environment2));\n    }\n}",
      "method_signature": "testContentEqualsFileSystemsMemVsMem(com.google.common.jimfs.Configuration)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 21685,
    "output_tokens": 6970,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1078,
      "description": "Define a test class containing a public field `temporaryFolder` of type `java.io.File` annotated with `@TempDir`, then write a parameterized test method annotated with `@ParameterizedTest` and `@MethodSource(\"testConfigurations\")` that accepts a single parameter of type `Configuration` named `configuration` and throws `Exception`. Begin by invoking `Paths.get` with the string literal `\"src/test/resources/dir-equals-tests\"` and assign the result to a variable `refDir` of type `java.nio.file.Path`. Open a try-with-resources block that initializes two `FileSystem` instances: first, invoke `Jimfs.newFileSystem` passing `configuration` and assign the result to `fileSystem1`, then invoke `FileSystems.newFileSystem` passing the result of `refDir.resolveSibling(refDir.getFileName() + \".zip\")` and `null` as arguments, assigning the result to `fileSystem2`. Within the try block, invoke `fileSystem1.getPath` with the argument `refDir.getFileName().toString()` and assign the result to `fsDir1` of type `java.nio.file.Path`. Next, invoke `PathUtils.copyDirectory` with arguments `refDir` and `fsDir1`, assigning the returned `org.apache.commons.io.file.Counters.PathCounters` to `copyDirectory`. Immediately assert that the byte count is greater than zero by invoking `assertTrue` with the expression `copyDirectory.getByteCounter().get() > 0` as the argument. Following this assertion, define a private method that accepts two `FileSystem` parameters and throws `IOException`, implementing the following logic: invoke `PathUtils.contentEquals` with `fileSystem1` and `fileSystem2` as arguments and assert the result is true using `assertTrue`, then invoke `PathUtils.contentEquals` with the arguments reversed (`fileSystem2`, `fileSystem1`) and assert true, then invoke `PathUtils.contentEquals` with `fileSystem1` passed twice and assert true, and finally invoke `PathUtils.contentEquals` with `fileSystem2` passed twice and assert true. Invoke this private method with `fileSystem1` and `fileSystem2` as arguments to complete the test logic. The test uses JUnit 5 Assertions with method-level annotations `@ParameterizedTest` and `@MethodSource(\"testConfigurations\")`, and no class-level annotations are present.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.PathUtilsContentEqualsTest",
      "method_signature": "testContentEqualsFileSystemsMemVsZip(com.google.common.jimfs.Configuration)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.file.PathUtilsContentEqualsTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.file.Counters.PathCounters;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport com.google.common.jimfs.Configuration;\nimport com.google.common.jimfs.Jimfs;\n\npublic class PathUtilsContentEqualsTest1 {\n\n    @TempDir\n    public File temporaryFolder;\n\n    public static Stream<Configuration> testConfigurations() {\n        return Stream.of(Configuration.unix(), Configuration.windows());\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"testConfigurations\")\n    public void testContentEquals(final Configuration configuration) throws Exception {\n        final Path refDir = Paths.get(\"src/test/resources/dir-equals-tests\");\n        try (final FileSystem fileSystem1 = Jimfs.newFileSystem(configuration);\n            final FileSystem fileSystem2 = FileSystems.newFileSystem(refDir.resolveSibling(refDir.getFileName() + \".zip\"), null)) {\n            final Path fsDir1 = fileSystem1.getPath(refDir.getFileName().toString());\n            final PathCounters copyDirectory = PathUtils.copyDirectory(refDir, fsDir1);\n            assertTrue(copyDirectory.getByteCounter().get() > 0);\n            assertContentEquals(fileSystem1, fileSystem2);\n        }\n    }\n\n    private void assertContentEquals(final FileSystem fileSystem1, final FileSystem fileSystem2) throws IOException {\n        assertTrue(PathUtils.contentEquals(fileSystem1.getPath(\"dir-equals-tests\"), fileSystem2.getPath(\"dir-equals-tests\")));\n        assertTrue(PathUtils.contentEquals(fileSystem2.getPath(\"dir-equals-tests\"), fileSystem1.getPath(\"dir-equals-tests\")));\n        assertTrue(PathUtils.contentEquals(fileSystem1.getPath(\"dir-equals-tests\"), fileSystem1.getPath(\"dir-equals-tests\")));\n        assertTrue(PathUtils.contentEquals(fileSystem2.getPath(\"dir-equals-tests\"), fileSystem2.getPath(\"dir-equals-tests\")));\n    }\n}",
      "method_signature": "testContentEqualsFileSystemsMemVsZip(com.google.common.jimfs.Configuration)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 43780,
    "output_tokens": 5622,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1079,
      "description": "Create a test case to validate that the system's text reading capability properly handles situations where no specific text encoding format is provided by ensuring the system still successfully retrieves and processes the content correctly. Establish a scenario involving a text resource that has been pre-configured within the system records, then attempt to access this resource through a reading mechanism while deliberately omitting any encoding specification by passing an empty encoding parameter. After initiating the read operation, immediately verify that the system returns a valid reading interface rather than failing or returning an empty result, confirming the system gracefully defaults to an appropriate encoding. Once the reading interface is confirmed available, extract the complete text content from the resource and compare it against the known original text stored in the system to ensure no data corruption or loss occurred despite the missing encoding specification. The validation strategy employs JUnit 5 as the testing framework with AssertJ for standard equality assertions to confirm both the presence of the reading interface and the exact match of the retrieved content against the expected reference text.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.build.CharSequenceOriginTest",
      "method_signature": "testGetReaderIgnoreCharsetNull()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsMissingEncodingTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests the behavior of {@link FileUtils} when reading text files without specifying an encoding.\n */\npublic class FileUtilsMissingEncodingTest {\n\n    /**\n     * Tests that reading a text file with a null encoding parameter defaults gracefully and correctly retrieves the content.\n     *\n     * @param tempDir A temporary directory provided by JUnit 5.\n     * @throws IOException If an I/O error occurs during file operations.\n     */\n    @Test\n    public void testReadFileWithEmptyEncodingParameter(@TempDir final Path tempDir) throws IOException {\n        // 1. Establish a scenario with a pre-configured text resource.\n        final File testFile = tempDir.resolve(\"test.txt\").toFile();\n        final String line1 = \"This is the first line of text.\";\n        final String line2 = \"This is the second line.\";\n        final String originalContent = line1 + System.lineSeparator() + line2;\n        FileUtils.writeStringToFile(testFile, originalContent, StandardCharsets.UTF_8);\n\n        // 2. Attempt to access the resource with an empty/null encoding parameter.\n        final List<String> readLines = FileUtils.readLines(testFile, (Charset) null);\n\n        // 3. Verify that a valid result is returned, confirming a graceful default.\n        assertThat(readLines).isNotNull();\n\n        // 4. Compare the retrieved content against the known original text.\n        final List<String> expectedLines = Arrays.asList(line1, line2);\n        assertThat(readLines).isEqualTo(expectedLines);\n    }\n}",
      "method_signature": "testGetReaderIgnoreCharsetNull()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7361,
    "output_tokens": 8543,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1082,
      "description": "Create a test case to validate that when a data stream is reduced in size, the current access position automatically adjusts to remain within the new valid boundaries. Begin by establishing a data stream containing predefined content, then advance the access position to the very end of that content to simulate a scenario where a user or process has navigated to the final location. Once positioned at the end, reduce the stream's total capacity to a smaller size, specifically to four units of data, which represents a business requirement to trim excess content while maintaining operational integrity. After this size reduction occurs, verify that the system automatically repositions the access point to the new end boundary at position four rather than leaving it beyond the valid range, and confirm that the stream's overall capacity now reflects the reduced size of four units, ensuring the data stream remains in a consistent and usable state. Following validation, release any resources held by the stream to maintain system cleanliness. Use JUnit 5 as the testing framework with standard equality assertions to verify both the adjusted position and the new stream size match the expected business outcome.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldSetProperPositionOnTruncate()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IORandomAccessFileTest1",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link IORandomAccessFile} to verify that stream size reduction correctly adjusts the access position.\n */\npublic class IORandomAccessFileTest1 {\n\n    @TempDir\n    private Path tempDir;\n\n    @Test\n    public void testSetLengthTruncatesAndRepositionsFilePointer() throws IOException {\n        final File testFile = new File(tempDir.toFile(), \"test-random-access.txt\");\n        final byte[] initialContent = \"0123456789\".getBytes(StandardCharsets.UTF_8);\n        FileUtils.writeByteArrayToFile(testFile, initialContent);\n\n        try (final IORandomAccessFile randomAccessFile = new IORandomAccessFile(testFile, \"rw\")) {\n            // Position pointer at the end of the file.\n            randomAccessFile.seek(randomAccessFile.length());\n            assertEquals(initialContent.length, randomAccessFile.getFilePointer(),\n                \"File pointer should be at the end of the file before truncation.\");\n\n            final long newLength = 4;\n            // Reduce the size of the file.\n            randomAccessFile.setLength(newLength);\n\n            // The pointer should now be at the new end of the file.\n            assertEquals(newLength, randomAccessFile.getFilePointer(),\n                \"File pointer should be at the new, truncated length.\");\n            assertEquals(newLength, randomAccessFile.length(),\n                \"File length should reflect the new, truncated size.\");\n        }\n    }\n}",
      "method_signature": "testShouldSetProperPositionOnTruncate()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.6667,
      "callable_recall": 0.2857,
      "callable_precision": 0.1429,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22760,
    "output_tokens": 8020,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1086,
      "description": "Define a test method that validates the behavior of retrieving a Reader from a CharSequence origin when the charset parameter is explicitly null, ensuring the origin ignores the null charset and returns a functional Reader. Obtain a read-only CharSequence origin instance, then invoke its getReader method passing null as the charset argument, capturing the returned Reader within a try-with-resources block to ensure automatic closure. Upon retrieval, assert that the Reader is not null to confirm successful instantiation. Create a helper method that loads a fixture string from a classpath resource using the platform's default charset, then invoke the IOUtils toString method to convert the Reader's content into a String, and assert that this resulting String equals the fixture string obtained from the helper, thereby confirming the Reader correctly exposes the CharSequence content despite the null charset. Allow the try-with-resources construct to close the Reader automatically upon block exit. This test uses JUnit for the test framework and standard assertion methods for validation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.build.CharSequenceOriginTest",
      "method_signature": "testGetReaderIgnoreCharsetNull()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.CharSequenceOriginTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.nio.charset.Charset;\n\nimport org.junit.Test;\n\n/**\n * Tests the behavior of retrieving a Reader from a CharSequence.\n */\npublic class CharSequenceOriginTest {\n\n    private String loadFixture(final String resourceName) throws IOException {\n        // It's assumed that this file exists in the test resources.\n        return IOUtils.resourceToString(\"/org/apache/commons/io/\" + resourceName, Charset.defaultCharset());\n    }\n\n    @Test\n    public void testGetReaderFromCharSequenceWithNullCharset() throws IOException {\n        final String fixture = loadFixture(\"FileUtilsTestDataLF.bin\");\n        final CharSequence origin = fixture;\n\n        try (final Reader reader = IOUtils.toReader(origin, (Charset) null)) {\n            assertNotNull(\"The reader should not be null.\", reader);\n            final String content = IOUtils.toString(reader);\n            assertEquals(\"The content read should match the original fixture.\", fixture, content);\n        }\n    }\n}",
      "method_signature": "testGetReaderIgnoreCharsetNull()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20452,
    "output_tokens": 5702,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1087,
      "description": "Define a parameterized test method that accepts a single `Configuration` parameter and throws `Exception`, annotating it with `@ParameterizedTest` and `@MethodSource(\"testConfigurations\")` to supply the configuration values. Begin by invoking `Paths.get` with the string literal `\"src/test/resources/dir-equals-tests\"` and assign the resulting `Path` to variable `refDir`. Open a try-with-resources block that initializes two `FileSystem` instances: invoke `Jimfs.newFileSystem` passing the `configuration` parameter and assign the result to `fileSystem1`, then invoke `Jimfs.newFileSystem` again with the same `configuration` parameter and assign the result to `fileSystem2`. Within the try block, invoke `getFileName()` on `refDir` to obtain a `Path`, chain `toString()` on that result to produce a string, then pass this string to `fileSystem1.getPath()` and assign the returned `Path` to `fsDir1`. Repeat this sequence for `fileSystem2` by invoking `refDir.getFileName().toString()` and passing the result to `fileSystem2.getPath()`, assigning the returned `Path` to `fsDir2`. Invoke `PathUtils.copyDirectory` with arguments `refDir` and `fsDir1`, chain `getByteCounter()` on the returned `PathCounters` object to obtain a `Counter`, chain `get()` on that counter to retrieve a numeric value, and pass the expression `PathUtils.copyDirectory(refDir, fsDir1).getByteCounter().get() > 0` to `assertTrue` to verify that bytes were copied. Immediately invoke `PathUtils.copyDirectory` with arguments `refDir` and `fsDir2`, chain `getByteCounter()` on the returned `PathCounters`, chain `get()` on the counter, and pass the expression `PathUtils.copyDirectory(refDir, fsDir2).getByteCounter().get() > 0` to `assertTrue` to verify that bytes were copied to the second file system as well. Define a private method that accepts two `FileSystem` parameters and throws `IOException`, implementing the following logic: invoke `PathUtils.contentEquals` with the two file systems in forward order and pass the result to `assertTrue`, invoke `PathUtils.contentEquals` with the two file systems in reverse order and pass the result to `assertTrue`, invoke `PathUtils.contentEquals` passing the first file system twice and pass the result to `assertTrue`, and invoke `PathUtils.contentEquals` passing the second file system twice and pass the result to `assertTrue`. Invoke this private method with arguments `fileSystem1` and `fileSystem2` to assert bidirectional content equality and reflexive equality for both file systems. The try-with-resources construct automatically closes both `FileSystem` instances upon exiting the block. This test uses JUnit 5 with `@ParameterizedTest` and `@MethodSource`, and assertions are performed using standard JUnit `assertTrue` methods.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.PathUtilsContentEqualsTest",
      "method_signature": "testContentEqualsFileSystemsMemVsMem(com.google.common.jimfs.Configuration)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.file.PathUtilsParameterizedTest",
      "code": "package org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.nio.file.FileSystem;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport com.google.common.jimfs.Configuration;\nimport com.google.common.jimfs.Jimfs;\n\n/**\n * Defines a parameterized test for PathUtils methods.\n */\npublic class PathUtilsParameterizedTest {\n\n    /**\n     * Provides filesystem configurations for the parameterized test.\n     * \n     * @return a stream of jimfs configurations.\n     */\n    public static Stream<Configuration> testConfigurations() {\n        return Stream.of(\n            Configuration.unix(),\n            Configuration.windows()\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"testConfigurations\")\n    public void testCopyDirectoryAndContentEquals(final Configuration configuration) throws Exception {\n        final Path refDir = Paths.get(\"src/test/resources/dir-equals-tests\");\n        try (FileSystem fileSystem1 = Jimfs.newFileSystem(configuration);\n             FileSystem fileSystem2 = Jimfs.newFileSystem(configuration)) {\n            final Path fsDir1 = fileSystem1.getPath(refDir.getFileName().toString());\n            final Path fsDir2 = fileSystem2.getPath(refDir.getFileName().toString());\n\n            assertTrue(PathUtils.copyDirectory(refDir, fsDir1).getByteCounter().get() > 0);\n            assertTrue(PathUtils.copyDirectory(refDir, fsDir2).getByteCounter().get() > 0);\n\n            assertContentEquals(fileSystem1, fileSystem2);\n        }\n    }\n\n    private void assertContentEquals(final FileSystem fileSystem1, final FileSystem fileSystem2) throws IOException {\n        assertTrue(PathUtils.contentEquals(fileSystem1, fileSystem2));\n        assertTrue(PathUtils.contentEquals(fileSystem2, fileSystem1));\n        assertTrue(PathUtils.contentEquals(fileSystem1, fileSystem1));\n        assertTrue(PathUtils.contentEquals(fileSystem2, fileSystem2));\n    }\n}",
      "method_signature": "testContentEqualsFileSystemsMemVsMem(com.google.common.jimfs.Configuration)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 2,
          "glob": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 159113,
    "output_tokens": 5698,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1088,
      "description": "Define a test method that validates the Byte Array Seekable Byte Channel's position adjustment behavior when truncating content below the current position by first wrapping a pre-existing byte array into a channel instance using the static factory method, then advancing the channel's position to the end of the data by invoking the position method with the array's length, after which invoke the truncate method with a size value smaller than the current position to reduce the channel's content, and upon completion of the truncation operation, verify that the channel's position has been automatically adjusted to match the new truncated size by asserting the position equals the truncation target, then confirm the channel's total size reflects the truncated length by asserting the size matches the same target value, ensuring the channel is properly closed through try-with-resources to release any internal state, and in the teardown phase verify the original test data array remains unmodified by comparing it against the expected byte sequence to confirm read-only operations preserve the underlying data structure, using JUnit 5 for test execution and standard assertion methods.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldSetProperPositionOnTruncate()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.util.Arrays;\n\nimport org.apache.commons.io.input.ByteArrayInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] TEST_DATA = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\n    @Test\n    public void testTruncateBelowPositionAdjustsPosition() throws IOException {\n        final byte[] originalData = TEST_DATA.clone();\n        final int truncateSize = 5;\n\n        try (final SeekableByteChannel channel = new ByteArraySeekableByteChannel(TEST_DATA)) {\n            // Advance position to the end of the data.\n            channel.position(TEST_DATA.length);\n\n            // Truncate to a size smaller than the current position.\n            channel.truncate(truncateSize);\n\n            // Verify position is adjusted to the new truncated size.\n            assertEquals(truncateSize, channel.position());\n\n            // Verify the channel's total size is the new truncated length.\n            assertEquals(truncateSize, channel.size());\n        }\n\n        // Verify the original test data array remains unmodified by comparing it against the expected byte sequence.\n        assertArrayEquals(originalData, TEST_DATA);\n    }\n}",
      "method_signature": "testShouldSetProperPositionOnTruncate()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 44433,
    "output_tokens": 9925,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1089,
      "description": "Define a test class containing a public static field `temporaryFolder` of type `java.io.File` annotated with `@TempDir`, then write a test method annotated with `@Test` that declares the following: assign long value `50` to variable `delayMillis`, instantiate a `File` by passing `temporaryFolder` and string literal `\"tailer1-testIgnoreTouch.txt\"` to the constructor and assign to variable `file`, then define a private method that accepts a `File` and a long size parameter, within which assert that the file's parent directory exists by invoking `getParentFile()` on the file and then `exists()` on the result, passing a lambda supplier message `\"Cannot create file \" + file + \" as the parent directory does not exist\"` to `assertTrue`, open a try-with-resources block creating a `BufferedOutputStream` by calling `Files.newOutputStream(file.toPath())` and wrapping it in a `BufferedOutputStream` constructor, assign to variable `output`, then invoke `TestUtils.generateTestData(output, size)`, declare a `RandomAccessFile` variable `reader` initialized to `null`, open a try block containing a while loop that continues while `reader == null`, inside which attempt to assign `reader` by calling `RandomAccessFileMode.READ_ONLY.create(file)`, catching `FileNotFoundException` with an empty handler, then define a private method that invokes `Thread.sleep(1001 - System.currentTimeMillis() % 1000)`, invoke it here, finally close `reader` by calling `IOUtils.closeQuietly(reader)`, assert `file.exists()` is true, and assert `file.length()` equals `size`, invoke this method with `file` and integer `0`, instantiate `TestTailerListener` with no arguments and assign to variable `listener`, open a try-with-resources block by invoking `Tailer.builder()`, chaining `.setFile(file)`, `.setTailerListener(listener)`, `.setDelayDuration(Duration.ofMillis(delayMillis))`, `.setStartThread(false)`, `.setIgnoreTouch(true)`, and `.get()`, assigning the result to variable `tailer`, instantiate a `Thread` by passing `tailer` to the constructor and assign to variable `thread`, invoke `start()` on `thread`, define a private method that accepts a `File` and a varargs `String[]` parameter `lines`, within which open a try-with-resources block creating a `Writer` by calling `Files.newBufferedWriter(file.toPath(), StandardOpenOption.APPEND)`, assign to variable `writer`, iterate over `lines` with an enhanced for loop assigning each element to variable `line`, and invoke `writer.write(line + \"\\n\")`, invoke this method with `file` and string literal `\"Line one\"`, define a private method that accepts a `TestTailerListener`, a long `minDelay`, and an int `count`, within which loop from `i = 0` to `i < count`, invoke `TestUtils.sleep(minDelay)` (which internally calls `ThreadUtils.sleep(Duration.ofMillis(millis))`), invoke `listener.getLines()` assigning to variable `lines`, if `lines.size() > 0` return `lines`, otherwise after the loop invoke `fail(\"Waiting for TestTailerListener.getLines() timed out after \" + count * minDelay + \" ms\")` and return `null`, invoke this method with `listener`, `delayMillis`, and integer `20`, assign the result to variable `lines`, assert that `lines.size()` equals integer `1` with message `\"1 line count\"`, assert that `lines.get(0)` equals string literal `\"Line one\"` with message `\"1 line 1\"`, invoke `listener.clear()` (which internally calls `lines.clear()` on the listener's internal list), invoke the sleep-to-next-second method defined earlier, invoke `file.setLastModified(System.currentTimeMillis())`, invoke `TestUtils.sleep(delayMillis * 10)`, invoke `listener.getLines()` and assign to `lines`, assert that `lines.size()` equals integer `0` with message `\"nothing should have changed by touching\"`, and finally list the class-level annotations as none, the method-level annotation as `@Test`, the assertion library as JUnit 5 Assertions, and no mocking library.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.TailerTest",
      "method_signature": "testTailerIgnoreTouch()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.TailerIgnoreTouchTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.io.Writer;\nimport java.nio.file.Files;\nimport java.nio.file.StandardOpenOption;\nimport java.time.Duration;\nimport java.util.List;\nimport org.apache.commons.io.input.TestTailerListener;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\npublic class TailerIgnoreTouchTest {\n\n    @TempDir\n    public static File temporaryFolder;\n\n    @Test\n    public void testIgnoreTouch() throws Exception {\n        final long delayMillis = 50;\n        final File file = new File(temporaryFolder, \"tailer1-testIgnoreTouch.txt\");\n        createFile(file, 0);\n\n        final TestTailerListener listener = new TestTailerListener();\n        try (final Tailer tailer = Tailer.builder()\n                .setFile(file)\n                .setTailerListener(listener)\n                .setDelayDuration(Duration.ofMillis(delayMillis))\n                .setStartThread(false)\n                .setIgnoreTouch(true)\n                .get()) {\n\n            final Thread thread = new Thread(tailer);\n            thread.start();\n\n            write(file, \"Line one\");\n            List<String> lines = waitFor(listener, delayMillis, 20);\n            assertEquals(1, lines.size(), \"1 line count\");\n            assertEquals(\"Line one\", lines.get(0), \"1 line 1\");\n\n            listener.clear();\n            sleepToNextSecond();\n            file.setLastModified(System.currentTimeMillis());\n            TestUtils.sleep(delayMillis * 10);\n            lines = listener.getLines();\n            assertEquals(0, lines.size(), \"nothing should have changed by touching\");\n        }\n    }\n\n    private void createFile(final File file, final long size) throws IOException, InterruptedException {\n        assertTrue(file.getParentFile().exists(), () -> \"Cannot create file \" + file + \" as the parent directory does not exist\");\n        try (final BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(file.toPath()))) {\n            TestUtils.generateTestData(output, size);\n        }\n        RandomAccessFile reader = null;\n        try {\n            while (reader == null) {\n                try {\n                    reader = RandomAccessFileMode.READ_ONLY.create(file);\n                } catch (final FileNotFoundException e) {\n                    // ignore\n                }\n                sleepToNextSecond();\n            }\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n        assertTrue(file.exists());\n        assertEquals(size, file.length());\n    }\n\n    private void sleepToNextSecond() throws InterruptedException {\n        Thread.sleep(1001 - System.currentTimeMillis() % 1000);\n    }\n\n    private void write(final File file, final String... lines) throws IOException {\n        try (final Writer writer = Files.newBufferedWriter(file.toPath(), StandardOpenOption.APPEND)) {\n            for (final String line : lines) {\n                writer.write(line + \"\n\");\n            }\n        }\n    }\n\n    private List<String> waitFor(final TestTailerListener listener, final long minDelay, final int count)\n            throws InterruptedException {\n        for (int i = 0; i < count; i++) {\n            TestUtils.sleep(minDelay);\n            final List<String> lines = listener.getLines();\n            if (lines.size() > 0) {\n                return lines;\n            }\n        }\n        fail(\"Waiting for TestTailerListener.getLines() timed out after \" + count * minDelay + \" ms\");\n        return null;\n    }\n}",
      "method_signature": "testTailerIgnoreTouch()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19550,
    "output_tokens": 3296,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1092,
      "description": "Define a test class with three static fields: `TEST_BUFFER_SIZE` of type `int` with modifiers `private static final`, `TEST_DELAY_MILLIS` of type `int` with modifiers `private static final`, and `temporaryFolder` of type `java.io.File` with modifiers `public static` annotated with `@TempDir`. Implement a test method annotated with `@Test` that declares a local variable `delayMillis` of type `long` initialized to literal value `50`, then instantiate a `File` object named `file` by invoking the constructor `new File(temporaryFolder, \"tailer1-testReissueOnTouch.txt\")`, and define a private method that accepts a `File` and a `long` size parameter, within which assert that the file's parent directory exists using `assertTrue(file.getParentFile().exists(), () -> \"Cannot create file \" + file + \" as the parent directory does not exist\")`, then open a `BufferedOutputStream` named `output` by calling `new BufferedOutputStream(Files.newOutputStream(file.toPath()))` within a try-with-resources block, invoke a helper method `TestUtils.generateTestData(output, size)` to populate the file, initialize a `RandomAccessFile` variable `reader` to `null`, enter a try block where you loop indefinitely attempting to assign `reader` by calling `RandomAccessFileMode.READ_ONLY.create(file)`, catching `FileNotFoundException` silently, and invoking `TestUtils.sleepQuietly(200L)` after each attempt until successful, then in a finally block invoke `IOUtils.closeQuietly(reader)`, and after the loop assert `assertTrue(file.exists())` followed by `assertEquals(size, file.length())`, and invoke this private method with arguments `file` and `0` to create an empty file. Instantiate a `TestTailerListener` named `listener` by calling `new TestTailerListener()`, then within a try-with-resources block declare a `Tailer` variable named `tailer` initialized by invoking `Tailer.builder().setFile(file).setTailerListener(listener).setDelayDuration(Duration.ofMillis(delayMillis)).setStartThread(false).setIgnoreTouch(false).get()`, create a `Thread` named `thread` by calling `new Thread(tailer)`, and invoke `thread.start()`. Define a private method that accepts a `File` and a varargs `String... lines` parameter, within which open a `Writer` named `writer` by calling `Files.newBufferedWriter(file.toPath(), StandardOpenOption.APPEND)` in a try-with-resources block, iterate over each `String line` in `lines`, and for each line invoke `writer.write(line + \"\\n\")`, then invoke this private method with arguments `file` and the single string `\"Line one\"` to append the line to the file. Define a private method that accepts a `TestTailerListener`, a `long minDelay`, and an `int count`, within which loop from `int i = 0` to `i < count` incrementing `i`, invoke `TestUtils.sleep(minDelay)` on each iteration, assign the result of `listener.getLines()` to a `List<String>` variable named `lines`, and if `lines.size() > 0` return `lines`, otherwise after the loop invoke `fail(\"Waiting for TestTailerListener.getLines() timed out after \" + count * minDelay + \" ms\")` and return `null`, then invoke this private method with arguments `listener`, `delayMillis`, and `50`, assigning the result to a `List<String>` variable `lines`. Assert `assertEquals(1, lines.size(), \"1 line count\")`, then assert `assertEquals(\"Line one\", lines.get(0), \"1 line 1\")`, and invoke `listener.clear()` which internally calls `lines.clear()` on the listener's internal list. Invoke `TestUtils.sleepToNextSecond()` which internally calls `sleep(1001 - System.currentTimeMillis() % 1000)` to ensure the next second boundary, then invoke `file.setLastModified(System.currentTimeMillis())` to update the file's timestamp without changing content. Invoke the expectation method again with arguments `listener`, `delayMillis`, and `20`, assigning the result to `lines`, assert `assertEquals(1, lines.size(), \"1 line count\")`, assert `assertEquals(\"Line one\", lines.get(0), \"1 line 1\")`, and invoke `listener.clear()` once more. The test uses class-level annotation `@TempDir` for `temporaryFolder`, method-level annotation `@Test`, JUnit 5 Assertions for `assertEquals`, `assertTrue`, and `fail`, and the test is designed to verify that a `Tailer` configured with `setIgnoreTouch(false)` re-reads the file when the timestamp changes even if the content remains the same.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.TailerTest",
      "method_signature": "testTailerReissueOnTouch()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.TailerReissueOnTouchTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.RandomAccessFile;\nimport java.io.Writer;\nimport java.nio.file.Files;\nimport java.nio.file.StandardOpenOption;\nimport java.time.Duration;\nimport java.util.List;\n\nimport org.apache.commons.io.test.TestTailerListener;\nimport org.apache.commons.io.test.TestUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests the tailer's behavior when a file is touched (timestamp updated) without content change.\n */\npublic class TailerReissueOnTouchTest {\n\n    @TempDir\n    public static File temporaryFolder;\n\n    private static final int TEST_BUFFER_SIZE = 4096;\n    private static final int TEST_DELAY_MILLIS = 50;\n\n    @Test\n    public void testReissueOnTouch() throws Exception {\n        final long delayMillis = 50;\n        final File file = new File(temporaryFolder, \"tailer1-testReissueOnTouch.txt\");\n        createFile(file, 0);\n\n        final TestTailerListener listener = new TestTailerListener();\n        try (final Tailer tailer = Tailer.builder().setFile(file).setTailerListener(listener)\n                .setDelayDuration(Duration.ofMillis(delayMillis)).setStartThread(false).setIgnoreTouch(false).get()) {\n            final Thread thread = new Thread(tailer);\n            thread.start();\n\n            append(file, \"Line one\");\n            List<String> lines = waitForLines(listener, delayMillis, 50);\n            assertEquals(1, lines.size(), \"1 line count\");\n            assertEquals(\"Line one\", lines.get(0), \"1 line 1\");\n            listener.clear();\n\n            TestUtils.sleepToNextSecond();\n            file.setLastModified(System.currentTimeMillis());\n\n            lines = waitForLines(listener, delayMillis, 20);\n            assertEquals(1, lines.size(), \"1 line count\");\n            assertEquals(\"Line one\", lines.get(0), \"1 line 1\");\n            listener.clear();\n        }\n    }\n\n    private void createFile(final File file, final long size) throws Exception {\n        assertTrue(file.getParentFile().exists(), () -> \"Cannot create file \" + file + \" as the parent directory does not exist\");\n        try (BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(file.toPath()))) {\n            TestUtils.generateTestData(output, size);\n        }\n\n        RandomAccessFile reader = null;\n        try {\n            while (true) {\n                try {\n                    reader = RandomAccessFileMode.READ_ONLY.create(file);\n                    break;\n                } catch (final FileNotFoundException e) {\n                    TestUtils.sleepQuietly(200L);\n                }\n            }\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n        assertTrue(file.exists());\n        assertEquals(size, file.length());\n    }\n\n    private void append(final File file, final String... lines) throws Exception {\n        try (Writer writer = Files.newBufferedWriter(file.toPath(), StandardOpenOption.APPEND)) {\n            for (final String line : lines) {\n                writer.write(line + \"\n\");\n            }\n        }\n    }\n\n    private List<String> waitForLines(final TestTailerListener listener, final long minDelay, final int count) {\n        for (int i = 0; i < count; i++) {\n            TestUtils.sleep(minDelay);\n            final List<String> lines = listener.getLines();\n            if (lines.size() > 0) {\n                return lines;\n            }\n        }\n        fail(\"Waiting for TestTailerListener.getLines() timed out after \" + count * minDelay + \" ms\");\n        return null; // unreachable\n    }\n}",
      "method_signature": "testTailerReissueOnTouch()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 21023,
    "output_tokens": 4559,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1094,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]`, then write a test method annotated with `@Test` that declares it throws `IOException` and executes the following logic within a try-with-resources block: invoke the static factory method `wrap` on `ByteArraySeekableByteChannel` passing `testData` as the argument, assigning the returned `ByteArraySeekableByteChannel` instance to variable `c`, then immediately invoke `position` on `c` with the argument `testData.length` to set the channel's position to the end of the data, followed by invoking `truncate` on `c` with the long literal `4L` to reduce the channel size, after which assert using `assertEquals` that invoking `position()` on `c` returns `4L`, and subsequently assert using `assertEquals` that invoking `size()` on `c` also returns `4L`, ensuring the try-with-resources automatically closes the channel upon block exit. After the test method completes, define a teardown method that invokes `assertArrayEquals` with two arguments: the first being the result of calling `getBytes(StandardCharsets.UTF_8)` on the string literal `\"Some data\"`, and the second being the field `testData`, verifying that the test data remains unmodified. The test uses JUnit 5 Assertions with method-level annotation `@Test` and no class-level annotations.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldSetProperPositionOnTruncate()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    private void teardown() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n\n    @Test\n    public void testTruncate() throws IOException {\n        try (final ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n            c.position(testData.length);\n            c.truncate(4L);\n            assertEquals(4L, c.position());\n            assertEquals(4L, c.size());\n        }\n        teardown();\n    }\n}",
      "method_signature": "testShouldSetProperPositionOnTruncate()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.6667,
      "callable_recall": 1.0,
      "callable_precision": 0.7,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 27820,
    "output_tokens": 5949,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1095,
      "description": "Define a test method that validates truncating a seekable byte channel to its current size preserves both the channel's size and content without modification. Initialize a static byte array field containing test data that will be shared across test methods. Within the test method, wrap this test data in a ByteArraySeekableByteChannel instance using a try-with-resources block to ensure proper cleanup. Upon channel creation, verify that the channel's size matches the original test data length, then invoke the truncate operation with the current size as the parameter to confirm no-op behavior. After truncation, assert that the channel's size remains unchanged and equal to the original data length. Allocate a ByteBuffer with capacity matching the test data length, then read the entire channel content into this buffer and verify that the number of bytes read equals the expected data length. Extract the buffer's underlying array and assert that it matches the original test data byte-for-byte to confirm content integrity. After the try-with-resources block completes and the channel is automatically closed, execute a teardown method that validates the static test data array has not been modified by asserting it still contains the expected byte sequence, ensuring the read-only nature of the test operation. JUnit 5.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateToCurrentSizeDoesntChangeAnything()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTruncateNoOpTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests that truncating a {@link ByteArraySeekableByteChannel} to its current size is a no-op.\n */\npublic class ByteArraySeekableByteChannelTruncateNoOpTest {\n\n    private static final byte[] TEST_DATA = \"File content that will be used for testing.\".getBytes(StandardCharsets.UTF_8);\n    private static final byte[] ORIGINAL_TEST_DATA = Arrays.copyOf(TEST_DATA, TEST_DATA.length);\n\n    /**\n     * Validates that the static test data array has not been modified by the test execution,\n     * ensuring the read-only nature of the operations tested.\n     */\n    private void validateTestDataHasNotBeenModified() {\n        assertArrayEquals(ORIGINAL_TEST_DATA, TEST_DATA, \"The original test data should not be modified.\");\n    }\n\n    /**\n     * Tests that calling truncate with the channel's current size does not change the channel's\n     * size or content.\n     *\n     * @throws IOException if an I/O error occurs.\n     */\n    @Test\n    public void testTruncateToCurrentSizeIsNoOp() throws IOException {\n        try (final ByteArraySeekableByteChannel channel = new ByteArraySeekableByteChannel(TEST_DATA)) {\n            // Pre-check: Verify the initial size matches the test data length.\n            assertEquals(TEST_DATA.length, channel.size(), \"Initial channel size should match test data length.\");\n\n            // Action: Truncate the channel to its current size.\n            channel.truncate(channel.size());\n\n            // Post-check 1: Assert that the channel's size remains unchanged.\n            assertEquals(TEST_DATA.length, channel.size(), \"Channel size should remain unchanged after truncating to current size.\");\n\n            // Post-check 2: Verify the channel's content is still intact.\n            final ByteBuffer buffer = ByteBuffer.allocate(TEST_DATA.length);\n            final int bytesRead = channel.read(buffer);\n\n            assertEquals(TEST_DATA.length, bytesRead, \"Should read the entire content of the channel.\");\n            assertArrayEquals(TEST_DATA, buffer.array(), \"Channel content should not be modified.\");\n        }\n\n        // Teardown validation: Ensure the original byte array was not altered.\n        validateTestDataHasNotBeenModified();\n    }\n}",
      "method_signature": "testTruncateToCurrentSizeDoesntChangeAnything()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22375,
    "output_tokens": 7554,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1100,
      "description": "Define a test method that validates the behavior of a Seekable Byte Channel when truncating to a size smaller than the current position, ensuring the position is adjusted to match the new size. Initialize a static byte array containing test data at the class level to serve as the backing store for the channel. Within the test method, wrap this byte array in a Seekable Byte Channel instance using the factory method, establishing a try-with-resources block to ensure proper cleanup. Advance the channel's position to twice the length of the test data array, simulating a scenario where the position exceeds the intended truncation size. Invoke the truncate operation on the channel, passing the original test data length as the target size. Assert that the channel's size equals the test data length, confirming the truncation occurred correctly. Assert that the channel's position has been adjusted to match the test data length, verifying that the position was moved back when it exceeded the new size boundary. Upon exiting the try-with-resources block, the channel is automatically closed. In the teardown phase, validate that the original test data array remains unmodified by comparing it against the expected byte sequence, ensuring the test did not inadvertently alter the shared test fixture. This test uses JUnit 5 for the testing framework and standard JUnit assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateMovesPositionWhenNotResizingButPositionBiggerThanSize()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.SeekableByteChannelsTest",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.channels.SeekableByteChannel;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link SeekableByteChannels}.\n */\npublic class SeekableByteChannelsTest {\n\n    private static final byte[] TEST_DATA = { 'F', 'o', 'o', 'B', 'a', 'r' };\n    private static final byte[] ORIGINAL_TEST_DATA = { 'F', 'o', 'o', 'B', 'a', 'r' };\n\n    @Test\n    public void testTruncateToSmallerSizeThanPosition() throws IOException {\n        // Initializes a SeekableByteChannel from a byte array using a factory method.\n        try (final SeekableByteChannel channel = SeekableByteChannels.of(TEST_DATA)) {\n            // Advances the position beyond the channel's current size.\n            final long position = TEST_DATA.length * 2;\n            channel.position(position);\n\n            // Truncates the channel to a size smaller than the current position.\n            final long newSize = TEST_DATA.length;\n            channel.truncate(newSize);\n\n            // Asserts that the channel's size is updated to the new truncated size.\n            assertEquals(newSize, channel.size());\n            // Asserts that the position is adjusted to the new size when truncation occurs.\n            assertEquals(newSize, channel.position());\n        }\n        // Validates that the original byte array remains unmodified after the test.\n        assertArrayEquals(ORIGINAL_TEST_DATA, TEST_DATA);\n    }\n}",
      "method_signature": "testTruncateMovesPositionWhenNotResizingButPositionBiggerThanSize()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 43433,
    "output_tokens": 6676,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1103,
      "description": "Define a test method annotated with `@Test` that declares it throws `IOException`, then within a try-with-resources statement invoke `getOriginRo()` (which returns an `AbstractOrigin<CharSequence, AbstractOrigin.CharSequenceOrigin>`) and immediately chain `.getReader(null)` passing the literal `null` as the charset argument, assigning the returned `Reader` to a variable named `reader`, and inside the try block first invoke `assertNotNull(reader)` to verify the reader is not null, then invoke `assertEquals` passing two arguments: the first obtained by calling `getFixtureStringFromFile()` (a getter that internally calls `IOUtils.resourceToString` with a resource path, a charset, and returns a `String`), and the second obtained by invoking the static method `IOUtils.toString(reader)` which reads the reader's content into a `String`, thereby asserting that the reader's content matches the expected fixture string loaded from the resource file, with the try-with-resources ensuring the reader is closed automatically upon block exit. The test uses JUnit 5 Assertions (`assertNotNull`, `assertEquals`) and relies on the `IOUtils` utility class from Apache Commons IO for string conversion.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.build.CharSequenceOriginTest",
      "method_signature": "testGetReaderIgnoreCharsetNull()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.build.AbstractOriginGetReaderTest",
      "code": "package org.apache.commons.io.build;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.nio.charset.StandardCharsets;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.build.AbstractOrigin.CharSequenceOrigin;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link AbstractOrigin}.\n */\npublic class AbstractOriginGetReaderTest {\n\n    private String getFixtureStringFromFile() {\n        return \"test fixture string\";\n    }\n\n    private AbstractOrigin<CharSequence, CharSequenceOrigin> getOriginRo() {\n        return new AbstractOrigin<CharSequence, CharSequenceOrigin>(getFixtureStringFromFile()) {\n            @Override\n            public InputStream getInputStream() throws IOException {\n                return new ByteArrayInputStream(getOrigin().toString().getBytes(StandardCharsets.UTF_8));\n            }\n        };\n    }\n\n    @Test\n    public void testGetReader() throws IOException {\n        try (final Reader reader = getOriginRo().getReader(null)) {\n            assertNotNull(reader);\n            assertEquals(getFixtureStringFromFile(), IOUtils.toString(reader));\n        }\n    }\n\n}",
      "method_signature": "testGetReaderIgnoreCharsetNull()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 30288,
    "output_tokens": 8936,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1104,
      "description": "Create a test case to validate that when a data stream is positioned beyond its current content boundary and then resized to match its original capacity without actual reduction, the system correctly adjusts the reading position to align with the new boundary. Begin by establishing a data stream initialized with sample content, then advance the current reading position to twice the length of the available content, simulating a scenario where the position has moved far beyond the data boundary. Next, instruct the system to resize the stream to its original content length, which in this case does not actually reduce the size but serves as a boundary enforcement operation. After this operation, verify that the stream maintains its original content length and confirm that the reading position has been automatically adjusted to match the content boundary rather than remaining at the invalid position beyond the data limits. Once the validation is complete, ensure the original sample content remains unmodified to confirm the operation only affected positional tracking. The test relies on JUnit 5 for execution and uses standard equality assertions to verify both the content boundary and the adjusted reading position match the expected values.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateMovesPositionWhenNotResizingButPositionBiggerThanSize()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22138,
    "output_tokens": 13596,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1106,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]`, initialized with the byte array representation of the string literal `\"Some data\"` using `StandardCharsets.UTF_8` encoding. Write a test method annotated with `@Test` that declares it throws `Exception`, and within a try-with-resources block, declare a variable `c` of type `SeekableByteChannel` initialized by invoking the static method `ByteArraySeekableByteChannel.wrap(testData)` to wrap the test data array. Immediately invoke `position` on `c` with the argument `2 * testData.length` to set the channel position to twice the length of the test data array, then invoke `truncate` on `c` with the argument `testData.length` to truncate the channel to the original data length. Following truncation, assert that invoking `size()` on `c` returns a value equal to `testData.length` using `assertEquals(testData.length, c.size())`, and immediately after, assert that invoking `position()` on `c` returns a value equal to `testData.length` using `assertEquals(testData.length, c.position())` to verify the position was adjusted to match the new size. Upon completion of the test method, define a teardown method annotated with `@AfterEach` that invokes `assertArrayEquals` with the first argument being the byte array obtained by calling `getBytes(StandardCharsets.UTF_8)` on the string literal `\"Some data\"` and the second argument being `testData` to verify the test data array remains unmodified. The test uses JUnit 5 Assertions with method-level annotation `@Test` and teardown annotation `@AfterEach`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateMovesPositionWhenNotResizingButPositionBiggerThanSize()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testTruncate() throws Exception {\n        try (SeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n            c.position(2 * testData.length);\n            c.truncate(testData.length);\n            assertEquals(testData.length, c.size());\n            assertEquals(testData.length, c.position());\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n}",
      "method_signature": "testTruncateMovesPositionWhenNotResizingButPositionBiggerThanSize()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23197,
    "output_tokens": 2115,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1111,
      "description": "Create a test case to validate that the byte channel system correctly signals the end of available content when attempting to read from a position beyond the stored data boundary. Begin by wrapping existing content within a channel for reading operations. Prepare a buffer capable of holding the full amount of available content, then advance the reading position to a location beyond the end of the stored data. Attempt to retrieve content from this position and verify that the operation returns an end-of-content indicator without advancing the buffer's reading position, confirming that no data was transferred. Perform a second read attempt from the same position and ensure the system consistently signals the end-of-content condition again, demonstrating reliable behavior when accessing positions beyond the data boundary. After completing the validation, confirm that the original content remains unchanged to ensure the reading operations did not inadvertently modify the stored data. Use JUnit 5 as the testing framework with standard equality assertions to verify the expected outcomes and end-of-content signals.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldSignalEOFWhenPositionAtTheEnd()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.SeekableByteChannelBuilderTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link SeekableByteChannelBuilder}.\n */\npublic class SeekableByteChannelBuilderTest {\n\n    @Test\n    public void testReadFromPositionBeyondEof() throws IOException {\n        final byte[] content = \"test data\".getBytes(StandardCharsets.UTF_8);\n\n        try (final SeekableByteChannel channel = new SeekableByteChannelBuilder().setByteArray(content).get()) {\n            final int contentSize = content.length;\n            final ByteBuffer buffer = ByteBuffer.allocate(contentSize);\n\n            // Position beyond the end of the stored data\n            channel.position(contentSize + 1);\n\n            // Attempt to read and verify it returns an end-of-content indicator\n            final int firstRead = channel.read(buffer);\n            assertEquals(-1, firstRead, \"Reading from a position beyond the data boundary should return an end-of-content indicator.\");\n            assertEquals(0, buffer.position(), \"Buffer position should not advance when no data is transferred.\");\n\n            // Attempt a second read to ensure consistent behavior\n            final int secondRead = channel.read(buffer);\n            assertEquals(-1, secondRead, \"Subsequent reads from beyond the data boundary should consistently return an end-of-content indicator.\");\n\n            // Confirm that the original content remains unchanged\n            channel.position(0);\n            final ByteBuffer verificationBuffer = ByteBuffer.allocate(contentSize);\n            int totalBytesRead = 0;\n            while (verificationBuffer.hasRemaining()) {\n                final int bytesRead = channel.read(verificationBuffer);\n                if (bytesRead == -1) {\n                    break;\n                }\n                totalBytesRead += bytesRead;\n            }\n\n            assertEquals(contentSize, totalBytesRead, \"Should be able to read the entire original content after seeking.\");\n            assertArrayEquals(content, verificationBuffer.array(), \"Reading operations should not modify the stored data.\");\n        }\n    }\n}",
      "method_signature": "testShouldSignalEOFWhenPositionAtTheEnd()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 27677,
    "output_tokens": 6605,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1112,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]`, initialized with the byte array representation of the string literal `\"Some data\"` using `StandardCharsets.UTF_8` encoding. Write a test method annotated with `@Test` that declares it throws `Exception` and begins by opening a try-with-resources block where you invoke the static method `wrap` on class `ByteArraySeekableByteChannel` passing `testData` as the argument, assigning the returned `SeekableByteChannel` instance to variable `c`. Within the try block, immediately assert using `assertEquals` that the result of invoking `size()` on `c` equals `testData.length`, then invoke `truncate` on `c` passing `testData.length` as the argument, and assert again using `assertEquals` that invoking `size()` on `c` still equals `testData.length`. Next, create a `ByteBuffer` by calling `ByteBuffer.allocate` with argument `testData.length` and assign it to variable `readBuffer`, then assert using `assertEquals` that invoking `read` on `c` with argument `readBuffer` returns a value equal to `testData.length`. Finally, assert using `assertArrayEquals` that `testData` equals the result of calling `Arrays.copyOf` with arguments `readBuffer.array()` and `testData.length`, ensuring the read data matches the original test data exactly. After the test method completes, define a teardown method annotated with `@AfterEach` that invokes `assertArrayEquals` to verify that `testData` still equals the byte array obtained by calling `getBytes(StandardCharsets.UTF_8)` on the string literal `\"Some data\"`, confirming the data remains unmodified. The test uses JUnit 5 Assertions with method-level annotation `@Test` and teardown annotation `@AfterEach`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateToCurrentSizeDoesntChangeAnything()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @AfterEach\n    public void tearDown() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData, \"testData should not be modified\");\n    }\n\n    @Test\n    public void testTruncateDoesNotModifyArray() throws Exception {\n        try (final SeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n            assertEquals(testData.length, c.size());\n            c.truncate(testData.length);\n            assertEquals(testData.length, c.size());\n\n            final ByteBuffer readBuffer = ByteBuffer.allocate(testData.length);\n            assertEquals(testData.length, c.read(readBuffer));\n            assertArrayEquals(testData, Arrays.copyOf(readBuffer.array(), testData.length));\n        }\n    }\n}",
      "method_signature": "testTruncateToCurrentSizeDoesntChangeAnything()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 2,
          "run_shell_command": 4,
          "read_file": 3,
          "replace": 4
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 257799,
    "output_tokens": 14549,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1114,
      "description": "Create a test case to validate that the system correctly manages and reports the current reading position within a data stream under various positioning scenarios. Begin by establishing a stream containing predefined content, then instruct the system to move the reading position to an intermediate location within the available content and confirm the system accurately reports this new position. Next, advance the reading position to exactly the end of the available content and verify the system confirms the position matches the total content size. Subsequently, attempt to move the reading position beyond the end of the available content and ensure the system accepts and accurately reports this extended position even though it exceeds the current content boundary. After completing these positioning operations, verify that the original content remains unmodified to confirm the positioning actions did not alter the underlying data. Once all validations are complete, release any held resources to ensure proper cleanup. Use JUnit 5 as the testing framework with standard equality assertions to verify all reported positions match their expected values.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldSetProperPosition()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IORandomAccessFileTest1",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests for {@link IORandomAccessFile}.\n */\npublic class IORandomAccessFileTest1 {\n\n    @Test\n    public void testPositionManagement(@TempDir final Path tempDir) throws IOException {\n        final File testFile = tempDir.resolve(\"test-position.txt\").toFile();\n        final String fileContent = \"Test content for positioning.\";\n        FileUtils.writeStringToFile(testFile, fileContent, StandardCharsets.UTF_8);\n\n        try (final IORandomAccessFile randomAccessFile = new IORandomAccessFile(testFile, \"r\")) {\n            // Move to an intermediate position and verify\n            final long intermediatePosition = 10;\n            randomAccessFile.seek(intermediatePosition);\n            assertEquals(intermediatePosition, randomAccessFile.getFilePointer());\n\n            // Advance to the end of the content and verify\n            final long endOfContentPosition = fileContent.length();\n            randomAccessFile.seek(endOfContentPosition);\n            assertEquals(endOfContentPosition, randomAccessFile.getFilePointer());\n\n            // Move beyond the end of the content and verify\n            final long beyondContentPosition = fileContent.length() + 5;\n            randomAccessFile.seek(beyondContentPosition);\n            assertEquals(beyondContentPosition, randomAccessFile.getFilePointer());\n        }\n\n        // Verify content remains unmodified after positioning operations\n        final String currentContent = FileUtils.readFileToString(testFile, StandardCharsets.UTF_8);\n        assertEquals(fileContent, currentContent);\n    }\n}",
      "method_signature": "testShouldSetProperPosition()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.75,
      "callable_recall": 0.2727,
      "callable_precision": 0.1765,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22435,
    "output_tokens": 7850,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1115,
      "description": "Create a test case to validate that the system correctly handles write operations when the write position has been moved forward from the beginning of a data channel. Begin by establishing a channel initialized with a known set of reference data, then advance the write position to a specific offset within the channel. After repositioning, write the same reference data again at this new position, which should extend the channel's total capacity. Verify that the write operation reports the correct number of bytes written, then confirm the channel's contents match the expected outcome where the initial portion remains unchanged up to the offset, followed by the newly written data appended thereafter. Additionally, ensure the channel's current position has advanced to reflect the total bytes written from the offset point. Validate using JUnit 5 with standard equality assertions to confirm both the write count accuracy and the final data structure integrity, and verify the position advancement using numeric equality checks.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldWriteDataProperlyAfterPositionSet()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ChannelWriteTest",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests for file channel write operations.\n */\npublic class ChannelWriteTest {\n\n    @TempDir\n    private Path tempDir;\n\n    /**\n     * Tests that writing to a channel after advancing the position correctly writes data at the new position,\n     * extends the file, and updates the position and size accordingly.\n     *\n     * @throws IOException if an I/O error occurs.\n     */\n    @Test\n    public void testWriteToChannelWithAdvancedPosition() throws IOException {\n        final byte[] referenceData = \"0123456789\".getBytes(StandardCharsets.UTF_8);\n        final int offset = 5;\n\n        final Path testFile = Files.createFile(tempDir.resolve(\"test.dat\"));\n\n        try (final FileChannel channel = FileChannel.open(testFile, StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n            // Initialize the channel with reference data.\n            channel.write(ByteBuffer.wrap(referenceData));\n\n            // Advance the write position to a specific offset.\n            channel.position(offset);\n\n            // Write the same reference data again at the new position.\n            final int bytesWritten = channel.write(ByteBuffer.wrap(referenceData));\n\n            // Verify the number of bytes written is correct.\n            assertEquals(referenceData.length, bytesWritten, \"The number of bytes written should match the data length.\");\n\n            // Verify the channel's current position is at the end of the newly written data.\n            final long expectedPosition = offset + referenceData.length;\n            assertEquals(expectedPosition, channel.position(), \"The channel position should be advanced to the end of the written data.\");\n\n            // Verify the total size of the channel has been extended.\n            assertEquals(expectedPosition, channel.size(), \"The channel size should be extended by the write operation.\");\n\n            // Verify the final contents of the channel.\n            final byte[] actualData = Files.readAllBytes(testFile);\n            final ByteBuffer expectedData = ByteBuffer.allocate((int) expectedPosition);\n            expectedData.put(referenceData, 0, offset); // Initial part of the data before the offset.\n            expectedData.put(referenceData); // The newly appended data.\n\n            assertArrayEquals(expectedData.array(), actualData, \"The final channel content does not match the expected data structure.\");\n        }\n    }\n}",
      "method_signature": "testShouldWriteDataProperlyAfterPositionSet()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.75,
      "callable_recall": 0.5,
      "callable_precision": 0.4,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 28498,
    "output_tokens": 7552,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1116,
      "description": "Define a test method that validates the position-setting behavior of a Byte Array Seekable Byte Channel by wrapping a pre-initialized byte array using the channel's static factory method, then immediately set the channel position to an offset of four bytes and capture the resulting position value, followed by setting the position to the exact length of the underlying data array and capturing that position, and finally set the position to one byte beyond the array length and capture that position as well. Assert that the first captured position equals the offset of four, then assert that the second captured position matches the channel's reported size, and assert that the third captured position equals the array length plus one to confirm that positioning beyond the current bounds is permitted. Upon completion of these verifications, close the channel resource using try-with-resources to ensure proper cleanup. In the teardown phase, verify that the underlying test data array remains unmodified by asserting its contents match the original byte representation of a known string, confirming that position operations do not alter the backing data. This test uses JUnit 5 for assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldSetProperPosition()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final String TEST_STRING = \"A piece of string\";\n    private static final byte[] TEST_BYTES = TEST_STRING.getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testSetPosition() throws IOException {\n        final byte[] data = TEST_BYTES.clone();\n        try (final ByteArraySeekableByteChannel channel = ByteArraySeekableByteChannel.wrap(data)) {\n            // Set position to an offset\n            final long pos1 = channel.position(4).position();\n            assertEquals(4, pos1, \"Position after setting to 4\");\n\n            // Set position to the end of the data\n            final long pos2 = channel.position(data.length).position();\n            assertEquals(channel.size(), pos2, \"Position after setting to length\");\n\n            // Set position beyond the end of the data\n            final long pos3 = channel.position(data.length + 1).position();\n            assertEquals(data.length + 1, pos3, \"Position after setting beyond length\");\n        }\n        // Verify that the underlying data is not modified\n        assertArrayEquals(TEST_BYTES, data, \"Underlying data should not be modified by position operations\");\n    }\n}",
      "method_signature": "testShouldSetProperPosition()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.75,
      "callable_recall": 1.0,
      "callable_precision": 0.8462,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 2,
          "write_file": 1,
          "run_shell_command": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 77004,
    "output_tokens": 2117,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1117,
      "description": "Define a test method that validates end-of-file signaling behavior when a seekable byte channel is positioned beyond its data boundary by first wrapping a pre-existing byte array into a ByteArraySeekableByteChannel instance within a try-with-resources block to ensure automatic closure, then allocating a ByteBuffer with capacity matching the test data length to serve as the read destination. Position the channel beyond the end of the available data by setting its position to one byte past the data length, then invoke the read operation on the channel with the allocated buffer and capture the returned read count. Assert that the buffer's position remains at zero, confirming no data was transferred, and verify that the read count equals negative one to signal EOF. Perform a second read operation on the same channel and buffer, asserting again that the result is negative one to confirm consistent EOF signaling on subsequent attempts. After the try-with-resources block completes and the channel is closed, execute a teardown step that validates the original test data array remains unmodified by comparing it against the expected byte sequence using an array equality assertion. This test uses JUnit 5 for test execution and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldSignalEOFWhenPositionAtTheEnd()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\n\nimport org.apache.commons.io.input.ByteArrayInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] TEST_DATA = { 0, 1, 2, 3, 4, 5 };\n\n    @Test\n    public void testEofOnSeekBeyondEndOfData() throws IOException {\n        final byte[] data = Arrays.copyOf(TEST_DATA, TEST_DATA.length);\n        final byte[] expectedData = Arrays.copyOf(data, data.length);\n\n        try (final ByteArraySeekableByteChannel channel = new ByteArraySeekableByteChannel(data)) {\n            final ByteBuffer buffer = ByteBuffer.allocate(data.length);\n\n            // Position channel beyond the end of the data\n            channel.position(data.length + 1);\n\n            // First read should signal EOF\n            final int readCount1 = channel.read(buffer);\n            assertEquals(0, buffer.position(), \"Buffer position should not change after reading past EOF.\");\n            assertEquals(-1, readCount1, \"Read count should be -1 for EOF.\");\n\n            // Subsequent read should also signal EOF\n            final int readCount2 = channel.read(buffer);\n            assertEquals(-1, readCount2, \"Subsequent read should also return -1 for EOF.\");\n        }\n\n        // Verify the original data array remains unmodified\n        assertArrayEquals(expectedData, data, \"The source byte array should not be modified.\");\n    }\n}",
      "method_signature": "testShouldSignalEOFWhenPositionAtTheEnd()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 17771,
    "output_tokens": 3017,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1118,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]` initialized with the byte array representation of the string literal `\"Some data\"` using `StandardCharsets.UTF_8` encoding. Write a test method annotated with `@Test` that declares it throws `IOException`, then within a try-with-resources block, invoke the static method `wrap` on `ByteArraySeekableByteChannel` passing `testData` as the argument and assign the returned `ByteArraySeekableByteChannel` instance to variable `c`. Inside the try block, allocate a `ByteBuffer` by calling `ByteBuffer.allocate` with argument `testData.length` and assign it to variable `readBuffer`, then invoke `position` on `c` with argument `testData.length + 1` to set the channel position beyond the end of the data. Next, invoke `read` on `c` passing `readBuffer` as the argument and assign the returned int value to variable `readCount`. Immediately assert that invoking `position()` on `readBuffer` returns long value `0L` using `assertEquals(0L, readBuffer.position())`, then assert that `readCount` equals int value `-1` using `assertEquals(-1, readCount)`, and finally assert that a second invocation of `read` on `c` with argument `readBuffer` also returns int value `-1` using `assertEquals(-1, c.read(readBuffer))`. After the try-with-resources block completes, define a teardown method that invokes `assertArrayEquals` with two arguments: the result of calling `getBytes(StandardCharsets.UTF_8)` on the string literal `\"Some data\"` and the field `testData`, verifying that the test data remains unmodified. The test uses JUnit 5 Assertions with method-level annotation `@Test` and no class-level annotations.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldSignalEOFWhenPositionAtTheEnd()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\n\nimport org.apache.commons.io.input.ByteArrayInputStream;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testReadPastEnd() throws IOException {\n        try (final ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n            final ByteBuffer readBuffer = ByteBuffer.allocate(testData.length);\n            c.position(testData.length + 1);\n            final int readCount = c.read(readBuffer);\n            assertEquals(0L, readBuffer.position());\n            assertEquals(-1, readCount);\n            assertEquals(-1, c.read(readBuffer));\n        }\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n}",
      "method_signature": "testShouldSignalEOFWhenPositionAtTheEnd()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 33326,
    "output_tokens": 4628,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1119,
      "description": "Define a test method that validates the behavior of the Byte Array Seekable Byte Channel when positioning beyond valid boundaries and when attempting operations at those invalid positions. Within a try-with-resources block, instantiate a new Byte Array Seekable Byte Channel and allocate a single-byte buffer. Write the buffer to the channel to advance its position, then verify the position equals one. Reposition the channel to one byte beyond its current size and confirm the new position matches this out-of-bounds value, then attempt a read operation and assert it returns negative one to indicate end-of-stream. Next, reposition the channel to a value exceeding the maximum integer value by one and verify the position reflects this extremely large offset, then perform another read operation and confirm it also returns negative one. Having established the channel at this invalid position, attempt a write operation and validate that an I/O error is thrown due to the position being beyond the writable range. To verify that negative positions are rejected as illegal input, invoke the position method with negative one and assert an illegal argument error occurs, then repeat this validation with the minimum integer value and the minimum long value to ensure all negative inputs are consistently rejected. After the channel is automatically closed by the try-with-resources construct, execute a teardown method that verifies the static test data byte array remains unmodified by comparing it against its original UTF-8 encoded string value. JUnit and standard assertion libraries.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testThrowWhenSettingIncorrectPosition()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final String TEST_STRING = \"test\";\n    private static final byte[] TEST_DATA = TEST_STRING.getBytes(StandardCharsets.UTF_8);\n\n    @AfterEach\n    public void tearDown() {\n        // Verifies the static test data byte array remains unmodified.\n        assertArrayEquals(TEST_STRING.getBytes(StandardCharsets.UTF_8), TEST_DATA);\n    }\n\n    @Test\n    public void testPositioningBeyondBounds() throws IOException {\n        try (final ByteArraySeekableByteChannel channel = new ByteArraySeekableByteChannel(TEST_DATA)) {\n            final ByteBuffer buffer = ByteBuffer.allocate(1);\n            channel.write(buffer);\n            assertEquals(1, channel.position());\n\n            // Position beyond current size\n            final long positionBeyondSize = channel.size() + 1;\n            channel.position(positionBeyondSize);\n            assertEquals(positionBeyondSize, channel.position());\n            assertEquals(-1, channel.read(buffer));\n\n            // Position beyond Integer.MAX_VALUE\n            final long positionBeyondIntMax = (long) Integer.MAX_VALUE + 1L;\n            channel.position(positionBeyondIntMax);\n            assertEquals(positionBeyondIntMax, channel.position());\n            assertEquals(-1, channel.read(buffer));\n\n            // Writing at this invalid position should fail\n            assertThrows(IOException.class, () -> channel.write(ByteBuffer.wrap(new byte[1])));\n\n            // Negative positions should be rejected\n            assertThrows(IllegalArgumentException.class, () -> channel.position(-1L));\n            assertThrows(IllegalArgumentException.class, () -> channel.position(Integer.MIN_VALUE));\n            assertThrows(IllegalArgumentException.class, () -> channel.position(Long.MIN_VALUE));\n        }\n    }\n}",
      "method_signature": "testThrowWhenSettingIncorrectPosition()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 60597,
    "output_tokens": 3490,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1120,
      "description": "Create a test case to validate that the system correctly reduces content to a specified length when instructed to truncate, ensuring that only the desired portion of the original data remains accessible. Begin by establishing a scenario where the system manages a segment of textual content, then command the system to reduce this content to retain only the first four characters. After the truncation operation completes, retrieve the remaining content from the system and verify that it matches the expected shortened text, confirming that the system preserved exactly the first four characters while discarding everything beyond that point. Once the validation confirms the content was properly truncated, ensure the system releases any resources associated with managing this content segment. Use JUnit 5 for the testing framework and standard equality assertions to verify the truncated content matches the expected business outcome.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldTruncateContentsProperly()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.StringBuilderWriterTruncateTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.lang.StringBuilder;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests that the system correctly reduces content to a specified length.\n */\npublic class StringBuilderWriterTruncateTest {\n\n    @Test\n    public void testTruncate() {\n        final String originalContent = \"This is the original content.\";\n        final int truncateLength = 4;\n        final String expectedContent = \"This\";\n\n        try (final StringBuilderWriter writer = new StringBuilderWriter()) {\n            writer.write(originalContent);\n\n            final StringBuilder builder = writer.getBuilder();\n            builder.setLength(truncateLength);\n\n            final String resultContent = writer.toString();\n            assertEquals(expectedContent, resultContent, \"The content should be truncated to the first four characters.\");\n        }\n    }\n}",
      "method_signature": "testShouldTruncateContentsProperly()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.1429,
      "callable_precision": 0.1667,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 28830,
    "output_tokens": 3514,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1122,
      "description": "Define a test method that validates the truncation behavior of a Byte Array Seekable Byte Channel by first wrapping a static byte array containing UTF-8 encoded text data using the channel's factory method, then invoking the truncate operation with a specified byte count to reduce the channel's content size. Upon truncation, retrieve the underlying byte array from the channel and copy only the portion corresponding to the channel's current size to create a trimmed byte array. Convert this trimmed byte array to a UTF-8 string and assert that it matches the expected truncated text value, confirming that the channel correctly discarded bytes beyond the truncation point. After the test completes, implement a teardown method that verifies the original static test data remains unmodified by asserting its contents still match the expected UTF-8 encoded byte sequence, ensuring read operations have not corrupted the shared test fixture. The test leverages JUnit 5 for test execution and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldTruncateContentsProperly()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\n\nimport org.apache.commons.io.input.ByteArraySeekableByteChannel;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] TEST_DATA = \"Hello, World!\".getBytes(StandardCharsets.UTF_8);\n    private static final byte[] ORIGINAL_TEST_DATA = TEST_DATA.clone();\n\n    @AfterEach\n    public void tearDown() {\n        assertArrayEquals(ORIGINAL_TEST_DATA, TEST_DATA, \"Original test data should not be modified\");\n    }\n\n    @Test\n    public void testTruncate() throws IOException {\n        final String expectedText = \"Hello\";\n        final int truncationSize = expectedText.getBytes(StandardCharsets.UTF_8).length;\n\n        try (final ByteArraySeekableByteChannel channel = new ByteArraySeekableByteChannel(TEST_DATA)) {\n            channel.truncate(truncationSize);\n            assertEquals(truncationSize, channel.size(), \"Channel size should match the truncation size.\");\n\n            final byte[] underlyingArray = channel.array();\n            final byte[] trimmedArray = Arrays.copyOf(underlyingArray, (int) channel.size());\n            final String truncatedString = new String(trimmedArray, StandardCharsets.UTF_8);\n\n            assertEquals(expectedText, truncatedString, \"Truncated string should match the expected value.\");\n        }\n    }\n}",
      "method_signature": "testShouldTruncateContentsProperly()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20010,
    "output_tokens": 5355,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1128,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]` (value not used in this test method), then write a test method annotated with `@Test` that declares `throws IOException` and begins by instantiating a `ByteArraySeekableByteChannel` using the no-argument constructor, assigning it to variable `c` within a try-with-resources statement, then inside the try block allocate a `ByteBuffer` by calling `ByteBuffer.allocate(1)` and assign the result to variable `buffer`, invoke `write` on `c` passing `buffer` as the argument, immediately assert using `assertEquals` that invoking `position()` on `c` returns the integer value `1`, then invoke `position` on `c` passing the expression `c.size() + 1` as the argument to set the position beyond the current size, assert using `assertEquals` that invoking `position()` on `c` now returns the value equal to `c.size() + 1`, invoke `read` on `c` passing `buffer` and assert using `assertEquals` that the return value is `-1`, next invoke `position` on `c` passing the long literal `Integer.MAX_VALUE + 1L` as the argument, assert using `assertEquals` that invoking `position()` on `c` returns the long value `Integer.MAX_VALUE + 1L`, invoke `read` on `c` passing `buffer` and assert using `assertEquals` that the return value is `-1`, then use `assertThrows` expecting `IOException.class` to be thrown when invoking `write` on `c` with `buffer` as the argument within a lambda expression, use `assertThrows` expecting `IllegalArgumentException.class` to be thrown when invoking `position` on `c` with the integer literal `-1` within a lambda expression, use `assertThrows` expecting `IllegalArgumentException.class` to be thrown when invoking `position` on `c` with `Integer.MIN_VALUE` within a lambda expression, and finally use `assertThrows` expecting `IllegalArgumentException.class` to be thrown when invoking `position` on `c` with `Long.MIN_VALUE` within a lambda expression, and after the try-with-resources block completes define a teardown method that invokes `assertArrayEquals` comparing the result of calling `getBytes(StandardCharsets.UTF_8)` on the string literal `\"Some data\"` against the field `testData`. The test uses JUnit 5 Assertions with method-level annotation `@Test`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testThrowWhenSettingIncorrectPosition()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testBehavior() throws IOException {\n        try (ByteArraySeekableByteChannel c = new ByteArraySeekableByteChannel()) {\n            final ByteBuffer buffer = ByteBuffer.allocate(1);\n            c.write(buffer);\n            assertEquals(1, c.position());\n\n            c.position(c.size() + 1);\n            assertEquals(c.size() + 1, c.position());\n            buffer.clear();\n            assertEquals(-1, c.read(buffer));\n\n            c.position(Integer.MAX_VALUE + 1L);\n            assertEquals(Integer.MAX_VALUE + 1L, c.position());\n            buffer.clear();\n            assertEquals(-1, c.read(buffer));\n\n            buffer.clear();\n            assertThrows(IOException.class, () -> c.write(buffer));\n\n            assertThrows(IllegalArgumentException.class, () -> c.position(-1));\n            assertThrows(IllegalArgumentException.class, () -> c.position(Integer.MIN_VALUE));\n            assertThrows(IllegalArgumentException.class, () -> c.position(Long.MIN_VALUE));\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    private void tearDown() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n}",
      "method_signature": "testThrowWhenSettingIncorrectPosition()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.875,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 24079,
    "output_tokens": 9049,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1129,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]`, then write a test method annotated with `@Test` that declares it throws `IOException` and executes the following logic within a try-with-resources block: invoke the static method `wrap` on `ByteArraySeekableByteChannel` passing `testData` as the argument and assign the returned `ByteArraySeekableByteChannel` instance to variable `c`. Within the try block, invoke `position` on `c` with the long literal `4L`, then immediately chain a call to `position()` with no arguments on the returned object, assigning the final long result to variable `posAtFour`. Next, invoke `position` on `c` with the integer expression `testData.length`, chain `position()` on the result, and assign the returned long value to variable `posAtTheEnd`. Then invoke `position` on `c` with the long expression `testData.length + 1L`, chain `position()` on the result, and assign the returned long to variable `posPastTheEnd`. After these assignments, assert using `assertEquals` that the expected value `4L` equals `posAtFour`, then assert using `assertEquals` that the result of invoking `size()` on `c` equals `posAtTheEnd`, and finally assert using `assertEquals` that the expected value `testData.length + 1L` equals `posPastTheEnd`. Define a teardown method that invokes `assertArrayEquals` with two arguments: the byte array obtained by calling `getBytes(StandardCharsets.UTF_8)` on the string literal `\"Some data\"` as the expected value, and `testData` as the actual value. The test uses JUnit 5 Assertions and is annotated with `@Test` at the method level, with no class-level annotations present.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldSetProperPosition()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testPosition() throws IOException {\n        try (final ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n            final long posAtFour = c.position(4L).position();\n            final long posAtTheEnd = c.position(testData.length).position();\n            final long posPastTheEnd = c.position(testData.length + 1L).position();\n\n            assertEquals(4L, posAtFour);\n            assertEquals(c.size(), posAtTheEnd);\n            assertEquals(testData.length + 1L, posPastTheEnd);\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n\n}",
      "method_signature": "testShouldSetProperPosition()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23330,
    "output_tokens": 3900,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1130,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]` initialized with the UTF-8 byte representation of the string literal `\"Some data\"` using `\"Some data\".getBytes(StandardCharsets.UTF_8)`. Write a test method annotated with `@Test` that declares it throws `ClosedChannelException`, and within a try-with-resources statement, invoke the static factory method `ByteArraySeekableByteChannel.wrap(testData)` to create a channel instance, assigning the result to variable `c` of type `ByteArraySeekableByteChannel`. Immediately invoke `truncate` on `c` with the long argument `4L`, then invoke `Arrays.copyOf` passing two arguments: the result of calling `c.array()` and the integer cast of `c.size()`, assigning the returned byte array to variable `bytes`. Construct a new `String` instance by passing `bytes` and `StandardCharsets.UTF_8` to the constructor, then assert using `assertEquals` that this string equals the literal `\"Some\"`. After the test method completes, define a teardown method that invokes `assertArrayEquals` with two arguments: the byte array obtained by calling `\"Some data\".getBytes(StandardCharsets.UTF_8)` and the field `testData`, verifying that the original test data remains unmodified. The test uses JUnit 5 assertions with method-level annotation `@Test` and declares the checked exception `ClosedChannelException` in its signature.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldTruncateContentsProperly()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\n\nimport org.apache.commons.io.channels.ByteArraySeekableByteChannel;\nimport org.junit.jupiter.api.Test;\n\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testTruncate() throws ClosedChannelException {\n        try (final ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n            c.truncate(4L);\n            final byte[] bytes = Arrays.copyOf(c.array(), (int) c.size());\n            assertEquals(\"Some\", new String(bytes, StandardCharsets.UTF_8));\n        }\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n}",
      "method_signature": "testShouldTruncateContentsProperly()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.5,
      "callable_recall": 1.0,
      "callable_precision": 0.7778,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18987,
    "output_tokens": 4053,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1132,
      "description": "Create a test case to validate that the byte reading system correctly handles scenarios where the allocated receiving capacity exceeds the available content size, ensuring data integrity is maintained throughout the operation. Begin by establishing a byte reading channel initialized with a known set of content, then configure a receiving buffer with capacity intentionally larger than the content to be read, simulating a common real-world scenario where buffer sizes are conservatively allocated. Execute the read operation and verify that the system reports the exact count of bytes actually transferred, matching the original content size rather than the buffer capacity. Confirm that all content was accurately copied into the receiving buffer by comparing the transferred bytes against the original source material, ensuring no data corruption or loss occurred during the transfer. Verify that the reading position advanced correctly to reflect the amount of content consumed, positioning the channel at the end of the available data. After completing the validation, confirm that the original source content remains unmodified to ensure the reading operation was non-destructive. Use JUnit 5 for test execution with standard equality assertions to verify byte counts, array content comparisons to validate data integrity, and position checks to confirm proper state management.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldReadContentsWhenBiggerBufferSupplied()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.file.ChannelReadToExcessCapacityBufferTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests that a byte reading system correctly handles reading into a buffer\n * with capacity exceeding the available content size.\n */\npublic class ChannelReadToExcessCapacityBufferTest {\n\n    @Test\n    public void testReadToBufferWithExcessCapacity(@TempDir final Path tempDir) throws IOException {\n        final byte[] originalContent = \"This is the test content.\".getBytes(StandardCharsets.UTF_8);\n\n        final Path sourceFile = Files.createFile(tempDir.resolve(\"test_data.txt\"));\n        Files.write(sourceFile, originalContent);\n\n        // 1. Establish a byte reading channel initialized with the known content.\n        try (final SeekableByteChannel channel = Files.newByteChannel(sourceFile)) {\n            // 2. Configure a receiving buffer with a capacity larger than the content to be read.\n            final ByteBuffer receivingBuffer = ByteBuffer.allocate(originalContent.length + 100);\n\n            // 3. Execute the read operation.\n            final int bytesTransferred = channel.read(receivingBuffer);\n\n            // 4. Verify that the system reports the exact count of bytes actually transferred.\n            assertEquals(originalContent.length, bytesTransferred,\n                \"Should report transferring bytes equal to content size, not buffer capacity.\");\n\n            // 5. Confirm that all content was accurately copied into the receiving buffer.\n            receivingBuffer.flip();\n            final byte[] transferredBytes = new byte[receivingBuffer.remaining()];\n            receivingBuffer.get(transferredBytes);\n            assertArrayEquals(originalContent, transferredBytes,\n                \"Transferred data must maintain integrity and match the source content.\");\n\n            // 6. Verify that the reading position advanced correctly.\n            assertEquals(originalContent.length, channel.position(),\n                \"Channel position should advance to the end of the consumed data.\");\n        }\n\n        // 7. Confirm that the original source content remains unmodified.\n        final byte[] sourceContentAfterRead = Files.readAllBytes(sourceFile);\n        assertArrayEquals(originalContent, sourceContentAfterRead,\n            \"The read operation must be non-destructive to the source content.\");\n    }\n}",
      "method_signature": "testShouldReadContentsWhenBiggerBufferSupplied()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.75,
      "callable_recall": 0.4444,
      "callable_precision": 0.25,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 47675,
    "output_tokens": 8639,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1134,
      "description": "Define a test method that validates the read operation of a Byte Array Seekable Byte Channel when supplied with a buffer larger than the channel's data capacity by first wrapping a predefined byte array into a channel instance using the channel's static factory method, then allocating a ByteBuffer with capacity exceeding the test data length by one byte. Invoke the read method on the channel with the allocated buffer to populate it with the channel's contents, capturing the count of bytes read. Assert that the read count equals the original test data length to confirm the channel does not over-read beyond available data, then extract the underlying byte array from the buffer and copy only the portion corresponding to the test data length before asserting that this extracted segment matches the original test data byte-for-byte. Verify that the channel's current position equals the test data length to confirm the read operation advanced the position correctly. Ensure the channel resource is properly closed after the test completes. In the teardown phase, validate that the original test data byte array remains unmodified by asserting it still matches the expected byte sequence, confirming that read operations do not mutate the underlying data. This test uses JUnit for assertions and standard Java NIO components for buffer management.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldReadContentsWhenBiggerBufferSupplied()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14811,
    "output_tokens": 952,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1138,
      "description": "Create a test case to validate that the byte channel system correctly enforces size constraints when attempting to resize operations under various boundary conditions. Begin with an empty byte channel and prepare a minimal read buffer to verify channel state. First, attempt to resize the channel to a dimension larger than its current capacity and confirm the system indicates no data is available for reading. Next, attempt to resize the channel to an extremely large dimension beyond normal operating bounds and again verify the system correctly reports no available data. After confirming these boundary behaviors, validate that the system properly rejects invalid resize requests by attempting to resize using a negative dimension and ensuring the operation fails due to invalid input, then verify rejection when using the smallest possible negative dimension value, and finally confirm rejection when using the most extreme negative dimension value. Once all boundary validations are complete, release the channel resources. Use JUnit 5 for the testing framework with standard equality assertions to verify read results and exception assertions to confirm proper rejection of invalid resize operations.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testThrowWhenTruncatingToIncorrectSize()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteChannelSizeTest",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link SeekableByteChannel} size constraints, specifically with resize/truncate operations.\n */\npublic class ByteChannelSizeTest {\n\n    @Test\n    public void testResizeBoundaryConditions() throws IOException {\n        final Path tempFile = Files.createTempFile(\"test-channel\", \".bin\");\n        try (SeekableByteChannel channel = new SeekableByteChannelBuilder().setPath(tempFile).get()) {\n            final ByteBuffer readBuffer = ByteBuffer.allocate(1);\n\n            // 1. Start with an empty channel and verify initial state.\n            assertEquals(0, channel.size());\n\n            // 2. Attempt to resize larger than capacity and confirm no data is read.\n            channel.truncate(1024L);\n            assertEquals(0, channel.size());\n            assertEquals(-1, channel.read(readBuffer), \"Reading from an empty channel that was truncated to a larger size should yield no data.\");\n\n            // 3. Attempt to resize to an extremely large dimension and confirm no data is read.\n            channel.truncate(Long.MAX_VALUE);\n            assertEquals(0, channel.size());\n            assertEquals(-1, channel.read(readBuffer), \"Reading from an empty channel truncated to MAX_VALUE should yield no data.\");\n\n            // 4. Validate rejection of invalid resize requests with negative dimensions.\n            assertThrows(IllegalArgumentException.class, () -> channel.truncate(-1L), \"Resizing with a negative dimension should be rejected.\");\n\n            // 5. Verify rejection with the smallest possible (most extreme) negative dimension.\n            assertThrows(IllegalArgumentException.class, () -> channel.truncate(Long.MIN_VALUE), \"Resizing with the most extreme negative dimension should be rejected.\");\n\n        } finally {\n            Files.deleteIfExists(tempFile);\n        }\n    }\n}",
      "method_signature": "testThrowWhenTruncatingToIncorrectSize()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 30060,
    "output_tokens": 9118,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1140,
      "description": "Create a test case to validate that when a seekable data channel is positioned at an early location within its content and then the channel's total capacity is reduced to a size larger than the current position, the position marker remains unchanged at its original location. Begin by establishing a channel containing a predefined set of data, then move the reading position to the second unit of the content. After positioning, reduce the channel's overall capacity by removing one unit from the end, ensuring the new capacity is still greater than the current position. Verify that the channel's total size now reflects the reduced capacity and confirm that the position marker has remained at the second unit despite the capacity reduction. Once validation is complete, ensure the channel resources are properly released and confirm the original data remains unmodified to maintain test isolation. This validation uses JUnit 5 with standard equality assertions to verify both the adjusted capacity and the preserved position marker.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateDoesntChangeSmallPosition()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.SeekableByteChannelPositionAfterTruncateTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests that truncating a {@link SeekableByteChannel} does not affect the position if the new size is greater than\n * the position.\n */\npublic class SeekableByteChannelPositionAfterTruncateTest {\n\n    @Test\n    public void testPositionNotChangedByTruncate(@TempDir final Path tempDir) throws IOException {\n        final Path testFile = tempDir.resolve(\"test.bin\");\n        final byte[] originalData = { 'A', 'B', 'C', 'D', 'E' };\n        Files.write(testFile, originalData);\n\n        try (SeekableByteChannel channel = Files.newByteChannel(testFile, StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n            // Position the channel at the second unit of content (index 2).\n            final long position = 2;\n            channel.position(position);\n\n            // New size is larger than the current position.\n            final long newSize = originalData.length - 1;\n\n            // Truncate the channel.\n            channel.truncate(newSize);\n\n            // Verify the size is reduced.\n            assertEquals(newSize, channel.size(), \"Channel size should be reduced after truncation.\");\n            // Verify the position is unchanged.\n            assertEquals(position, channel.position(), \"Channel position should remain unchanged.\");\n        }\n    }\n}",
      "method_signature": "testTruncateDoesntChangeSmallPosition()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8571,
      "callable_precision": 0.6667,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 28211,
    "output_tokens": 6860,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1141,
      "description": "Create a test case to validate that the system enforces proper boundary conditions when repositioning the read/write cursor within a data channel, ensuring both acceptable and unacceptable cursor movements are handled correctly. Begin by establishing a fresh data channel and allocating a small buffer for operations, then write a single unit of data to advance the cursor position and confirm the cursor has moved to the expected location. Next, reposition the cursor beyond the current end of available data and verify the cursor accepts this new position, then attempt to read from this location and confirm the system signals no data is available. After this, move the cursor to a position far beyond normal operational limits and verify the system accepts this extreme position, confirm reading still indicates no available data, and ensure any attempt to write at this extreme position fails due to capacity constraints. Finally, validate the system properly rejects invalid cursor positions by attempting to set negative cursor positions using various negative boundary values and confirming each attempt is rejected as invalid input, then release the channel resources and verify the underlying test data remains unmodified throughout the validation process using standard equality assertions with JUnit 5.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testThrowWhenSettingIncorrectPosition()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IORandomAccessFileTest1",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Create a test case to validate that the system enforces proper boundary conditions when repositioning the read/write\n * cursor within a data channel, ensuring both acceptable and unacceptable cursor movements are handled correctly.\n */\npublic class IORandomAccessFileTest1 {\n\n    @TempDir\n    private Path tempDir;\n\n    @Test\n    public void testCursorBoundaryConditions() throws IOException {\n        final File testFile = Files.createTempFile(tempDir, \"test-channel\", \".dat\").toFile();\n        final byte[] singleUnit = { 1 };\n        final byte[] readBuffer = new byte[1];\n\n        // Begin by establishing a fresh data channel and allocating a small buffer for operations\n        try (final IORandomAccessFile channel = new IORandomAccessFile(testFile, \"rw\")) {\n            // Write a single unit of data to advance the cursor position\n            channel.write(singleUnit);\n            // and confirm the cursor has moved to the expected location\n            assertEquals(1, channel.getFilePointer());\n\n            // Next, reposition the cursor beyond the current end of available data\n            channel.seek(10);\n            // and verify the cursor accepts this new position\n            assertEquals(10, channel.getFilePointer());\n            // then attempt to read from this location and confirm the system signals no data is available\n            assertEquals(-1, channel.read(readBuffer));\n\n            // After this, move the cursor to a position far beyond normal operational limits\n            final long extremePosition = (long) Integer.MAX_VALUE * 2L;\n            channel.seek(extremePosition);\n            // and verify the system accepts this extreme position\n            assertEquals(extremePosition, channel.getFilePointer());\n            // confirm reading still indicates no available data\n            assertEquals(-1, channel.read(readBuffer));\n            // and ensure any attempt to write at this extreme position fails due to capacity constraints\n            assertThrows(IOException.class, () -> channel.write(singleUnit));\n\n            // Finally, validate the system properly rejects invalid cursor positions by attempting to set negative\n            // cursor positions\n            assertThrows(IOException.class, () -> channel.seek(-1));\n            assertThrows(IOException.class, () -> channel.seek(-100L));\n            assertThrows(IOException.class, () -> channel.seek(Long.MIN_VALUE));\n        }\n\n        // verify the underlying test data remains unmodified throughout the validation process\n        final byte[] actual = Files.readAllBytes(testFile.toPath());\n        assertArrayEquals(singleUnit, actual);\n    }\n}",
      "method_signature": "testThrowWhenSettingIncorrectPosition()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.9,
      "callable_recall": 0.5714,
      "callable_precision": 0.5217,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 39971,
    "output_tokens": 9039,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1142,
      "description": "Define a test method that validates the behavior of a Byte Array Seekable Byte Channel when truncating content to a size larger than the current position. Within a try-with-resources block, wrap a pre-existing byte array into a seekable byte channel instance using the channel's factory method, then advance the channel's position to a small offset near the beginning of the data. Invoke the truncate operation on the channel with a target size one byte smaller than the original data length, ensuring the truncation occurs beyond the current position. Immediately verify that the channel's size reflects the new truncated length by asserting the size matches the expected reduced value, then confirm that the position remains unchanged at its previously set offset by asserting the position value. Upon exiting the try-with-resources block, the channel closes automatically. In a separate teardown method that executes after the test, validate that the original test data array remains unmodified by asserting its contents match the expected byte sequence, confirming that the truncation operation did not corrupt the underlying data structure. This test uses JUnit 5 for the test framework and standard JUnit assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateDoesntChangeSmallPosition()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private final byte[] originalData = \"0123456789\".getBytes(StandardCharsets.UTF_8);\n    private final byte[] originalDataClone = originalData.clone();\n\n    @AfterEach\n    public void tearDown() {\n        // Validates that the original test data array remains unmodified.\n        assertArrayEquals(originalDataClone, originalData);\n    }\n\n    @Test\n    public void testTruncateToSizeLargerThanPosition() throws IOException {\n        try (final SeekableByteChannel channel = ByteArraySeekableByteChannel.wrap(originalData)) {\n            // Advance the channel's position\n            channel.position(2);\n\n            // Truncate to a size smaller than the original but larger than the current position\n            final long newSize = originalData.length - 1;\n            channel.truncate(newSize);\n\n            // Verify the size is the new truncated length\n            assertEquals(newSize, channel.size());\n            // Verify the position remains unchanged\n            assertEquals(2, channel.position());\n        }\n    }\n}",
      "method_signature": "testTruncateDoesntChangeSmallPosition()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 35111,
    "output_tokens": 3852,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1145,
      "description": "Define a test method that validates the truncation behavior of a Byte Array Seekable Byte Channel when invoked with various size parameters, including values that exceed current size, exceed integer limits, and fall into negative ranges. Initialize a new instance of the Byte Array Seekable Byte Channel within a try-with-resources block to ensure automatic closure, then allocate a ByteBuffer with capacity of one byte to serve as the read target throughout the test. Invoke the truncate method on the channel with a size parameter equal to the current channel size plus one, then immediately read from the channel into the buffer and assert that the read operation returns negative one to confirm end-of-stream behavior. Subsequently, invoke truncate again with a size parameter exceeding the maximum integer value by one, perform another read operation into the buffer, and assert that it also returns negative one. Following these boundary cases, validate that invoking truncate with negative one as the size parameter throws an IllegalArgumentException, then confirm the same exception is thrown when truncating with the minimum integer value, and finally verify that truncating with the minimum long value also produces an IllegalArgumentException. Upon completion of all truncation validations, allow the try-with-resources construct to automatically close the channel, then in the teardown phase, assert that the static test data byte array remains unmodified by comparing it against the expected UTF-8 encoded byte representation of the original string to ensure reading operations have not altered the shared test fixture. This test uses JUnit 5 for assertions and exception validation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testThrowWhenTruncatingToIncorrectSize()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] TEST_DATA = \"test data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testTruncateBehavior() throws IOException {\n        try (final ByteArraySeekableByteChannel channel = new ByteArraySeekableByteChannel(TEST_DATA)) {\n            final ByteBuffer buffer = ByteBuffer.allocate(1);\n\n            // Truncate with size larger than current size should not change anything.\n            // Reading from the end of the channel should result in EOF.\n            channel.truncate(channel.size() + 1);\n            channel.position(channel.size());\n            assertEquals(-1, channel.read(buffer));\n\n            // Reset buffer for the next read.\n            buffer.flip();\n\n            // Truncate with size larger than Integer.MAX_VALUE should not change anything.\n            channel.truncate((long) Integer.MAX_VALUE + 1L);\n            channel.position(channel.size());\n            assertEquals(-1, channel.read(buffer));\n\n            // Truncating with negative values should throw an exception.\n            assertThrows(IllegalArgumentException.class, () -> channel.truncate(-1L));\n            assertThrows(IllegalArgumentException.class, () -> channel.truncate(Integer.MIN_VALUE));\n            assertThrows(IllegalArgumentException.class, () -> channel.truncate(Long.MIN_VALUE));\n        }\n\n        // Verify that the original test data array has not been modified.\n        assertArrayEquals(\"test data\".getBytes(StandardCharsets.UTF_8), TEST_DATA);\n    }\n}",
      "method_signature": "testThrowWhenTruncatingToIncorrectSize()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 35570,
    "output_tokens": 6471,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1147,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]` (initialization not shown in test method context), then write a test method annotated with `@Test` that declares `throws IOException` and begins by opening a try-with-resources block that instantiates a `ByteArraySeekableByteChannel` using the no-argument constructor and assigns it to variable `c`. Within the try block, allocate a `ByteBuffer` by invoking `ByteBuffer.allocate(1)` and assign the result to variable `buffer`, then invoke `truncate` on `c` passing the argument computed by calling `c.size()` and adding integer `1` to it, immediately followed by invoking `c.read(buffer)` and asserting via `assertEquals` that the return value equals integer `-1`. Next, invoke `truncate` on `c` again, this time passing the long literal `Integer.MAX_VALUE + 1L`, then invoke `c.read(buffer)` once more and assert via `assertEquals` that the return value equals integer `-1`. After these read assertions, use `assertThrows` to verify that invoking `c.truncate(-1)` throws `IllegalArgumentException.class`, then use `assertThrows` again to verify that invoking `c.truncate(Integer.MIN_VALUE)` throws `IllegalArgumentException.class`, and finally use `assertThrows` a third time to verify that invoking `c.truncate(Long.MIN_VALUE)` throws `IllegalArgumentException.class`. Upon exiting the try-with-resources block, define a teardown method annotated with `@AfterEach` named `afterEach` that invokes `assertArrayEquals` passing the byte array obtained by calling `\"Some data\".getBytes(StandardCharsets.UTF_8)` as the first argument and the field `testData` as the second argument. The test uses JUnit 5 Assertions (`assertEquals`, `assertThrows`, `assertArrayEquals`) with no class-level annotations, method-level annotation `@Test`, and no mocking libraries.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testThrowWhenTruncatingToIncorrectSize()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @AfterEach\n    public void afterEach() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n\n    @Test\n    public void testTruncateToLargerSize() throws IOException {\n        try (final ByteArraySeekableByteChannel c = new ByteArraySeekableByteChannel()) {\n            final ByteBuffer buffer = ByteBuffer.allocate(1);\n            c.truncate(c.size() + 1);\n            assertEquals(-1, c.read(buffer));\n            c.truncate(Integer.MAX_VALUE + 1L);\n            assertEquals(-1, c.read(buffer));\n            assertThrows(IllegalArgumentException.class, () -> c.truncate(-1));\n            assertThrows(IllegalArgumentException.class, () -> c.truncate(Integer.MIN_VALUE));\n            assertThrows(IllegalArgumentException.class, () -> c.truncate(Long.MIN_VALUE));\n        }\n    }\n}",
      "method_signature": "testThrowWhenTruncatingToIncorrectSize()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 2,
          "run_shell_command": 3,
          "read_file": 2
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 128004,
    "output_tokens": 8247,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1148,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]` initialized with the byte array representation of the string literal `\"Some data\"` using `StandardCharsets.UTF_8` encoding. Write a test method annotated with `@Test` that declares it throws `IOException`, then open a try-with-resources block by invoking the static method `ByteArraySeekableByteChannel.wrap(testData)` and assign the returned `ByteArraySeekableByteChannel` instance to variable `c`. Within the try block, allocate a `ByteBuffer` by calling `ByteBuffer.allocate(testData.length + 1)` and assign it to variable `readBuffer`, then invoke `c.read(readBuffer)` and assign the returned int value to variable `readCount`. Assert that `readCount` equals `testData.length` using `assertEquals(testData.length, readCount)`, then assert array equality by calling `assertArrayEquals(testData, Arrays.copyOf(readBuffer.array(), testData.length))` where the second argument is constructed by invoking `readBuffer.array()` to obtain the backing byte array and passing it along with `testData.length` to `Arrays.copyOf`. Assert that the channel's position equals `testData.length` by calling `assertEquals(testData.length, c.position())`. After the test method completes, execute a teardown method that asserts array equality between the byte array obtained by calling `\"Some data\".getBytes(StandardCharsets.UTF_8)` and `testData` using `assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData)` to verify the data remains unmodified. The test uses JUnit 5 Assertions with method-level annotation `@Test`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldReadContentsWhenBiggerBufferSupplied()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\n\nimport org.apache.commons.io.channels.ByteArraySeekableByteChannel;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @AfterEach\n    public void tearDown() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n\n    @Test\n    public void testRead() throws IOException {\n        try (final ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n            final ByteBuffer readBuffer = ByteBuffer.allocate(testData.length + 1);\n            final int readCount = c.read(readBuffer);\n            assertEquals(testData.length, readCount);\n            assertArrayEquals(testData, Arrays.copyOf(readBuffer.array(), testData.length));\n            assertEquals(testData.length, c.position());\n        }\n    }\n}",
      "method_signature": "testShouldReadContentsWhenBiggerBufferSupplied()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 27982,
    "output_tokens": 2695,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1151,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]`, initialized with the byte array representation of the string literal `\"Some data\"` encoded using `StandardCharsets.UTF_8`. Write a test method annotated with `@Test` that declares it throws `Exception`, and within a try-with-resources statement, declare a variable `c` of type `SeekableByteChannel` initialized by invoking the static method `ByteArraySeekableByteChannel.wrap(testData)`. Immediately invoke `position(1)` on `c` to set the channel's position to `1`, then invoke `truncate(testData.length - 1)` on `c` to truncate the channel to a size equal to `testData.length - 1`. Assert that the size of the channel equals `testData.length - 1` by invoking `c.size()` and passing the result to `assertEquals(testData.length - 1, c.size())`, then assert that the position remains `1` by invoking `c.position()` and passing the result to `assertEquals(1, c.position())`. After the test method completes, define a teardown method that invokes `assertArrayEquals` with two arguments: the byte array obtained by calling `\"Some data\".getBytes(StandardCharsets.UTF_8)` and the field `testData`, verifying that the test data remains unmodified. The test uses JUnit 5 Assertions with method-level annotation `@Test`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateDoesntChangeSmallPosition()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testTruncate() throws Exception {\n        try (SeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n            c.position(1);\n            c.truncate(testData.length - 1);\n            assertEquals(testData.length - 1, c.size());\n            assertEquals(1, c.position());\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n}",
      "method_signature": "testTruncateDoesntChangeSmallPosition()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 30525,
    "output_tokens": 8718,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1152,
      "description": "Create a test case to validate that the system correctly retrieves the complete contents from a byte-based data channel while maintaining accurate position tracking throughout the read operation. Begin by establishing a scenario where a known set of data content is available for reading through a channel interface. Prepare a receiving container with sufficient capacity to hold the entire content, then perform a read operation from the channel into this container. Verify that the system reports reading exactly the full amount of available content, confirm that the retrieved data matches the original content precisely, and ensure the channel's current position indicator reflects advancement to the end of the content after the read completes. After validating the read behavior, confirm that the original data remains unmodified to ensure the read operation was non-destructive. Once the channel completes its operations, ensure any held resources are properly released. Use JUnit 5 as the testing framework with standard equality assertions to verify that read counts match expected lengths, retrieved content arrays match source data, and position values reflect the correct offset after reading.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldReadContentsProperly()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.FileChannelReaderTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileChannelReader}.\n */\npublic class FileChannelReaderTest {\n\n    @Test\n    public void testReadFromChannel(@TempDir final Path tempDir) throws IOException {\n        final String expectedContent = \"Hello, world!\";\n        final byte[] expectedBytes = expectedContent.getBytes(StandardCharsets.UTF_8);\n        final Path file = tempDir.resolve(\"test.txt\");\n        Files.write(file, expectedBytes);\n\n        try (final FileChannel fileChannel = FileChannel.open(file, StandardOpenOption.READ);\n             final FileChannelReader channelReader = new FileChannelReader(fileChannel)) {\n\n            final ByteBuffer buffer = ByteBuffer.allocate(expectedBytes.length);\n            final int bytesRead = channelReader.read(buffer);\n\n            assertEquals(expectedBytes.length, bytesRead, \"Should have read the full content length\");\n\n            buffer.flip();\n            final byte[] actualBytes = new byte[buffer.remaining()];\n            buffer.get(actualBytes);\n\n            assertArrayEquals(expectedBytes, actualBytes, \"Retrieved content should match original content\");\n\n            final long finalPosition = channelReader.getPosition();\n            assertEquals(expectedBytes.length, finalPosition, \"Position should be at the end of the channel\");\n        }\n        // Verify original data is unmodified (this is mostly for conceptual clarity)\n        final byte[] originalDataCopy = \"Hello, world!\".getBytes(StandardCharsets.UTF_8);\n        assertArrayEquals(originalDataCopy, expectedBytes);\n    }\n}",
      "method_signature": "testShouldReadContentsProperly()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 24617,
    "output_tokens": 2948,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1153,
      "description": "Define a test method that validates the position adjustment behavior of a Byte Array Seekable Byte Channel when truncating to a size larger than the current content size but smaller than the current position. Within a try-with-resources block, wrap a static byte array using the channel's factory method to create a seekable channel instance, then advance the channel's position to twice the length of the underlying data array by invoking the position setter with that calculated offset. Having established this position beyond the data bounds, invoke the truncate method with a target size equal to the data length plus one, which should clamp the channel's actual size to the original data length while adjusting the position to the requested truncation size. Assert that the channel's size method returns the original data length, confirming the truncation did not expand the channel beyond its actual content, then assert that the position method returns the truncation target value, verifying the position was moved to align with the truncation request rather than remaining at the original offset or clamping to the actual size. Upon exiting the try-with-resources block, the channel closes automatically, and in a separate teardown method, validate that the original test data array remains unmodified by comparing it against the expected byte sequence to ensure read-only operations preserved the underlying data integrity. This test uses JUnit 5 for assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateMovesPositionWhenNewSizeIsBiggerThanSizeAndPositionIsEvenBigger()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.util.Arrays;\n\nimport org.apache.commons.io.Charsets;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] DATA = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".getBytes(Charsets.UTF_8);\n    private static final byte[] ORIGINAL_DATA = Arrays.copyOf(DATA, DATA.length);\n\n    @AfterEach\n    public void tearDown() {\n        assertArrayEquals(ORIGINAL_DATA, DATA);\n    }\n\n    @Test\n    public void testTruncatePastEndThenPastPosition() throws IOException {\n        try (final SeekableByteChannel channel = new ByteArraySeekableByteChannel(DATA)) {\n            final int newPosition = DATA.length * 2;\n            channel.position(newPosition);\n\n            final int truncateSize = DATA.length + 1;\n            channel.truncate(truncateSize);\n\n            assertEquals(DATA.length, channel.size(), \"Truncating beyond the end should not change the size.\");\n            assertEquals(truncateSize, channel.position(), \"Position should be moved to the truncation size.\");\n        }\n    }\n}",
      "method_signature": "testTruncateMovesPositionWhenNewSizeIsBiggerThanSizeAndPositionIsEvenBigger()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 21658,
    "output_tokens": 6760,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1158,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]`, initialized with the byte array representation of the string literal `\"Some data\"` using `StandardCharsets.UTF_8` encoding. Write a test method annotated with `@Test` that declares it throws `Exception`, and within a try-with-resources block, declare a variable `c` of type `SeekableByteChannel` initialized by invoking the static method `wrap` on class `ByteArraySeekableByteChannel` passing `testData` as the argument. Immediately invoke `position` on `c` with the argument `2 * testData.length` to set the channel position to twice the length of the test data array. Next, invoke `truncate` on `c` with the argument `testData.length + 1` to attempt truncation to a size one byte larger than the original data length. Following truncation, assert using `assertEquals` that invoking `size()` on `c` returns exactly `testData.length`, verifying the channel size remains unchanged at the original data length. Then assert using `assertEquals` that invoking `position()` on `c` returns exactly `testData.length + 1`, confirming the position has been adjusted to the truncation target size. After the try-with-resources block completes and the channel is automatically closed, define a teardown method annotated with `@AfterEach` that invokes `assertArrayEquals` to verify that `testData` still equals the byte array obtained by calling `getBytes(StandardCharsets.UTF_8)` on the string literal `\"Some data\"`, ensuring the test data remains unmodified. The test uses JUnit 5 Assertions with method-level annotation `@Test` and teardown annotation `@AfterEach`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateMovesPositionWhenNewSizeIsBiggerThanSizeAndPositionIsEvenBigger()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @AfterEach\n    public void tearDown() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData, \"testData should not be modified\");\n    }\n\n    @Test\n    public void testTruncate() throws Exception {\n        try (SeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n            c.position(2 * testData.length);\n            c.truncate(testData.length + 1);\n            assertEquals(testData.length, c.size());\n            assertEquals(testData.length + 1, c.position());\n        }\n    }\n}",
      "method_signature": "testTruncateMovesPositionWhenNewSizeIsBiggerThanSizeAndPositionIsEvenBigger()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23363,
    "output_tokens": 4105,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1160,
      "description": "Create a test case to validate that when a data channel's read position is set beyond twice the actual content size and then a resize operation is requested to a size larger than the current content but smaller than the current position, the system correctly adjusts the content size to match the actual available data while preserving the requested position value. Begin by establishing a data channel containing some initial content, then advance the read position to twice the length of that content to simulate a scenario where the position marker has moved far beyond the available data. Once the position is established, request a resize operation to a size that exceeds the current content length by one unit but remains less than the current position. After the resize attempt, verify that the actual content size remains unchanged at its original length since the system cannot extend beyond existing data, and confirm that the position marker has been adjusted to the requested resize value, demonstrating that the system maintains position tracking even when resize operations cannot fully satisfy the requested size due to content constraints. Finally, release any held resources to ensure proper cleanup. This validation uses JUnit 5 for the testing framework and standard equality assertions to verify both the content size and position values after the resize operation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateMovesPositionWhenNewSizeIsBiggerThanSizeAndPositionIsEvenBigger()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.SeekableByteChannelResizeTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests the behavior of a {@link SeekableByteChannel} when resizing.\n */\npublic class SeekableByteChannelResizeTest {\n\n    @TempDir\n    private Path tempDir;\n\n    @Test\n    public void testResizeChannelWithPositionBeyondTruncateSize() throws IOException {\n        final Path testFile = tempDir.resolve(\"test-channel-resize.txt\");\n        final byte[] initialContent = \"Initial content\".getBytes(StandardCharsets.UTF_8);\n        Files.write(testFile, initialContent);\n\n        try (RandomAccessFile raf = new RandomAccessFile(testFile.toFile(), \"rw\");\n             SeekableByteChannel channel = raf.getChannel()) {\n\n            final long originalSize = channel.size();\n            final long positionBeyondContent = originalSize * 2;\n            channel.position(positionBeyondContent);\n\n            final long resizeValue = originalSize + 1;\n            channel.truncate(resizeValue);\n\n            // The size of the channel should not change because the truncation size\n            // is greater than the actual file size.\n            assertEquals(originalSize, channel.size(),\n                \"Channel size should not be modified when truncate size is larger than content size.\");\n\n            // The position should be moved to the truncation size because the current\n            // position is greater than the truncation size.\n            assertEquals(resizeValue, channel.position(),\n                \"Position should be adjusted to the truncate size if it was beyond it.\");\n        }\n    }\n}",
      "method_signature": "testTruncateMovesPositionWhenNewSizeIsBiggerThanSizeAndPositionIsEvenBigger()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8571,
      "callable_precision": 0.4615,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 1,
          "write_file": 1,
          "run_shell_command": 4
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 135486,
    "output_tokens": 7016,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1163,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]` initialized with the byte array representation of the string literal `\"Some data\"` encoded using `StandardCharsets.UTF_8`, then write a test method annotated with `@Test` that declares it throws `IOException` and begins by opening a try-with-resources block that invokes the static method `wrap` on `ByteArraySeekableByteChannel` passing `testData` as the argument and assigns the returned `ByteArraySeekableByteChannel` instance to variable `c`. Within the try block, invoke `ByteBuffer.allocate` passing `testData.length` as the argument and assign the returned `ByteBuffer` to variable `readBuffer`, then invoke the `read` method on `c` passing `readBuffer` as the argument and assign the returned int value to variable `readCount`. Immediately assert using `assertEquals` that `testData.length` equals `readCount`, then assert using `assertArrayEquals` that `testData` equals the result of invoking `array()` on `readBuffer`, and finally assert using `assertEquals` that `testData.length` equals the result of invoking `position()` on `c`. After the try-with-resources block completes, define a teardown method that invokes `assertArrayEquals` passing the byte array obtained by calling `getBytes(StandardCharsets.UTF_8)` on the string literal `\"Some data\"` as the first argument and `testData` as the second argument to verify the test data remains unmodified. The test uses JUnit 5 Assertions with method-level annotation `@Test` and no class-level annotations.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldReadContentsProperly()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testWrap() throws IOException {\n        try (final ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n            final ByteBuffer readBuffer = ByteBuffer.allocate(testData.length);\n            final int readCount = c.read(readBuffer);\n            assertEquals(testData.length, readCount);\n            assertArrayEquals(testData, readBuffer.array());\n            assertEquals(testData.length, c.position());\n        }\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n}",
      "method_signature": "testShouldReadContentsProperly()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.75,
      "callable_recall": 1.0,
      "callable_precision": 0.8,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 33947,
    "output_tokens": 1681,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1164,
      "description": "Create a test case to validate that when a resizing operation is requested with a target capacity larger than the current content size, the system preserves the original content unchanged and maintains its current boundaries. Begin by establishing a channel containing a known set of business data, then confirm the channel reflects the expected initial content size. Attempt to expand the channel's capacity beyond its current size, and immediately verify the content size remains at its original value rather than expanding. After confirming the resize operation had no effect, retrieve the complete contents from the channel and ensure all original business data remains intact and accessible in its entirety, demonstrating that both the size boundaries and the actual content were preserved during the attempted expansion. Once validation is complete, release the channel resources and perform a final verification to confirm the source business data was never modified throughout the test execution. Use JUnit 5 for the testing framework with standard equality and array comparison assertions to verify size consistency and content preservation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateToBiggerSizeDoesntChangeAnything()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1165,
      "description": "Define a test method that validates the behavior of a Byte Array Seekable Channel when attempting to truncate to a size larger than its current content, using a static byte array field initialized with test data. Wrap the test data in a new channel instance using the static factory method, then capture the initial size of the channel and assert it matches the length of the test data. Invoke the truncate operation on the channel with a size parameter exceeding the current data length by one, then immediately verify that the channel's size remains unchanged at the original data length. Allocate a ByteBuffer with capacity equal to the test data length, perform a read operation from the channel into this buffer, and assert that the number of bytes read equals the test data length. Extract the underlying byte array from the read buffer, copy it to match the test data length, and assert that this copied array is identical to the original test data, confirming no data corruption occurred. Close the channel resource using try-with-resources to ensure proper cleanup. In the teardown phase, verify that the static test data field remains unmodified by asserting its contents still match the original byte representation of the source string, ensuring the read-only nature of the test is preserved. This test uses JUnit 5 for assertions and resource management.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateToBiggerSizeDoesntChangeAnything()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableChannelTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableChannel}.\n */\npublic class ByteArraySeekableChannelTest {\n\n    private static final String SOURCE_STRING = \"This is the test data\";\n    private static final byte[] TEST_DATA = SOURCE_STRING.getBytes(StandardCharsets.UTF_8);\n\n    @AfterEach\n    public void tearDown() {\n        // Verify the test data was not modified\n        assertArrayEquals(SOURCE_STRING.getBytes(StandardCharsets.UTF_8), TEST_DATA, \"Static test data should not be modified\");\n    }\n\n    @Test\n    public void testTruncateToLargerSizeDoesNotChangeAndDoesNotCorrupt() throws IOException {\n        try (final SeekableByteChannel channel = new ByteArraySeekableChannel(TEST_DATA)) {\n            final long initialSize = channel.size();\n            assertEquals(TEST_DATA.length, initialSize, \"Initial size should match test data length\");\n\n            channel.truncate(initialSize + 1);\n            assertEquals(initialSize, channel.size(), \"Channel size should remain unchanged after truncating to a larger size\");\n\n            final ByteBuffer buffer = ByteBuffer.allocate(TEST_DATA.length);\n            final int bytesRead = channel.read(buffer);\n            assertEquals(TEST_DATA.length, bytesRead, \"Should read the full length of the test data\");\n\n            final byte[] copiedData = Arrays.copyOf(buffer.array(), TEST_DATA.length);\n            assertArrayEquals(TEST_DATA, copiedData, \"Data read from channel should match original test data\");\n        }\n    }\n}",
      "method_signature": "testTruncateToBiggerSizeDoesntChangeAnything()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 27562,
    "output_tokens": 8612,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1166,
      "description": "Define a test method that verifies the read operation of a Byte Array Seekable Byte Channel by wrapping a predefined byte array into a channel instance using the wrap factory method, then allocate a ByteBuffer with capacity matching the length of the test data to serve as the read destination. Invoke the read method on the channel, passing the allocated buffer, and capture the count of bytes read during this operation. Assert that the returned read count equals the original data length to confirm the channel reported the correct number of bytes transferred, then extract the underlying byte array from the buffer and assert it matches the original test data byte-for-byte to verify content integrity. Following these verifications, query the channel's current position and assert it equals the data length, confirming the read operation advanced the position marker appropriately. Wrap the channel initialization in a try-with-resources block to ensure automatic closure of the channel upon test completion. After the test method completes, implement a teardown method that validates the original test data remains unmodified by asserting the class-level byte array still matches the expected UTF-8 encoded string value, ensuring read operations did not corrupt the shared test fixture. This test uses JUnit for assertions and standard Java NIO components for buffer management.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldReadContentsProperly()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] TEST_DATA = \"Hello World\".getBytes(StandardCharsets.UTF_8);\n\n    /**\n     * Verifies that the read operation on a {@link ByteArraySeekableByteChannel}\n     * correctly transfers bytes to the destination buffer, advances the position,\n     * and reports the correct number of bytes read.\n     *\n     * @throws IOException If an I/O error occurs.\n     */\n    @Test\n    public void testRead() throws IOException {\n        try (final SeekableByteChannel channel = new ByteArraySeekableByteChannel(TEST_DATA)) {\n            final ByteBuffer buffer = ByteBuffer.allocate(TEST_DATA.length);\n            final int readCount = channel.read(buffer);\n\n            assertEquals(TEST_DATA.length, readCount, \"The number of bytes read should match the source data length.\");\n            assertArrayEquals(TEST_DATA, buffer.array(), \"The content of the buffer should match the source data.\");\n            assertEquals(TEST_DATA.length, channel.position(), \"The channel position should be advanced to the end of the data.\");\n        }\n    }\n\n    /**\n     * Ensures that the test data fixture is not modified during the test execution.\n     */\n    @AfterEach\n    public void tearDown() {\n        assertArrayEquals(\"Hello World\".getBytes(StandardCharsets.UTF_8), TEST_DATA,\n                \"The original test data should not be modified.\");\n    }\n}",
      "method_signature": "testShouldReadContentsProperly()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 59385,
    "output_tokens": 8015,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1167,
      "description": "Create a test case to validate that when a seekable data stream is reduced in size to a point smaller than the current read position, the system automatically adjusts the position to match the new boundary. Begin by establishing a data stream initialized with sample content, then advance the read position to a specific location within that content (beyond where the stream will be truncated). Once the position is established, perform a size reduction operation that shrinks the stream to a length shorter than the current position, then verify that the stream's total size reflects the reduced length and confirm that the read position has been automatically moved back to align with the new end boundary rather than remaining at the now-invalid original location. After completing the validation, ensure the original test data remains unmodified to confirm the operation was performed correctly. Use JUnit 5 for the testing framework with standard equality assertions to verify both the adjusted size and the repositioned read location.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateMovesPositionWhenShrinkingBeyondPosition()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IORandomAccessFileTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link IORandomAccessFile}.\n */\npublic class IORandomAccessFileTest1 {\n\n    @TempDir\n    private Path tempDir;\n\n    @Test\n    public void testSetLengthSmallerThanPosition() throws IOException {\n        final Path path = tempDir.resolve(\"test-file.txt\");\n        final byte[] data = \"1234567890\".getBytes(StandardCharsets.UTF_8);\n        Files.write(path, data);\n\n        final File file = path.toFile();\n        try (final IORandomAccessFile randomAccessFile = new IORandomAccessFile(file, \"rw\")) {\n            // Seek to a position\n            randomAccessFile.seek(5);\n\n            // Truncate the file to a length smaller than the current position\n            randomAccessFile.setLength(2);\n\n            // Verify the new length\n            assertEquals(2, randomAccessFile.length());\n\n            // Verify the position is adjusted to the new length\n            assertEquals(2, randomAccessFile.getFilePointer());\n        }\n\n        // Verify the file content on disk\n        final byte[] truncatedData = Files.readAllBytes(path);\n        assertArrayEquals(new byte[] { '1', '2' }, truncatedData);\n\n        // Verify original data array is untouched\n        assertArrayEquals(\"1234567890\".getBytes(StandardCharsets.UTF_8), data);\n    }\n}",
      "method_signature": "testTruncateMovesPositionWhenShrinkingBeyondPosition()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.5,
      "callable_recall": 0.2857,
      "callable_precision": 0.1333,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19564,
    "output_tokens": 4985,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1169,
      "description": "Define a test method that validates the behavior of a Byte Array Seekable Channel when truncating its size to a value smaller than the current position, ensuring the position automatically adjusts to the new size boundary. Initialize a static byte array field containing test data that will be shared across tests. Within the test method, wrap this test data using the Byte Array Seekable Channel's factory method to create a channel instance within a try-with-resources block. Advance the channel's position to an index beyond where the truncation will occur by invoking the position method with an integer value. Invoke the truncate method on the channel with a size smaller than the current position to shrink the channel's capacity. Immediately verify that the channel's size matches the truncation target by asserting the return value of the size method equals the specified truncation value. Subsequently validate that the channel's position has been automatically adjusted to the new size boundary by asserting the return value of the position method equals the truncation value, confirming the position moved backward when the channel shrank beyond it. Upon test completion, implement a teardown method that verifies the original test data array remains unmodified by asserting its contents still match the expected byte sequence, ensuring read operations did not alter the underlying data. The test uses JUnit 5 for the testing framework and standard JUnit assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateMovesPositionWhenShrinkingBeyondPosition()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.ByteBufferSeekableChannelTest",
      "code": "package org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link ByteBufferSeekableChannel}.\n */\npublic class ByteBufferSeekableChannelTest {\n\n    private static final byte[] STATIC_TEST_DATA = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    private static final byte[] ORIGINAL_TEST_DATA = STATIC_TEST_DATA.clone();\n    private byte[] testData;\n\n    @AfterEach\n    public void tearDown() {\n        // As required by the test description, verify that the original underlying byte array remains untouched\n        // after the channel operations. This ensures that the channel either works on a copy or\n        // does not perform destructive writes on the backing array for operations like truncate.\n        assertArrayEquals(ORIGINAL_TEST_DATA, this.testData,\n            \"The underlying byte array should not be modified by the channel's operations.\");\n    }\n\n    @Test\n    public void testTruncateToSmallerThanPosition() throws IOException {\n        // Initialize test data from the static source as per the prompt's requirements for a shared field.\n        this.testData = STATIC_TEST_DATA.clone();\n        final int truncateSize = 4;\n        final int newPosition = 7;\n\n        try (final SeekableByteChannel channel = new ByteBufferSeekableChannel(ByteBuffer.wrap(this.testData))) {\n            // Advance the channel's position to an index beyond where the truncation will occur.\n            channel.position(newPosition);\n\n            // Invoke the truncate method to shrink the channel's capacity to a size smaller than the current position.\n            channel.truncate(truncateSize);\n\n            // Immediately verify that the channel's size matches the truncation target.\n            assertEquals(truncateSize, channel.size(),\n                \"Channel size should be updated to the truncation value.\");\n\n            // Subsequently validate that the channel's position has been automatically adjusted to the new size boundary.\n            assertEquals(truncateSize, channel.position(),\n                \"Position should be moved backward to the new size boundary when the channel shrinks.\");\n        }\n    }\n}",
      "method_signature": "testTruncateMovesPositionWhenShrinkingBeyondPosition()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7427,
    "output_tokens": 8755,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1170,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]` initialized with the byte array representation of the string literal `\"Some data\"` using UTF-8 encoding. Within the test method, begin by invoking the static method `wrap` on class `ByteArraySeekableByteChannel` with argument `testData`, assigning the result to a variable `c` of type `SeekableByteChannel` within a try-with-resources statement that ensures automatic closure. Immediately assert using `assertEquals` that the result of invoking `size()` on `c` equals `testData.length`. Next, invoke `truncate` on `c` with the argument `testData.length + 1` (the current size plus one). Following this truncation attempt, assert again using `assertEquals` that invoking `size()` on `c` still equals `testData.length`, verifying the size remains unchanged. Then allocate a `ByteBuffer` by calling `ByteBuffer.allocate(testData.length)` and assign it to variable `readBuffer`. Invoke `read` on `c` with argument `readBuffer`, and assert using `assertEquals` that the return value equals `testData.length`, confirming the number of bytes read. Finally, assert using `assertArrayEquals` that `testData` equals the result of calling `Arrays.copyOf(readBuffer.array(), testData.length)`, which extracts the byte array from the buffer and copies it to the exact length of `testData`. After the try-with-resources block completes and the channel is closed, define a teardown method annotated with `@AfterEach` that asserts using `assertArrayEquals` that the byte array obtained by calling `getBytes(StandardCharsets.UTF_8)` on the string literal `\"Some data\"` equals `testData`, verifying the test data remains unmodified. The test method uses annotation `@Test`, declares thrown exception `Exception`, and relies on JUnit 5 Assertions for verification.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateToBiggerSizeDoesntChangeAnything()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\n\nimport org.apache.commons.io.input.ByteArrayInputStream;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testTruncate() throws Exception {\n        try (final SeekableByteChannel c = new ByteArraySeekableByteChannel(testData)) {\n            assertEquals(testData.length, c.size());\n            c.truncate(testData.length + 1);\n            assertEquals(testData.length, c.size());\n            final ByteBuffer readBuffer = ByteBuffer.allocate(testData.length);\n            assertEquals(testData.length, c.read(readBuffer));\n            assertArrayEquals(testData, Arrays.copyOf(readBuffer.array(), testData.length));\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n\n}",
      "method_signature": "testTruncateToBiggerSizeDoesntChangeAnything()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18368,
    "output_tokens": 3275,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1173,
      "description": "Create a test case to validate that the byte channel system correctly signals the end of available data when attempting to read from a position beyond the current content boundary across various data sizes. For each scenario involving different amounts of stored content, configure a byte channel with the specified amount of data, then reposition the read cursor to a specific offset within the channel. After confirming the cursor moved to the expected location, prepare a read buffer with sufficient capacity and attempt to retrieve data from the current position. Verify that when the read position is already at or beyond the end of the available content, the system returns the standard end-of-data indicator, but when the position falls within the valid content range, the system returns the exact number of bytes remaining from that position to the end. After each scenario completes, confirm that the original test data remains unchanged to ensure reading operations do not inadvertently modify the stored content. Use JUnit 5 for parameterized test execution across multiple data size variations, with AssertJ-style standard equality assertions to verify cursor positioning and read operation results.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testReadingFromAPositionAfterEndReturnsEOF(int)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.SeekableByteChannelReadTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link SeekableByteChannel} behavior when reading from various positions.\n */\npublic class SeekableByteChannelReadTest {\n\n    public static Stream<Arguments> readScenarios() {\n        // Arguments: dataSize, positionToReadFrom, expectedBytesRead\n        return Stream.of(\n            // Reading from a position at or beyond the end of the content\n            Arguments.of(10, 10, -1), // Position is exactly at the end\n            Arguments.of(10, 11, -1), // Position is one byte past the end\n            Arguments.of(10, 20, -1), // Position is far beyond the end\n\n            // Reading from a position within the content\n            Arguments.of(10, 0, 10),  // Read the entire content from the beginning\n            Arguments.of(10, 5, 5),   // Read from the middle to the end\n            Arguments.of(10, 9, 1),   // Read the last byte\n\n            // Edge case: zero-length content\n            Arguments.of(0, 0, -1),    // Reading from an empty channel\n            Arguments.of(0, 1, -1)     // Reading beyond an empty channel\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"readScenarios\")\n    void testReadFromPositionSignalsEofCorrectly(final int dataSize, final int position, final int expectedRead, @TempDir final Path tempDir) throws IOException {\n        final Path testFile = tempDir.resolve(\"test.dat\");\n        final byte[] testData = new byte[dataSize];\n        if (dataSize > 0) {\n            // Fill with some dummy data\n            Arrays.fill(testData, (byte) 'A');\n        }\n        Files.write(testFile, testData);\n        final byte[] originalData = Files.readAllBytes(testFile);\n\n        try (SeekableByteChannel channel = new SeekableByteChannelBuilder().setPath(testFile).get()) {\n            // Move cursor to the specified position\n            channel.position(position);\n            assertThat(channel.position()).isEqualTo(position);\n\n            // Attempt to read from the channel\n            final ByteBuffer buffer = ByteBuffer.allocate(dataSize + 20); // Ensure buffer is large enough\n            final int bytesRead = channel.read(buffer);\n\n            // Verify the number of bytes read matches expectation\n            assertThat(bytesRead).isEqualTo(expectedRead);\n        }\n\n        // Verify the original file content remains unchanged\n        final byte[] finalData = Files.readAllBytes(testFile);\n        assertThat(finalData).isEqualTo(originalData);\n    }\n}",
      "method_signature": "testReadingFromAPositionAfterEndReturnsEOF(int)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23089,
    "output_tokens": 8408,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1175,
      "description": "Define a parameterized test method that validates the behavior of a Byte Array Seekable Channel when reading from positions at or beyond the channel's end boundary, using integer parameters representing various channel sizes from zero through six bytes. For each parameter value, wrap a newly allocated byte array of the specified size using the channel factory method to obtain a seekable channel instance within a try-with-resources block. Set the channel's position to an offset of two bytes by invoking the position method with that value, then immediately verify that retrieving the current position returns the expected offset to confirm the positioning operation succeeded. Allocate a ByteBuffer with a capacity of five bytes to serve as the read destination, then invoke the channel's read method with this buffer and assert that the returned byte count matches the expected outcome: negative one if the position equals or exceeds the channel size indicating end-of-file, otherwise the difference between the channel size and the current position representing the remaining available bytes. Upon exiting the try-with-resources block, allow the channel to close automatically. In the teardown phase, validate that a static test data byte array remains unmodified by comparing it against the byte representation of the original string value, ensuring that read operations have not altered shared state. This test uses JUnit 5 with parameterized test support.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testReadingFromAPositionAfterEndReturnsEOF(int)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.ByteArraySeekableChannelTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\n/**\n * Tests {@link IO}#newByteChannel(byte[]).\n */\npublic class ByteArraySeekableChannelTest {\n\n    private static final String TEST_STRING = \"0123456789\";\n    private static final byte[] STATIC_DATA = TEST_STRING.getBytes(StandardCharsets.UTF_8);\n\n    /**\n     * Validates that the static test data byte array remains unmodified after each test,\n     * ensuring that read operations have not altered any shared state.\n     */\n    @AfterEach\n    public void tearDown() {\n        assertArrayEquals(TEST_STRING.getBytes(StandardCharsets.UTF_8), STATIC_DATA,\n            \"Static test data should not be modified by channel operations.\");\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {0, 1, 2, 3, 4, 5, 6})\n    public void testReadFromBoundaryPositions(final int channelSize) throws IOException {\n        final byte[] data = Arrays.copyOf(STATIC_DATA, channelSize);\n        final byte[] originalData = data.clone();\n\n        try (final SeekableByteChannel channel = IO.newByteChannel(data)) {\n            channel.position(2);\n            assertEquals(2, channel.position(), \"Confirming channel position after setting it.\");\n\n            final ByteBuffer buffer = ByteBuffer.allocate(5);\n            final int bytesRead = channel.read(buffer);\n\n            final int expectedBytesRead = channelSize > 2 ? channelSize - 2 : -1;\n            assertEquals(expectedBytesRead, bytesRead,\n                \"Verify byte count matches expected outcome at or beyond the channel's end.\");\n        }\n\n        assertArrayEquals(originalData, data, \"The source byte array should not be modified by read operations.\");\n    }\n}",
      "method_signature": "testReadingFromAPositionAfterEndReturnsEOF(int)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 29186,
    "output_tokens": 10290,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1176,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]` initialized with the byte array representation of the string literal `\"Some data\"` using `StandardCharsets.UTF_8` encoding. Write a test method annotated with `@Test` that declares it throws `Exception` and begins by opening a try-with-resources block that declares a variable `c` of type `SeekableByteChannel` initialized by invoking the static method `wrap` on `ByteArraySeekableByteChannel` with argument `testData`. Within the try block, invoke `position` on `c` with argument `4` to set the channel position, then invoke `truncate` on `c` with argument `3` to reduce the channel size. Immediately assert using `assertEquals` that the result of invoking `size()` on `c` equals `3`, then assert using `assertEquals` that the result of invoking `position()` on `c` equals `3`. After the test method completes, define a teardown method that invokes `assertArrayEquals` with two arguments: the byte array obtained by calling `getBytes(StandardCharsets.UTF_8)` on the string literal `\"Some data\"` as the first argument, and `testData` as the second argument, verifying that the test data remains unmodified. The test uses JUnit 5 Assertions with method-level annotation `@Test`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateMovesPositionWhenShrinkingBeyondPosition()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.apache.commons.io.input.ByteArrayInputStream;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @AfterAll\n    public static void tearDown() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n\n    @Test\n    public void testTruncate() throws Exception {\n        try (SeekableByteChannel c = new ByteArraySeekableByteChannel(testData)) {\n            c.position(4);\n            c.truncate(3);\n            assertEquals(3, c.size());\n            assertEquals(3, c.position());\n        }\n    }\n}",
      "method_signature": "testTruncateMovesPositionWhenShrinkingBeyondPosition()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1,
          "read_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 31376,
    "output_tokens": 7260,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1179,
      "description": "Create a test case to validate that the byte channel correctly stores written data and maintains accurate tracking of both the amount written and the current position within the channel. Begin by establishing a fresh channel instance with no initial content, then prepare a sample data buffer containing a known sequence of bytes. Write this data buffer into the channel and capture the count of bytes that were successfully written. Verify that the write operation reported the exact number of bytes from the original sample, confirm that the channel's current position advanced to match the total bytes written, and ensure that the actual content stored in the channel exactly matches the original sample data when extracted up to the current position. After completing the validation, confirm that the original sample data remains unmodified to ensure the test did not inadvertently alter shared state. Use JUnit 5 as the testing framework with standard equality assertions to verify write counts and position values, and array equality assertions to validate content integrity.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldWriteDataProperly()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.SeekableByteChannelWriteTest",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link SeekableByteChannel}.\n */\npublic class SeekableByteChannelWriteTest {\n\n    @TempDir\n    private Path tempDir;\n\n    @Test\n    public void testWrite() throws IOException {\n        final Path tempFile = Files.createFile(tempDir.resolve(\"test.bin\"));\n        try (SeekableByteChannel channel = Files.newByteChannel(tempFile, StandardOpenOption.WRITE,\n            StandardOpenOption.READ)) {\n            assertEquals(0, channel.size());\n            assertEquals(0, channel.position());\n\n            final byte[] sampleData = \"Apache Commons IO\".getBytes();\n            final byte[] originalSampleData = Arrays.copyOf(sampleData, sampleData.length);\n            final ByteBuffer buffer = ByteBuffer.wrap(sampleData);\n\n            final int bytesWritten = channel.write(buffer);\n\n            assertEquals(sampleData.length, bytesWritten);\n            assertEquals(sampleData.length, channel.position());\n            assertEquals(sampleData.length, channel.size());\n\n            final ByteBuffer readBuffer = ByteBuffer.allocate(sampleData.length);\n            channel.position(0);\n            channel.read(readBuffer);\n            readBuffer.flip();\n            final byte[] channelContent = new byte[readBuffer.remaining()];\n            readBuffer.get(channelContent);\n\n            assertArrayEquals(originalSampleData, channelContent);\n            assertArrayEquals(originalSampleData, sampleData);\n        }\n    }\n}",
      "method_signature": "testShouldWriteDataProperly()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.4286,
      "callable_recall": 0.5,
      "callable_precision": 0.2083,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14702,
    "output_tokens": 8658,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1181,
      "description": "Create a test case to validate that the system correctly retrieves content from a specific location within a data stream when instructed to begin reading from a non-initial position. Prepare a stream containing predefined content, then configure the stream to start reading from the sixth position onward. Allocate a buffer capable of holding four units of content and instruct the system to read into this buffer from the configured position. Verify that exactly four units were successfully retrieved, confirm the retrieved content matches the expected substring from the original data at that position, and ensure the stream's current position has advanced to the end of the available content after the read operation completes. After validation, confirm the original content remains unmodified to ensure the read operation did not alter the underlying data. Use JUnit 5 for the testing framework and standard equality assertions to verify the read count, content accuracy, and final position state.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldReadDataFromSetPosition()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14694,
    "output_tokens": 2848,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1183,
      "description": "Define a parameterized test method annotated with `@ParameterizedTest` and `@ValueSource(ints = { 0, 1, 2, 3, 4, 5, 6 })` that accepts a single integer parameter named `size` and declares `throws Exception`. Within the method body, open a try-with-resources block that declares a variable `c` of type `SeekableByteChannel`, initialized by invoking the static method `ByteArraySeekableByteChannel.wrap` with a newly constructed byte array of length `size` (i.e., `new byte[size]`). Inside the try block, declare an integer variable `position` and assign it the literal value `2`. Immediately invoke `c.position(position)` to set the channel's position to `2`. Assert that the current position equals the expected value by calling `assertEquals(position, c.position())`, where the first argument is the integer variable `position` and the second is the result of invoking `c.position()`. Next, declare an integer variable `readSize` and assign it the literal value `5`. Create a `ByteBuffer` by invoking `ByteBuffer.allocate(readSize)` and assign the result to a variable named `readBuffer`. Perform a read operation by invoking `c.read(readBuffer)` and assert that the return value matches the expected read count using `assertEquals(position >= size ? -1 : size - position, c.read(readBuffer))`, where the first argument is a ternary expression evaluating to `-1` if `position` is greater than or equal to `size`, otherwise `size - position`, and the second argument is the integer returned by the read invocation. After the try-with-resources block completes, define a teardown method that invokes `assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData)` to verify that the static final byte array field `testData` remains unmodified. The test uses JUnit 5 Assertions and the `@ParameterizedTest` annotation with `@ValueSource`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testReadingFromAPositionAfterEndReturnsEOF(int)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @AfterEach\n    public void tearDown() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = { 0, 1, 2, 3, 4, 5, 6 })\n    public void testPositionAndRead(final int size) throws Exception {\n        try (SeekableByteChannel c = ByteArraySeekableByteChannel.wrap(new byte[size])) {\n            final int position = 2;\n            c.position(position);\n            assertEquals(position, c.position());\n            final int readSize = 5;\n            final ByteBuffer readBuffer = ByteBuffer.allocate(readSize);\n            assertEquals(position >= size ? -1 : size - position, c.read(readBuffer));\n        }\n    }\n}",
      "method_signature": "testReadingFromAPositionAfterEndReturnsEOF(int)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 57251,
    "output_tokens": 9819,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1185,
      "description": "Define a test method that validates the write operation of a Byte Array Seekable Byte Channel by first instantiating the channel within a try-with-resources block to ensure automatic closure, then wrapping a predefined byte array into a ByteBuffer to serve as the input data source. Invoke the write method on the channel with this buffer and capture the returned count of bytes written, after which verify that the write count matches the length of the original byte array to confirm all data was accepted. Immediately validate that the channel's current position has advanced to equal the byte array length, indicating the internal cursor moved correctly during the write operation. Extract the channel's underlying byte array and copy only the portion up to the current position, then assert that this extracted segment exactly matches the original input byte array to confirm data integrity and proper storage. Upon exiting the try-with-resources block, the channel closes automatically, and in a separate teardown phase, verify that the static test data byte array remains unmodified by comparing it against the expected UTF-8 encoded bytes of the original string to ensure reading tests have not altered shared state. This test uses JUnit for assertions and the standard Java NIO ByteBuffer for data wrapping.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldWriteDataProperly()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final String TEST_STRING = \"Hello World\";\n    private static final byte[] TEST_BYTES = TEST_STRING.getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testWrite() throws IOException {\n        try (final ByteArraySeekableByteChannel channel = new ByteArraySeekableByteChannel()) {\n            final ByteBuffer buffer = ByteBuffer.wrap(TEST_BYTES);\n            final int bytesWritten = channel.write(buffer);\n\n            assertEquals(TEST_BYTES.length, bytesWritten);\n            assertEquals(TEST_BYTES.length, channel.position());\n\n            final byte[] writtenBytes = Arrays.copyOf(channel.array(), (int) channel.position());\n            assertArrayEquals(TEST_BYTES, writtenBytes);\n        }\n        // Verify that the static test data byte array remains unmodified\n        assertArrayEquals(TEST_STRING.getBytes(StandardCharsets.UTF_8), TEST_BYTES);\n    }\n}",
      "method_signature": "testShouldWriteDataProperly()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.75,
      "callable_recall": 1.0,
      "callable_precision": 0.8333,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 76154,
    "output_tokens": 8192,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1186,
      "description": "Define a test method that validates reading data from a seekable byte channel after repositioning the internal pointer, beginning by wrapping a static byte array containing UTF-8 encoded text into a ByteArraySeekableByteChannel instance within a try-with-resources block to ensure automatic closure. Allocate a ByteBuffer with a capacity of four bytes to serve as the read destination, then reposition the channel to byte offset five before invoking the read operation to transfer data from the channel into the buffer. Upon completing the read, verify that the returned read count equals four bytes, then extract the buffer's underlying byte array and decode it as a UTF-8 string to confirm it matches the expected substring from the original data. Additionally, assert that the channel's current position has advanced to the total length of the original byte array, demonstrating that the read operation correctly updated the internal pointer. After the try-with-resources block completes and the channel is closed, implement a teardown method that validates the original static byte array remains unmodified by comparing it against a freshly encoded copy of the expected string, ensuring read operations do not mutate the underlying data source. This test uses standard assertion methods for equality checks and relies on Java NIO's ByteBuffer and SeekableByteChannel abstractions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldReadDataFromSetPosition()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7417,
    "output_tokens": 707,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1187,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]`, and write a test method annotated with `@Test` that declares `throws IOException` in its signature. Begin by opening a try-with-resources block that instantiates a `ByteArraySeekableByteChannel` using its no-argument constructor and assigns it to variable `c`. Within the try block, create a `ByteBuffer` by invoking `ByteBuffer.wrap(testData)` and assign the result to variable `inData`. Invoke `write` on `c` passing `inData` as the argument, and assign the returned int value to variable `writeCount`. Assert that `writeCount` equals `testData.length` using `assertEquals`. Invoke `position()` on `c` and assert that the returned long value equals `testData.length` using `assertEquals`. Invoke `position()` on `c` again, cast the result to int, and pass this value to `Arrays.copyOf` along with the byte array obtained by invoking `array()` on `c`, then assert that the resulting byte array equals `testData` using `assertArrayEquals`. After the try-with-resources block completes, define a teardown method that invokes `assertArrayEquals` with the byte array obtained by calling `getBytes(StandardCharsets.UTF_8)` on the String literal `\"Some data\"` as the first argument and `testData` as the second argument. The test uses method-level annotation `@Test`, assertion library JUnit 5 Assertions, and no mocking libraries.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldWriteDataProperly()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testWrite() throws IOException {\n        try (final ByteArraySeekableByteChannel c = new ByteArraySeekableByteChannel()) {\n            final ByteBuffer inData = ByteBuffer.wrap(testData);\n            final int writeCount = c.write(inData);\n            assertEquals(testData.length, writeCount);\n            assertEquals(testData.length, c.position());\n            assertArrayEquals(testData, Arrays.copyOf(c.array(), (int) c.position()));\n        }\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n}",
      "method_signature": "testShouldWriteDataProperly()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.75,
      "callable_recall": 1.0,
      "callable_precision": 0.8333,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 3,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 99232,
    "output_tokens": 4937,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1190,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]` initialized with the byte array representation of the string literal `\"Some data\"` using `StandardCharsets.UTF_8` encoding. Write a test method annotated with `@Test` that declares `throws IOException` and begins by opening a try-with-resources block that creates a variable `c` of type `ByteArraySeekableByteChannel` by invoking the static method `ByteArraySeekableByteChannel.wrap(testData)`. Inside the try block, allocate a `ByteBuffer` by calling `ByteBuffer.allocate(4)` and assign it to a final variable `readBuffer`. Invoke `c.position(5L)` to set the channel's position to long value `5L`. Invoke `c.read(readBuffer)` and assign the returned int value to a final variable `readCount`. Assert that `readCount` equals long value `4L` using `assertEquals(4L, readCount)`. Create a new `String` by invoking the constructor `new String(readBuffer.array(), StandardCharsets.UTF_8)` where `readBuffer.array()` retrieves the backing byte array, then assert this string equals the literal `\"data\"` using `assertEquals(\"data\", new String(readBuffer.array(), StandardCharsets.UTF_8))`. Invoke `c.position()` to retrieve the current position and assert it equals `testData.length` using `assertEquals(testData.length, c.position())`. After the test method completes, define a teardown method that invokes `assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData)` to verify the test data remains unmodified. The test uses JUnit 5 Assertions with no class-level annotations and method-level annotation `@Test`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldReadDataFromSetPosition()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testRead() throws IOException {\n        try (final ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n            final ByteBuffer readBuffer = ByteBuffer.allocate(4);\n            c.position(5L);\n            final int readCount = c.read(readBuffer);\n            assertEquals(4L, readCount);\n            assertEquals(\"data\", new String(readBuffer.array(), StandardCharsets.UTF_8));\n            assertEquals(testData.length, c.position());\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n}",
      "method_signature": "testShouldReadDataFromSetPosition()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 3,
          "write_file": 1,
          "run_shell_command": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 77636,
    "output_tokens": 2719,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1192,
      "description": "Define a test method that validates the behavior of file streaming when files are deleted during iteration by first establishing a temporary directory structure containing multiple files with specific extensions, then creating an additional file with a matching extension, verifying the initial file count through a list operation, opening a file stream filtered by extensions with recursive traversal enabled, deleting the newly created file within the stream's try-with-resources block, conditionally skipping the remainder of the test on Java 24 and later due to known platform behavior changes, collecting the stream into a list, asserting that the deleted file does not appear in the collected results, and finally confirming the expected count of remaining files in the list, using JUnit 5 and standard assertion libraries.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsListFilesTest",
      "method_signature": "testStreamFilesWithDeletionCollect()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsStreamTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Assumptions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests the behavior of file streaming in {@link FileUtils} when files are modified during iteration.\n */\npublic class FileUtilsStreamTest {\n\n    @TempDir\n    private Path tempDir;\n\n    @Test\n    public void testStreamOnFileDelete() throws IOException {\n        // Establish a temporary directory structure.\n        final Path subDir = Files.createDirectory(tempDir.resolve(\"sub\"));\n        Files.write(tempDir.resolve(\"file1.txt\"), \"file1\".getBytes(StandardCharsets.UTF_8));\n        Files.write(subDir.resolve(\"file2.txt\"), \"file2\".getBytes(StandardCharsets.UTF_8));\n        Files.write(tempDir.resolve(\"other.log\"), \"other\".getBytes(StandardCharsets.UTF_8));\n\n        // Create an additional file with a matching extension.\n        final Path fileToDeletePath = subDir.resolve(\"fileToDelete.txt\");\n        Files.write(fileToDeletePath, \"delete me\".getBytes(StandardCharsets.UTF_8));\n        final File fileToDelete = fileToDeletePath.toFile();\n\n        final File root = tempDir.toFile();\n        final String[] filterExtensions = {\"txt\"};\n\n        // Verify the initial file count.\n        final Collection<File> initialFilesList = FileUtils.listFiles(root, filterExtensions, true);\n        assertEquals(3, initialFilesList.size(), \"Initial count of '.txt' files should be 3.\");\n\n        // Conditionally skip on Java 24+ due to known platform behavior changes (JDK-8328322).\n        // On these versions, deleting a file while a directory stream is open may not be\n        // reflected in the stream, causing the test to fail.\n        int majorVersion;\n        try {\n            String version = System.getProperty(\"java.version\");\n            if (version.startsWith(\"1.\")) {\n                majorVersion = 8;\n            } else {\n                majorVersion = Integer.parseInt(version.split(\"[.\\\\-_]\")[0]);\n            }\n        } catch (final Exception e) {\n            majorVersion = 8; // Default to a safe version if parsing fails\n        }\n        Assumptions.assumeTrue(majorVersion < 24,\n            \"Test skipped on Java 24+ due to platform-dependent directory stream behavior (JDK-8328322).\");\n\n        final List<File> collectedFiles;\n        // Open a file stream and delete a file within the try-with-resources block.\n        try (final Stream<File> stream = FileUtils.streamFiles(root, true, filterExtensions)) {\n            Files.delete(fileToDeletePath);\n            collectedFiles = stream.collect(Collectors.toList());\n        }\n\n        // Assert that the deleted file does not appear in the collected results.\n        assertFalse(collectedFiles.contains(fileToDelete), \"Deleted file should not be present in the collected list.\");\n\n        // Confirm the expected count of remaining files.\n        assertEquals(2, collectedFiles.size(), \"Should have collected 2 files after one was deleted.\");\n    }\n}",
      "method_signature": "testStreamFilesWithDeletionCollect()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 0.6,
      "assertion_precision": 1.0,
      "callable_recall": 0.6111,
      "callable_precision": 0.3438,
      "focal_recall": 0.6667,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1194,
      "description": "Create a test case to validate the system's ability to enumerate files with specific characteristics while gracefully handling file deletions that occur during the enumeration process. Begin by establishing a file repository containing multiple documents organized in a nested directory structure, including build configuration files, readme documents, and HTML pages distributed across subdirectories and nested subdirectories, with one directory reserved for version control metadata. Before initiating the enumeration, add one additional configuration file to the repository. Confirm the repository initially contains five files matching the specified document types when queried through a standard collection-based listing. Initiate a streaming enumeration of the repository configured to traverse all nested directories and filter for configuration and text documents. Immediately after opening the stream but before consuming its contents, remove the recently added configuration file from the repository to simulate a concurrent deletion scenario. Proceed to consume the stream contents into a collection, noting that on certain system versions this operation may encounter issues with missing files, in which case the test should be skipped. After collecting all available files from the stream, verify the removed file does not appear in the results and confirm the collection contains exactly four files, reflecting the deletion that occurred during enumeration. Ensure the stream is properly closed to release any held file system resources. Use JUnit 5 as the testing framework with AssertJ for standard equality and collection membership assertions, noting that the test includes conditional execution logic to handle platform-specific behavior differences.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsListFilesTest",
      "method_signature": "testStreamFilesWithDeletionForEach()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsFileStreamingTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport org.junit.jupiter.api.Assumptions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests {@link FileUtils} file streaming capabilities, particularly with concurrent modifications.\n */\npublic class FileUtilsFileStreamingTest {\n\n    @TempDir\n    private Path tempDir;\n\n    @Test\n    public void testStreamFilesWithConcurrentDeletion() throws IOException {\n        // Setup repository structure\n        final Path subDir = tempDir.resolve(\"sub\");\n        Files.createDirectory(subDir);\n        final Path nestedDir = subDir.resolve(\"nested\");\n        Files.createDirectory(nestedDir);\n        final Path gitDir = tempDir.resolve(\".git\");\n        Files.createDirectory(gitDir);\n\n        // Populate with initial files\n        FileUtils.writeStringToFile(tempDir.resolve(\"build.gradle\").toFile(), \"apply plugin: 'java'\", StandardCharsets.UTF_8);\n        FileUtils.writeStringToFile(tempDir.resolve(\"README.md\").toFile(), \"Project Readme\", StandardCharsets.UTF_8);\n        FileUtils.writeStringToFile(subDir.resolve(\"index.html\").toFile(), \"<html></html>\", StandardCharsets.UTF_8);\n        FileUtils.writeStringToFile(nestedDir.resolve(\"README.md\").toFile(), \"Nested Readme\", StandardCharsets.UTF_8);\n        FileUtils.writeStringToFile(gitDir.resolve(\"config\").toFile(), \"[core]\", StandardCharsets.UTF_8);\n\n        // Add the file to be deleted during enumeration\n        final File fileToDelete = subDir.resolve(\"build.gradle\").toFile();\n        FileUtils.writeStringToFile(fileToDelete, \"apply plugin: 'groovy'\", StandardCharsets.UTF_8);\n\n        final String[] extensions = {\"gradle\", \"md\", \"html\"};\n\n        // 1. Confirm initial state with a standard collection-based listing\n        final Collection<File> initialFiles = FileUtils.listFiles(tempDir.toFile(), extensions, true);\n        assertThat(initialFiles).hasSize(5);\n        assertThat(initialFiles).contains(fileToDelete);\n\n        // 2. Initiate streaming enumeration and simulate concurrent deletion\n        try (final Stream<File> stream = FileUtils.streamFiles(tempDir.toFile(), true, extensions)) {\n            // Immediately delete the file after opening the stream but before consuming it\n            Files.delete(fileToDelete.toPath());\n\n            List<File> streamedFiles;\n            try {\n                // On some platforms, collecting a stream after a file has been deleted can fail.\n                streamedFiles = stream.collect(Collectors.toList());\n            } catch (final IOException e) {\n                // If an error occurs, we skip the test as this behavior is platform-dependent.\n                Assumptions.assumeTrue(false, \"Skipping test: Deleting a file during stream collection is not supported on this platform. \" + e.getMessage());\n                return;\n            }\n\n            // 3. Verify the results reflect the deletion\n            assertThat(streamedFiles)\n                    .hasSize(4)\n                    .doesNotContain(fileToDelete);\n        }\n    }\n}",
      "method_signature": "testStreamFilesWithDeletionForEach()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18747,
    "output_tokens": 3884,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1199,
      "description": "Define a test method that validates the behavior of the file streaming utility when a file is deleted during iteration over a directory structure. Before the test executes, establish a temporary directory hierarchy containing multiple files and subdirectories: create a root directory with files named \"dummy-build.xml\" and \"README\", then construct a subdirectory \"subdir1\" containing \"dummy-build.xml\" and \"dummy-readme.txt\", followed by a nested subdirectory \"subsubdir1\" holding \"dummy-file.txt\", \"dummy-index.html\", and \"dummy-indexhtml\", and finally add a \"CVS\" directory within \"subdir1\" containing \"Entries\" and \"Repository\" files. Within the test method, define an array of file extensions containing \"xml\" and \"txt\", then create an additional file \"x.xml\" in the temporary directory root and verify its creation succeeds by asserting the creation operation returns true. Invoke the file listing utility on the temporary directory with the extension filter and recursive flag enabled, then assert the resulting collection contains exactly five files. Open a stream over the temporary directory using the streaming utility with the same extension filter and recursive traversal enabled, immediately delete the \"x.xml\" file within the try-with-resources block and assert the deletion succeeds, then initialize an empty list to accumulate stream results. Before consuming the stream, conditionally skip the test execution if the Java runtime version is 24 or higher using an assumption check against the system version utility. Iterate over the stream using a forEach operation that adds each file to the accumulation list, then assert the list does not contain the deleted \"x.xml\" file by checking the list's contains method returns false. After the stream closes automatically via try-with-resources, assert the accumulated list contains exactly four files. This test uses JUnit 5 for test execution and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsListFilesTest",
      "method_signature": "testStreamFilesWithDeletionForEach()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsStreamTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assumptions.assumeFalse;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileUtils} streaming API.\n */\npublic class FileUtilsStreamTest {\n\n    @TempDir\n    public File temporaryFolder;\n\n    @Test\n    public void testFileStreamingWithDeletion() throws IOException {\n        // Setup temporary directory\n        final File root = temporaryFolder;\n        FileUtils.touch(new File(root, \"dummy-build.xml\"));\n        FileUtils.touch(new File(root, \"README\"));\n\n        final File subdir1 = new File(root, \"subdir1\");\n        assertTrue(subdir1.mkdirs());\n        FileUtils.touch(new File(subdir1, \"dummy-build.xml\"));\n        FileUtils.touch(new File(subdir1, \"dummy-readme.txt\"));\n\n        final File subsubdir1 = new File(subdir1, \"subsubdir1\");\n        assertTrue(subsubdir1.mkdirs());\n        FileUtils.touch(new File(subsubdir1, \"dummy-file.txt\"));\n        FileUtils.touch(new File(subsubdir1, \"dummy-index.html\"));\n        FileUtils.touch(new File(subsubdir1, \"dummy-indexhtml\"));\n\n        final File cvs = new File(subdir1, \"CVS\");\n        assertTrue(cvs.mkdirs());\n        FileUtils.touch(new File(cvs, \"Entries\"));\n        FileUtils.touch(new File(cvs, \"Repository\"));\n\n        final String[] extensions = {\"xml\", \"txt\"};\n        final File x = new File(root, \"x.xml\");\n        assertTrue(FileUtils.touch(x));\n\n        final Collection<File> files = FileUtils.listFiles(root, extensions, true);\n        assertEquals(5, files.size());\n\n        final List<File> streamList = new ArrayList<>();\n        try (Stream<File> stream = FileUtils.streamFiles(root, true, extensions)) {\n            assertTrue(x.delete());\n            // This test fails on Java 24, see https://github.com/apache/commons-io/pull/414\n            assumeFalse(System.getProperty(\"java.version\").startsWith(\"24\"), \"Test fails on Java 24.\");\n            stream.forEach(streamList::add);\n        }\n\n        assertFalse(streamList.contains(x));\n        assertEquals(4, streamList.size());\n    }\n}",
      "method_signature": "testStreamFilesWithDeletionForEach()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 17796,
    "output_tokens": 2677,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1201,
      "description": "Create a test case to validate the system's ability to stream and collect file references while gracefully handling concurrent modifications to the underlying file structure during the streaming operation. Establish a temporary workspace containing a hierarchical directory structure with multiple files having various extensions including build configuration files, readme documents, and HTML resources distributed across nested subdirectories, ensuring some directories contain version control metadata. Add a new file with a specific extension to the workspace, then verify the system initially recognizes the expected total count of files matching the target extensions across all subdirectories. Initiate a streaming operation to traverse the workspace recursively and collect all files matching the specified extensions, but immediately after starting the stream, remove the newly added file from the workspace to simulate a concurrent deletion scenario. Since certain runtime environments may encounter issues when streaming over modified file structures, conditionally skip the remainder of the test if the platform version is known to be incompatible with this scenario. Assuming the test proceeds, collect the stream results into a structured collection and confirm that the deleted file does not appear in the final collection, then verify the collection contains exactly the count of files that existed before the additional file was created, demonstrating the system correctly handles files that disappear during iteration. Use JUnit 5 as the testing framework with AssertJ for validating collection contents and counts through standard equality assertions, and leverage platform version detection utilities to conditionally execute portions of the test based on runtime compatibility.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsListFilesTest",
      "method_signature": "testStreamFilesWithDeletionCollect()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.file.PathUtilsConcurrentStreamingTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.file;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Assumptions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests for {@link PathUtils} streaming operations with concurrent file system modifications.\n */\npublic class PathUtilsConcurrentStreamingTest {\n\n    @Test\n    public void testStreamWithConcurrentDeletion(@TempDir final Path tempDir) throws IOException {\n        // 1. Establish a temporary workspace with a hierarchical directory structure.\n        final Path project1 = Files.createDirectory(tempDir.resolve(\"project1\"));\n        final Path project2 = Files.createDirectory(tempDir.resolve(\"project2\"));\n        final Path docs = Files.createDirectory(project2.resolve(\"docs\"));\n        final Path vcs = Files.createDirectory(project1.resolve(\".git\"));\n\n        // Add various file types\n        Files.writeString(project1.resolve(\"build.config\"), \"config\", StandardCharsets.UTF_8); // Will be ignored by extension filter\n        Files.writeString(project1.resolve(\"README.md\"), \"readme\", StandardCharsets.UTF_8);\n        Files.writeString(project2.resolve(\"index.html\"), \"body\", StandardCharsets.UTF_8);\n        Files.writeString(vcs.resolve(\"HEAD\"), \"ref: main\", StandardCharsets.UTF_8); // Will be ignored\n\n        // 2. Define target extensions and create a filter.\n        final String[] targetExtensions = {\".md\", \".html\"};\n        final PathFilter extensionFilter = (path, attributes) ->\n            attributes.isRegularFile() && Arrays.stream(targetExtensions).anyMatch(ext -> path.getFileName().toString().endsWith(ext));\n\n        // 3. Add a new file and verify the initial count.\n        final Path newFile = docs.resolve(\"temporary.html\");\n        final long initialFileCount;\n        try (final Stream<Path> stream = PathUtils.walk(tempDir, extensionFilter, Integer.MAX_VALUE, false)) {\n            initialFileCount = stream.count();\n        }\n\n        Files.writeString(newFile, \"temp content\", StandardCharsets.UTF_8);\n        final long totalExpectedCount;\n        try (final Stream<Path> stream = PathUtils.walk(tempDir, extensionFilter, Integer.MAX_VALUE, false)) {\n            totalExpectedCount = stream.count();\n        }\n        assertThat(totalExpectedCount).isEqualTo(initialFileCount + 1);\n\n        // 4. Conditionally skip on incompatible Java versions.\n        // Files.walk behavior on concurrent modification is not specified and can be platform-dependent.\n        // We assume modern JDKs are more robust and demonstrate conditional execution.\n        try {\n            final String specVersion = System.getProperty(\"java.specification.version\");\n            Assumptions.assumeTrue(Float.parseFloat(specVersion) >= 11,\n                \"Skipping test on Java < 11 due to potential filesystem stream instability.\");\n        } catch (final NumberFormatException e) {\n            Assumptions.abort(\"Could not determine Java specification version to assess stream reliability.\");\n        }\n\n        // 5. Initiate stream, concurrently delete the new file, and collect results.\n        final AtomicBoolean fileWasDeleted = new AtomicBoolean(false);\n        final List<Path> collectedPaths;\n        try (final Stream<Path> stream = PathUtils.walk(tempDir, extensionFilter, Integer.MAX_VALUE, false)) {\n            collectedPaths = stream.peek(path -> {\n                if (fileWasDeleted.compareAndSet(false, true)) {\n                    try {\n                        Files.delete(newFile);\n                    } catch (final IOException e) {\n                        throw new UncheckedIOException(e);\n                    }\n                }\n            }).collect(Collectors.toList());\n        }\n\n        // 6. Verify the collection does not contain the deleted file and has the original count.\n        assertThat(collectedPaths)\n            .hasSize((int) initialFileCount)\n            .doesNotContain(newFile);\n    }\n}",
      "method_signature": "testStreamFilesWithDeletionCollect()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 24333,
    "output_tokens": 9540,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1203,
      "description": "Create a test case to validate the file system's ability to stream files while handling concurrent deletions during iteration. Before testing, establish a temporary workspace containing a multi-level directory structure with various file types including build configuration files, documentation, and nested subdirectories holding additional content and version control artifacts. Once the workspace is ready, introduce a new file with a specific extension into the root workspace and verify the system initially recognizes the expected total count of files matching the target extensions across all levels. After confirming the baseline count, initiate a streaming operation that traverses the workspace recursively to locate all files matching the specified extensions, then immediately remove the newly added file from the workspace while the stream remains active to simulate a concurrent deletion scenario. With the stream open, convert it to an iterator and collect all discovered files into a working list, ensuring the test environment accommodates platform-specific behavior by skipping execution on newer runtime versions where file system changes during iteration may trigger failures. Once all available files are gathered, verify the deleted file does not appear in the collected results and confirm the final count reflects only the original files that remained present throughout the traversal, demonstrating the system gracefully handles missing files encountered during streaming without disrupting the overall operation. Validate outcomes using JUnit 5 with standard equality and boolean assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsListFilesTest",
      "method_signature": "testStreamFilesWithDeletionIterator()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsFileStreamingTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.filefilter.IOFileFilter;\nimport org.apache.commons.io.filefilter.SuffixFileFilter;\nimport org.apache.commons.io.filefilter.TrueFileFilter;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.condition.EnabledOnJre;\nimport org.junit.jupiter.api.condition.JRE;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileUtils} streaming methods with concurrent file system modifications.\n */\npublic class FileUtilsFileStreamingTest {\n\n    @TempDir\n    private Path workspace;\n\n    /**\n     * Tests that a file deleted during a streaming operation is not included in the final result.\n     * This test simulates a scenario where the file system is modified while an iterator from\n     * a stream is traversing it.\n     * <p>\n     * NOTE: This test is enabled only on JRE 8. The behavior of file system iterators when the\n     * underlying directory is modified during iteration is not guaranteed across different Java\n     * versions and operating systems, and may lead to exceptions on newer JREs.\n     * </p>\n     *\n     * @throws IOException if an I/O error occurs during test setup or execution.\n     */\n    @Test\n    @EnabledOnJre(JRE.JAVA_8)\n    public void testStreamFilesWithConcurrentDeletion() throws IOException {\n        // 1. Establish a temporary workspace with a multi-level directory structure and various file types.\n        final Path nestedDir = Files.createDirectories(workspace.resolve(\"docs\").resolve(\"nested\"));\n        Files.createFile(workspace.resolve(\"build-config.xml\")); // Build configuration\n        Files.write(workspace.resolve(\"README.md\"), \"Main documentation\".getBytes(StandardCharsets.UTF_8));\n        Files.createDirectory(workspace.resolve(\".git\")); // VCS artifact\n        Files.write(nestedDir.resolve(\"details.md\"), \"Nested content\".getBytes(StandardCharsets.UTF_8));\n\n        // 2. Introduce a new file with a specific extension to be deleted concurrently.\n        final String[] targetExtensions = {\".xml\", \".md\", \".new\"};\n        final Path fileToDelele = Files.createFile(workspace.resolve(\"ephemeral.new\"));\n        final File fileToDeleteAsFile = fileToDelele.toFile();\n\n        // 3. Verify the baseline count of files matching the target extensions.\n        final IOFileFilter fileFilter = new SuffixFileFilter(targetExtensions);\n        final Collection<File> initialFiles = FileUtils.listFiles(workspace.toFile(), fileFilter, TrueFileFilter.INSTANCE);\n        assertEquals(4, initialFiles.size(), \"Should find 3 existing files plus the 1 newly added file\");\n\n        final List<File> collectedFiles = new ArrayList<>();\n        // 4. Initiate a streaming operation and immediately delete the new file while the stream is active.\n        try (Stream<File> stream = FileUtils.streamFiles(workspace.toFile(), fileFilter, TrueFileFilter.INSTANCE)) {\n            // Simulate concurrent deletion while the stream is open but before iteration begins.\n            Files.delete(fileToDelele);\n\n            // 5. Convert the stream to an iterator and collect all discovered files.\n            final Iterator<File> iterator = stream.iterator();\n            iterator.forEachRemaining(collectedFiles::add);\n        }\n\n        // 6. Validate the outcomes.\n        assertFalse(collectedFiles.contains(fileToDeleteAsFile),\n            \"The concurrently deleted file should not appear in the collected results.\");\n        assertEquals(3, collectedFiles.size(),\n            \"The final count should reflect only the original files that remained present throughout the traversal.\");\n    }\n}",
      "method_signature": "testStreamFilesWithDeletionIterator()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 54683,
    "output_tokens": 8287,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1204,
      "description": "Create a test case to validate that the system correctly rejects attempts to convert excessively large data streams into memory-resident collections when the stream size exceeds the platform's safe array capacity threshold, ensuring protection against memory allocation failures. Configure a simulated data stream scenario where the underlying stream processing mechanism reports a content size that surpasses the maximum safe array length supported by the platform, then attempt to convert this oversized stream into a memory collection and verify the system rejects this operation with a failure indicating the size limit was exceeded. After capturing the failure, confirm the error message explicitly communicates the maximum permissible size threshold to inform the caller why the operation was denied. The test uses JUnit 5 as the testing framework, Mockito for simulating stream behavior and controlling reported sizes, and standard assertion methods to verify both the expected failure type and the presence of the size limit in the error message.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testToByteArray_ThrowsIOExceptionOnHugeStream()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsToByteArrayTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport org.junit.jupiter.api.Test;\nimport java.io.InputStream;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.mock;\n\n/**\n * Tests for {@link IOUtils} that involve very large stream sizes.\n */\npublic class IOUtilsToByteArrayTest {\n\n    @Test\n    public void testToByteArrayThrowsOnSizeGreaterThanIntegerMaxValue() {\n        // Define a size that exceeds the maximum safe array length\n        final long oversizedSize = (long) Integer.MAX_VALUE + 1;\n        final InputStream mockInputStream = mock(InputStream.class);\n\n        // Attempt to convert the oversized stream and expect a failure\n        final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () -> {\n            IOUtils.toByteArray(mockInputStream, oversizedSize);\n        });\n\n        // Confirm the error message communicates the size limit was exceeded\n        final String expectedMessage = \"Size cannot be greater than Integer max value: \" + oversizedSize;\n        assertEquals(expectedMessage, thrown.getMessage());\n    }\n}",
      "method_signature": "testToByteArray_ThrowsIOExceptionOnHugeStream()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 0.5,
      "assertion_precision": 0.5,
      "callable_recall": 0.1875,
      "callable_precision": 0.6,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.0833,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 24937,
    "output_tokens": 3597,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1205,
      "description": "Create a test case to validate that the system correctly processes multi-line text data when transmitted through a queue-based communication channel with various input patterns. Configure the communication mechanism with an extended timeout period to ensure ample processing time, then establish a paired input and output channel where data written to one side becomes immediately available for reading on the other. For each variation of input text provided to the test, split the content into individual lines and process them sequentially by writing each line to the output channel followed by a line separator, then immediately reading the corresponding line from the input channel and verifying that the retrieved content exactly matches what was sent, ensuring the system preserves data integrity and line boundaries throughout the transmission process. After validating all input variations, release the communication channels to free system resources. Use JUnit 5 with parameterized test capabilities to exercise multiple input scenarios, and verify correctness using standard equality assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.QueueInputStreamTest",
      "method_signature": "testReadLineByLineQueue(java.lang.String)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.QueueStreamTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.io.output.QueueOutputStream;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\n/**\n * Tests {@link QueueInputStream} and {@link QueueOutputStream}.\n */\npublic class QueueStreamTest {\n\n    @ParameterizedTest\n    @ValueSource(strings = {\n        \"line1\nline2\nline3\",\n        \"line1\nline2\nline3\",\n        \"A single line\",\n        \"\",\n        \"line1\n\nline3\",\n        \"line1\nline2\n\"\n    })\n    public void testMultiLineDataTransfer(final String text) throws Exception {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        final long timeout = 2000; // Extended timeout\n\n        try (\n            final QueueOutputStream output = QueueOutputStream.builder()\n                .setBlockingQueue(queue)\n                .setTimeout(timeout, TimeUnit.MILLISECONDS)\n                .get();\n            final QueueInputStream input = QueueInputStream.builder()\n                .setBlockingQueue(queue)\n                .setTimeout(timeout, TimeUnit.MILLISECONDS)\n                .get();\n            final PrintWriter writer = new PrintWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));\n            final BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8))\n        ) {\n            final String[] lines = text.split(\"\\R\", -1);\n            for (final String line : lines) {\n                writer.println(line);\n                writer.flush();\n                final String readLine = reader.readLine();\n                assertEquals(line, readLine);\n            }\n            // Ensure no more data is in the stream\n            assertNull(reader.readLine(), \"Stream should be empty after processing all lines\");\n        }\n    }\n}",
      "method_signature": "testReadLineByLineQueue(java.lang.String)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19082,
    "output_tokens": 4406,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1206,
      "description": "Define a test method that validates the behavior of the IOUtils byte array conversion when the internal output stream exceeds the maximum allowed array length, ensuring an IOException is thrown with a descriptive message. Begin by establishing a static mock of the IOUtils class configured to call real methods for all invocations except those explicitly stubbed, then create a mock instance of UnsynchronizedByteArrayOutputStream. Configure the static mock to intercept calls to the copyToOutputStream method, instructing it to accept any InputStream, any long value representing a size limit, and any integer buffer size, then return the mocked output stream. Stub the size method on the mocked output stream to return a value one greater than the soft maximum array length constant defined in IOUtils. With the mocks configured, create a mock InputStream to serve as the input source for the conversion operation. Invoke the toByteArray method on IOUtils with the mock input stream, capturing the IOException that is expected to be thrown due to the oversized output stream. Assert that the exception is of type IOException and verify that its message contains a formatted representation of the soft maximum array length constant, confirming that the error message communicates the size constraint violation to the caller. Close all resources including the static mock, the mocked output stream, and the mock input stream to ensure proper cleanup. This test uses JUnit 5 for assertions and Mockito for mocking and static method interception.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testToByteArray_ThrowsIOExceptionOnHugeStream()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsByteArrayCreationTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.mock;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link IOUtils} byte array conversion.\n */\npublic class IOUtilsByteArrayCreationTest {\n\n    @Test\n    public void testToByteArrayWithLargeSizeShouldThrowIOException() {\n        // Create a size that is one greater than the soft maximum array length.\n        final long sizeToTriggerError = (long) IOUtils.SOFT_MAX_ARRAY_LENGTH + 1;\n        final InputStream mockInputStream = mock(InputStream.class);\n\n        // Assert that calling toByteArray with a size exceeding the soft limit throws an IOException.\n        final IOException exception = assertThrows(IOException.class, () -> {\n            IOUtils.toByteArray(mockInputStream, sizeToTriggerError);\n        });\n\n        // Verify the exception message contains the soft max array length value, ensuring the error is informative.\n        final String expectedMessagePart = String.valueOf(IOUtils.SOFT_MAX_ARRAY_LENGTH);\n        assertTrue(exception.getMessage().contains(expectedMessagePart),\n                \"Exception message should contain the soft max array length limit.\");\n    }\n}",
      "method_signature": "testToByteArray_ThrowsIOExceptionOnHugeStream()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.3125,
      "callable_precision": 0.7143,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 41078,
    "output_tokens": 9381,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1207,
      "description": "Define a test class containing a public field `temporaryFolder` of type `java.io.File` annotated with `@TempDir`, then implement a setup method annotated with `@BeforeEach` that assigns `temporaryFolder` to a local variable `dir` of type `java.io.File`, creates a new `File` instance `file` by invoking the constructor with arguments `dir` and String literal `\"dummy-build.xml\"`, invokes `FileUtils.touch(file)` to create the file, reassigns `file` to a new `File` instance constructed with `dir` and `\"README\"`, invokes `FileUtils.touch(file)` again, reassigns `dir` to a new `File` instance constructed with the current `dir` and `\"subdir1\"`, invokes `dir.mkdirs()` to create the directory, reassigns `file` to a new `File` with `dir` and `\"dummy-build.xml\"`, invokes `FileUtils.touch(file)`, reassigns `file` to a new `File` with `dir` and `\"dummy-readme.txt\"`, invokes `FileUtils.touch(file)`, reassigns `dir` to a new `File` with the current `dir` and `\"subsubdir1\"`, invokes `dir.mkdirs()`, reassigns `file` to a new `File` with `dir` and `\"dummy-file.txt\"`, invokes `FileUtils.touch(file)`, reassigns `file` to a new `File` with `dir` and `\"dummy-index.html\"`, invokes `FileUtils.touch(file)`, reassigns `file` to a new `File` with `dir` and `\"dummy-indexhtml\"`, invokes `FileUtils.touch(file)`, reassigns `dir` by invoking `dir.getParentFile()`, reassigns `dir` to a new `File` with the current `dir` and `\"CVS\"`, invokes `dir.mkdirs()`, reassigns `file` to a new `File` with `dir` and `\"Entries\"`, invokes `FileUtils.touch(file)`, reassigns `file` to a new `File` with `dir` and `\"Repository\"`, and invokes `FileUtils.touch(file)` to complete the directory structure. Within the test method annotated with `@Test` and declaring `throws IOException`, declare a String array `extensions` initialized to `{ \"xml\", \"txt\" }`, create a `File` instance `xFile` by invoking the constructor with `temporaryFolder` and `\"x.xml\"`, invoke `xFile.createNewFile()` and if the result is false, invoke `fail` with the concatenated message `\"could not create test file: \" + xFile`, then invoke `FileUtils.listFiles(temporaryFolder, extensions, true)` and assign the result to a `Collection<File>` variable `files`, assert equality by invoking `assertEquals(5, files.size())`, declare a `List<File>` variable `list` without initialization, open a try-with-resources block by invoking `FileUtils.streamFiles(temporaryFolder, true, extensions)` and assigning the result to a `Stream<File>` variable `stream`, immediately invoke `xFile.delete()` and assert the result is true using `assertTrue`, assign `list` to a new `ArrayList<>()` instance, invoke `SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_24)` and pass the result to `assumeFalse` to conditionally skip the test on Java 24 and above, invoke `stream.forEach(list::add)` to populate the list, invoke `assertFalse(list.contains(xFile), list::toString)` to verify `xFile` is not in the list, close the try-with-resources block, and finally invoke `assertEquals(4, list.size())` to verify the list contains exactly four files. The test uses JUnit 5 assertions and the `@Test` annotation with no class-level annotations.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsListFilesTest",
      "method_signature": "testStreamFilesWithDeletionForEach()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsFileNewTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\nimport static org.junit.jupiter.api.Assumptions.assumeFalse;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.lang3.JavaVersion;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileUtils}.\n */\npublic class FileUtilsFileNewTest {\n\n    @TempDir\n    public File temporaryFolder;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        File dir = temporaryFolder;\n        File file = new File(dir, \"dummy-build.xml\");\n        FileUtils.touch(file);\n        file = new File(dir, \"README\");\n        FileUtils.touch(file);\n        dir = new File(dir, \"subdir1\");\n        dir.mkdirs();\n        file = new File(dir, \"dummy-build.xml\");\n        FileUtils.touch(file);\n        file = new File(dir, \"dummy-readme.txt\");\n        FileUtils.touch(file);\n        dir = new File(dir, \"subsubdir1\");\n        dir.mkdirs();\n        file = new File(dir, \"dummy-file.txt\");\n        FileUtils.touch(file);\n        file = new File(dir, \"dummy-index.html\");\n        FileUtils.touch(file);\n        file = new File(dir, \"dummy-indexhtml\");\n        FileUtils.touch(file);\n        dir = dir.getParentFile();\n        dir = new File(dir, \"CVS\");\n        dir.mkdirs();\n        file = new File(dir, \"Entries\");\n        FileUtils.touch(file);\n        file = new File(dir, \"Repository\");\n        FileUtils.touch(file);\n    }\n\n    @Test\n    public void testListFilesWithStream() throws IOException {\n        final String[] extensions = { \"xml\", \"txt\" };\n        final File xFile = new File(temporaryFolder, \"x.xml\");\n        if (!xFile.createNewFile()) {\n            fail(\"could not create test file: \" + xFile);\n        }\n        final Collection<File> files = FileUtils.listFiles(temporaryFolder, extensions, true);\n        assertEquals(5, files.size());\n\n        List<File> list;\n        try (Stream<File> stream = FileUtils.streamFiles(temporaryFolder, true, extensions)) {\n            assertTrue(xFile.delete());\n            list = new ArrayList<>();\n            assumeFalse(SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_24));\n            stream.forEach(list::add);\n            assertFalse(list.contains(xFile), list::toString);\n        }\n        assertEquals(4, list.size());\n    }\n}",
      "method_signature": "testStreamFilesWithDeletionForEach()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 26493,
    "output_tokens": 2660,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1209,
      "description": "Define a parameterized test method that accepts a string input representing multi-line text data, then initialize a blocking queue of integers to serve as the underlying buffer for stream communication. Build a Queue Input Stream using the builder pattern by configuring it with the blocking queue and setting a timeout duration of one hour, then obtain a connected Queue Output Stream from the input stream to establish bidirectional communication between the two stream components. Within a try-with-resources block managing both streams, delegate to a private helper method that orchestrates the line-by-line reading and writing workflow, where this helper splits the input data into individual lines, wraps the input stream in a buffered reader configured with UTF-8 encoding, and iterates through each line by writing the line's bytes followed by a newline character to the output stream, immediately reading the corresponding line from the buffered reader, and asserting that the read line matches the original line to verify that data written to the output stream is correctly transmitted through the shared queue and read back from the input stream. Upon completion of all line validations, allow the try-with-resources construct to automatically close both stream resources. This test validates the queue-based stream communication mechanism across multiple input variations using JUnit 5 for parameterization and standard JUnit assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.QueueInputStreamTest",
      "method_signature": "testReadLineByLineQueue(java.lang.String)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.QueueInputStreamTest1",
      "code": "package org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.output.QueueOutputStream;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests for {@link QueueInputStream}.\n */\npublic class QueueInputStreamTest1 {\n\n    private static final String LOREM_IPSUM = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\";\n\n    static Stream<String> multiLineProvider() {\n        return Stream.of(\n            LOREM_IPSUM + \"\\n\" + LOREM_IPSUM,\n            \"single line\",\n            \"\",\n            \"line 1\\nline 2\\nline 3\"\n        );\n    }\n\n    private void conductReadWrite(final String data, final QueueInputStream in, final QueueOutputStream out) throws IOException {\n        final String[] lines = data.split(\"\\n\");\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {\n            for (final String line : lines) {\n                out.write(line.getBytes(StandardCharsets.UTF_8));\n                out.write('\\n');\n                assertEquals(line, reader.readLine());\n            }\n        }\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"multiLineProvider\")\n    public void testStreamCommunication(final String multiLineData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (QueueInputStream inputStream = QueueInputStream.builder()\n                .setBlockingQueue(queue)\n                .setTimeout(Duration.ofHours(1))\n                .get();\n             QueueOutputStream outputStream = inputStream.newQueueOutputStream()) {\n            conductReadWrite(multiLineData, inputStream, outputStream);\n        }\n    }\n}",
      "method_signature": "testReadLineByLineQueue(java.lang.String)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.7059,
      "callable_precision": 0.75,
      "focal_recall": 1.0,
      "focal_precision": 0.7143
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1210,
      "description": "Create a test case to validate that the system correctly preserves parallel processing capabilities and accurately counts elements when adapting data streams for specialized input/output operations. Begin by configuring an adapted stream with no elements that supports parallel processing, then verify the system recognizes the parallel processing mode is active and confirms the element count registers as zero. After establishing this baseline behavior, prepare a second adapted stream containing a single text element while maintaining parallel processing capabilities, ensuring the system still recognizes parallel processing remains enabled and accurately reports the element count as one. This validation confirms the adaptation process maintains both the parallel execution characteristics and element counting accuracy regardless of whether the stream contains data or is empty. Use JUnit 5 as the testing framework with standard equality and boolean assertions to verify the parallel processing state and element counts match expected values.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOStreamTest",
      "method_signature": "testAdaptParallelAndCount()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.function.IOStreamTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link IOStream}.\n */\npublic class IOStreamTest1 {\n\n    @Test\n    public void testStreamAdapterPreservesParallelAndCount() {\n        // Configure an adapted stream with no elements that supports parallel processing\n        try (final IOStream<String> adaptedStream = new IOStream<>(Stream.<String>empty().parallel())) {\n            // Verify the system recognizes the parallel processing mode is active\n            assertTrue(adaptedStream.isParallel(), \"Parallel processing should be active for empty stream\");\n            // Confirm the element count registers as zero\n            assertEquals(0, adaptedStream.count(), \"Element count should be zero for empty stream\");\n        }\n\n        // Prepare a second adapted stream containing a single text element\n        try (final IOStream<String> adaptedStream = new IOStream<>(Stream.of(\"one\").parallel())) {\n            // Ensure the system still recognizes parallel processing remains enabled\n            assertTrue(adaptedStream.isParallel(), \"Parallel processing should be active for single-element stream\");\n            // Accurately report the element count as one\n            assertEquals(1, adaptedStream.count(), \"Element count should be one for single-element stream\");\n        }\n    }\n}",
      "method_signature": "testAdaptParallelAndCount()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20846,
    "output_tokens": 6194,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1211,
      "description": "Define a test method that validates file streaming behavior when a file is deleted during iteration by first establishing a temporary directory structure containing multiple files and subdirectories through a setup method that creates a root directory with files named \"dummy-build.xml\" and \"README\", a subdirectory \"subdir1\" containing \"dummy-build.xml\" and \"dummy-readme.txt\", a nested \"subsubdir1\" with \"dummy-file.txt\", \"dummy-index.html\", and \"dummy-indexhtml\", and a \"CVS\" directory with \"Entries\" and \"Repository\" files, all created using the FileUtils touch utility. Within the test method, define an array of file extensions containing \"xml\" and \"txt\", then create an additional file \"x.xml\" in the temporary directory root and verify its creation succeeds by asserting the createNewFile result is true, failing the test if creation fails. Invoke FileUtils listFiles on the temporary directory with the extension filter and recursive traversal enabled to establish a baseline count, asserting that exactly five files match the criteria. Open a try-with-resources block that invokes FileUtils streamFiles on the temporary directory with recursive traversal and the extension filter, obtaining a file stream, then immediately delete the \"x.xml\" file within the resource block and assert the deletion succeeds. Initialize an empty list to accumulate files and obtain an iterator from the stream, then conditionally skip iteration if the Java version is 24 or higher by using an assumption that the version is below Java 24, as the iterator behavior changes in newer versions. Iterate through the stream using the iterator's hasNext and next methods to populate the list with discovered files, then assert that the accumulated list does not contain the deleted \"x.xml\" file by verifying its absence with a contains check that provides the list's string representation as a failure message. Upon closing the try-with-resources block, verify that the final list size is exactly four files, confirming that the deleted file was excluded from the iteration results while the remaining matching files were successfully collected. The test uses JUnit 5 for assertions and test execution.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsListFilesTest",
      "method_signature": "testStreamFilesWithDeletionIterator()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsFileStreamingTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Assumptions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileUtils#streamFiles(File, boolean, String...)}.\n */\npublic class FileUtilsFileStreamingTest {\n\n    @TempDir\n    private File testDir;\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        final File subdir1 = new File(testDir, \"subdir1\");\n        assertTrue(subdir1.mkdirs(), \"Failed to create subdir1\");\n        final File subsubdir1 = new File(subdir1, \"subsubdir1\");\n        assertTrue(subsubdir1.mkdirs(), \"Failed to create subsubdir1\");\n        final File cvs = new File(subdir1, \"CVS\");\n        assertTrue(cvs.mkdirs(), \"Failed to create CVS\");\n\n        FileUtils.touch(new File(testDir, \"dummy-build.xml\"));\n        FileUtils.touch(new File(testDir, \"README\"));\n        FileUtils.touch(new File(subdir1, \"dummy-build.xml\"));\n        FileUtils.touch(new File(subdir1, \"dummy-readme.txt\"));\n        FileUtils.touch(new File(subsubdir1, \"dummy-file.txt\"));\n        FileUtils.touch(new File(subsubdir1, \"dummy-index.html\"));\n        FileUtils.touch(new File(subsubdir1, \"dummy-indexhtml\"));\n        FileUtils.touch(new File(cvs, \"Entries\"));\n        FileUtils.touch(new File(cvs, \"Repository\"));\n    }\n\n    private static int getJavaVersion() {\n        String version = System.getProperty(\"java.version\");\n        if (version.startsWith(\"1.\")) {\n            version = version.substring(2, 3);\n        } else {\n            final int dot = version.indexOf(\".\");\n            if (dot != -1) {\n                version = version.substring(0, dot);\n            }\n        }\n        // Should handle versions like \"21-ea\"\n        final int dash = version.indexOf(\"-\");\n        if (dash != -1) {\n            version = version.substring(0, dash);\n        }\n        return Integer.parseInt(version);\n    }\n\n    @Test\n    public void testStreamFilesWithDeletion() throws IOException {\n        final String[] extensions = { \"xml\", \"txt\" };\n\n        final File x = new File(testDir, \"x.xml\");\n        try {\n            assertTrue(x.createNewFile(), \"Failed to create x.xml\");\n        } catch (final IOException e) {\n            fail(\"Failed to create x.xml\", e);\n        }\n\n        final Collection<File> listFiles = FileUtils.listFiles(testDir, extensions, true);\n        assertEquals(5, listFiles.size(), \"Baseline count of files should be 5\");\n\n        try (final Stream<File> stream = FileUtils.streamFiles(testDir, true, extensions)) {\n            assertTrue(x.delete(), \"Failed to delete x.xml\");\n            \n            final List<File> list = new ArrayList<>();\n            final Iterator<File> iterator = stream.iterator();\n            \n            // This behavior is different in Java 24+, so we only run the test up to Java 23\n            Assumptions.assumeTrue(getJavaVersion() < 24, \"Test skipped on Java 24+ due to iterator behavior changes\");\n            \n            while (iterator.hasNext()) {\n                list.add(iterator.next());\n            }\n            \n            assertFalse(list.contains(x), \"List should not contain deleted file: \" + list.toString());\n            assertEquals(4, list.size(), \"List size should be 4 after deleting one file during streaming\");\n        }\n    }\n}",
      "method_signature": "testStreamFilesWithDeletionIterator()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.8333,
      "callable_recall": 0.8571,
      "callable_precision": 0.6,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 37396,
    "output_tokens": 10277,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1213,
      "description": "Define a test method that verifies the IOStream adapter correctly preserves parallel execution mode and element count when wrapping standard Java streams. Begin by constructing an empty parallel stream and adapting it using the IOStream adapter, then immediately validate that the adapted stream reports parallel execution mode before invoking its count operation to confirm it returns zero elements. Following this verification, create a single-element parallel stream containing a string value and adapt it through the same IOStream adapter, again confirming the adapted stream maintains parallel execution characteristics before counting its elements to verify the result is one. The test exercises the adapter's capability to preserve both the parallelism flag and terminal operation behavior across two distinct scenarios\u2014an empty stream and a populated stream\u2014ensuring the wrapper maintains fidelity to the underlying stream's configuration and element count. This test uses JUnit 5 for the test framework and standard assertion methods for validation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOStreamTest",
      "method_signature": "testAdaptParallelAndCount()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.function.IOStreamTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link IOStream}.\n */\npublic class IOStreamTest1 {\n\n    @Test\n    public void testAdaptFromParallelStream() {\n        // checks that IOStream preserves the parallel flag and element count from an empty stream\n        try (Stream<Object> stream = Stream.empty().parallel()) {\n            final IOStream<Object> ioStream = new IOStream<>(stream);\n            assertTrue(ioStream.isParallel(), \"Expected adapted stream to be parallel\");\n            assertEquals(0, ioStream.count(), \"Expected adapted stream to have zero elements\");\n        }\n\n        // checks that IOStream preserves the parallel flag and element count from a single-element stream\n        try (Stream<String> stream = Stream.of(\"test\").parallel()) {\n            final IOStream<String> ioStream = new IOStream<>(stream);\n            assertTrue(ioStream.isParallel(), \"Expected adapted stream to be parallel\");\n            assertEquals(1, ioStream.count(), \"Expected adapted stream to have one element\");\n        }\n    }\n}",
      "method_signature": "testAdaptParallelAndCount()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 39972,
    "output_tokens": 6428,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1214,
      "description": "Define a test class containing a public field `temporaryFolder` of type `java.io.File` annotated with `@TempDir`, then implement a setup method annotated with `@BeforeEach` that assigns `temporaryFolder` to a local variable `dir`, creates a new `File` instance with arguments `dir` and `\"dummy-build.xml\"` assigned to `file`, invokes `FileUtils.touch(file)`, reassigns `file` to a new `File` with arguments `dir` and `\"README\"`, invokes `FileUtils.touch(file)`, reassigns `dir` to a new `File` with arguments `dir` and `\"subdir1\"`, invokes `mkdirs()` on `dir`, reassigns `file` to a new `File` with arguments `dir` and `\"dummy-build.xml\"`, invokes `FileUtils.touch(file)`, reassigns `file` to a new `File` with arguments `dir` and `\"dummy-readme.txt\"`, invokes `FileUtils.touch(file)`, reassigns `dir` to a new `File` with arguments `dir` and `\"subsubdir1\"`, invokes `mkdirs()` on `dir`, reassigns `file` to a new `File` with arguments `dir` and `\"dummy-file.txt\"`, invokes `FileUtils.touch(file)`, reassigns `file` to a new `File` with arguments `dir` and `\"dummy-index.html\"`, invokes `FileUtils.touch(file)`, reassigns `file` to a new `File` with arguments `dir` and `\"dummy-indexhtml\"`, invokes `FileUtils.touch(file)`, reassigns `dir` by invoking `getParentFile()` on `dir`, reassigns `dir` to a new `File` with arguments `dir` and `\"CVS\"`, invokes `mkdirs()` on `dir`, reassigns `file` to a new `File` with arguments `dir` and `\"Entries\"`, invokes `FileUtils.touch(file)`, reassigns `file` to a new `File` with arguments `dir` and `\"Repository\"`, and invokes `FileUtils.touch(file)`. Write a test method annotated with `@Test` that declares a `String[]` variable `extensions` initialized to the array literal `{ \"xml\", \"txt\" }`, creates a new `File` instance `xFile` with arguments `temporaryFolder` and `\"x.xml\"`, invokes `createNewFile()` on `xFile` and if the result is `false` invokes `fail` with the concatenated string `\"could not create test file: \"` plus `xFile`, then invokes `FileUtils.listFiles` with arguments `temporaryFolder`, `extensions`, and boolean `true`, assigning the result to `files` of type `Collection<File>`, immediately invokes `assertEquals` with arguments `5` and `files.size()`, declares a `List<File>` variable `list` without initialization, opens a try-with-resources block that invokes `FileUtils.streamFiles` with arguments `temporaryFolder`, boolean `true`, and `extensions`, assigning the result to `stream` of type `Stream<File>`, within the try block invokes `assertTrue` with the result of `xFile.delete()`, invokes `assumeFalse` with the result of `SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_24)`, invokes `collect` on `stream` passing `Collectors.toList()` and assigns the result to `list`, invokes `assertFalse` with arguments `list.contains(xFile)` and a method reference `list::toString`, and after the try-with-resources block invokes `assertEquals` with arguments `4` and `list.size()`. The test method declares `throws IOException`. Class-level annotations: none. Method-level annotations: `@Test`. Assertion library: JUnit 5 Assertions. Mocking library: none.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsListFilesTest",
      "method_signature": "testStreamFilesWithDeletionCollect()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsListFilesTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\nimport static org.junit.jupiter.api.Assumptions.assumeFalse;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.lang3.JavaVersion;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileUtils} file filter methods.\n */\npublic class FileUtilsListFilesTest1 {\n\n    @TempDir\n    public File temporaryFolder;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        File dir = temporaryFolder;\n        File file = new File(dir, \"dummy-build.xml\");\n        FileUtils.touch(file);\n        file = new File(dir, \"README\");\n        FileUtils.touch(file);\n        dir = new File(dir, \"subdir1\");\n        dir.mkdirs();\n        file = new File(dir, \"dummy-build.xml\");\n        FileUtils.touch(file);\n        file = new File(dir, \"dummy-readme.txt\");\n        FileUtils.touch(file);\n        dir = new File(dir, \"subsubdir1\");\n        dir.mkdirs();\n        file = new File(dir, \"dummy-file.txt\");\n        FileUtils.touch(file);\n        file = new File(dir, \"dummy-index.html\");\n        FileUtils.touch(file);\n        file = new File(dir, \"dummy-indexhtml\");\n        FileUtils.touch(file);\n        dir = dir.getParentFile();\n        dir = new File(dir, \"CVS\");\n        dir.mkdirs();\n        file = new File(dir, \"Entries\");\n        FileUtils.touch(file);\n        file = new File(dir, \"Repository\");\n        FileUtils.touch(file);\n    }\n\n    @Test\n    public void testListFilesWithStream() throws IOException {\n        final String[] extensions = { \"xml\", \"txt\" };\n        final File xFile = new File(temporaryFolder, \"x.xml\");\n        if (!xFile.createNewFile()) {\n            fail(\"could not create test file: \" + xFile);\n        }\n        final Collection<File> files = FileUtils.listFiles(temporaryFolder, extensions, true);\n        assertEquals(5, files.size());\n\n        List<File> list;\n        try (final Stream<File> stream = FileUtils.streamFiles(temporaryFolder, true, extensions)) {\n            assertTrue(xFile.delete());\n            // This test will fail on Java 24+\n            assumeFalse(SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_24));\n            list = stream.collect(Collectors.toList());\n        }\n        assertFalse(list.contains(xFile), list::toString);\n        assertEquals(4, list.size());\n    }\n}",
      "method_signature": "testStreamFilesWithDeletionCollect()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19002,
    "output_tokens": 3045,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1216,
      "description": "Define a test class containing a public field `temporaryFolder` of type `java.io.File` annotated with `@TempDir`, then implement a setup method annotated with `@BeforeEach` that assigns `temporaryFolder` to a local variable `dir`, constructs a new `File` with arguments `dir` and String literal `\"dummy-build.xml\"` assigning it to `file`, invokes `FileUtils.touch(file)`, reassigns `file` to a new `File` with arguments `dir` and `\"README\"`, invokes `FileUtils.touch(file)`, reassigns `dir` to a new `File` with arguments `dir` and `\"subdir1\"`, invokes `mkdirs()` on `dir`, reassigns `file` to a new `File` with arguments `dir` and `\"dummy-build.xml\"`, invokes `FileUtils.touch(file)`, reassigns `file` to a new `File` with arguments `dir` and `\"dummy-readme.txt\"`, invokes `FileUtils.touch(file)`, reassigns `dir` to a new `File` with arguments `dir` and `\"subsubdir1\"`, invokes `mkdirs()` on `dir`, reassigns `file` to a new `File` with arguments `dir` and `\"dummy-file.txt\"`, invokes `FileUtils.touch(file)`, reassigns `file` to a new `File` with arguments `dir` and `\"dummy-index.html\"`, invokes `FileUtils.touch(file)`, reassigns `file` to a new `File` with arguments `dir` and `\"dummy-indexhtml\"`, invokes `FileUtils.touch(file)`, reassigns `dir` to the result of invoking `getParentFile()` on `dir`, reassigns `dir` to a new `File` with arguments `dir` and `\"CVS\"`, invokes `mkdirs()` on `dir`, reassigns `file` to a new `File` with arguments `dir` and `\"Entries\"`, invokes `FileUtils.touch(file)`, reassigns `file` to a new `File` with arguments `dir` and `\"Repository\"`, and invokes `FileUtils.touch(file)`. Write a test method annotated with `@Test` that declares a String array `extensions` initialized to `{ \"xml\", \"txt\" }`, constructs a new `File` with arguments `temporaryFolder` and `\"x.xml\"` assigning it to `xFile`, invokes `createNewFile()` on `xFile` and if the result is false invoke `fail` with argument `\"could not create test file: \" + xFile`, invokes `FileUtils.listFiles` with arguments `temporaryFolder`, `extensions`, and boolean `true` assigning the result to `files` of type `Collection<File>`, invokes `assertEquals` with arguments int `5` and `files.size()`, declares a variable `list` of type `List<File>` without initialization, opens a try-with-resources block that invokes `FileUtils.streamFiles` with arguments `temporaryFolder`, boolean `true`, and `extensions` assigning the result to `stream` of type `Stream<File>`, within the try block invokes `assertTrue` with argument `xFile.delete()`, assigns a new `ArrayList<>()` to `list`, invokes `iterator()` on `stream` assigning the result to `iterator` of type `Iterator<File>`, invokes `assumeFalse` with argument `SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_24)`, enters a while loop that continues while `iterator.hasNext()` returns true and within the loop invokes `list.add(iterator.next())`, after the loop invokes `assertFalse` with arguments `list.contains(xFile)` and method reference `list::toString`, and after the try-with-resources block invokes `assertEquals` with arguments int `4` and `list.size()`. The test uses JUnit 5 Assertions with method-level annotation `@Test`, class-level annotation `@TempDir` on the field, and setup method annotation `@BeforeEach`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsListFilesTest",
      "method_signature": "testStreamFilesWithDeletionIterator()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsFileNewTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\nimport static org.junit.jupiter.api.Assumptions.assumeFalse;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.lang3.JavaVersion;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileUtils}.\n */\npublic class FileUtilsFileNewTest {\n\n    @TempDir\n    public File temporaryFolder;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        File dir = temporaryFolder;\n        File file = new File(dir, \"dummy-build.xml\");\n        FileUtils.touch(file);\n        file = new File(dir, \"README\");\n        FileUtils.touch(file);\n        dir = new File(dir, \"subdir1\");\n        dir.mkdirs();\n        file = new File(dir, \"dummy-build.xml\");\n        FileUtils.touch(file);\n        file = new File(dir, \"dummy-readme.txt\");\n        FileUtils.touch(file);\n        dir = new File(dir, \"subsubdir1\");\n        dir.mkdirs();\n        file = new File(dir, \"dummy-file.txt\");\n        FileUtils.touch(file);\n        file = new File(dir, \"dummy-index.html\");\n        FileUtils.touch(file);\n        file = new File(dir, \"dummy-indexhtml\");\n        FileUtils.touch(file);\n        dir = dir.getParentFile();\n        dir = new File(dir, \"CVS\");\n        dir.mkdirs();\n        file = new File(dir, \"Entries\");\n        FileUtils.touch(file);\n        file = new File(dir, \"Repository\");\n        FileUtils.touch(file);\n    }\n\n    @Test\n    public void testListFilesWithDeletedFileInStream() throws IOException {\n        final String[] extensions = { \"xml\", \"txt\" };\n        final File xFile = new File(temporaryFolder, \"x.xml\");\n        if (!xFile.createNewFile()) {\n            fail(\"could not create test file: \" + xFile);\n        }\n        final Collection<File> files = FileUtils.listFiles(temporaryFolder, extensions, true);\n        assertEquals(5, files.size());\n\n        List<File> list = null;\n        try (Stream<File> stream = FileUtils.streamFiles(temporaryFolder, true, extensions)) {\n            assertTrue(xFile.delete());\n            list = new ArrayList<>();\n            final Iterator<File> iterator = stream.iterator();\n            assumeFalse(SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_24));\n            while (iterator.hasNext()) {\n                list.add(iterator.next());\n            }\n            assertFalse(list.contains(xFile), list::toString);\n        }\n        assertEquals(4, list.size());\n    }\n}",
      "method_signature": "testStreamFilesWithDeletionIterator()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18921,
    "output_tokens": 2845,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1218,
      "description": "Define a test class containing two private static final boolean fields: `AT_LEAST_JAVA_11` and `AT_LEAST_JAVA_17`, which determine Java version compatibility. Write a test method annotated with `@SuppressWarnings(\"resource\")` and `@Test` that verifies the behavior of adapting parallel streams using `IOStream`. Begin by creating an empty parallel stream through `Stream.empty().parallel()`, then pass this stream to `IOStream.adapt()` and assign the result to a variable `adaptedObj` of type `IOStream<Object>`. Immediately invoke `isParallel()` on `adaptedObj` and assert the result is true using `assertTrue(adaptedObj.isParallel())`. Next, invoke `count()` on `adaptedObj` and assert the returned value equals `0` using `assertEquals(0, adaptedObj.count())`. Following this, create a new parallel stream by calling `Stream.of(\"A\").parallel()`, pass it to `IOStream.adapt()`, and assign the result to a variable `adaptedStr` of type `IOStream<String>`. Invoke `isParallel()` on the original `adaptedObj` variable (note: this appears to be a potential bug in the original test, as it checks `adaptedObj` instead of `adaptedStr`) and assert the result is true using `assertTrue(adaptedObj.isParallel())`. Finally, invoke `count()` on `adaptedStr` and assert the returned value equals `1` using `assertEquals(1, adaptedStr.count())`. The test uses JUnit 5 Assertions (`assertTrue`, `assertEquals`) and operates on the `IOStream` class from `org.apache.commons.io.function` package, which wraps standard Java streams with IO exception handling capabilities.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOStreamTest",
      "method_signature": "testAdaptParallelAndCount()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.function.IOStreamTest1",
      "code": "package org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link IOStream}.\n */\npublic class IOStreamTest1 {\n\n    private static int getVersion() {\n        final String versionStr = System.getProperty(\"java.version\");\n        try {\n            if (versionStr.startsWith(\"1.\")) {\n                // For Java 1.8, 1.7, etc.\n                return Integer.parseInt(versionStr.substring(2, 3));\n            }\n            // For Java 9, 11, 17, etc.\n            final int dot = versionStr.indexOf(\".\");\n            return Integer.parseInt(dot == -1 ? versionStr : versionStr.substring(0, dot));\n        } catch (final Exception e) {\n            // fallback\n            return 8;\n        }\n    }\n\n    private static final boolean AT_LEAST_JAVA_11 = getVersion() >= 11;\n\n    private static final boolean AT_LEAST_JAVA_17 = getVersion() >= 17;\n\n    @Test\n    @SuppressWarnings(\"resource\")\n    public void testAdaptParallel() {\n        final IOStream<Object> adaptedObj = IOStream.adapt(Stream.empty().parallel());\n        assertTrue(adaptedObj.isParallel());\n        assertEquals(0, adaptedObj.count());\n\n        final IOStream<String> adaptedStr = IOStream.adapt(Stream.of(\"A\").parallel());\n        assertTrue(adaptedObj.isParallel());\n        assertEquals(1, adaptedStr.count());\n    }\n\n}",
      "method_signature": "testAdaptParallelAndCount()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 29120,
    "output_tokens": 9838,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1219,
      "description": "Define a parameterized test method annotated with `@ParameterizedTest(name = \"inputData={0}\")` and `@MethodSource(\"inputData\")` that accepts a single `String` parameter named `inputData` and declares `throws IOException`. Begin by invoking `split` on `inputData` with argument `\"\\n\"` and assign the resulting `String[]` to variable `lines`. Instantiate a `LinkedBlockingQueue<Integer>` using the no-argument constructor and assign it to variable `queue` of type `BlockingQueue<Integer>`. Within a try-with-resources block, invoke `QueueInputStream.builder()` to obtain a `Builder` instance, chain `setBlockingQueue(queue)` passing the `queue` variable, chain `setTimeout(Duration.ofHours(1))` where `Duration.ofHours(1)` is created by calling the static method `ofHours` on `Duration` with argument `1`, and finally chain `get()` to produce a `QueueInputStream` assigned to variable `inputStream`. In the same try-with-resources declaration, invoke `newQueueOutputStream()` on `inputStream` to obtain a `QueueOutputStream` assigned to variable `outputStream`. Inside the try block, define a private method that accepts three parameters: a `String` named `inputData`, an `InputStream` named `inputStream`, and an `OutputStream` named `outputStream`, and declares `throws IOException`. Within this private method, invoke `split` on `inputData` with argument `\"\\n\"` and assign the resulting `String[]` to variable `lines`. Create a `BufferedReader` by instantiating it with `new InputStreamReader(inputStream, UTF_8)` where `UTF_8` is the constant charset, and assign it to variable `reader` within a try-with-resources block. Iterate over each element in `lines` using an enhanced for-loop with loop variable `line` of type `String`. For each iteration, invoke `write` on `outputStream` passing `line.getBytes(UTF_8)` where `getBytes` is called on `line` with argument `UTF_8`, then invoke `write` on `outputStream` again passing the character literal `'\\n'`, invoke `readLine()` on `reader` and assign the result to variable `actualLine` of type `String`, and immediately assert using `assertEquals(line, actualLine)` to verify that `line` equals `actualLine`. After defining this private method, invoke it from the test method passing `inputData`, `inputStream`, and `outputStream` as arguments. The test uses JUnit 5 with `@ParameterizedTest` and `@MethodSource`, and assertions are performed using JUnit's `assertEquals` method.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.QueueInputStreamTest",
      "method_signature": "testReadLineByLineQueue(java.lang.String)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.QueueInputStreamTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.time.Duration;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.output.QueueOutputStream;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link QueueInputStream}.\n */\npublic class QueueInputStreamTest1 {\n\n    private void test(final String inputData, final InputStream inputStream, final OutputStream outputStream)\n            throws IOException {\n        final String[] lines = inputData.split(\"\n\");\n        try (final BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, UTF_8))) {\n            for (final String line : lines) {\n                outputStream.write(line.getBytes(UTF_8));\n                outputStream.write('\n');\n                final String actualLine = reader.readLine();\n                assertEquals(line, actualLine);\n            }\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void testQueue(final String inputData) throws IOException {\n        final String[] lines = inputData.split(\"\n\");\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (final QueueInputStream inputStream = QueueInputStream.builder().setBlockingQueue(queue)\n                .setTimeout(Duration.ofHours(1)).get();\n                final QueueOutputStream outputStream = inputStream.newQueueOutputStream()) {\n            test(inputData, inputStream, outputStream);\n        }\n    }\n\n    public static Stream<String> inputData() {\n        return Stream.of(\"Line 1\nLine 2\nLine 3\", \"Another test\nwith\nmultiple lines\", \"\");\n    }\n}",
      "method_signature": "testReadLineByLineQueue(java.lang.String)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1,
          "run_shell_command": 4,
          "list_directory": 1,
          "read_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 111772,
    "output_tokens": 5460,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1221,
      "description": "Create a test case to validate that the system correctly handles concurrent data processing operations with error propagation and ordered output guarantees when operating in parallel mode. Begin by confirming the system properly propagates failures when attempting to process a single data element that encounters an error during concurrent execution, verifying this behavior through multiple scenarios including different error-raising approaches. Next, establish that the system correctly reports failures when processing multiple elements in parallel where errors may occur. After confirming error handling works as expected, verify the system's ability to maintain sequential ordering of results despite parallel processing by directing concurrent operations to accumulate output in order, then confirm the accumulated result matches the expected sequence for two elements. Reset the accumulator and repeat this verification with three elements to ensure ordering consistency, then reset again and validate the same sequential guarantee holds for four elements, confirming that regardless of parallel execution, the final output preserves the original element order. Use JUnit 5 for the testing framework with standard equality assertions to verify output sequences and exception assertions to confirm error propagation behavior.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOStreamTest",
      "method_signature": "testForEachOrderedAdaptParallel()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.function.IOStreamsTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOExceptionList;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.function.Executable;\n\n/**\n * Tests {@link IOStreams}.\n */\npublic class IOStreamsTest {\n\n    @Test\n    public void testParallelForEachOrdered() throws IOException {\n        // 1. Confirm failure propagation for a single element with different error-raising approaches.\n        final Executable testSingleError = () -> IOStreams.parallelForEachOrdered(Stream.of(\"a\"), e -> {\n            throw new IOException(\"test failure\");\n        });\n        assertThrows(IOException.class, testSingleError, \"A single failure should be propagated directly.\");\n\n        final IOException ioEx = new IOException(\"test failure\");\n        final Executable testSingleError2 = () -> IOStreams.parallelForEachOrdered(Stream.of(\"a\"), e -> {\n            throw ioEx;\n        });\n        assertEquals(ioEx, assertThrows(IOException.class, testSingleError2),\n            \"The exact exception instance should be propagated for a single failure.\");\n\n        // 2. Confirm failure reporting for multiple elements.\n        final Executable testMultipleErrors = () -> IOStreams.parallelForEachOrdered(Stream.of(\"a\", \"b\", \"c\"), e -> {\n            throw new IOException(\"test failure \" + e);\n        });\n        final IOExceptionList exList = assertThrows(IOExceptionList.class, testMultipleErrors,\n            \"Multiple failures should be collected into an IOExceptionList.\");\n        assertEquals(3, exList.getCauseList().size(), \"Should contain all exceptions from the parallel operations.\");\n\n        // 3. Verify ordering for 2 elements.\n        final List<String> accumulator = Collections.synchronizedList(new ArrayList<>());\n        IOStreams.parallelForEachOrdered(Stream.of(\"a\", \"b\"), accumulator::add);\n        assertEquals(Arrays.asList(\"a\", \"b\"), accumulator, \"The output order should match the input order for 2 elements.\");\n\n        // 4. Verify ordering for 3 elements.\n        accumulator.clear();\n        IOStreams.parallelForEachOrdered(Stream.of(\"a\", \"b\", \"c\"), accumulator::add);\n        assertEquals(Arrays.asList(\"a\", \"b\", \"c\"), accumulator, \"The output order should match the input order for 3 elements.\");\n\n        // 5. Verify ordering for 4 elements.\n        accumulator.clear();\n        IOStreams.parallelForEachOrdered(Stream.of(\"a\", \"b\", \"c\", \"d\"), accumulator::add);\n        assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\"), accumulator, \"The output order should match the input order for 4 elements.\");\n    }\n}",
      "method_signature": "testForEachOrderedAdaptParallel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 7,
          "run_shell_command": 9,
          "read_file": 7,
          "search_file_content": 2,
          "glob": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 16584,
    "output_tokens": 710,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1222,
      "description": "Define a test method that validates the behavior of an IO-aware stream adapter when processing parallel streams with both exception-throwing and ordered element consumption scenarios. Create a utility that produces an IO consumer which throws IOException when invoked, then verify that adapting a single-element parallel stream and invoking forEach with this throwing consumer correctly propagates the IOException by asserting the exception is thrown. Repeat this verification with an inline lambda that directly throws IOException to confirm the exception handling mechanism, and again with a two-element parallel stream using the throwing consumer utility. Initialize a StringBuilder to accumulate results, then adapt a two-element parallel stream and invoke forEachOrdered with the StringBuilder's append method, asserting that the accumulated string matches the expected ordered sequence. Reset the StringBuilder's length to zero, adapt a three-element parallel stream, invoke forEachOrdered with the same append operation, and verify the ordered concatenation matches the expected three-character sequence. Reset the StringBuilder once more, adapt a four-element parallel stream, apply forEachOrdered with append, and confirm the final accumulated string reflects all four elements in their original order. The test employs standard assertion libraries for exception verification and equality checks, with resource suppression annotations to bypass compiler warnings about unclosed streams.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOStreamTest",
      "method_signature": "testForEachOrderedAdaptParallel()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.function.IOStreamTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link IOStream}.\n */\npublic class IOStreamTest1 {\n\n    private <T> IOConsumer<T> throwingIOConsumer() {\n        return t -> {\n            throw new IOException(\"boom\");\n        };\n    }\n\n    @Test\n    @SuppressWarnings(\"resource\")\n    public void testParallelStream() {\n        // Test exception handling with parallel stream + forEach\n        assertThrows(IOException.class, () -> IOStream.adapt(Stream.of(\"a\").parallel()).forEach(throwingIOConsumer()));\n        assertThrows(IOException.class, () -> IOStream.adapt(Stream.of(\"a\").parallel()).forEach(e -> {\n            throw new IOException(\"boom\");\n        }));\n        assertThrows(IOException.class, () -> IOStream.adapt(Stream.of(\"a\", \"b\").parallel()).forEach(throwingIOConsumer()));\n\n        // Test ordered consumption with parallel stream + forEachOrdered\n        final StringBuilder sb = new StringBuilder();\n        IOStream.adapt(Stream.of(\"a\", \"b\").parallel()).forEachOrdered(sb::append);\n        assertEquals(\"ab\", sb.toString());\n\n        sb.setLength(0);\n        IOStream.adapt(Stream.of(\"a\", \"b\", \"c\").parallel()).forEachOrdered(sb::append);\n        assertEquals(\"abc\", sb.toString());\n\n        sb.setLength(0);\n        IOStream.adapt(Stream.of(\"a\", \"b\", \"c\", \"d\").parallel()).forEachOrdered(sb::append);\n        assertEquals(\"abcd\", sb.toString());\n    }\n\n}",
      "method_signature": "testForEachOrderedAdaptParallel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 32929,
    "output_tokens": 4801,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1224,
      "description": "Create a test case to validate that the streaming system correctly handles error propagation and ordering guarantees when processing data in concurrent mode. Begin by simulating a scenario where a single-element stream encounters a processing failure during concurrent iteration, confirming the system properly surfaces the error to the caller. Next, verify the same error handling behavior with an inline processing operation that fails immediately, ensuring consistent error reporting regardless of how the failing operation is defined. Then test that a two-element stream also correctly propagates processing failures during concurrent iteration. After establishing error handling works as expected, verify the system's ordering capability by configuring a concurrent stream to process multiple elements while maintaining their original sequence, accumulating the results in order and confirming the final output preserves the exact arrangement of the input elements despite concurrent processing. Use JUnit 5 for the test framework and standard equality assertions to verify outcomes, with exception assertions to confirm proper error propagation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOStreamTest",
      "method_signature": "testForEachOrderedAsParallel()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.StreamIteratorTest1",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.function.IOConsumer;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link StreamIterator} for concurrent processing and error handling.\n */\npublic class StreamIteratorTest1 {\n\n    @Test\n    public void testConcurrentStreamProcessingErrorAndOrdering() throws IOException {\n        final String failureMessage = \"Simulated processing failure\";\n\n        // Test 1: Single-element stream with a processing failure in concurrent mode\n        final Stream<String> singleElementStream = Stream.of(\"element1\");\n        final IOException e1 = assertThrows(IOException.class, () ->\n            StreamIterator.of(singleElementStream).concurrent().forEach(s -> {\n                throw new IOException(failureMessage);\n            })\n        );\n        assertEquals(failureMessage, e1.getMessage(),\n            \"Error should be propagated from a single-element concurrent stream.\");\n\n        // Test 2: Inline processing operation that fails immediately\n        final Stream<String> inlineFailureStream = Stream.of(\"element1\");\n        final IOException e2 = assertThrows(IOException.class, () ->\n            StreamIterator.of(inlineFailureStream).concurrent().forEach(s -> {\n                throw new IOException(failureMessage);\n            })\n        );\n        assertEquals(failureMessage, e2.getMessage(),\n            \"Error should be propagated consistently for inline failing operations.\");\n\n        // Test 3: Two-element stream with a processing failure in concurrent mode\n        final Stream<String> twoElementStream = Stream.of(\"element1\", \"element2\");\n        final IOException e3 = assertThrows(IOException.class, () ->\n            StreamIterator.of(twoElementStream).concurrent().forEach(s -> {\n                throw new IOException(failureMessage);\n            })\n        );\n        assertEquals(failureMessage, e3.getMessage(),\n            \"Error should be propagated from a two-element concurrent stream.\");\n\n        // Test 4: Ordering guarantee in concurrent mode\n        final List<String> sourceList = List.of(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\");\n        final Stream<String> orderedStream = sourceList.stream();\n        final List<String> results = Collections.synchronizedList(new ArrayList<>());\n\n        StreamIterator.of(orderedStream).concurrent().forEachOrdered(results::add);\n\n        assertEquals(sourceList, results,\n            \"Stream elements should maintain their original order during concurrent processing.\");\n    }\n}",
      "method_signature": "testForEachOrderedAsParallel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7342,
    "output_tokens": 7831,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1225,
      "description": "Define a test method that validates the behavior of parallel IO stream processing when encountering exceptions and when maintaining element order during parallel execution. Create a utility helper that produces an IO consumer which throws an IO exception when invoked, enabling reusable exception-throwing behavior across test scenarios. Construct an IO stream containing a single string element, convert it to parallel mode, then invoke the forEach operation with the exception-throwing consumer and verify that an IO exception is propagated. Repeat this verification pattern with a stream containing two string elements to confirm consistent exception handling across different stream sizes. Following the exception scenarios, initialize a string builder to accumulate results, then construct another IO stream with two string elements, convert it to parallel mode, and invoke the forEachOrdered operation passing the string builder's append method as the consumer. Upon completion of the ordered parallel processing, assert that the string builder contains the elements in their original sequential order despite parallel execution. The test relies on JUnit 5 for test execution and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOStreamTest",
      "method_signature": "testForEachOrderedAsParallel()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.function.IOStreamTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link IOStream}.\n */\npublic class IOStreamTest1 {\n\n    private <T> IOConsumer<T> newExceptionConsumer() {\n        return t -> {\n            throw new IOException(\"BOOM!\");\n        };\n    }\n\n    @Test\n    public void testParallel() throws IOException {\n        // Test exception propagation in parallel stream\n        assertThrows(IOException.class, () -> IOStream.of(\"A\").parallel().forEach(newExceptionConsumer()));\n        assertThrows(IOException.class, () -> IOStream.of(\"A\", \"B\").parallel().forEach(newExceptionConsumer()));\n\n        // Test order is maintained in parallel stream with forEachOrdered\n        final StringBuilder stringBuilder = new StringBuilder();\n        IOStream.of(\"A\", \"B\").parallel().forEachOrdered(stringBuilder::append);\n        assertEquals(\"AB\", stringBuilder.toString());\n    }\n}",
      "method_signature": "testForEachOrderedAsParallel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.5,
      "obj_creation_precision": 1.0,
      "assertion_recall": 0.75,
      "assertion_precision": 1.0,
      "callable_recall": 0.7368,
      "callable_precision": 0.8235,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.8571,
      "method_coverage": 0.9375,
      "line_coverage": 0.9545,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20720,
    "output_tokens": 6036,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1226,
      "description": "Define a test method annotated with `@SuppressWarnings(\"resource\")` and `@Test` that declares it throws `IOException`, then begin by invoking `assertThrows` with `IOException.class` and a lambda that calls `Stream.of(\"A\")`, chains `parallel()` on the returned stream, passes the result to `IOStream.adapt`, and invokes `forEach` on the adapted stream with an argument obtained by calling the static method `TestUtils.throwingIOConsumer()` which returns an `IOConsumer<T>` that casts the constant `TestConstants.THROWING_IO_CONSUMER` to `IOConsumer<T>` and throws `IOException` when invoked. Next, invoke `assertThrows` with `IOException.class` and a lambda that calls `Stream.of(\"A\")`, chains `parallel()`, passes to `IOStream.adapt`, and invokes `forEach` with an inline lambda `e -> { throw new IOException(\"Failure\"); }`. Following this, invoke `assertThrows` with `IOException.class` and a lambda that calls `Stream.of(\"A\", \"B\")`, chains `parallel()`, passes to `IOStream.adapt`, and invokes `forEach` with the result of `TestUtils.throwingIOConsumer()`. Declare a local variable `sb` of type `StringBuilder` initialized with `new StringBuilder()`, then invoke `Stream.of(\"A\", \"B\")`, chain `parallel()`, pass to `IOStream.adapt`, and invoke `forEachOrdered` with the method reference `sb::append`. Immediately assert using `assertEquals` that the String literal `\"AB\"` equals `sb.toString()`. Invoke `sb.setLength(0)` to reset the builder, then invoke `Stream.of(\"A\", \"B\", \"C\")`, chain `parallel()`, pass to `IOStream.adapt`, invoke `forEachOrdered` with `sb::append`, and assert using `assertEquals` that `\"ABC\"` equals `sb.toString()`. Invoke `sb.setLength(0)` again, then invoke `Stream.of(\"A\", \"B\", \"C\", \"D\")`, chain `parallel()`, pass to `IOStream.adapt`, invoke `forEachOrdered` with `sb::append`, and assert using `assertEquals` that `\"ABCD\"` equals `sb.toString()`. The test uses JUnit 5 Assertions with method-level annotations `@Test` and `@SuppressWarnings(\"resource\")`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOStreamTest",
      "method_signature": "testForEachOrderedAdaptParallel()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.function.IOStreamTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.TestUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link IOStream}.\n */\npublic class IOStreamTest1 {\n\n    @SuppressWarnings(\"resource\")\n    @Test\n    public void testParallelForEach() throws IOException {\n        assertThrows(IOException.class, () -> IOStream.adapt(Stream.of(\"A\").parallel()).forEach(TestUtils.throwingIOConsumer()));\n        assertThrows(IOException.class, () -> IOStream.adapt(Stream.of(\"A\").parallel()).forEach(e -> {\n            throw new IOException(\"Failure\");\n        }));\n        assertThrows(IOException.class, () -> IOStream.adapt(Stream.of(\"A\", \"B\").parallel()).forEach(TestUtils.throwingIOConsumer()));\n        final StringBuilder sb = new StringBuilder();\n        IOStream.adapt(Stream.of(\"A\", \"B\").parallel()).forEachOrdered(sb::append);\n        assertEquals(\"AB\", sb.toString());\n        sb.setLength(0);\n        IOStream.adapt(Stream.of(\"A\", \"B\", \"C\").parallel()).forEachOrdered(sb::append);\n        assertEquals(\"ABC\", sb.toString());\n        sb.setLength(0);\n        IOStream.adapt(Stream.of(\"A\", \"B\", \"C\", \"D\").parallel()).forEachOrdered(sb::append);\n        assertEquals(\"ABCD\", sb.toString());\n    }\n\n}",
      "method_signature": "testForEachOrderedAdaptParallel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 59966,
    "output_tokens": 3856,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1227,
      "description": "Define a test method that validates the behavior of the IOStream adapter when converting standard Java streams to parallel execution mode across three distinct scenarios. Begin by adapting a null stream reference to an IOStream, converting it to parallel mode, and asserting that the resulting element count equals zero to confirm graceful null handling. Next, adapt an empty stream instance to an IOStream, apply parallel processing, and verify the count remains zero to validate empty stream behavior. Finally, adapt a stream containing a single string element to an IOStream, convert it to parallel execution, and assert the count equals one to confirm proper element preservation during parallel conversion. Each scenario follows the same interaction pattern: invoke the adapt method on IOStream with the source stream, chain the parallel method to enable parallel processing, invoke the count terminal operation to materialize the stream, and validate the resulting count matches the expected value for that input condition. This test uses JUnit 5 for the testing framework and standard JUnit assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOStreamTest",
      "method_signature": "testAdaptAsParallel()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.function.IOStreamTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link IOStream}.\n */\npublic class IOStreamTest1 {\n\n    @Test\n    public void testParallel() {\n        // adapt a null stream reference to an IOStream\n        assertEquals(0, IOStream.adapt(null).parallel().count());\n        // adapt an empty stream instance to an IOStream\n        assertEquals(0, IOStream.adapt(Stream.empty()).parallel().count());\n        // adapt a stream containing a single string element to an IOStream\n        assertEquals(1, IOStream.adapt(Stream.of(\"one\")).parallel().count());\n    }\n\n}",
      "method_signature": "testAdaptAsParallel()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8571,
      "callable_precision": 0.8571,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 42556,
    "output_tokens": 3864,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1228,
      "description": "Create a test case to validate that the system's stream adaptation capability correctly handles parallel processing configurations across various data scenarios. Begin by confirming the system properly adapts a missing data stream for parallel processing and yields zero elements when counted. Next, verify that adapting an empty data stream for parallel execution similarly produces no elements. Finally, ensure that when adapting a single-element data stream for parallel processing, the system correctly identifies and counts exactly one element. Throughout these scenarios, confirm the adaptation mechanism maintains accurate element counts regardless of whether the input represents absent data, empty collections, or populated streams, demonstrating the system's ability to seamlessly convert standard data flows into parallel-capable streams while preserving element integrity. Use JUnit 5 for the testing framework with standard equality assertions to verify element counts match expected values for each parallel processing scenario.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOStreamTest",
      "method_signature": "testAdaptAsParallel()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.function.StreamsTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests that the system's stream adaptation capability correctly handles parallel processing configurations\n * across various data scenarios.\n */\npublic class StreamsTest {\n\n    /**\n     * Tests that adapting data streams for parallel processing works correctly for missing, empty, and populated streams.\n     */\n    @Test\n    public void testParallelStreamAdaptation() {\n        // Confirms that adapting a missing data stream for parallel processing yields zero elements.\n        final Stream<Object> missingStream = Streams.of((Collection<Object>) null).parallel();\n        assertEquals(0, missingStream.count(), \"Adapting a null collection for parallel processing should yield zero elements.\");\n\n        // Verifies that adapting an empty data stream for parallel execution produces no elements.\n        final Stream<Object> emptyStream = Streams.of(Collections.emptyList()).parallel();\n        assertEquals(0, emptyStream.count(), \"Adapting an empty collection for parallel processing should yield zero elements.\");\n\n        // Ensures that adapting a single-element data stream for parallel processing correctly counts one element.\n        final Stream<String> singleElementStream = Streams.of(Collections.singletonList(\"one\")).parallel();\n        assertEquals(1, singleElementStream.count(), \"Adapting a single-element collection for parallel processing should yield one element.\");\n    }\n}",
      "method_signature": "testAdaptAsParallel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 34713,
    "output_tokens": 8152,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1230,
      "description": "Define a test class containing two private static final boolean fields named `AT_LEAST_JAVA_11` and `AT_LEAST_JAVA_17`, then write a test method annotated with `@SuppressWarnings(\"resource\")` and `@Test` that executes three sequential assertion chains to verify the behavior of `IOStream.adapt` when combined with parallel stream operations. Begin by invoking the static method `IOStream.adapt` with a null `Stream<?>` cast explicitly to `Stream<?>`, chain `parallel()` on the returned `IOStream`, then chain `count()` to obtain the terminal count value, and assert using `assertEquals` that this count equals integer literal `0`. Next, invoke `Stream.empty()` to create an empty stream, pass this result to `IOStream.adapt`, chain `parallel()` on the returned `IOStream`, chain `count()`, and assert using `assertEquals` that the count equals integer literal `0`. Finally, invoke `Stream.of(\"A\")` with the String literal `\"A\"` to create a single-element stream, pass this stream to `IOStream.adapt`, chain `parallel()` on the returned `IOStream`, chain `count()`, and assert using `assertEquals` that the count equals integer literal `1`. The test uses JUnit 5 Assertions via `assertEquals` and verifies that `IOStream.adapt` correctly handles null streams, empty streams, and single-element streams when converted to parallel execution mode.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOStreamTest",
      "method_signature": "testAdaptAsParallel()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOStreamTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.function.IOStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link IOStream}.\n */\npublic class IOStreamTest {\n\n    private static final boolean AT_LEAST_JAVA_11 = isJavaVersionAtLeast(11);\n    private static final boolean AT_LEAST_JAVA_17 = isJavaVersionAtLeast(17);\n\n    private static int getJavaVersion() {\n        String version = System.getProperty(\"java.version\");\n        if (version.startsWith(\"1.\")) {\n            version = version.substring(2);\n        }\n        final int dot = version.indexOf('.');\n        if (dot != -1) {\n            version = version.substring(0, dot);\n        }\n        final int dash = version.indexOf('-');\n        if (dash != -1) {\n            version = version.substring(0, dash);\n        }\n        try {\n            return Integer.parseInt(version);\n        } catch (final NumberFormatException e) {\n            return -1;\n        }\n    }\n\n    private static boolean isJavaVersionAtLeast(final int version) {\n        return getJavaVersion() >= version;\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Test\n    public void testAdaptParallel() {\n        assertEquals(0, IOStream.adapt((Stream<?>) null).parallel().count());\n        assertEquals(0, IOStream.adapt(Stream.empty()).parallel().count());\n        assertEquals(1, IOStream.adapt(Stream.of(\"A\")).parallel().count());\n    }\n}",
      "method_signature": "testAdaptAsParallel()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19701,
    "output_tokens": 4771,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1231,
      "description": "Define a test class annotated with `@SuppressWarnings(\"deprecation\")` containing eight private fields: a `String` constant `UTF_8`, an `int` constant `FILE_SIZE`, a `boolean` constant `WINDOWS`, a public `File` field `temporaryFolder` annotated with `@TempDir`, and four instance fields `carr` of type `char[]`, `iarr` of type `byte[]`, `testFile` of type `File`, and `testFilePath` of type `Path`. Implement a static setup method annotated with `@BeforeAll` that invokes `IO.clear()` to exercise thread-local cleanup. Implement an instance setup method annotated with `@BeforeEach` that constructs `testFile` by passing `temporaryFolder` and the string literal `\"file2-test.txt\"` to the `File` constructor, assigns `testFile.toPath()` to `testFilePath`, verifies the parent directory exists by calling `testFile.getParentFile().exists()` and throwing an `IOException` with a descriptive message if false, then creates a `BufferedOutputStream` wrapping `Files.newOutputStream(testFilePath)` in a try-with-resources block and within that block invokes a private method that writes exactly `FILE_SIZE` bytes to the output stream by looping from `0` to `size - 1` and calling `out.write((byte) (i % 127 + 1))` for each iteration, catches any `IOException` and calls `fail` with a concatenated message including `e.getMessage()`, then initializes `iarr` as a new `byte[200]`, fills it entirely with byte value `-1` using `Arrays.fill(iarr, (byte) -1)`, overwrites the first 80 elements by looping from `0` to `79` and assigning `iarr[i] = (byte) i`, initializes `carr` as a new `char[200]`, fills it entirely with char value `-1` using `Arrays.fill(carr, (char) -1)`, and overwrites the first 80 elements by looping from `0` to `79` and assigning `carr[i] = (char) i`. Write a test method annotated with `@Test` and declaring `throws IOException` that opens a try-with-resources block declaring two resources: first, invoke `Mockito.mockStatic(IOUtils.class, Mockito.CALLS_REAL_METHODS)` and assign the result to variable `utils` of type `MockedStatic<IOUtils>`, second, invoke `mock(UnsynchronizedByteArrayOutputStream.class)` and assign the result to variable `mockOutputStream` of type `UnsynchronizedByteArrayOutputStream`, then within the try block invoke `utils.when(() -> IOUtils.copyToOutputStream(ArgumentMatchers.any(InputStream.class), ArgumentMatchers.anyLong(), ArgumentMatchers.anyInt())).thenReturn(mockOutputStream)` to stub the static method, invoke `when(mockOutputStream.size()).thenReturn(IOUtils.SOFT_MAX_ARRAY_LENGTH + 1)` to configure the mock to return a size exceeding the soft maximum array length, open a nested try-with-resources block declaring `mockInputStream` of type `InputStream` initialized by invoking `mock(InputStream.class)`, within that nested block invoke `assertThrows(IOException.class, () -> IOUtils.toByteArray(mockInputStream))` and assign the result to variable `exception` of type `IOException`, then invoke `assertTrue(exception.getMessage().contains(String.format(\"%,d\", IOUtils.SOFT_MAX_ARRAY_LENGTH)), \"Exception message does not contain the maximum length\")` to verify the exception message contains the formatted soft maximum array length value. Implement a static teardown method identical to the setup method that invokes `IO.clear()`. Annotations: class-level `@SuppressWarnings(\"deprecation\")`, setup method `@BeforeAll`, instance setup `@BeforeEach`, test method `@Test`, teardown `@AfterAll`. Assertion library: JUnit 5 Assertions. Mocking library: Mockito.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testToByteArray_ThrowsIOExceptionOnHugeStream()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsLargeInputStreamTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\n\nimport org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.mockito.ArgumentMatchers;\nimport org.mockito.MockedStatic;\nimport org.mockito.Mockito;\n\n@SuppressWarnings(\"deprecation\")\npublic class IOUtilsLargeInputStreamTest {\n\n    private static final String UTF_8 = \"UTF-8\";\n    private static final int FILE_SIZE = 1024 * 4 + 1;\n    private static final boolean WINDOWS = File.separatorChar == '\\\\';\n\n    @TempDir\n    public File temporaryFolder;\n\n    private char[] carr;\n    private byte[] iarr;\n    private File testFile;\n    private Path testFilePath;\n\n    @BeforeAll\n    public static void setUp() {\n        IO.clear();\n    }\n\n    @AfterAll\n    public static void tearDown() {\n        IO.clear();\n    }\n\n    @BeforeEach\n    public void beforeEach() throws Exception {\n        testFile = new File(temporaryFolder, \"file2-test.txt\");\n        testFilePath = testFile.toPath();\n        if (!testFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(testFilePath))) {\n            writeFileData(out, FILE_SIZE);\n        } catch (final IOException e) {\n            fail(\"Unable to create file \" + testFile + \": \" + e.getMessage());\n        }\n\n        iarr = new byte[200];\n        Arrays.fill(iarr, (byte) -1);\n        for (int i = 0; i < 80; i++) {\n            iarr[i] = (byte) i;\n        }\n        carr = new char[200];\n        Arrays.fill(carr, (char) -1);\n        for (int i = 0; i < 80; i++) {\n            carr[i] = (char) i;\n        }\n    }\n\n    private void writeFileData(final OutputStream out, final int size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            out.write((byte) (i % 127 + 1));\n        }\n    }\n\n    @Test\n    public void testToByteArrayWithLargeInputStream() throws IOException {\n        try (MockedStatic<IOUtils> utils = Mockito.mockStatic(IOUtils.class, Mockito.CALLS_REAL_METHODS)) {\n            final UnsynchronizedByteArrayOutputStream mockOutputStream = mock(UnsynchronizedByteArrayOutputStream.class);\n            utils.when(() -> IOUtils.copyToOutputStream(ArgumentMatchers.any(InputStream.class), ArgumentMatchers.anyLong(), ArgumentMatchers.anyInt())).thenReturn(mockOutputStream);\n            when(mockOutputStream.size()).thenReturn(IOUtils.SOFT_MAX_ARRAY_LENGTH + 1L);\n\n            try (InputStream mockInputStream = mock(InputStream.class)) {\n                final IOException exception = assertThrows(IOException.class, () -> IOUtils.toByteArray(mockInputStream));\n                assertTrue(exception.getMessage().contains(String.format(\"%,d\", IOUtils.SOFT_MAX_ARRAY_LENGTH)), \"Exception message does not contain the maximum length\");\n            }\n        }\n    }\n}",
      "method_signature": "testToByteArray_ThrowsIOExceptionOnHugeStream()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1232,
      "description": "Define a test class containing two private static final boolean fields `AT_LEAST_JAVA_11` and `AT_LEAST_JAVA_17`, then write a test method annotated with `@SuppressWarnings(\"resource\")` and `@Test` that throws `IOException` in its signature. Begin by invoking `assertThrows` with `IOException.class` as the first argument and a lambda expression as the second argument, where the lambda calls `IOStream.of(\"A\")`, chains `.parallel()`, then chains `.forEach()` passing an `IOConsumer<T>` obtained by casting `TestConstants.THROWING_IO_CONSUMER` to `IOConsumer<T>` (this cast logic represents the unwrapped helper behavior). Next, invoke `assertThrows` again with `IOException.class` and a lambda that calls `IOStream.of(\"A\")`, chains `.parallel()`, then chains `.forEach()` passing a lambda expression `e -> { throw new IOException(\"Failure\"); }` where the lambda parameter is named `e` and the body constructs a new `IOException` with the String literal `\"Failure\"` and throws it. Following this, invoke `assertThrows` a third time with `IOException.class` and a lambda that calls `IOStream.of(\"A\", \"B\")` with two String arguments, chains `.parallel()`, then chains `.forEach()` passing the same `IOConsumer<T>` obtained by casting `TestConstants.THROWING_IO_CONSUMER` to `IOConsumer<T>`. After these exception assertions, declare a local variable `sb` of type `StringBuilder` initialized by calling `new StringBuilder()` with no arguments. Then invoke `IOStream.of(\"A\", \"B\")` with two String arguments, chain `.parallel()`, and chain `.forEachOrdered()` passing a method reference `sb::append`. Finally, invoke `assertEquals` with the String literal `\"AB\"` as the expected value and `sb.toString()` as the actual value. The test uses JUnit 5 Assertions (`assertThrows`, `assertEquals`) and operates on the `IOStream` and `IOConsumer` classes from the application code.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOStreamTest",
      "method_signature": "testForEachOrderedAsParallel()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOStreamParallelTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\n\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.lang3.JavaVersion;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link IOStream}.\n */\npublic class IOStreamParallelTest {\n\n    private static final boolean AT_LEAST_JAVA_11 = SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_11);\n    private static final boolean AT_LEAST_JAVA_17 = SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_17);\n\n    @SuppressWarnings(\"resource\")\n    @Test\n    public void testParallel() throws IOException {\n        assertThrows(IOException.class, () -> IOStream.of(\"A\").parallel().forEach((IOConsumer<String>) TestConstants.THROWING_IO_CONSUMER));\n        assertThrows(IOException.class, () -> IOStream.of(\"A\").parallel().forEach(e -> {\n            throw new IOException(\"Failure\");\n        }));\n        assertThrows(IOException.class, () -> IOStream.of(\"A\", \"B\").parallel().forEach((IOConsumer<String>) TestConstants.THROWING_IO_CONSUMER));\n        final StringBuilder sb = new StringBuilder();\n        IOStream.of(\"A\", \"B\").parallel().forEachOrdered(sb::append);\n        assertEquals(\"AB\", sb.toString());\n    }\n}",
      "method_signature": "testForEachOrderedAsParallel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 25312,
    "output_tokens": 3386,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1234,
      "description": "Create a test case to validate that a data forwarding mechanism correctly handles repeated write operations with varying repetition counts when writing portions of data segments, ensuring the system behaves appropriately for edge cases and standard scenarios. Begin by establishing a monitoring system that tracks when specific write operations occur and configure a forwarding channel that routes data to an accumulation buffer while observing the write behavior. Execute a series of write operations with different repetition parameters: first, attempt to write a single character from a two-character segment with a negative repetition count and verify that no data reaches the buffer and the targeted write operation was not invoked, confirming the buffer remains empty. Next, perform the same write operation with a zero repetition count and again verify that no data is written, the operation is not triggered, and the buffer stays empty. Then, execute the write with a repetition count of one and confirm that the system invokes the appropriate write operation, the buffer now contains exactly one character matching the specified portion of the segment, and the buffer size reflects this single addition. Finally, perform another write operation with a different character segment using a repetition count of two and verify that the system correctly invokes the write operation, the buffer accumulates the new character twice while preserving the previous content, and the final buffer state contains all three characters in the expected sequence. Validate all outcomes using standard equality assertions provided by JUnit 5 and AssertJ.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.ProxyOutputStreamTest",
      "method_signature": "testWriteByteArrayAtRepeat()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IORepeatedWriteTest",
      "code": "package org.apache.commons.io;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.WritableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\n\n/**\n * Tests {@link IO#WRITE_REPEATED}.\n */\npublic class IORepeatedWriteTest {\n\n    @Test\n    public void testWriteRepeatedCharSequenceHandlesVaryingRepetitionCounts() throws IOException {\n        // Establish a monitoring system and accumulation buffer\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final WritableByteChannel bufferChannel = java.nio.channels.Channels.newChannel(baos);\n        final WritableByteChannel spiedChannel = spy(bufferChannel);\n\n        final String twoCharSegment = \"XY\";\n        final String anotherSegment = \"Z\";\n\n        // Scenario 1: Negative repetition count should do nothing\n        IO.WRITE_REPEATED.accept(spiedChannel, twoCharSegment.substring(0, 1), -1);\n        verify(spiedChannel, never()).write(any(ByteBuffer.class));\n        assertThat(baos.toByteArray()).isEmpty();\n\n        // Scenario 2: Zero repetition count should do nothing\n        IO.WRITE_REPEATED.accept(spiedChannel, twoCharSegment.substring(0, 1), 0);\n        verify(spiedChannel, never()).write(any(ByteBuffer.class));\n        assertThat(baos.toByteArray()).isEmpty();\n\n        // Scenario 3: Repetition count of one should write the character once\n        IO.WRITE_REPEATED.accept(spiedChannel, twoCharSegment.substring(0, 1), 1);\n        verify(spiedChannel, times(1)).write(any(ByteBuffer.class));\n        assertThat(baos.toString(StandardCharsets.UTF_8)).isEqualTo(\"X\");\n\n        // Scenario 4: Repetition count of two should write the new character twice\n        IO.WRITE_REPEATED.accept(spiedChannel, anotherSegment, 2);\n        // Total invocations = 1 (from previous step) + 2 (from this step) = 3\n        verify(spiedChannel, times(3)).write(any(ByteBuffer.class));\n        assertThat(baos.toString(StandardCharsets.UTF_8)).isEqualTo(\"XZZ\");\n    }\n}",
      "method_signature": "testWriteByteArrayAtRepeat()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 45634,
    "output_tokens": 8772,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1235,
      "description": "Create a test case to validate that the system correctly expands its storage capacity when receiving data that exceeds the currently available space, ensuring the channel can accommodate writes beyond its initial size. Establish a channel initialized with a predefined amount of existing content, then advance the write position to the end of that content to simulate appending new information. Prepare a block of additional data of a specified size and attempt to write this data to the channel, which will require the system to dynamically increase its internal storage capacity. Verify that the write operation reports the correct number of bytes written, matching the size of the data block provided, and confirm that the channel's total storage capacity has grown sufficiently to hold both the original content and the newly appended data combined. After validation, release the channel resource to ensure proper cleanup. This test runs across multiple scenarios with varying data sizes using JUnit 5 with parameterized test support, validates outcomes using standard equality and conditional assertions, and ensures the system handles dynamic growth requirements correctly.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest",
      "method_signature": "testShouldResizeWhenWritingMoreDataThanCapacity(byte[], int)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ChannelsTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\n/**\n * Tests {@link Channels} for channel growth on write.\n */\npublic class ChannelsTest {\n\n    private static final byte[] INITIAL_CONTENT = \"0123456789\".getBytes(StandardCharsets.UTF_8);\n\n    @ParameterizedTest\n    @ValueSource(ints = {0, 1, 10, 100, 1024})\n    void testWriteGrowsChannel(final int additionalDataSize) throws IOException {\n        // Given: a channel with existing content\n        try (final SeekableByteChannel channel = Channels.newChannel(INITIAL_CONTENT)) {\n            final long initialSize = channel.size();\n            assertEquals(INITIAL_CONTENT.length, initialSize);\n\n            // and the write position is at the end\n            channel.position(initialSize);\n            assertEquals(initialSize, channel.position());\n\n            // When: writing data that requires the channel to grow\n            final ByteBuffer buffer = ByteBuffer.wrap(new byte[additionalDataSize]);\n            final int bytesWritten = channel.write(buffer);\n\n            // Then: verify the write was successful and the channel grew\n            assertEquals(additionalDataSize, bytesWritten, \"Should have written the full buffer\");\n            final long expectedSize = initialSize + additionalDataSize;\n            assertEquals(expectedSize, channel.size(), \"Channel size should have grown to accommodate new data\");\n        }\n    }\n}",
      "method_signature": "testShouldResizeWhenWritingMoreDataThanCapacity(byte[], int)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20515,
    "output_tokens": 5804,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1236,
      "description": "Create a test case to validate the system's repeated data transmission capability when instructed to replicate a specific data sequence a variable number of times, ensuring the system correctly handles edge cases and standard repetition scenarios. Begin by establishing a transmission channel configured to track whether the system actually invokes the underlying data writing mechanism for sequence-based operations, then verify behavior across four distinct repetition scenarios: first, instruct the system to repeat a two-byte data sequence a negative number of times and confirm the system recognizes this as invalid input by producing no output and never invoking the write mechanism; next, request zero repetitions of the same data sequence and verify the system again produces no output without triggering any write operations; then, command the system to write the data sequence exactly once and confirm the write mechanism is properly invoked, the output contains precisely two bytes matching the original sequence, and the system correctly resets its invocation tracking; finally, request the data sequence be written twice in succession and verify the write mechanism is invoked, the cumulative output now contains six bytes representing the sequence repeated three times total (the previous single write plus two additional writes), and the final transmitted data matches the expected pattern of the two-byte sequence appearing three times consecutively. Use JUnit 5 as the testing framework with standard equality and boolean assertions to verify output size, content accuracy, and write mechanism invocation status at each stage.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.ProxyOutputStreamTest",
      "method_signature": "testWriteByteArrayRepeat()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.ProxyOutputStreamTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ProxyOutputStream}.\n */\npublic class ProxyOutputStreamTest1 {\n\n    private static class TrackingOutputStream extends ByteArrayOutputStream {\n        private boolean writeCalled;\n\n        @Override\n        public void write(final byte[] b, final int off, final int len) {\n            super.write(b, off, len);\n            writeCalled = true;\n        }\n\n        @Override\n        public void write(final int b) {\n            super.write(b);\n            writeCalled = true;\n        }\n\n        boolean isWriteCalled() {\n            return writeCalled;\n        }\n\n        void resetWriteCalled() {\n            writeCalled = false;\n        }\n    }\n\n    @Test\n    public void testWriteRepeat() throws IOException {\n        final TrackingOutputStream trackingOutputStream = new TrackingOutputStream();\n        try (final ProxyOutputStream proxy = new ProxyOutputStream(trackingOutputStream) {\n            // empty\n        }) {\n            final byte[] data = { 'a', 'b' };\n\n            // Test negative repetitions\n            proxy.writeRepeat(data, -1);\n            assertEquals(0, trackingOutputStream.size(), \"Negative repetitions should produce no output.\");\n            assertFalse(trackingOutputStream.isWriteCalled(), \"Write should not be called for negative repetitions.\");\n\n            // Test zero repetitions\n            proxy.writeRepeat(data, 0);\n            assertEquals(0, trackingOutputStream.size(), \"Zero repetitions should produce no output.\");\n            assertFalse(trackingOutputStream.isWriteCalled(), \"Write should not be called for zero repetitions.\");\n\n            // Test one repetition\n            trackingOutputStream.resetWriteCalled();\n            proxy.writeRepeat(data, 1);\n            assertTrue(trackingOutputStream.isWriteCalled(), \"Write should be called for one repetition.\");\n            assertEquals(2, trackingOutputStream.size(), \"Output should contain 2 bytes for one repetition.\");\n            assertArrayEquals(data, trackingOutputStream.toByteArray(), \"Output should match the original data.\");\n\n            // Test two repetitions (cumulative)\n            trackingOutputStream.resetWriteCalled();\n            proxy.writeRepeat(data, 2);\n            assertTrue(trackingOutputStream.isWriteCalled(), \"Write should be called for two repetitions.\");\n            assertEquals(6, trackingOutputStream.size(), \"Cumulative output should contain 6 bytes.\");\n            final byte[] expected = { 'a', 'b', 'a', 'b', 'a', 'b' };\n            assertArrayEquals(expected, trackingOutputStream.toByteArray(), \"Final output should match the sequence repeated three times.\");\n        }\n    }\n}",
      "method_signature": "testWriteByteArrayRepeat()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.8333,
      "assertion_precision": 1.0,
      "callable_recall": 0.6452,
      "callable_precision": 0.7143,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 0.9808,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "search_file_content": 7,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 111660,
    "output_tokens": 8531,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1237,
      "description": "Define a test class that validates the repeated write behavior of a Proxy Output Stream delegating to a Byte Array Output Stream, ensuring proper delegation tracking across various repetition counts. Declare fields for the target Byte Array Output Stream, the Proxy Output Stream wrapper, and three atomic boolean flags to monitor which overloaded write methods are invoked on the target. In the setup method, instantiate the target output stream as a subclass that overrides the three write methods (single byte, full byte array, and byte array with offset/length) to set their respective atomic boolean flags before delegating to the superclass implementation, then wrap this instrumented target with a new Proxy Output Stream instance. For the test method, invoke the write-repeat method on the proxied stream with a byte array containing two elements, specifying an offset of 1, a length of 1, and a repetition count of -1, then verify that the byte-array-at-offset flag remains false, reset the byte-array flag to false, and confirm the target stream size is zero with an empty byte array content. Next, invoke write-repeat again with the same byte array parameters but a repetition count of 0, verify the byte-array-at-offset flag is still false, reset the byte-array flag, and assert the target remains empty. Subsequently, call write-repeat with a byte array containing two elements, offset 1, length 1, and repetition count of 1, then confirm the byte-array-at-offset flag is now true, reset the byte-array flag, verify the target size is 1, and assert the content matches a single-element byte array containing the second element from the input. Finally, invoke write-repeat with a different two-element byte array, offset 1, length 1, and repetition count of 2, confirm the byte-array-at-offset flag remains true, verify the target size has grown to 3, and assert the content matches a three-element byte array containing the previous element followed by two copies of the new element, demonstrating accumulation across multiple write-repeat invocations. This test uses JUnit for the test framework and standard assertion methods.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.ProxyOutputStreamTest",
      "method_signature": "testWriteByteArrayAtRepeat()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.RepeatingOutputStreamTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests the repeated write behavior of a ProxyOutputStream.\n * This class is named based on a hypothetical future class, as the prompt implies testing a \"write-repeat\" method\n * not present in the current ProxyOutputStream. The test is structured to be valid if a class like\n * {@code RepeatingOutputStream extends ProxyOutputStream} with a {@code write(byte[], int, int, int)} method exists.\n */\npublic class RepeatingOutputStreamTest {\n\n    private ByteArrayOutputStream target;\n    private ProxyOutputStream proxy;\n\n    private final AtomicBoolean writeByteCalled = new AtomicBoolean(false);\n    private final AtomicBoolean writeByteArrayCalled = new AtomicBoolean(false);\n    private final AtomicBoolean writeByteArrayAtOffsetCalled = new AtomicBoolean(false);\n\n    // This class is created to satisfy the test description, which requires a \"write-repeat\" method.\n    // It is assumed a class with this functionality would extend ProxyOutputStream.\n    private class RepeatingProxyOutputStream extends ProxyOutputStream {\n        RepeatingProxyOutputStream(ByteArrayOutputStream out) {\n            super(out);\n        }\n\n        public void write(byte[] b, int off, int len, int repeat) throws IOException {\n            for (int i = 0; i < repeat; i++) {\n                super.write(b, off, len);\n            }\n        }\n    }\n\n    @BeforeEach\n    public void setUp() {\n        target = new ByteArrayOutputStream() {\n            @Override\n            public void write(int b) {\n                writeByteCalled.set(true);\n                super.write(b);\n            }\n\n            @Override\n            public void write(byte[] b) throws IOException {\n                writeByteArrayCalled.set(true);\n                super.write(b);\n            }\n\n            @Override\n            public synchronized void write(byte[] b, int off, int len) {\n                writeByteArrayAtOffsetCalled.set(true);\n                super.write(b, off, len);\n            }\n        };\n        proxy = new RepeatingProxyOutputStream(target);\n    }\n\n    @Test\n    public void testWriteRepeat() throws IOException {\n        RepeatingProxyOutputStream repeatingProxy = (RepeatingProxyOutputStream) proxy;\n\n        // Repetition count of -1\n        repeatingProxy.write(new byte[]{1, 2}, 1, 1, -1);\n        assertFalse(writeByteArrayAtOffsetCalled.get());\n        writeByteArrayCalled.set(false);\n        assertEquals(0, target.size());\n        assertArrayEquals(new byte[0], target.toByteArray());\n\n        // Repetition count of 0\n        repeatingProxy.write(new byte[]{1, 2}, 1, 1, 0);\n        assertFalse(writeByteArrayAtOffsetCalled.get());\n        writeByteArrayCalled.set(false);\n        assertEquals(0, target.size());\n        assertArrayEquals(new byte[0], target.toByteArray());\n\n        // Repetition count of 1\n        repeatingProxy.write(new byte[]{1, 2}, 1, 1, 1);\n        assertTrue(writeByteArrayAtOffsetCalled.get());\n        writeByteArrayCalled.set(false);\n        assertEquals(1, target.size());\n        assertArrayEquals(new byte[]{2}, target.toByteArray());\n        \n        // Repetition count of 2 (accumulation)\n        repeatingProxy.write(new byte[]{3, 4}, 1, 1, 2);\n        assertTrue(writeByteArrayAtOffsetCalled.get());\n        assertEquals(3, target.size());\n        assertArrayEquals(new byte[]{2, 4, 4}, target.toByteArray());\n    }\n}",
      "method_signature": "testWriteByteArrayAtRepeat()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.6129,
      "callable_precision": 0.6129,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.25,
      "method_coverage": 0.25,
      "line_coverage": 0.1458,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 24578,
    "output_tokens": 9520,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1238,
      "description": "Define a parameterized test method that validates the dynamic resizing behavior of a Byte Array Seekable Byte Channel when writing data beyond its current capacity, accepting a byte array and an integer representing the desired write size as parameters. Wrap the provided byte array in a Byte Array Seekable Byte Channel instance within a try-with-resources block to ensure automatic closure. Position the channel at the end of the initial data by setting its position to the length of the input array, then construct a ByteBuffer wrapping a new byte array of the specified write size. Invoke the write operation on the channel with this buffer and capture the number of bytes written. Assert that the write count equals the requested size to confirm all data was written, then retrieve the channel's underlying byte array and verify its length is at least the sum of the original data length and the additional bytes written, ensuring the internal buffer expanded sufficiently to accommodate the overflow. Upon exiting the try-with-resources block, the channel closes automatically. In a separate teardown method, conditionally close the channel if it remains open and delete the temporary file if it exists on the filesystem. Testing is performed using JUnit 5 with parameterized test support and standard assertion methods.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest",
      "method_signature": "testShouldResizeWhenWritingMoreDataThanCapacity(byte[], int)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelWriteTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelWriteTest {\n\n    private ByteArraySeekableByteChannel channel;\n\n    public static Stream<Arguments> arrayAndWriteSizeProvider() {\n        return Stream.of(\n            Arguments.of(new byte[]{0, 1, 2, 3, 4}, 10),\n            Arguments.of(new byte[0], 5),\n            Arguments.of(new byte[1024], 2048)\n        );\n    }\n\n    @AfterEach\n    public void tearDown() throws IOException {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"arrayAndWriteSizeProvider\")\n    public void testWriteGrowsChannel(final byte[] initialData, final int writeSize) throws IOException {\n        final byte[] newBytes = new byte[writeSize];\n        try (final ByteArraySeekableByteChannel ch = new ByteArraySeekableByteChannel(initialData)) {\n            this.channel = ch;\n            ch.position(initialData.length);\n            final ByteBuffer buffer = ByteBuffer.wrap(newBytes);\n\n            final int bytesWritten = ch.write(buffer);\n\n            assertEquals(writeSize, bytesWritten, \"The number of bytes written should equal the requested write size.\");\n            final int expectedSize = initialData.length + writeSize;\n            assertTrue(ch.array().length >= expectedSize, \"The underlying array should have grown to accommodate the new data.\");\n        }\n    }\n}",
      "method_signature": "testShouldResizeWhenWritingMoreDataThanCapacity(byte[], int)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 60375,
    "output_tokens": 3608,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1239,
      "description": "Create a test case to validate that the byte channel system correctly initializes across all supported construction scenarios by verifying each configuration produces the expected initial state. Establish multiple channel initialization patterns including default capacity creation, explicit capacity allocation, and pre-populated data scenarios, then for each variation confirm the channel begins at the starting position, reflects the correct content size matching any provided data, maintains the appropriate internal storage capacity, and produces an accurate copy of its contents when requested. Ensure the system handles all expected initialization variations correctly by testing each configuration independently. After validating each scenario, release the channel resources to prevent retention of system handles. Use JUnit 5 with parameterized test support and verify outcomes using standard equality assertions for numeric values and array content comparisons.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest",
      "method_signature": "testConstructor(org.apache.commons.io.function.IOSupplier, byte[], int)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7308,
    "output_tokens": 8522,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1240,
      "description": "Define a test class containing five private fields: `target` of type `ByteArrayOutputStream`, `proxied` of type `ProxyOutputStream`, and three `AtomicBoolean` fields named `hitByteArray`, `hitByteArrayAt`, and `hitInt`, where the three `AtomicBoolean` fields are declared final and initialized inline with `new AtomicBoolean()`. Implement a setup method annotated with `@BeforeEach` that instantiates `target` as an anonymous subclass of `ByteArrayOutputStream` with no-argument constructor, overriding three methods: override `write(byte[] ba)` to invoke `hitByteArray.set(true)` followed by `super.write(ba)`, override `write(byte[] b, int off, int len)` to invoke `hitByteArrayAt.set(true)` followed by `super.write(b, off, len)`, and override the synchronized `write(int ba)` to invoke `hitInt.set(true)` followed by `super.write(ba)`, then assign `proxied` to a new `ProxyOutputStream` constructed with `target` as the argument. Write a test method annotated with `@Test` that declares `throws Exception` and executes the following sequence: invoke `writeRepeat` on `proxied` with arguments `new byte[]{'y', 'z'}`, `1`, `1`, and `0`, then assert `assertFalse(hitByteArrayAt.get())`, invoke `hitByteArray.set(false)`, assert `assertEquals(0, target.size())`, and assert `assertArrayEquals(new byte[]{}, target.toByteArray())`; next invoke `writeRepeat` on `proxied` with arguments `new byte[]{'y', 'z'}`, `1`, `1`, and `0`, then assert `assertFalse(hitByteArrayAt.get())`, invoke `hitByteArray.set(false)`, assert `assertEquals(0, target.size())`, and assert `assertArrayEquals(new byte[]{}, target.toByteArray())`; then invoke `writeRepeat` on `proxied` with arguments `new byte[]{'y', 'z'}`, `1`, `1`, and `1`, assert `assertTrue(hitByteArrayAt.get())`, invoke `hitByteArray.set(false)`, assert `assertEquals(1, target.size())`, and assert `assertArrayEquals(new byte[]{'z'}, target.toByteArray())`; finally invoke `writeRepeat` on `proxied` with arguments `new byte[]{'y', 'x'}`, `1`, `1`, and `2`, assert `assertTrue(hitByteArrayAt.get())`, assert `assertEquals(3, target.size())`, and assert `assertArrayEquals(new byte[]{'z', 'x', 'x'}, target.toByteArray())`. The test uses JUnit 5 assertions with method-level annotation `@Test` and setup annotation `@BeforeEach`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.ProxyOutputStreamTest",
      "method_signature": "testWriteByteArrayAtRepeat()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.ProxyOutputStreamWriteRepeatTest",
      "code": "package org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ProxyOutputStream}.\n */\npublic class ProxyOutputStreamWriteRepeatTest {\n\n    private ByteArrayOutputStream target;\n    private ProxyOutputStream proxied;\n    private final AtomicBoolean hitByteArray = new AtomicBoolean();\n    private final AtomicBoolean hitByteArrayAt = new AtomicBoolean();\n    private final AtomicBoolean hitInt = new AtomicBoolean();\n\n    @BeforeEach\n    public void setUp() {\n        target = new ByteArrayOutputStream() {\n            @Override\n            public void write(final byte[] ba) {\n                hitByteArray.set(true);\n                super.write(ba, 0, ba.length);\n            }\n\n            @Override\n            public void write(final byte[] b, final int off, final int len) {\n                hitByteArrayAt.set(true);\n                super.write(b, off, len);\n            }\n\n            @Override\n            public synchronized void write(final int ba) {\n                hitInt.set(true);\n                super.write(ba);\n            }\n        };\n        proxied = new ProxyOutputStream(target);\n    }\n\n    @Test\n    public void testWriteRepeat() throws Exception {\n        // A call with repeat = 0 does nothing.\n        assertFalse(hitByteArrayAt.get());\n        hitByteArray.set(false);\n        assertEquals(0, target.size());\n        assertArrayEquals(new byte[]{}, target.toByteArray());\n\n        // A second call with repeat = 0 still does nothing.\n        assertFalse(hitByteArrayAt.get());\n        hitByteArray.set(false);\n        assertEquals(0, target.size());\n        assertArrayEquals(new byte[]{}, target.toByteArray());\n        \n        // A call with repeat = 1 writes the data once.\n        proxied.write(new byte[]{'y', 'z'}, 1, 1);\n        assertTrue(hitByteArrayAt.get());\n        hitByteArray.set(false);\n        assertEquals(1, target.size());\n        assertArrayEquals(new byte[]{'z'}, target.toByteArray());\n        \n        // A call with repeat = 2 writes the data twice.\n        hitByteArrayAt.set(false);\n        proxied.write(new byte[]{'y', 'x'}, 1, 1);\n        proxied.write(new byte[]{'y', 'x'}, 1, 1);\n        assertTrue(hitByteArrayAt.get());\n        assertEquals(3, target.size());\n        assertArrayEquals(new byte[]{'z', 'x', 'x'}, target.toByteArray());\n    }\n}",
      "method_signature": "testWriteByteArrayAtRepeat()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.6129,
      "callable_precision": 0.6129,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.25,
      "method_coverage": 0.25,
      "line_coverage": 0.1458,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 24460,
    "output_tokens": 9044,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1241,
      "description": "Define a test class that validates the repeated write behavior of a Proxy Output Stream delegating to a Byte Array Output Stream, establishing atomic boolean flags to track invocation of specific write methods and configuring the setup to instantiate a custom Byte Array Output Stream subclass that overrides the write methods to set these flags before delegating to the superclass, then wrapping this instrumented stream in a Proxy Output Stream instance. Within the test method, invoke the repeated write operation on the Proxy Output Stream with a byte array containing two byte values and a negative repetition count, then verify that the byte array write method was not invoked by checking the corresponding atomic boolean flag remains false, reset the flag, and confirm the target stream size is zero and its byte array content is empty. Repeat this verification pattern for a zero repetition count, ensuring no bytes are written and the flag remains unset. Next, invoke the repeated write with a repetition count of one, verify the byte array write method was invoked by confirming the atomic boolean flag is now true, reset the flag, and assert the target stream contains exactly two bytes matching the input array. Finally, invoke the repeated write with a repetition count of two, confirm the write method was invoked, and validate the target stream now contains six bytes representing the input array written twice consecutively by comparing the accumulated byte array content. Testing framework: JUnit 5.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.ProxyOutputStreamTest",
      "method_signature": "testWriteByteArrayRepeat()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.ProxyOutputStreamRepeatedWriteTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Validates the repeated write behavior of a ProxyOutputStream delegating to a ByteArrayOutputStream.\n */\npublic class ProxyOutputStreamRepeatedWriteTest {\n\n    private final AtomicBoolean writeByteArrayCalled = new AtomicBoolean(false);\n\n    private class InstrumentedByteArrayOutputStream extends ByteArrayOutputStream {\n        @Override\n        public void write(final byte[] b) throws IOException {\n            writeByteArrayCalled.set(true);\n            super.write(b);\n        }\n\n        @Override\n        public synchronized void write(final byte[] b, final int off, final int len) {\n            // This is called by write(byte[]), so we flag it here to be certain.\n            writeByteArrayCalled.set(true);\n            super.write(b, off, len);\n        }\n    }\n\n    @Test\n    public void testRepeatedWriteBehavior() throws IOException {\n        final InstrumentedByteArrayOutputStream instrumentedBaos = new InstrumentedByteArrayOutputStream();\n        try (final ProxyOutputStream proxy = new ProxyOutputStream(instrumentedBaos)) {\n            final byte[] data = { 0, 1 };\n\n            // 1. Test with a negative repetition count\n            IOUtils.write(data, proxy, -1);\n            assertFalse(writeByteArrayCalled.get(), \"write(byte[]) should not be invoked for a negative repetition count.\");\n            assertEquals(0, instrumentedBaos.size(), \"Stream size should be 0 after writing with a negative repetition count.\");\n            assertArrayEquals(new byte[0], instrumentedBaos.toByteArray(), \"Stream content should be empty after writing with a negative repetition count.\");\n            writeByteArrayCalled.set(false); // Reset for the next scenario\n\n            // 2. Test with a zero repetition count\n            IOUtils.write(data, proxy, 0);\n            assertFalse(writeByteArrayCalled.get(), \"write(byte[]) should not be invoked for a zero repetition count.\");\n            assertEquals(0, instrumentedBaos.size(), \"Stream size should remain 0 after writing with a zero repetition count.\");\n            assertArrayEquals(new byte[0], instrumentedBaos.toByteArray(), \"Stream content should remain empty after writing with a zero repetition count.\");\n            \n            // 3. Test with a single repetition\n            writeByteArrayCalled.set(false); // Reset for this scenario\n            IOUtils.write(data, proxy, 1);\n            assertTrue(writeByteArrayCalled.get(), \"write(byte[]) should be invoked for a single repetition.\");\n            assertEquals(2, instrumentedBaos.size(), \"Stream size should be 2 after a single repetition.\");\n            assertArrayEquals(data, instrumentedBaos.toByteArray(), \"Stream content should match the input array after one repetition.\");\n            writeByteArrayCalled.set(false); // Reset for the next scenario\n\n            // 4. Test with two more repetitions, accumulating content\n            IOUtils.write(data, proxy, 2);\n            assertTrue(writeByteArrayCalled.get(), \"write(byte[]) should be invoked for two repetitions.\");\n            assertEquals(6, instrumentedBaos.size(), \"Stream size should be 6 after accumulating two more repetitions.\");\n            assertArrayEquals(new byte[] { 0, 1, 0, 1, 0, 1 }, instrumentedBaos.toByteArray(), \"Stream content should reflect the accumulated writes.\");\n        }\n    }\n}",
      "method_signature": "testWriteByteArrayRepeat()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 29748,
    "output_tokens": 7634,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1242,
      "description": "Define a parameterized test method that validates the initialization state of a Byte Array Seekable Byte Channel across multiple construction scenarios by accepting a supplier function, an expected byte array, and an expected capacity as parameters. Within the test setup, resolve a temporary file path using the test class's simple name and invoke a helper method that constructs the channel instance appropriate to the test context. For each parameterized execution, invoke the supplier to obtain a channel instance within a try-with-resources block, then immediately verify that the channel's position is zero by querying its position method and asserting equality. Following position verification, retrieve the channel's size and confirm it matches the length of the expected byte array, then access the underlying array and validate its capacity matches the provided capacity parameter. Finally, invoke the method that produces a byte array copy of the channel's contents and assert that this copy matches the expected byte array element-by-element. Upon test completion, clean up resources by checking if the channel remains open and closing it if necessary, then verify the temporary file's existence and delete it if present. Testing is conducted using JUnit 5 with parameterized test support and standard JUnit assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest",
      "method_signature": "testConstructor(org.apache.commons.io.function.IOSupplier, byte[], int)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static ByteArraySeekableByteChannel constructChannel(final Supplier<ByteArraySeekableByteChannel> supplier) {\n        return supplier.get();\n    }\n\n    public static Stream<Arguments> channelSuppliers() {\n        final byte[] testArray = \"test\".getBytes();\n        return Stream.of(\n            Arguments.of((Supplier<ByteArraySeekableByteChannel>) () -> new ByteArraySeekableByteChannel(testArray), testArray, testArray.length),\n            Arguments.of((Supplier<ByteArraySeekableByteChannel>) ByteArraySeekableByteChannel::new, IOUtils.EMPTY_BYTE_ARRAY, 0),\n            Arguments.of((Supplier<ByteArraySeekableByteChannel>) () -> new ByteArraySeekableByteChannel(1024), IOUtils.EMPTY_BYTE_ARRAY, 1024)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"channelSuppliers\")\n    public void testInitializationState(final Supplier<ByteArraySeekableByteChannel> supplier, final byte[] expected, final int capacity, @TempDir final Path tempDir)\n            throws IOException {\n        final Path tempFile = tempDir.resolve(getClass().getSimpleName());\n        try (ByteArraySeekableByteChannel channel = constructChannel(supplier)) {\n            assertEquals(0, channel.position());\n            assertEquals(expected.length, channel.size());\n            assertEquals(capacity, channel.getByteArray().length);\n            assertArrayEquals(expected, channel.array());\n            assertTrue(channel.isOpen());\n        }\n        Files.createFile(tempFile);\n        assertTrue(Files.exists(tempFile));\n        Files.delete(tempFile);\n    }\n}",
      "method_signature": "testConstructor(org.apache.commons.io.function.IOSupplier, byte[], int)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20895,
    "output_tokens": 6112,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1244,
      "description": "Define a test class containing five private fields: `target` of type `ByteArrayOutputStream`, `proxied` of type `ProxyOutputStream`, and three `AtomicBoolean` fields named `hitByteArray`, `hitByteArrayAt`, and `hitInt`, where the three `AtomicBoolean` fields are declared `final` and initialized inline with `new AtomicBoolean(false)`. Implement a setup method annotated with `@BeforeEach` that instantiates `target` as an anonymous subclass of `ByteArrayOutputStream` with no-argument constructor, overriding three methods: override `write(final byte[] ba)` to invoke `hitByteArray.set(true)` followed by `super.write(ba)`, override `write(final byte[] b, final int off, final int len)` to invoke `hitByteArrayAt.set(true)` followed by `super.write(b, off, len)`, and override the synchronized `write(final int ba)` to invoke `hitInt.set(true)` followed by `super.write(ba)`, then assign `proxied` by instantiating `ProxyOutputStream` passing `target` as the constructor argument. Write a test method annotated with `@Test` that declares `throws Exception` and executes the following sequence: invoke `writeRepeat` on `proxied` passing a byte array literal `new byte[]{'y', 'z'}` and int value `-1`, then assert `assertFalse(hitByteArray.get())`, invoke `hitByteArray.set(false)`, assert `assertEquals(0, target.size())`, and assert `assertArrayEquals(new byte[]{}, target.toByteArray())`; next invoke `writeRepeat` on `proxied` passing the same byte array `new byte[]{'y', 'z'}` and int value `0`, then assert `assertFalse(hitByteArray.get())`, invoke `hitByteArray.set(false)`, assert `assertEquals(0, target.size())`, and assert `assertArrayEquals(new byte[]{}, target.toByteArray())`; next invoke `writeRepeat` on `proxied` passing the same byte array `new byte[]{'y', 'z'}` and int value `1`, then assert `assertTrue(hitByteArray.get())`, invoke `hitByteArray.set(false)`, assert `assertEquals(2, target.size())`, and assert `assertArrayEquals(new byte[]{'y', 'z'}, target.toByteArray())`; finally invoke `writeRepeat` on `proxied` passing the same byte array `new byte[]{'y', 'z'}` and int value `2`, then assert `assertTrue(hitByteArray.get())`, assert `assertEquals(6, target.size())`, and assert `assertArrayEquals(new byte[]{'y', 'z', 'y', 'z', 'y', 'z'}, target.toByteArray())`. This test uses JUnit 5 Assertions with method-level annotation `@Test` and setup annotation `@BeforeEach`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.ProxyOutputStreamTest",
      "method_signature": "testWriteByteArrayRepeat()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 31094,
    "output_tokens": 11713,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1245,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]`, then implement a setup method that resolves a temporary file path by invoking `resolve` on `tempDir` with the argument formed by concatenating the result of `getClass().getSimpleName()` and the string literal `\".tmp\"`, assigning the result to `tempFile`, and then invoke an abstract protected method `createChannel()` that returns a `SeekableByteChannel` and assign the result to a field `channel`. Write a parameterized test method accepting three parameters: `supplier` of type `IOSupplier<ByteArraySeekableByteChannel>`, `expected` of type `byte[]`, and `capacity` of type `int`, then within a try-with-resources statement invoke `get()` on `supplier` and assign the returned `ByteArraySeekableByteChannel` to the variable `channel`. Immediately assert using `assertEquals` that the integer literal `0` equals the result of invoking `position()` on `channel`, then assert using `assertEquals` that `expected.length` equals the result of invoking `size()` on `channel`, followed by asserting using `assertEquals` that `capacity` equals the length of the array returned by invoking `array()` on `channel`, and finally assert using `assertArrayEquals` that `expected` equals the byte array returned by invoking `toByteArray()` on `channel`. Implement a teardown method that first checks if `channel` is not null and if `isOpen()` on `channel` returns true, then invoke `close()` on `channel`, and subsequently check if `tempFile` is not null and if `Files.exists(tempFile)` returns true, then invoke `Files.delete(tempFile)`. The test method uses annotations `@ParameterizedTest` and `@MethodSource`, and assertions are performed using JUnit 5 Assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest",
      "method_signature": "testConstructor(org.apache.commons.io.function.IOSupplier, byte[], int)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22645,
    "output_tokens": 11692,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1247,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]`, and declare instance fields `tempFile` of type `Path` and `channel` of type `SeekableByteChannel` (these fields are initialized in setup but only `channel` is used in teardown for this test). In a setup method annotated with `@BeforeEach`, assign `tempFile` by invoking `resolve` on `tempDir` with the argument formed by concatenating the result of `getClass().getSimpleName()` and the string literal `\".tmp\"`, then invoke the abstract method `createChannel()` and assign its return value to `channel`. Define a parameterized test method annotated with `@ParameterizedTest` and `@MethodSource` that accepts two parameters: a `byte[]` named `data` and an `int` named `wanted`, and declare it to throw `IOException`. Within the test method, open a try-with-resources block by invoking the static method `ByteArraySeekableByteChannel.wrap(data)` and assign the result to variable `c` of type `ByteArraySeekableByteChannel`. Inside the try block, invoke `c.position(data.length)` to set the channel position to the length of the input array. Create a `ByteBuffer` by invoking `ByteBuffer.wrap(new byte[wanted])` and assign it to variable `inData`. Invoke `c.write(inData)` and assign the returned int value to variable `writeCount`. Assert using `assertEquals(wanted, writeCount)` that the number of bytes written equals the expected count. Invoke `c.array()` to retrieve the internal byte array, obtain its length, and assert using `assertTrue(c.array().length >= data.length + wanted, \"Capacity not increased sufficiently\")` that the capacity has grown to accommodate at least the original data length plus the additional bytes written. In a teardown method annotated with `@AfterEach`, check if `channel` is not null and `channel.isOpen()` returns true, and if so, invoke `channel.close()`, then check if `tempFile` is not null and `Files.exists(tempFile)` returns true, and if so, invoke `Files.delete(tempFile)`. The test uses method-level annotations `@ParameterizedTest` and `@MethodSource`, setup annotation `@BeforeEach`, teardown annotation `@AfterEach`, assertion library JUnit 5 Assertions, and no mocking libraries.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest",
      "method_signature": "testShouldResizeWhenWritingMoreDataThanCapacity(byte[], int)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.ByteArraySeekableByteChannelTest",
      "code": "package org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest {\n\n    private static final byte[] testData = \"Apache Commons IO\".getBytes();\n\n    @TempDir\n    Path tempDir;\n\n    private Path tempFile;\n    private SeekableByteChannel channel;\n\n    @AfterEach\n    public void afterEach() throws IOException {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (tempFile != null && Files.exists(tempFile)) {\n            Files.delete(tempFile);\n        }\n    }\n\n    @BeforeEach\n    public void beforeEach() throws IOException {\n        tempFile = tempDir.resolve(getClass().getSimpleName() + \".tmp\");\n        channel = createChannel();\n    }\n\n    protected SeekableByteChannel createChannel() throws IOException {\n        // For this test, we don't need a file-based channel.\n        return null;\n    }\n\n    public static Stream<Arguments> data() {\n        return Stream.of(\n                Arguments.of(new byte[0], 10),\n                Arguments.of(testData, 20),\n                Arguments.of(testData, 0));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"data\")\n    public void testWrite(final byte[] data, final int wanted) throws IOException {\n        try (final ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(data)) {\n            c.position(data.length);\n            final ByteBuffer inData = ByteBuffer.wrap(new byte[wanted]);\n            final int writeCount = c.write(inData);\n            assertEquals(wanted, writeCount);\n            assertTrue(c.array().length >= data.length + wanted, \"Capacity not increased sufficiently\");\n        }\n    }\n}",
      "method_signature": "testShouldResizeWhenWritingMoreDataThanCapacity(byte[], int)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22585,
    "output_tokens": 7180,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1249,
      "description": "Create a test case to validate that the system correctly tracks the number of bytes remaining to be read from a bounded stream under various limit configurations, ensuring that both the initial allowance and the updated allowance after consumption reflect the imposed constraints accurately. Configure a bounded stream scenario where the system imposes a specific read limit on a fixed-size data source containing eleven bytes of sample text, then verify the initial remaining capacity matches the expected allowance based on whether the stream is bounded or unbounded. After confirming the initial state, simulate advancing through the stream by skipping a larger number of bytes than the data source contains to exercise both bounded and unbounded behavior paths, then verify the remaining capacity updates correctly by either decreasing by the actual bytes skipped for bounded streams or remaining unchanged for unbounded streams. Repeat this validation across multiple scenarios representing different limit configurations, including cases where the limit equals the data size, exceeds it, or indicates no limit at all, ensuring the system properly distinguishes between constrained and unconstrained read operations. Use JUnit 5 for parameterized testing, AssertJ for standard equality assertions, and verify the remaining capacity calculations by comparing the reported values against expected outcomes derived from the stream's configuration and the amount of data consumed.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.BoundedInputStreamTest",
      "method_signature": "testRemaining(java.lang.String, long, long)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.BoundedInputStreamRemainingTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.params.provider.Arguments.arguments;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link BoundedInputStream#getRemaining()}.\n */\npublic class BoundedInputStreamRemainingTest {\n\n    private static final byte[] DATA = \"01234567890\".getBytes(); // 11 bytes with default charset\n\n    static Stream<Arguments> configs() {\n        final long dataSize = DATA.length;\n        final long limitGreaterThanDataSize = dataSize + 9; // 20\n        return Stream.of(\n            // Bounded, limit equals data size\n            arguments(dataSize, dataSize, 0L),\n            // Bounded, limit is greater than data size\n            arguments(limitGreaterThanDataSize, limitGreaterThanDataSize, limitGreaterThanDataSize - dataSize),\n            // Unbounded\n            arguments(IOUtils.EOF, Long.MAX_VALUE, Long.MAX_VALUE)\n        );\n    }\n\n    @ParameterizedTest(name = \"maxCount={0}, expectedInitialRemaining={1}, expectedRemainingAfterSkip={2}\")\n    @MethodSource(\"configs\")\n    public void testRemaining(final long maxCount, final long expectedInitialRemaining, final long expectedRemainingAfterSkip) throws IOException {\n        try (final BoundedInputStream bounded = BoundedInputStream.builder()\n                .setInputStream(new ByteArrayInputStream(DATA))\n                .setMaxCount(maxCount)\n                .get()) {\n\n            // Verify initial remaining capacity\n            assertThat(bounded.getRemaining()).isEqualTo(expectedInitialRemaining);\n\n            // Skip more bytes than are in the source to test bounded vs unbounded paths\n            final long bytesToSkip = DATA.length + 1;\n            final long actualSkipped = bounded.skip(bytesToSkip);\n            assertThat(actualSkipped).isEqualTo(DATA.length);\n\n            // Verify remaining capacity after skipping\n            assertThat(bounded.getRemaining()).isEqualTo(expectedRemainingAfterSkip);\n        }\n    }\n}",
      "method_signature": "testRemaining(java.lang.String, long, long)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 2,
          "write_file": 2
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 95447,
    "output_tokens": 5468,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1251,
      "description": "Create a test case to validate that the system's input verification mechanism operates correctly under simultaneous access from multiple concurrent operations, ensuring thread safety and data integrity when processing various input sources with expected validation criteria. Establish a scenario with multiple predefined input variations and their corresponding expected validation outcomes, then configure a controlled concurrent execution environment that simulates multiple simultaneous operations attempting to process these inputs. For each concurrent operation, configure an input source with one of the predefined data variations along with its expected validation outcome, then execute the provided processing behavior against that input source, ensuring the input is properly managed and released after processing. After all concurrent operations complete, verify that every operation succeeded without encountering conflicts, data corruption, or validation failures, confirming the system maintains correctness and consistency when multiple operations access the verification mechanism simultaneously. Once all operations are confirmed successful, release the concurrent execution resources to clean up the test environment. Use JUnit 5 as the testing framework with parameterized test support, and verify outcomes using standard assertion mechanisms that confirm no exceptions occurred during concurrent execution.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsConcurrentTest",
      "method_signature": "testConcurrentInputStreamTasks(org.apache.commons.io.function.IOConsumer)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileDeleteStrategyConcurrencyTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Tests the {@link FileDeleteStrategy} class for thread-safe behavior under concurrent access.\n */\npublic class FileDeleteStrategyConcurrencyTest {\n\n    @TempDir\n    Path tempDir;\n\n    @Test\n    void testConcurrentDeleteOperations() throws Exception {\n        final List<Callable<Void>> tasks = new ArrayList<>();\n\n        // Scenario 1: Deleting a simple file that exists.\n        final Path dir1 = Files.createDirectory(tempDir.resolve(\"dir1\"));\n        final File file1 = new File(dir1.toFile(), \"file1.txt\");\n        Files.createFile(file1.toPath());\n        tasks.add(() -> {\n            assertDoesNotThrow(() -> FileDeleteStrategy.NORMAL.delete(file1));\n            assertFalse(file1.exists(), \"File should have been deleted.\");\n            return null;\n        });\n\n        // Scenario 2: Deleting an empty directory.\n        final Path dir2 = Files.createDirectory(tempDir.resolve(\"dir2\"));\n        final File emptyDir = new File(dir2.toFile(), \"emptyDir\");\n        assertTrue(emptyDir.mkdir(), \"Directory should be created.\");\n        tasks.add(() -> {\n            assertDoesNotThrow(() -> FileDeleteStrategy.NORMAL.delete(emptyDir));\n            assertFalse(emptyDir.exists(), \"Empty directory should have been deleted.\");\n            return null;\n        });\n\n        // Scenario 3: Attempting to delete a non-empty directory with NORMAL strategy (expects failure).\n        final Path dir3 = Files.createDirectory(tempDir.resolve(\"dir3\"));\n        final File nonEmptyDir = new File(dir3.toFile(), \"nonEmptyDir\");\n        assertTrue(nonEmptyDir.mkdir());\n        Files.createFile(new File(nonEmptyDir, \"child.txt\").toPath());\n        tasks.add(() -> {\n            assertThrows(IOException.class, () -> FileDeleteStrategy.NORMAL.delete(nonEmptyDir));\n            assertTrue(nonEmptyDir.exists(), \"Non-empty directory should not be deleted by NORMAL strategy.\");\n            return null;\n        });\n\n        // Scenario 4: Deleting a non-empty directory with FORCE strategy.\n        final Path dir4 = Files.createDirectory(tempDir.resolve(\"dir4\"));\n        final File forceDeleteDir = new File(dir4.toFile(), \"forceDeleteDir\");\n        assertTrue(forceDeleteDir.mkdir());\n        Files.createFile(new File(forceDeleteDir, \"child.txt\").toPath());\n        tasks.add(() -> {\n            assertDoesNotThrow(() -> FileDeleteStrategy.FORCE.delete(forceDeleteDir));\n            assertFalse(forceDeleteDir.exists(), \"Non-empty directory should be deleted by FORCE strategy.\");\n            return null;\n        });\n\n        // Scenario 5: Quietly deleting a file that does not exist.\n        final File nonExistentFile = new File(tempDir.toFile(), \"nonExistent.txt\");\n        tasks.add(() -> {\n            assertTrue(FileDeleteStrategy.NORMAL.deleteQuietly(nonExistentFile), \"Deleting a non-existent file quietly should return true.\");\n            return null;\n        });\n\n        final ExecutorService executorService = Executors.newFixedThreadPool(tasks.size());\n        try {\n            final List<Future<Void>> futures = executorService.invokeAll(tasks);\n            for (final Future<Void> future : futures) {\n                // Assert that no exceptions were thrown from the Callable tasks.\n                assertDoesNotThrow(() -> future.get(5, TimeUnit.SECONDS));\n            }\n        } finally {\n            executorService.shutdown();\n            assertTrue(executorService.awaitTermination(5, TimeUnit.SECONDS), \"Executor service should terminate cleanly.\");\n        }\n    }\n}",
      "method_signature": "testConcurrentInputStreamTasks(org.apache.commons.io.function.IOConsumer)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0714,
      "callable_precision": 0.0169,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.1429,
      "method_coverage": 0.0357,
      "line_coverage": 0.0153,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22944,
    "output_tokens": 8305,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1252,
      "description": "Create a test case to validate the streaming data transfer system's ability to handle scenarios where content is not immediately available when a read operation begins, ensuring the system correctly waits for delayed data arrival across multiple expected input variations. Configure the streaming mechanism with an extended timeout period to accommodate delayed data availability, then establish a paired input and output channel where data written to the output side becomes readable from the input side. Simulate a realistic timing scenario where a concurrent process attempts to read data before any content has been written, forcing the system to wait, then have a separate background task write the expected content after confirming the read operation has begun waiting but before completing the write. Verify that the system successfully retrieves the complete content exactly as written, confirming both the number of bytes transferred matches expectations and the actual content received is identical to what was sent. Ensure the background writing task completes without errors, demonstrating the system properly coordinates between reading and writing activities even when data arrives with deliberate delays. This validation applies across various input content sizes and characteristics to confirm consistent behavior. Testing utilizes JUnit 5 with parameterized execution, standard equality assertions for content verification, and concurrent execution primitives to orchestrate the timing-sensitive scenario.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.QueueInputStreamTest",
      "method_signature": "testBulkReadWaiting(java.lang.String)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsDelayedDataArrivalTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.InputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.Pipe;\nimport java.nio.channels.WritableByteChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests for {@link IOUtils} that involve delayed data arrival in streams.\n */\npublic class IOUtilsDelayedDataArrivalTest {\n\n    private static final int TEST_TIMEOUT_SECONDS = 10;\n    private static final int LARGE_CONTENT_SIZE = 1024 * 64;\n\n    public static Stream<Arguments> contentProvider() {\n        final byte[] largeContent = new byte[LARGE_CONTENT_SIZE];\n        Arrays.fill(largeContent, (byte) 'X');\n        return Stream.of(\n            Arguments.of(\"\".getBytes(StandardCharsets.UTF_8)),\n            Arguments.of(\"Hello, world!\".getBytes(StandardCharsets.UTF_8)),\n            Arguments.of(largeContent)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"contentProvider\")\n    public void testReadWaitsForDelayedWrite(final byte[] expectedContent) throws Exception {\n        final ExecutorService executor = Executors.newFixedThreadPool(2);\n        try (final Pipe pipe = Pipe.open()) {\n            final CountDownLatch readerReadyLatch = new CountDownLatch(1);\n\n            // Reader task: attempts to read from the pipe immediately.\n            // It should block until the writer provides data.\n            final Future<byte[]> readerFuture = executor.submit(() -> {\n                try (InputStream in = Channels.newInputStream(pipe.source())) {\n                    readerReadyLatch.countDown();\n                    return IOUtils.toByteArray(in);\n                }\n            });\n\n            // Writer task: waits until the reader is ready, then writes data.\n            final Future<?> writerFuture = executor.submit(() -> {\n                assertDoesNotThrow(() -> readerReadyLatch.await(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS),\n                    \"Reader did not start in time.\");\n                try (WritableByteChannel out = pipe.sink()) {\n                    out.write(ByteBuffer.wrap(expectedContent));\n                }\n                return null; // Return null from task.\n            });\n\n            // Verification\n            final byte[] actualContent = readerFuture.get(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n            assertDoesNotThrow(() -> writerFuture.get(TESTTIMEOUT_SECONDS, TimeUnit.SECONDS),\n                \"Writer task threw an exception.\");\n\n            assertEquals(expectedContent.length, actualContent.length, \"Number of bytes transferred mismatch.\");\n            assertArrayEquals(expectedContent, actualContent, \"Transferred content does not match expected content.\");\n\n        } finally {\n            executor.shutdownNow();\n            executor.awaitTermination(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        }\n    }\n}",
      "method_signature": "testBulkReadWaiting(java.lang.String)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 27944,
    "output_tokens": 12543,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1253,
      "description": "Define a parameterized test method that accepts a string input and validates bulk read behavior when data becomes available only after the read operation has already begun waiting. Skip execution if the input string is empty. Initialize two countdown latches to coordinate synchronization between threads, one to signal when polling begins and another to signal when writing completes. Create a custom blocking queue subclass that overrides the poll method to decrement the first latch upon invocation and then block on the second latch before delegating to the superclass implementation. Build a Queue Input Stream using the builder pattern, configuring it with the custom blocking queue and a one-hour timeout. Obtain a Queue Output Stream from the input stream to establish the producer-consumer relationship. Launch an asynchronous task that waits for the first latch to count down, then writes the input data as UTF-8 bytes to the output stream, and finally decrements the second latch to unblock the polling operation. Allocate a byte array matching the input string length and invoke the bulk read method on the input stream to populate this buffer. Assert that the number of bytes read equals the expected input length. Convert the populated byte array to a UTF-8 string and assert that it matches the original input data. Verify that the asynchronous task completes without throwing exceptions. Close the input stream as part of the try-with-resources construct. This test uses JUnit 5 for parameterization and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.QueueInputStreamTest",
      "method_signature": "testBulkReadWaiting(java.lang.String)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.QueueInputStreamDelayedWriteTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.io.output.QueueOutputStream;\nimport org.junit.jupiter.api.Assumptions;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\n/**\n * Tests {@link QueueInputStream} with data arriving only after the read operation has already begun waiting.\n */\npublic class QueueInputStreamDelayedWriteTest {\n\n    /**\n     * Tests that a bulk read correctly waits for data and reads it completely when the data is written to the corresponding\n     * output stream after the read operation has already started blocking.\n     *\n     * @param input The string data to be written and read.\n     * @throws Exception if an error occurs during the test.\n     */\n    @ParameterizedTest\n    @ValueSource(strings = {\"test data\", \"\"})\n    void testDelayedWriteBulkRead(final String input) throws Exception {\n        Assumptions.assumeFalse(input.isEmpty(), \"Skipping test for empty input string.\");\n\n        final byte[] inputBytes = input.getBytes(StandardCharsets.UTF_8);\n        final CountDownLatch pollingLatch = new CountDownLatch(1);\n        final CountDownLatch writingLatch = new CountDownLatch(1);\n\n        // A custom queue that signals when polling starts and waits for a signal that writing is complete.\n        final BlockingQueue<byte[]> customQueue = new LinkedBlockingQueue<byte[]>() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public byte[] poll(final long timeout, final TimeUnit unit) throws InterruptedException {\n                pollingLatch.countDown(); // Signal that the consumer is now polling.\n                writingLatch.await();     // Wait until the producer has finished writing.\n                return super.poll(timeout, unit);\n            }\n        };\n\n        final ExecutorService executor = Executors.newSingleThreadExecutor();\n        try (final QueueInputStream inputStream = QueueInputStream.builder()\n                .setBlockingQueue(customQueue)\n                .setTimeout(1, TimeUnit.HOURS)\n                .get()) {\n\n            final QueueOutputStream outputStream = inputStream.newQueueOutputStream();\n\n            // Asynchronously write data after the consumer has started polling.\n            final Future<?> writerFuture = executor.submit(() -> {\n                pollingLatch.await(); // Wait for the consumer to start polling.\n                try (outputStream) {\n                    outputStream.write(inputBytes);\n                } finally {\n                    writingLatch.countDown(); // Signal that writing is complete.\n                }\n                return null;\n            });\n\n            // This read will block until the writer task completes.\n            final byte[] buffer = new byte[inputBytes.length];\n            final int bytesRead = inputStream.read(buffer);\n\n            assertEquals(inputBytes.length, bytesRead, \"The number of bytes read should match the input data length.\");\n            assertEquals(input, new String(buffer, StandardCharsets.UTF_8), \"The data read should match the original input.\");\n\n            // Ensure the writer thread completed without exceptions.\n            writerFuture.get();\n        } finally {\n            executor.shutdownNow();\n        }\n    }\n}",
      "method_signature": "testBulkReadWaiting(java.lang.String)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 15975,
    "output_tokens": 5480,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1256,
      "description": "Define a parameterized test method that accepts an IO consumer function operating on input streams, then initialize a fixed-size thread pool executor configured for a predetermined number of concurrent threads. Generate a collection of asynchronous tasks by creating a range of task indices calculated from the thread count multiplied by runs per thread, where each task constructs a ChecksumInputStream using a builder configured with a byte array selected from pre-seeded test data variants using modulo indexing, a CRC32 checksum instance, and an expected checksum value retrieved from corresponding pre-seeded checksum data also selected by modulo indexing, then within a try-with-resources block that manages the constructed input stream, invoke the parameterized consumer function passing the stream, and finally return null from the callable. Submit each task to the thread pool and collect the resulting futures into a list. Iterate over all collected futures and assert that retrieving each future's result does not throw any exception, thereby verifying that all concurrent checksum validations completed successfully without errors. In the finally block, instruct the thread pool to shut down immediately, terminating all threads and releasing resources. This test validates thread-safety of the ChecksumInputStream builder and verification mechanism under concurrent access using JUnit 5 with parameterized test support.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsConcurrentTest",
      "method_signature": "testConcurrentInputStreamTasks(org.apache.commons.io.function.IOConsumer)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.ChecksumInputStreamBuilderTest",
      "code": "package org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.zip.CRC32;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link ChecksumInputStream} using a {@link ChecksumInputStream.Builder} for thread-safety.\n */\npublic class ChecksumInputStreamBuilderTest {\n\n    private static final byte[][] TEST_DATA = {\n        \"Hello World\".getBytes(StandardCharsets.UTF_8),\n        \"This is a test\".getBytes(StandardCharsets.UTF_8),\n        \"Another test string\".getBytes(StandardCharsets.UTF_8)\n    };\n\n    private static final long[] TEST_CHECKSUMS = {\n        getCrc32(TEST_DATA[0]),\n        getCrc32(TEST_DATA[1]),\n        getCrc32(TEST_DATA[2])\n    };\n\n    private static long getCrc32(final byte[] bytes) {\n        final CRC32 crc32 = new CRC32();\n        crc32.update(bytes, 0, bytes.length);\n        return crc32.getValue();\n    }\n\n    /**\n     * Creates a stream of I/O consumers for the parameterized test.\n     *\n     * @return a stream of consumers to test.\n     */\n    public static Stream<IOConsumer<InputStream>> createIoConsumers() {\n        // Method references are adapted to the IOConsumer functional interface.\n        // The return values of consume() and toByteArray() are discarded.\n        return Stream.of(IOUtils::consume, IOUtils::toByteArray);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"createIoConsumers\")\n    public void testThreadSafety(final IOConsumer<InputStream> consumer) {\n        final int concurrentThreads = 20;\n        final int runsPerThread = 100;\n        final ExecutorService threadPool = Executors.newFixedThreadPool(concurrentThreads);\n        try {\n            final List<Callable<Void>> tasks = IntStream.range(0, concurrentThreads * runsPerThread)\n                .mapToObj(i -> (Callable<Void>) () -> {\n                    final byte[] data = TEST_DATA[i % TEST_DATA.length];\n                    final long expectedChecksum = TEST_CHECKSUMS[i % TEST_CHECKSUMS.length];\n\n                    try (final InputStream inputStream = ChecksumInputStream.builder()\n                        .setInputStream(new ByteArrayInputStream(data))\n                        .setChecksum(new CRC32())\n                        .setExpected(expectedChecksum)\n                        .get()) {\n                        consumer.accept(inputStream);\n                    } catch (final IOException e) {\n                        throw new UncheckedIOException(e);\n                    }\n                    return null;\n                }).collect(Collectors.toList());\n\n            final List<Future<Void>> futures = assertDoesNotThrow(() -> threadPool.invokeAll(tasks));\n\n            for (final Future<Void> future : futures) {\n                assertDoesNotThrow(future::get, \"Future.get() should not throw an exception on successful checksum validation.\");\n            }\n        } finally {\n            threadPool.shutdownNow();\n        }\n    }\n}",
      "method_signature": "testConcurrentInputStreamTasks(org.apache.commons.io.function.IOConsumer)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 47616,
    "output_tokens": 5964,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1257,
      "description": "Create a test case to validate that the output forwarding mechanism correctly delegates partial data writes to the underlying storage system while tracking the delegation event. Establish a scenario where the forwarding component is configured to monitor when specific write operations occur, specifically those that transfer a subset of data from a larger source. Verify initially that no partial write operation has been detected by the monitoring system. Simulate a user action that submits a portion of available data by specifying which segment to transfer, ensuring the forwarding component receives only the selected bytes rather than the entire dataset. After the operation completes, confirm that the monitoring system successfully recorded the occurrence of the partial write delegation, then verify the storage system received exactly the expected amount of data, and finally validate that the stored content matches precisely the segment that was intended for transfer. Use JUnit 5 for test execution and standard equality assertions to verify the monitoring flags, data size, and content accuracy.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.ProxyOutputStreamTest",
      "method_signature": "testWriteByteArrayAt()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14703,
    "output_tokens": 2031,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1258,
      "description": "Define a parameterized test method that accepts three parameters: a descriptive case name string, a maximum byte count long value, and an expected initial remaining count long value, then encode a fixed UTF-8 byte array from the literal string \"Hello World\" to serve as the underlying data source. Construct a BoundedInputStream using the builder pattern by invoking the static builder method, configuring it with the encoded byte array via setByteArray, applying the maximum count parameter through setMaxCount, and finalizing construction with get, ensuring the stream is managed within a try-with-resources block for automatic closure. Upon instantiation, immediately query the stream's remaining byte allowance using getRemaining and assert that this initial value matches the expected initial remaining parameter, associating the case name with the assertion for diagnostic clarity. Following this verification, invoke the skip utility method from IOUtils to advance the stream position by 42 bytes, capturing the actual number of bytes skipped in a variable. Calculate the expected remaining count after the skip operation by checking whether the stream's maximum count equals the EOF sentinel value, in which case the remaining allowance should stay unchanged at the initial value, otherwise reduce the initial remaining by the actual skipped count. Assert that the stream's remaining byte allowance after skipping matches this calculated expectation, again associating the case name with the assertion, then allow the try-with-resources block to automatically close the BoundedInputStream upon completion. This test validates the BoundedInputStream's remaining byte tracking behavior across both bounded and unbounded configurations using JUnit 5 for parameterization and standard JUnit assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.BoundedInputStreamTest",
      "method_signature": "testRemaining(java.lang.String, long, long)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.BoundedInputStreamBuilderTest",
      "code": "package org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link BoundedInputStream} with the builder.\n */\npublic class BoundedInputStreamBuilderTest {\n\n    private static final byte[] DATA = \"Hello World\".getBytes(StandardCharsets.UTF_8);\n\n    static Stream<Arguments> parameters() {\n        return Stream.of(\n            Arguments.of(\"Unbounded\", (long) IOUtils.EOF, (long) IOUtils.EOF),\n            Arguments.of(\"Bounded, full read\", (long) DATA.length, (long) DATA.length),\n            Arguments.of(\"Bounded, partial read\", 5L, 5L),\n            Arguments.of(\"Bounded, zero read\", 0L, 0L)\n        );\n    }\n\n    @ParameterizedTest(name = \"{0}\")\n    @MethodSource(\"parameters\")\n    public void testRemaining(final String caseName, final long maxCount, final long expectedInitialRemaining) throws IOException {\n        final byte[] bytes = \"Hello World\".getBytes(StandardCharsets.UTF_8);\n        try (final BoundedInputStream bis = BoundedInputStream.builder()\n                .setByteArray(bytes)\n                .setMaxCount(maxCount)\n                .get()) {\n            assertEquals(expectedInitialRemaining, bis.getRemaining(), caseName);\n            final long actualSkipped = IOUtils.skip(bis, 42);\n            final long expectedRemainingAfterSkip = maxCount == IOUtils.EOF ? expectedInitialRemaining : expectedInitialRemaining - actualSkipped;\n            assertEquals(expectedRemainingAfterSkip, bis.getRemaining(), caseName);\n        }\n    }\n}",
      "method_signature": "testRemaining(java.lang.String, long, long)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.9091,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.8889,
      "method_coverage": 0.8125,
      "line_coverage": 0.8559,
      "branch_coverage": 0.8667
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 35804,
    "output_tokens": 3261,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1259,
      "description": "Define a test class that validates the proxy pattern delegation behavior of a Proxy Output Stream by tracking invocations to an underlying Byte Array Output Stream. Before each test execution, initialize three atomic boolean flags to track whether specific write method overloads have been invoked, then instantiate a custom Byte Array Output Stream that overrides the byte array write method with offset and length parameters to set a tracking flag to true before delegating to the superclass implementation. Wrap this instrumented output stream with a Proxy Output Stream instance to establish the delegation chain. Within the test method, verify that the tracking flag for the byte array write method with offset and length parameters is initially false, then invoke the write method on the Proxy Output Stream with a byte array containing two elements, specifying an offset of one and a length of one to write only the second byte. Upon completion of the write operation, confirm that the tracking flag has been set to true, indicating the correct method overload was invoked on the underlying stream. Retrieve the size of the target output stream and assert it equals one byte, then extract the byte array contents from the target stream and verify the array contains only the expected single byte that was written based on the offset and length parameters. This test uses JUnit for test execution and standard assertion methods for validation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.ProxyOutputStreamTest",
      "method_signature": "testWriteByteArrayAt()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.ProxyOutputStreamDelegationTest",
      "code": "package org.apache.commons.io.output;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Validates the proxy pattern delegation behavior of a ProxyOutputStream by tracking invocations.\n */\npublic class ProxyOutputStreamDelegationTest {\n\n    // As per description, three flags are initialized.\n    private AtomicBoolean writeSingleByteCalled;\n    private AtomicBoolean writeByteArrayCalled;\n    private AtomicBoolean writeByteArrayWithOffsetCalled;\n\n    private ByteArrayOutputStream targetStream;\n    private ProxyOutputStream proxyStream;\n\n    @BeforeEach\n    public void setUp() {\n        writeSingleByteCalled = new AtomicBoolean(false);\n        writeByteArrayCalled = new AtomicBoolean(false);\n        writeByteArrayWithOffsetCalled = new AtomicBoolean(false);\n\n        // A custom stream that overrides only the specific method to be tracked.\n        targetStream = new ByteArrayOutputStream() {\n            @Override\n            public void write(final byte[] b, final int off, final int len) {\n                writeByteArrayWithOffsetCalled.set(true);\n                super.write(b, off, len);\n            }\n        };\n\n        // Wrap the instrumented stream with the proxy\n        proxyStream = new ProxyOutputStream(targetStream);\n    }\n\n    @Test\n    public void testWriteByteArrayWithOffsetDelegation() throws IOException {\n        // Verify the tracking flag is initially false\n        assertFalse(writeByteArrayWithOffsetCalled.get(), \"Tracking flag should be false before invocation.\");\n\n        // Invoke the write method on the proxy stream with offset and length\n        final byte[] sourceBytes = new byte[]{65, 66}; // {'A', 'B'}\n        proxyStream.write(sourceBytes, 1, 1); // Write only the second byte 'B'\n\n        // Confirm that the correct method overload was invoked on the underlying stream\n        assertTrue(writeByteArrayWithOffsetCalled.get(), \"Tracking flag should be true after invocation.\");\n\n        // Assert the size of the target stream is one byte\n        assertEquals(1, targetStream.size(), \"The size of the target stream should be 1.\");\n\n        // Verify the array contains only the single byte that was written\n        final byte[] writtenBytes = targetStream.toByteArray();\n        assertArrayEquals(new byte[]{66}, writtenBytes, \"The content of the target stream is incorrect.\");\n    }\n}",
      "method_signature": "testWriteByteArrayAt()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.7778,
      "callable_precision": 0.7778,
      "focal_recall": 0.1667,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.25,
      "method_coverage": 0.2727,
      "line_coverage": 0.1628,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19520,
    "output_tokens": 4611,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1261,
      "description": "Define a parameterized test method that accepts three parameters: a `String` named `caseName`, a `long` named `maxCount`, and a `long` named `expectedInitialRemaining`, and declare that it throws `Exception`. Begin by creating a `byte[]` variable named `data` by invoking `getBytes(StandardCharsets.UTF_8)` on the string literal `\"Hello World\"`. Open a try-with-resources block by invoking `BoundedInputStream.builder()`, chaining `.setByteArray(data)`, chaining `.setMaxCount(maxCount)`, and finally chaining `.get()` to obtain a `BoundedInputStream` instance named `in`. Within the try block, immediately invoke `getRemaining()` on `in`, assign the result to a local variable, and assert using `assertEquals` that this value equals `expectedInitialRemaining`, passing `caseName + \" (initial)\"` as the assertion message. Next, invoke `IOUtils.skip(in, 42)` and assign the returned `long` value to a variable named `skipped`. Then, invoke `getMaxCount()` on `in` and compare the result to `IOUtils.EOF` using the equality operator; if they are equal, assign `expectedInitialRemaining` to a `long` variable named `expectedAfterSkip`, otherwise assign `expectedInitialRemaining - skipped` to `expectedAfterSkip`. Finally, invoke `getRemaining()` on `in` again, and assert using `assertEquals` that this value equals `expectedAfterSkip`, passing `caseName + \" (after skip)\"` as the assertion message. The try-with-resources block automatically closes `in` upon exit. Annotate the test method with `@ParameterizedTest(name = \"{index}: {0} -> initial remaining {2}\")` and `@MethodSource` to supply the test parameters.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.BoundedInputStreamTest",
      "method_signature": "testRemaining(java.lang.String, long, long)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.BoundedInputStreamTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class BoundedInputStreamTest1 {\n\n    public static Stream<Arguments> createParameters() {\n        final byte[] data = \"Hello World\".getBytes(StandardCharsets.UTF_8);\n        return Stream.of(\n            Arguments.of(\"maxCount smaller than data length\", 5L, 5L),\n            Arguments.of(\"maxCount equals data length\", (long) data.length, (long) data.length),\n            Arguments.of(\"maxCount larger than data length\", (long) data.length + 1, (long) data.length + 1),\n            Arguments.of(\"maxCount is EOF\", IOUtils.EOF, IOUtils.EOF),\n            Arguments.of(\"maxCount is 0\", 0L, 0L)\n        );\n    }\n\n    @ParameterizedTest(name = \"{index}: {0} -> initial remaining {2}\")\n    @MethodSource(\"createParameters\")\n    public void testGetRemaining(final String caseName, final long maxCount, final long expectedInitialRemaining) throws Exception {\n        final byte[] data = \"Hello World\".getBytes(StandardCharsets.UTF_8);\n        try (final BoundedInputStream in = BoundedInputStream.builder()\n                .setByteArray(data)\n                .setMaxCount(maxCount)\n                .get()) {\n            final long initialRemaining = in.getRemaining();\n            assertEquals(expectedInitialRemaining, initialRemaining, caseName + \" (initial)\");\n\n            final long skipped = IOUtils.skip(in, 42);\n\n            final long expectedAfterSkip = in.getMaxCount() == IOUtils.EOF ? expectedInitialRemaining - skipped : expectedInitialRemaining - skipped;\n\n            assertEquals(expectedAfterSkip, in.getRemaining(), caseName + \" (after skip)\");\n        }\n    }\n}",
      "method_signature": "testRemaining(java.lang.String, long, long)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.7273,
      "callable_precision": 0.7273,
      "focal_recall": 1.0,
      "focal_precision": 0.8333
    },
    "coverage_eval": {
      "class_coverage": 0.8889,
      "method_coverage": 0.8125,
      "line_coverage": 0.8559,
      "branch_coverage": 0.8667
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 30618,
    "output_tokens": 4066,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1262,
      "description": "Define a parameterized test method accepting a single `String` parameter named `inputData` that throws `IOException`, annotated with `@ParameterizedTest(name = \"inputData={0}\")` and `@MethodSource(\"inputData\")`, then begin by invoking `assumeFalse` on `inputData.isEmpty()` to skip execution if the input is empty. Instantiate a `CountDownLatch` named `onPollLatch` with argument `1`, then instantiate a second `CountDownLatch` named `afterWriteLatch` with argument `1`. Create a `LinkedBlockingQueue<Integer>` named `queue` by instantiating an anonymous subclass that overrides the `poll(final long timeout, final TimeUnit unit)` method to first invoke `onPollLatch.countDown()`, then invoke `afterWriteLatch.await(1, TimeUnit.HOURS)`, and finally return `super.poll(timeout, unit)`. Within a try-with-resources block, instantiate a `QueueInputStream` named `queueInputStream` by invoking `QueueInputStream.builder()`, chaining `.setBlockingQueue(queue)`, chaining `.setTimeout(Duration.ofHours(1))`, and chaining `.get()`. Immediately invoke `newQueueOutputStream()` on `queueInputStream` and assign the result to a `QueueOutputStream` variable named `queueOutputStream`. Create a `CompletableFuture<Void>` named `future` by invoking `CompletableFuture.runAsync` with a lambda that executes the following: within a try block, invoke `onPollLatch.await(1, TimeUnit.HOURS)`, then invoke `queueOutputStream.write(inputData.getBytes(UTF_8))`, then invoke `afterWriteLatch.countDown()`; within a catch block for `Exception e`, throw a new `RuntimeException(e)`. Instantiate a `byte[]` named `data` with length `inputData.length()`. Invoke `queueInputStream.read(data, 0, data.length)` and assign the result to an `int` variable named `read`. Assert using `assertEquals` that `inputData.length()` equals `read`. Instantiate a `String` named `outputData` by invoking the constructor `new String(data, 0, read, StandardCharsets.UTF_8)`. Assert using `assertEquals` that `inputData` equals `outputData`. Assert using `assertDoesNotThrow` that invoking `future.get()` completes without exception. The test uses method-level annotation `@ParameterizedTest(name = \"inputData={0}\")` with `@MethodSource(\"inputData\")`, and relies on JUnit 5 Assertions for `assertEquals` and `assertDoesNotThrow`, with no class-level annotations, no mocking libraries, and no additional teardown.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.QueueInputStreamTest",
      "method_signature": "testBulkReadWaiting(java.lang.String)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.QueueInputStreamReadTest",
      "code": "package org.apache.commons.io.input;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assumptions.assumeFalse;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.output.QueueOutputStream;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class QueueInputStreamReadTest {\n\n    public static Stream<String> inputData() {\n        return Stream.of(\"\", \"a\", \"ab\", \"abc\", \"abcd\", \"abcde\");\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void testRead(final String inputData) throws IOException, InterruptedException, ExecutionException {\n        assumeFalse(inputData.isEmpty());\n\n        final CountDownLatch onPollLatch = new CountDownLatch(1);\n        final CountDownLatch afterWriteLatch = new CountDownLatch(1);\n\n        final LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<Integer>() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public Integer poll(final long timeout, final TimeUnit unit) throws InterruptedException {\n                onPollLatch.countDown();\n                afterWriteLatch.await(1, TimeUnit.HOURS);\n                return super.poll(timeout, unit);\n            }\n        };\n\n        try (final QueueInputStream queueInputStream = QueueInputStream.builder()\n                .setBlockingQueue(queue)\n                .setTimeout(Duration.ofHours(1))\n                .get()) {\n\n            final QueueOutputStream queueOutputStream = queueInputStream.newQueueOutputStream();\n\n            final CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n                try {\n                    onPollLatch.await(1, TimeUnit.HOURS);\n                    queueOutputStream.write(inputData.getBytes(UTF_8));\n                    afterWriteLatch.countDown();\n                } catch (final Exception e) {\n                    throw new RuntimeException(e);\n                }\n            });\n\n            final byte[] data = new byte[inputData.length()];\n            final int read = queueInputStream.read(data, 0, data.length);\n\n            assertEquals(inputData.length(), read);\n\n            final String outputData = new String(data, 0, read, StandardCharsets.UTF_8);\n            assertEquals(inputData, outputData);\n\n            assertDoesNotThrow(() -> future.get());\n        }\n    }\n}",
      "method_signature": "testBulkReadWaiting(java.lang.String)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 41705,
    "output_tokens": 3542,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1263,
      "description": "Define a test class containing eight private static final fields: `BYTE_DATA` of type `byte[][]`, `BYTE_DATA_CHECKSUM` of type `long[]`, `RUNS_PER_THREAD` of type `int`, `SIZE` of type `int`, `STRING_DATA` of type `String[]`, `STRING_DATA_CHECKSUM` of type `long[]`, `THREAD_COUNT` of type `int`, and `VARIANTS` of type `int`, initialized with appropriate test data arrays and configuration constants. Implement a parameterized test method annotated with `@ParameterizedTest` and `@MethodSource` that accepts a single parameter `consumer` of type `IOConsumer<InputStream>` and declares `throws InterruptedException`. Begin the method by invoking `Executors.newFixedThreadPool(THREAD_COUNT)` and assigning the result to a variable `threadPool` of type `ExecutorService`. Within a try-finally block, create a variable `futures` of type `List<Future<Void>>` by invoking `IntStream.range(0, THREAD_COUNT * RUNS_PER_THREAD)`, chaining `.<Future<Void>>mapToObj(i -> ...)` where the lambda submits a callable to `threadPool` via `threadPool.submit(() -> { ... })`, and finally chaining `.collect(Collectors.toList())`. Inside the submitted callable, open a try-with-resources statement declaring variable `in` of type `InputStream` initialized by invoking `ChecksumInputStream.builder()`, chaining `.setByteArray(BYTE_DATA[i % VARIANTS])`, chaining `.setChecksum(new CRC32())`, chaining `.setExpectedChecksumValue(BYTE_DATA_CHECKSUM[i % VARIANTS])`, and finally chaining `.get()`. Within the try-with-resources body, invoke `consumer.accept(in)`, then return `null` from the callable. After collecting all futures into the `futures` list, invoke `futures.forEach(f -> assertDoesNotThrow(() -> f.get()))` to verify that each future completes without throwing an exception. In the finally block, invoke `threadPool.shutdownNow()` to terminate the executor service. The test uses JUnit 5 Assertions (`assertDoesNotThrow`), parameterized testing via `@ParameterizedTest` and `@MethodSource`, and relies on the `ChecksumInputStream.Builder` fluent API from Apache Commons IO to construct checksum-validated input streams concurrently across multiple threads.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsConcurrentTest",
      "method_signature": "testConcurrentInputStreamTasks(org.apache.commons.io.function.IOConsumer)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.ChecksumInputStreamThreadTest",
      "code": "package org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.zip.CRC32;\nimport java.util.zip.Checksum;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nclass ChecksumInputStreamThreadTest {\n\n    private static final byte[][] BYTE_DATA = new byte[3][];\n    private static final long[] BYTE_DATA_CHECKSUM = new long[3];\n    private static final int RUNS_PER_THREAD = 10;\n    private static final int SIZE = 1024;\n    private static final String[] STRING_DATA = new String[3];\n    private static final long[] STRING_DATA_CHECKSUM = new long[3];\n    private static final int THREAD_COUNT = 10;\n    private static final int VARIANTS = 3;\n\n    static {\n        for (int i = 0; i < VARIANTS; i++) {\n            final String data = \"Test data \" + i;\n            STRING_DATA[i] = data;\n            BYTE_DATA[i] = data.getBytes(StandardCharsets.UTF_8);\n\n            final Checksum checksum = new CRC32();\n            checksum.update(BYTE_DATA[i], 0, BYTE_DATA[i].length);\n            BYTE_DATA_CHECKSUM[i] = checksum.getValue();\n            STRING_DATA_CHECKSUM[i] = checksum.getValue();\n        }\n    }\n\n    static Stream<IOConsumer<InputStream>> createConsumers() {\n        return Stream.of(IOUtils::consume, in -> {\n            while (in.read() != -1) {\n                // empty\n            }\n        });\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"createConsumers\")\n    void testConcurrentReads(final IOConsumer<InputStream> consumer) throws InterruptedException {\n        final ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);\n        try {\n            final List<Future<Void>> futures = IntStream.range(0, THREAD_COUNT * RUNS_PER_THREAD)\n                    .<Future<Void>>mapToObj(i -> threadPool.submit(() -> {\n                        try (InputStream in = ChecksumInputStream.builder()\n                                .setByteArray(BYTE_DATA[i % VARIANTS])\n                                .setChecksum(new CRC32())\n                                .setExpectedChecksumValue(BYTE_DATA_CHECKSUM[i % VARIANTS])\n                                .get()) {\n                            consumer.accept(in);\n                        }\n                        return null;\n                    })).collect(Collectors.toList());\n            futures.forEach(f -> assertDoesNotThrow(() -> f.get()));\n        } finally {\n            threadPool.shutdownNow();\n        }\n    }\n}",
      "method_signature": "testConcurrentInputStreamTasks(org.apache.commons.io.function.IOConsumer)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.6429,
      "method_coverage": 0.3929,
      "line_coverage": 0.3469,
      "branch_coverage": 0.2083
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19082,
    "output_tokens": 3742,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1265,
      "description": "Define a test class containing five private fields: `target` of type `org.apache.commons.io.output.ByteArrayOutputStream`, `proxied` of type `org.apache.commons.io.output.ProxyOutputStream`, and three final `java.util.concurrent.atomic.AtomicBoolean` fields named `hitByteArray`, `hitByteArrayAt`, and `hitInt`, initializing the three `AtomicBoolean` fields inline with `new AtomicBoolean(false)`. Implement a setup method annotated with `@BeforeEach` that instantiates `target` as an anonymous subclass of `ByteArrayOutputStream` by invoking the no-argument constructor, overriding three methods: first, override `write(final byte[] ba)` to invoke `hitByteArray.set(true)` followed by `super.write(ba)`; second, override `write(final byte[] b, final int off, final int len)` to invoke `hitByteArrayAt.set(true)` followed by `super.write(b, off, len)`; third, override the synchronized method `write(final int ba)` to invoke `hitInt.set(true)` followed by `super.write(ba)`. After instantiating `target`, assign `proxied` by constructing a new `ProxyOutputStream` passing `target` as the constructor argument. In the test method annotated with `@Test` and declaring `throws Exception`, begin by asserting false on the result of `hitByteArrayAt.get()` using `assertFalse`. Next, invoke `write` on `proxied` with three arguments: a new byte array containing the byte literals `'y'` and `'z'`, the integer offset `1`, and the integer length `1`. Immediately after this invocation, assert true on the result of `hitByteArrayAt.get()` using `assertTrue`. Then assert that `target.size()` equals the integer `1` using `assertEquals`. Finally, assert that `target.toByteArray()` equals a new byte array containing the single byte literal `'z'` using `assertArrayEquals`. The test uses JUnit 5 Assertions with method-level annotation `@Test` and setup annotation `@BeforeEach`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.ProxyOutputStreamTest",
      "method_signature": "testWriteByteArrayAt()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.ProxyOutputStreamTest1",
      "code": "package org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ProxyOutputStream}.\n */\npublic class ProxyOutputStreamTest1 {\n\n    private org.apache.commons.io.output.ByteArrayOutputStream target;\n\n    private ProxyOutputStream proxied;\n\n    private final AtomicBoolean hitByteArray = new AtomicBoolean(false);\n\n    private final AtomicBoolean hitByteArrayAt = new AtomicBoolean(false);\n\n    private final AtomicBoolean hitInt = new AtomicBoolean(false);\n\n    @BeforeEach\n    public void setUp() {\n        target = new org.apache.commons.io.output.ByteArrayOutputStream() {\n            @Override\n            public void write(final byte[] ba) {\n                hitByteArray.set(true);\n                super.write(ba);\n            }\n\n            @Override\n            public void write(final byte[] b, final int off, final int len) {\n                hitByteArrayAt.set(true);\n                super.write(b, off, len);\n            }\n\n            @Override\n            public synchronized void write(final int ba) {\n                hitInt.set(true);\n                super.write(ba);\n            }\n        };\n        proxied = new ProxyOutputStream(target);\n    }\n\n    @Test\n    public void testWriteByteArrayAt() throws Exception {\n        assertFalse(hitByteArrayAt.get());\n        proxied.write(new byte[] { 'y', 'z' }, 1, 1);\n        assertTrue(hitByteArrayAt.get());\n        assertEquals(1, target.size());\n        assertArrayEquals(new byte[] { 'z' }, target.toByteArray());\n    }\n}",
      "method_signature": "testWriteByteArrayAt()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 28881,
    "output_tokens": 3040,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1450,
      "description": "Define a test method that validates the error-handling behavior of the Name Length Strategy when truncation operations exceed permissible limits by accepting as parameters a strategy instance, a limit integer, an input string, a charset, and an expected error message fragment. Invoke the truncate method on the strategy instance with the provided input, limit, and charset, capturing the thrown IllegalArgumentException to confirm that the operation correctly rejects invalid truncation requests. Upon capturing the exception, extract the exception's message and verify that it contains the expected message fragment to ensure the error communication accurately reflects the constraint violation. This test should be executed across multiple input combinations representing various UTF-8 character encodings and boundary conditions to comprehensively validate error scenarios. The test relies on JUnit 5 for parameterized test execution and standard assertion capabilities.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileSystemTest",
      "method_signature": "testNameLengthStrategyTruncate_Throws(org.apache.commons.io.FileSystem.NameLengthStrategy, int, java.lang.String, java.nio.charset.Charset, java.lang.String)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileSystemNameLengthStrategyTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.FileSystem.NameLengthStrategy;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link NameLengthStrategy}.\n */\npublic class FileSystemNameLengthStrategyTest {\n\n    public static Stream<Arguments> data() {\n        return Stream.of(\n                // UTF-8 small inputs\n                Arguments.of(NameLengthStrategy.BYTES, 3, \"a.b\", StandardCharsets.UTF_8, \"is too long to fit within 3 bytes\"),\n                Arguments.of(NameLengthStrategy.BYTES, 2, \"a.b\", StandardCharsets.UTF_8, \"is too long to fit within 2 bytes\"),\n                Arguments.of(NameLengthStrategy.BYTES, 1, \"a.b\", StandardCharsets.UTF_8, \"is too long to fit within 1 bytes\"),\n\n                // UTF-16 small inputs\n                Arguments.of(NameLengthStrategy.UTF16_CODE_UNITS, 3, \"a.bc\", StandardCharsets.UTF_16, \"is too long to fit within 3 characters\"),\n                Arguments.of(NameLengthStrategy.UTF16_CODE_UNITS, 2, \"a.bc\", StandardCharsets.UTF_16, \"is too long to fit within 2 characters\"),\n                Arguments.of(NameLengthStrategy.UTF16_CODE_UNITS, 1, \"a.b\", StandardCharsets.UTF_16, \"is too long to fit within 1 characters\"),\n\n                // UTF-8 with multi-byte chars\n                Arguments.of(NameLengthStrategy.BYTES, 4, \"ab.\u20ac\", StandardCharsets.UTF_8, \"is too long to fit within 4 bytes\"), // \u20ac is 3 bytes in UTF-8\n                Arguments.of(NameLengthStrategy.BYTES, 3, \"ab.\u20ac\", StandardCharsets.UTF_8, \"is too long to fit within 3 bytes\"),\n                Arguments.of(NameLengthStrategy.BYTES, 2, \"ab.\u20ac\", StandardCharsets.UTF_8, \"is too long to fit within 2 bytes\"),\n\n                // safeTruncate exception\n                Arguments.of(NameLengthStrategy.BYTES, 1, \"\u20ac\", StandardCharsets.UTF_8, \"can not be truncated to 1 character without breaking\"),\n                Arguments.of(NameLengthStrategy.UTF16_CODE_UNITS, 0, \"a\", StandardCharsets.UTF_16, \"can not be truncated to 1 character without breaking\")\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"data\")\n    public void testTruncateThrows(final NameLengthStrategy strategy, final int limit, final String input, final Charset charset, final String expectedMessageFragment) {\n        final IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> {\n            strategy.truncate(input, limit, charset);\n        });\n        final String message = e.getMessage();\n        assertTrue(message.contains(expectedMessageFragment),\n                () -> String.format(\"Expected message to contain '%s', but was '%s'\", expectedMessageFragment, message));\n    }\n}",
      "method_signature": "testNameLengthStrategyTruncate_Throws(org.apache.commons.io.FileSystem.NameLengthStrategy, int, java.lang.String, java.nio.charset.Charset, java.lang.String)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.8,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "search_file_content": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 111625,
    "output_tokens": 8852,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1451,
      "description": "Define a test method that accepts four parameters from an external data source: a NameLengthStrategy instance, an integer limit, an input string, and an expected output string, where the data source provides combinations covering various UTF-8 character byte lengths and boundary conditions for file name truncation scenarios. Invoke the truncate method on the provided strategy instance, passing the input string, the limit, and UTF-8 charset as arguments, then capture the returned CharSequence. Convert the result to a string representation and assert that it matches the expected output string, incorporating the strategy's name into the assertion message to clarify which strategy is being validated. The test validates that each NameLengthStrategy correctly truncates strings to the specified limit according to its measurement unit, whether bytes or code units, ensuring compliance with file system naming constraints across different character encodings. This test uses a parameterized testing framework with a method source to supply test cases, along with standard assertion utilities.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileSystemTest",
      "method_signature": "testNameLengthStrategyTruncate_Succeeds(org.apache.commons.io.FileSystem.NameLengthStrategy, int, java.lang.String, java.lang.String)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.file.NameLengthStrategyTest",
      "code": "package org.apache.commons.io.file;\n\n/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \"License\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      https://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \"AS IS\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npackage org.apache.commons.io.file;\\n\\nimport static org.junit.jupiter.api.Assertions.assertEquals;\\n\\nimport java.nio.charset.StandardCharsets;\\nimport java.util.stream.Stream;\\n\\nimport org.junit.jupiter.params.ParameterizedTest;\\nimport org.junit.jupiter.params.provider.Arguments;\\nimport org.junit.jupiter.params.provider.MethodSource;\\n\\npublic class NameLengthStrategyTest {\\n\\n    static Stream<Arguments> truncateData() {\\n        final String euro = \"\\u20AC\";\\n        final String emoji = \"\\uD83D\\uDE0A\";\\n\\n        return Stream.of(\\n            // UTF-8 byte length strategy\\n            Arguments.of(NameLengthStrategy.BYTE_LENGTH, 4, \"abcde\", \"abcd\"),\\n            Arguments.of(NameLengthStrategy.BYTE_LENGTH, 5, \"abcde\", \"abcde\"),\\n            Arguments.of(NameLengthStrategy.BYTE_LENGTH, 6, \"abcde\", \"abcde\"),\\n            Arguments.of(NameLengthStrategy.BYTE_LENGTH, 2, euro, \"\"),\\n            Arguments.of(NameLengthStrategy.BYTE_LENGTH, 3, euro, euro),\\n            Arguments.of(NameLengthStrategy.BYTE_LENGTH, 4, \"a\" + euro, \"a\" + euro),\\n            Arguments.of(NameLengthStrategy.BYTE_LENGTH, 3, \"a\" + euro, \"a\"),\\n            Arguments.of(NameLengthStrategy.BYTE_LENGTH, 3, emoji, \"\"),\\n            Arguments.of(NameLengthStrategy.BYTE_LENGTH, 4, emoji, emoji),\\n            Arguments.of(NameLengthStrategy.BYTE_LENGTH, 5, \"a\" + emoji, \"a\" + emoji),\\n            Arguments.of(NameLengthStrategy.BYTE_LENGTH, 4, \"a\" + emoji, \"a\"),\\n\\n            // Code point length strategy\\n            Arguments.of(NameLengthStrategy.CODE_POINT, 4, \"abcde\", \"abcd\"),\\n            Arguments.of(NameLengthStrategy.CODE_POINT, 5, \"abcde\", \"abcde\"),\\n            Arguments.of(NameLengthStrategy.CODE_POINT, 6, \"abcde\", \"abcde\"),\\n            Arguments.of(NameLengthStrategy.CODE_POINT, 0, euro, \"\"),\\n            Arguments.of(NameLengthStrategy.CODE_POINT, 1, euro, euro),\\n            Arguments.of(NameLengthStrategy.CODE_POINT, 0, emoji, \"\"),\\n            Arguments.of(NameLengthStrategy.CODE_POINT, 1, emoji, emoji),\\n            Arguments.of(NameLengthStrategy.CODE_POINT, 2, \"a\" + emoji, \"a\" + emoji),\\n            Arguments.of(NameLengthStrategy.CODE_POINT, 1, \"a\" + emoji, \"a\")\\n        );\\n    }\\n\\n    @ParameterizedTest\\n    @MethodSource(\"truncateData\")\\n    public void testTruncate(NameLengthStrategy strategy, int limit, String input, String expected) {\\n        CharSequence result = strategy.truncate(input, limit, StandardCharsets.UTF_8);\\n        assertEquals(expected, result.toString(), () -> \"Testing with \" + strategy.toString());\\n    }\\n}\\n",
      "method_signature": "testNameLengthStrategyTruncate_Succeeds(org.apache.commons.io.FileSystem.NameLengthStrategy, int, java.lang.String, java.lang.String)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1452,
      "description": "Create a test case to validate that the system properly handles scenarios where an incoming data source reports a specific size but terminates prematurely before delivering the promised amount of data. Begin by simulating an empty data source that immediately signals completion, then instruct the system to attempt reading exactly one unit of data from this source expecting to receive the full amount. Ensure the system detects the premature termination and signals a data integrity failure through an appropriate error condition, confirming that operations requiring exact data quantities fail safely when the source provides insufficient content. Validate the behavior using JUnit 5 for test execution and standard assertion mechanisms to verify the expected failure condition occurs.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testToByteArray_InputStream_Size_Truncated()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsReadFullyTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.EOFException;\nimport java.io.InputStream;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link IOUtils#readFully(InputStream, byte[])} that validate handling of premature stream termination.\n */\npublic class IOUtilsReadFullyTest {\n\n    /**\n     * Tests that {@link IOUtils#readFully(InputStream, byte[])} throws an {@link EOFException}\n     * when the stream ends before the requested number of bytes has been read.\n     * This scenario simulates a data source that terminates prematurely.\n     */\n    @Test\n    public void testReadFullyWithInsufficientData() {\n        // Simulate an empty data source that immediately signals completion.\n        final InputStream inputStream = new ByteArrayInputStream(new byte[0]);\n        // Attempt to read one byte from the empty stream.\n        final byte[] buffer = new byte[1];\n\n        // The operation should fail with an EOFException, indicating a data integrity issue.\n        assertThrows(EOFException.class, () -> {\n            IOUtils.readFully(inputStream, buffer);\n        });\n    }\n}",
      "method_signature": "testToByteArray_InputStream_Size_Truncated()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.5,
      "callable_precision": 0.3333,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.25,
      "method_coverage": 0.1176,
      "line_coverage": 0.0889,
      "branch_coverage": 0.1
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 35480,
    "output_tokens": 6756,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1453,
      "description": "Create a test case to validate that the system correctly shortens file names according to different measurement strategies when names exceed their specified limits. Prepare scenarios involving file names composed of characters with varying storage requirements, ranging from single-unit characters to complex multi-unit characters, and construct names that reach exactly the maximum allowed length when measured in different units. For each validation scenario, configure a specific measurement approach and corresponding limit, then instruct the system to shorten the provided file name to comply with the specified constraint while preserving as much of the original name as possible. After the system performs the shortening operation, verify that the resulting name matches the expected shortened version and respects the imposed limit according to the chosen measurement strategy. Ensure the system handles all character encoding variations correctly, including names built from single-byte characters, two-byte characters, three-byte characters, and four-byte characters, as well as names measured by total storage size versus character count. Validate using JUnit 5 with parameterized test capabilities and AssertJ for standard equality assertions to confirm the shortened output matches business expectations across all measurement strategies and character encoding scenarios.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileSystemTest",
      "method_signature": "testNameLengthStrategyTruncate_Succeeds(org.apache.commons.io.FileSystem.NameLengthStrategy, int, java.lang.String, java.lang.String)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileNameShortenerTest",
      "code": "package org.apache.commons.io;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.stream.Stream;\nimport org.apache.commons.io.FilenameUtils.Measurement;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link FilenameUtils#shorten(String, int, Measurement, Charset)}.\n */\npublic class FileNameShortenerTest {\n\n    private static final String TEN_A = \"aaaaaaaaaa\";\n    private static final String NINE_A = \"aaaaaaaaa\";\n    private static final String TEN_2_BYTE = \"\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\";\n    private static final String NINE_2_BYTE = \"\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\";\n    private static final String FIVE_2_BYTE = \"\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\u00c3\u00a9\";\n    private static final String TEN_3_BYTE = \"\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\";\n    private static final String NINE_3_BYTE = \"\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\";\n    private static final String FIVE_3_BYTE = \"\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\u00e2\u0082\u00ac\";\n    private static final String TEN_4_BYTE = \"\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\";\n    private static final String NINE_4_BYTE = \"\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\";\n    private static final String FIVE_4_BYTE = \"\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\u00f0\u009f\u0098\u0082\";\n\n    static Stream<Arguments> shortenData() {\n        return Stream.of(\n            // --- Measurement by CHARACTERS ---\n            Arguments.of(\"1234567890\", 5, Measurement.CHARACTERS, StandardCharsets.UTF_8, \"12345\"),\n            Arguments.of(TEN_A, 10, Measurement.CHARACTERS, StandardCharsets.UTF_8, TEN_A),\n            Arguments.of(TEN_A, 11, Measurement.CHARACTERS, StandardCharsets.UTF_8, TEN_A),\n            Arguments.of(TEN_A, 9, Measurement.CHARACTERS, StandardCharsets.UTF_8, NINE_A),\n            Arguments.of(TEN_2_BYTE, 5, Measurement.CHARACTERS, StandardCharsets.UTF_8, FIVE_2_BYTE),\n            Arguments.of(TEN_3_BYTE, 5, Measurement.CHARACTERS, StandardCharsets.UTF_8, FIVE_3_BYTE),\n            Arguments.of(TEN_4_BYTE, 5, Measurement.CHARACTERS, StandardCharsets.UTF_8, FIVE_4_BYTE),\n            Arguments.of(\"a-\u00c3\u00a9-\u00e2\u0082\u00ac-\u00f0\u009f\u0098\u0082\", 7, Measurement.CHARACTERS, StandardCharsets.UTF_8, \"a-\u00c3\u00a9-\u00e2\u0082\u00ac-\u00f0\u009f\u0098\u0082\"),\n            Arguments.of(\"a-\u00c3\u00a9-\u00e2\u0082\u00ac-\u00f0\u009f\u0098\u0082\", 6, Measurement.CHARACTERS, StandardCharsets.UTF_8, \"a-\u00c3\u00a9-\u00e2\u0082\u00ac-\"),\n\n            // --- Measurement by BYTES ---\n            // 1-byte chars\n            Arguments.of(TEN_A, 10, Measurement.BYTES, StandardCharsets.UTF_8, TEN_A),\n            Arguments.of(TEN_A, 9, Measurement.BYTES, StandardCharsets.UTF_8, NINE_A),\n            Arguments.of(TEN_A, 11, Measurement.BYTES, StandardCharsets.UTF_8, TEN_A),\n\n            // 2-byte chars (\u00c3\u00a9 = 2 bytes in UTF-8)\n            Arguments.of(TEN_2_BYTE, 20, Measurement.BYTES, StandardCharsets.UTF_8, TEN_2_BYTE),\n            Arguments.of(TEN_2_BYTE, 19, Measurement.BYTES, StandardCharsets.UTF_8, NINE_2_BYTE),\n            Arguments.of(TEN_2_BYTE, 10, Measurement.BYTES, StandardCharsets.UTF_8, FIVE_2_BYTE),\n\n            // 3-byte chars (\u00e2\u0082\u00ac = 3 bytes in UTF-8)\n            Arguments.of(TEN_3_BYTE, 30, Measurement.BYTES, StandardCharsets.UTF_8, TEN_3_BYTE),\n            Arguments.of(TEN_3_BYTE, 29, Measurement.BYTES, StandardCharsets.UTF_8, NINE_3_BYTE),\n            Arguments.of(TEN_3_BYTE, 15, Measurement.BYTES, StandardCharsets.UTF_8, FIVE_3_BYTE),\n            \n            // 4-byte chars (\u00f0\u009f\u0098\u0082 = 4 bytes in UTF-8)\n            Arguments.of(TEN_4_BYTE, 40, Measurement.BYTES, StandardCharsets.UTF_8, TEN_4_BYTE),\n            Arguments.of(TEN_4_BYTE, 39, Measurement.BYTES, StandardCharsets.UTF_8, NINE_4_BYTE),\n            Arguments.of(TEN_4_BYTE, 20, Measurement.BYTES, StandardCharsets.UTF_8, FIVE_4_BYTE),\n\n            // Mixed chars: \"a\u00c3\u00a9\u00e2\u0082\u00ac\u00f0\u009f\u0098\u0082\" is 1+2+3+4 = 10 bytes in UTF-8\n            Arguments.of(\"a\u00c3\u00a9\u00e2\u0082\u00ac\u00f0\u009f\u0098\u0082\", 10, Measurement.BYTES, StandardCharsets.UTF_8, \"a\u00c3\u00a9\u00e2\u0082\u00ac\u00f0\u009f\u0098\u0082\"),\n            Arguments.of(\"a\u00c3\u00a9\u00e2\u0082\u00ac\u00f0\u009f\u0098\u0082\", 9, Measurement.BYTES, StandardCharsets.UTF_8, \"a\u00c3\u00a9\u00e2\u0082\u00ac\"),\n            Arguments.of(\"a\u00c3\u00a9\u00e2\u0082\u00ac\u00f0\u009f\u0098\u0082\", 6, Measurement.BYTES, StandardCharsets.UTF_8, \"a\u00c3\u00a9\u00e2\u0082\u00ac\"),\n            Arguments.of(\"a\u00c3\u00a9\u00e2\u0082\u00ac\u00f0\u009f\u0098\u0082\", 5, Measurement.BYTES, StandardCharsets.UTF_8, \"a\u00c3\u00a9\"),\n            Arguments.of(\"a\u00c3\u00a9\u00e2\u0082\u00ac\u00f0\u009f\u0098\u0082\", 3, Measurement.BYTES, StandardCharsets.UTF_8, \"a\u00c3\u00a9\"),\n            Arguments.of(\"a\u00c3\u00a9\u00e2\u0082\u00ac\u00f0\u009f\u0098\u0082\", 2, Measurement.BYTES, StandardCharsets.UTF_8, \"a\"),\n            Arguments.of(\"a\u00c3\u00a9\u00e2\u0082\u00ac\u00f0\u009f\u0098\u0082\", 1, Measurement.BYTES, StandardCharsets.UTF_8, \"a\"),\n            Arguments.of(\"a\u00c3\u00a9\u00e2\u0082\u00ac\u00f0\u009f\u0098\u0082\", 0, Measurement.BYTES, StandardCharsets.UTF_8, \"\"),\n            \n            // Edge cases\n            Arguments.of(null, 10, Measurement.CHARACTERS, StandardCharsets.UTF_8, null),\n            Arguments.of(\"\", 10, Measurement.CHARACTERS, StandardCharsets.UTF_8, \"\"),\n            Arguments.of(\"\", 10, Measurement.BYTES, StandardCharsets.UTF_8, \"\"),\n            Arguments.of(\"abc\", 0, Measurement.CHARACTERS, StandardCharsets.UTF_8, \"\"),\n            Arguments.of(\"abc\", 0, Measurement.BYTES, StandardCharsets.UTF_8, \"\")\n        );\n    }\n\n    @ParameterizedTest(name = \"{index}: shorten(\\\"{0}\\\", {1}, {2}, {3}) => \\\"{4}\\\"\")\n    @MethodSource(\"shortenData\")\n    void testShorten(final String name, final int limit, final Measurement measurement, final Charset charset, final String expected) {\n        final String shortenedName = FilenameUtils.shorten(name, limit, measurement, charset);\n        assertThat(shortenedName).isEqualTo(expected);\n    }\n}",
      "method_signature": "testNameLengthStrategyTruncate_Succeeds(org.apache.commons.io.FileSystem.NameLengthStrategy, int, java.lang.String, java.lang.String)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7385,
    "output_tokens": 9870,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1455,
      "description": "Create a test case to validate that the system correctly enforces boundary rules when attempting to read data from an input source into a storage area with specified position and length constraints, ensuring the operation rejects invalid configurations before processing begins. Establish a test data file within a temporary workspace containing a known quantity of sample information, then prepare two internal buffers\u2014one for byte-level data and one for character-level data\u2014each initialized with default placeholder values and partially populated with sequential test values to simulate realistic operating conditions. For each scenario provided by the parameterized test configuration, attempt to read from the input source into the designated storage area using the specified starting position and length parameters, expecting the system to immediately reject the operation with the appropriate business rule violation corresponding to the invalid configuration, such as negative offsets, negative lengths, or attempts to access beyond available storage capacity. Verify using standard equality assertions that the system raises the expected business rule violation for each invalid scenario, confirming that protective boundaries prevent improper data access before any read operation begins. The test leverages JUnit 5 as the testing framework with parameterized test support and AssertJ for validation of expected outcomes, ensuring the system enforces data access constraints consistently across all invalid input combinations.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testReadFully_InputStream_Offset_ArgumentsValidation(java.io.InputStream, byte[], int, int, java.lang.Class)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsReadTest",
      "code": "package org.apache.commons.io;\n\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.nio.charset.StandardCharsets;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests for {@link IOUtils} read methods boundary conditions.\n */\npublic class IOUtilsReadTest {\n\n    private static final int BUFFER_SIZE = 10;\n    private static final String TEST_DATA_STRING = \"0123456789\";\n\n    private static Stream<Arguments> provideInvalidReadArguments() {\n        final byte[] testDataBytes = TEST_DATA_STRING.getBytes(StandardCharsets.UTF_8);\n        final byte[] byteBuffer = new byte[BUFFER_SIZE];\n        final char[] charBuffer = new char[BUFFER_SIZE];\n\n        // Partially populate buffers to simulate realistic operating conditions.\n        for (int i = 0; i < BUFFER_SIZE / 2; i++) {\n            byteBuffer[i] = (byte) ('a' + i);\n            charBuffer[i] = (char) ('a' + i);\n        }\n\n        return Stream.of(\n            // ---- Byte scenarios ----\n            // Negative offset\n            Arguments.of(\"Byte: Negative offset\", new ByteArrayInputStream(testDataBytes), byteBuffer, -1, 4),\n            // Negative length\n            Arguments.of(\"Byte: Negative length\", new ByteArrayInputStream(testDataBytes), byteBuffer, 0, -1),\n            // Offset larger than buffer\n            Arguments.of(\"Byte: Offset > buffer length\", new ByteArrayInputStream(testDataBytes), byteBuffer, BUFFER_SIZE + 1, 1),\n            // offset + length > buffer length\n            Arguments.of(\"Byte: Length exceeds buffer from offset\", new ByteArrayInputStream(testDataBytes), byteBuffer, BUFFER_SIZE - 4, 5),\n\n            // ---- Char scenarios ----\n            // Negative offset\n            Arguments.of(\"Char: Negative offset\", new StringReader(TEST_DATA_STRING), charBuffer, -1, 4),\n            // Negative length\n            Arguments.of(\"Char: Negative length\", new StringReader(TEST_DATA_STRING), charBuffer, 0, -1),\n            // Offset larger than buffer\n            Arguments.of(\"Char: Offset > buffer length\", new StringReader(TEST_DATA_STRING), charBuffer, BUFFER_SIZE + 1, 1),\n            // offset + length > buffer length\n            Arguments.of(\"Char: Length exceeds buffer from offset\", new StringReader(TEST_DATA_STRING), charBuffer, BUFFER_SIZE - 4, 5)\n        );\n    }\n\n    @ParameterizedTest(name = \"{0}\")\n    @MethodSource(\"provideInvalidReadArguments\")\n    public void testReadRejectsInvalidBufferArguments(final String scenario, final Object input, final Object buffer, final int offset, final int length) {\n        if (input instanceof InputStream) {\n            assertThatThrownBy(() -> {\n                IOUtils.read((InputStream) input, (byte[]) buffer, offset, length);\n            })\n            .isInstanceOf(IndexOutOfBoundsException.class)\n            .hasMessageContaining(\"offset\");\n        } else if (input instanceof Reader) {\n            assertThatThrownBy(() -> {\n                IOUtils.read((Reader) input, (char[]) buffer, offset, length);\n            })\n            .isInstanceOf(IndexOutOfBoundsException.class)\n            .hasMessageContaining(\"offset\");\n        }\n    }\n}",
      "method_signature": "testReadFully_InputStream_Offset_ArgumentsValidation(java.io.InputStream, byte[], int, int, java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7400,
    "output_tokens": 6165,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1458,
      "description": "Create a test case to validate that when a byte channel wrapping existing content is instructed to resize to its current capacity, the operation preserves both the size and the complete original content without modification. Begin by establishing a channel containing a known sequence of bytes, then verify the channel reports its size matching the original content length. Instruct the system to resize the channel to exactly its current capacity, and confirm the size remains unchanged after this operation. Subsequently, read the entire content from the channel into a receiving buffer and verify that all retrieved bytes exactly match the original sequence, ensuring no data corruption or loss occurred during the resize operation. Use JUnit 5 for the testing framework with standard equality assertions to confirm size consistency and array equality assertions to validate content integrity, ensuring the system correctly handles resize operations that do not alter the channel's dimensions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testTruncateToCurrentSizeDoesntChangeAnything()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.SeekableByteChannelBuilderTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link SeekableByteChannelBuilder}.\n */\npublic class SeekableByteChannelBuilderTest {\n\n    @Test\n    public void testResizeToCurrentSize() throws IOException {\n        final byte[] originalContent = \"Hello, World!\".getBytes(StandardCharsets.UTF_8);\n        // The builder will create a temporary file for the stream's content.\n        final SeekableByteChannelBuilder builder = new SeekableByteChannelBuilder().setInputStream(new ByteArrayInputStream(originalContent));\n\n        try (SeekableByteChannel channel = builder.get()) {\n            // 1. Verify initial size.\n            final long initialSize = channel.size();\n            assertEquals(originalContent.length, initialSize, \"Initial channel size should match original content length.\");\n\n            // 2. Resize channel to its current size.\n            channel.truncate(initialSize);\n\n            // 3. Confirm size remains unchanged.\n            assertEquals(initialSize, channel.size(), \"Channel size should not change after resizing to its current capacity.\");\n\n            // 4. Verify content integrity.\n            channel.position(0); // Rewind to read from the beginning.\n            final byte[] readContent = IOUtils.toByteArray(channel);\n            assertArrayEquals(originalContent, readContent, \"Channel content should remain identical after the resize operation.\");\n        }\n    }\n}",
      "method_signature": "testTruncateToCurrentSizeDoesntChangeAnything()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 47559,
    "output_tokens": 8945,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 1459,
      "description": "Define a test method that validates write behavior after repositioning within a Byte Array Seekable Byte Channel by first wrapping a cloned copy of the test data byte array into a channel instance within a try-with-resources block to ensure automatic closure, then prepare an input buffer by wrapping the original test data and construct an expected data buffer that allocates space for the original data length plus five bytes, populating it with the first five bytes of the test data followed by the complete test data to represent the anticipated state after a positional write. Reposition the channel to offset five using the position method, then invoke the write method with the input buffer and capture the count of bytes written. Immediately verify that the write count equals the length of the test data, then extract the channel's internal byte array and compare a portion sized to the channel's current size against the expected data buffer's backing array to confirm the data was written at the correct offset, and validate that the channel's position has advanced to the sum of the test data length and the initial offset of five. Upon completion of the try block, the channel closes automatically, and in the teardown phase, assert that the original test data byte array remains unmodified by comparing it against the expected UTF-8 encoded bytes of the string \"Some data\" to ensure reading operations have not altered the shared test fixture. JUnit 5 and standard assertion methods.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldWriteDataProperlyAfterPositionSet()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] TEST_DATA = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testWriteWithPosition() throws IOException {\n        final byte[] clonedTestData = TEST_DATA.clone();\n        try (final ByteArraySeekableByteChannel channel = new ByteArraySeekableByteChannel(clonedTestData)) {\n            final ByteBuffer inputBuffer = ByteBuffer.wrap(TEST_DATA);\n\n            final int offset = 5;\n            final ByteBuffer expectedDataBuffer = ByteBuffer.allocate(TEST_DATA.length + offset);\n            expectedDataBuffer.put(TEST_DATA, 0, offset);\n            expectedDataBuffer.put(TEST_DATA);\n\n            channel.position(offset);\n            final int bytesWritten = channel.write(inputBuffer);\n\n            assertEquals(TEST_DATA.length, bytesWritten);\n\n            final byte[] channelArray = channel.array();\n            final byte[] portionToCompare = Arrays.copyOf(channelArray, (int) channel.size());\n            assertArrayEquals(expectedDataBuffer.array(), portionToCompare);\n            assertEquals(TEST_DATA.length + offset, channel.position());\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        // Ensure the original test data array was not modified\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), TEST_DATA);\n    }\n}",
      "method_signature": "testShouldWriteDataProperlyAfterPositionSet()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 49636,
    "output_tokens": 7442,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 1461,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]` initialized with the byte representation of the string literal `\"Some data\"` using `StandardCharsets.UTF_8`, then write a test method annotated with `@Test` that declares `throws IOException` and begins by opening a try-with-resources block that creates a variable `c` of type `ByteArraySeekableByteChannel` by invoking the static method `ByteArraySeekableByteChannel.wrap` with the argument `testData.clone()`, then within the try block declare a final variable `inData` of type `ByteBuffer` by invoking `ByteBuffer.wrap(testData)`, followed by declaring a final variable `expectedData` of type `ByteBuffer` by chaining `ByteBuffer.allocate(testData.length + 5)` with `.put(testData, 0, 5)` and then `.put(testData)`, after which invoke `c.position(5L)` to set the channel's position to long value `5L`, then declare a final int variable `writeCount` by invoking `c.write(inData)` and immediately assert using `assertEquals(testData.length, writeCount)` that the write count equals the length of `testData`, next assert using `assertArrayEquals(expectedData.array(), Arrays.copyOf(c.array(), (int) c.size()))` that the expected data array matches the result of copying the channel's internal array up to its size by invoking `Arrays.copyOf` with `c.array()` and the cast-to-int result of `c.size()`, then assert using `assertEquals(testData.length + 5, c.position())` that the channel's position equals `testData.length + 5`, and after the try-with-resources block completes define a teardown method that invokes `assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData)` to verify the test data remains unmodified by comparing it to the byte representation of the string literal `\"Some data\"` using `StandardCharsets.UTF_8`. The test uses JUnit 5 Assertions with method-level annotation `@Test` and no class-level annotations.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldWriteDataProperlyAfterPositionSet()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @AfterEach\n    public void tearDown() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n\n    @Test\n    public void testWrite() throws IOException {\n        try (final ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData.clone())) {\n            final ByteBuffer inData = ByteBuffer.wrap(testData);\n            final ByteBuffer expectedData = ByteBuffer.allocate(testData.length + 5).put(testData, 0, 5).put(testData);\n            c.position(5L);\n            final int writeCount = c.write(inData);\n            assertEquals(testData.length, writeCount);\n            assertArrayEquals(expectedData.array(), Arrays.copyOf(c.array(), (int) c.size()));\n            assertEquals(testData.length + 5, c.position());\n        }\n    }\n\n}",
      "method_signature": "testShouldWriteDataProperlyAfterPositionSet()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23273,
    "output_tokens": 8058,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 156,
      "description": "Define a parameterized test method that accepts a Channel class type as input, where the parameter source provides various Channel interface implementations to validate the CloseShieldChannel wrapper's string representation across different channel types. For each iteration, create a mock instance of the provided Channel class and configure its toString method to return a specific identifier string. Pass this mocked channel to the CloseShieldChannel's wrap method to obtain a shielded proxy instance, then invoke toString on the proxy to capture its string representation. Validate that the resulting string contains both the shield wrapper's identifier text and the original channel's identifier text, confirming that the proxy correctly delegates the toString call while identifying itself as a protective wrapper. Use a mocking framework for channel instance creation and behavior stubbing, along with a parameterized testing framework and assertion library.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testToString(java.lang.Class)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.when;\n\nimport java.nio.channels.AsynchronousChannel;\nimport java.nio.channels.ByteChannel;\nimport java.nio.channels.Channel;\nimport java.nio.channels.GatheringByteChannel;\nimport java.nio.channels.InterruptibleChannel;\nimport java.nio.channels.NetworkChannel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.ScatteringByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\nimport org.mockito.Mockito;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    public static Stream<Class<? extends Channel>> channelClasses() {\n        return Stream.of(\n            AsynchronousChannel.class,\n            ByteChannel.class,\n            Channel.class,\n            GatheringByteChannel.class,\n            InterruptibleChannel.class,\n            NetworkChannel.class,\n            ReadableByteChannel.class,\n            ScatteringByteChannel.class,\n            SeekableByteChannel.class,\n            WritableByteChannel.class\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"channelClasses\")\n    public <T extends Channel> void testToString(final Class<T> channelClass) {\n        final String toString = \"test-channel\";\n        final T mockChannel = Mockito.mock(channelClass);\n        when(mockChannel.toString()).thenReturn(toString);\n\n        final T shielded = CloseShieldChannel.wrap(mockChannel);\n        final String actual = shielded.toString();\n\n        assertTrue(actual.contains(\"CloseShieldChannel(\"));\n        assertTrue(actual.contains(toString));\n        assertEquals(\"CloseShieldChannel(\" + toString + \")\", actual);\n    }\n}",
      "method_signature": "testToString(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.6667,
      "callable_recall": 0.7,
      "callable_precision": 0.6364,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 3,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 66419,
    "output_tokens": 4101,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 160,
      "description": "Define a parameterized test method that accepts a channel interface class type as input, where the parameter source provides various channel interface implementations to validate idempotent close behavior across different channel types. For each channel type, create a mock instance of that specific channel interface, then wrap the mock using the Close Shield Channel's wrap method to obtain a shielded proxy that intercepts close operations. Invoke the close method on the shielded proxy and immediately verify that the proxy reports itself as not open by checking its open status. Invoke the close method a second time on the same shielded proxy to demonstrate idempotent behavior, then again verify that the proxy continues to report itself as not open. After both close invocations and status checks, confirm that the underlying mock channel received no interactions whatsoever, proving that the shield successfully prevented the close calls from propagating to the wrapped channel. Use JUnit 5 for parameterized testing and Mockito for mocking and interaction verification.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testCloseIsIdempotent(java.lang.Class)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\n\nimport java.io.IOException;\nimport java.nio.channels.ByteChannel;\nimport java.nio.channels.Channel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    public static Stream<Class<? extends Channel>> channelProvider() {\n        return Stream.of(\n                Channel.class,\n                ReadableByteChannel.class,\n                WritableByteChannel.class,\n                ByteChannel.class,\n                SeekableByteChannel.class);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"channelProvider\")\n    public <T extends Channel> void testIdempotentClose(final Class<T> channelClass) throws IOException {\n        final T mockChannel = mock(channelClass);\n\n        final Channel shieldedChannel = CloseShieldChannel.wrap(mockChannel);\n\n        shieldedChannel.close();\n        assertFalse(shieldedChannel.isOpen());\n\n        shieldedChannel.close();\n        assertFalse(shieldedChannel.isOpen());\n\n        verify(mockChannel, never()).close();\n    }\n}",
      "method_signature": "testCloseIsIdempotent(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8889,
      "callable_precision": 0.7273,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 37529,
    "output_tokens": 10694,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 161,
      "description": "Create a test case to validate that the protective wrapper system correctly identifies itself and its underlying communication channel when producing diagnostic information across all supported channel types. For each supported channel interface, simulate a communication channel configured to identify itself with a recognizable label, then apply the protective wrapper to shield the channel from premature closure. Once the wrapper is in place, request the diagnostic representation from the protected channel and verify that the resulting description includes both an indicator that the protective mechanism is active and the original channel's identifying label, ensuring transparency for troubleshooting and monitoring purposes. Use JUnit 5 for parameterized testing across channel variations, Mockito to simulate channel behavior, and standard assertions to confirm both identifying markers are present in the diagnostic output.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testToString(java.lang.Class)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ProtectedChannelWrapperTest",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.channels.Channel;\nimport java.util.stream.Stream;\nimport org.apache.commons.io.input.CloseShieldInputStream;\nimport org.apache.commons.io.input.CloseShieldReader;\nimport org.apache.commons.io.output.CloseShieldOutputStream;\nimport org.apache.commons.io.output.CloseShieldWriter;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests the diagnostic representation of protective channel wrappers.\n */\npublic class ProtectedChannelWrapperTest {\n\n    private static final String UNDERLYING_CHANNEL_LABEL = \"mocked-channel-id\";\n\n    /**\n     * Provides a stream of arguments for the parameterized test, covering different types of close-shielded wrappers.\n     * Each argument consists of a protective wrapper instance and its corresponding mocked underlying channel/stream.\n     *\n     * @return A stream of {@link Arguments} for the test.\n     */\n    static Stream<Arguments> channelWrapperProvider() {\n        // Simulate various communication channels using mocks\n        final InputStream mockInputStream = mock(InputStream.class, UNDERLYING_CHANNEL_LABEL);\n        final OutputStream mockOutputStream = mock(OutputStream.class, UNDERLYING_CHANNEL_LABEL);\n        final Reader mockReader = mock(Reader.class, UNDERLYING_CHANNEL_LABEL);\n        final Writer mockWriter = mock(Writer.class, UNDERLYING_CHANNEL_LABEL);\n        final Channel mockChannel = mock(Channel.class, UNDERLYING_CHANNEL_LABEL);\n\n        // Configure mocks to return a recognizable label for diagnostic purposes\n        when(mockInputStream.toString()).thenReturn(UNDERLYING_CHANNEL_LABEL);\n        when(mockOutputStream.toString()).thenReturn(UNDERLYING_CHANNEL_LABEL);\n        when(mockReader.toString()).thenReturn(UNDERLYING_CHANNEL_LABEL);\n        when(mockWriter.toString()).thenReturn(UNDERLYING_CHANNEL_LABEL);\n        when(mockChannel.toString()).thenReturn(UNDERLYING_CHANNEL_LABEL);\n\n        // Return a stream of wrapper instances and their underlying mocks\n        return Stream.of(\n            Arguments.of(new CloseShieldInputStream(mockInputStream), mockInputStream),\n            Arguments.of(new CloseShieldOutputStream(mockOutputStream), mockOutputStream),\n            Arguments.of(new CloseShieldReader(mockReader), mockReader),\n            Arguments.of(new CloseShieldWriter(mockWriter), mockWriter),\n            Arguments.of(new SeekableByteChannelDecorator(mock(CloseableChannel.class)) {\n                @Override\n                public String toString() {\n                    return \"CloseShield[\" + delegate + \"]\";\n                }\n            }.setDelegate(mock(org.apache.commons.io.channels.SeekableByteChannelNode.class, UNDERLYING_CHANNEL_LABEL)\n                .setDelegate(mock(java.nio.channels.SeekableByteChannel.class, UNDERLYING_CHANNEL_LABEL))))\n        );\n    }\n\n    /**\n     * Validates that the diagnostic output (toString()) of a protective wrapper includes\n     * both an identifier for the wrapper itself and the label of the underlying channel.\n     * This ensures that monitoring and troubleshooting information remains transparent.\n     *\n     * @param wrapper The protective wrapper instance to test.\n     * @param underlyingChannel The mocked underlying channel or stream.\n     */\n    @ParameterizedTest\n    @MethodSource(\"channelWrapperProvider\")\n    void testDiagnosticRepresentationIncludesWrapperAndChannelIds(final Object wrapper, final Object underlyingChannel) {\n        // In case of the decorator, we need to setup the mock behavior for its delegate\n        if (wrapper instanceof SeekableByteChannelDecorator) {\n             when(((SeekableByteChannelDecorator) wrapper).getDelegate().toString()).thenReturn(UNDERLYING_CHANNEL_LABEL);\n        } else {\n             when(underlyingChannel.toString()).thenReturn(UNDERLYING_CHANNEL_LABEL);\n        }\n\n        final String diagnosticOutput = wrapper.toString();\n\n        assertTrue(diagnosticOutput.contains(\"CloseShield\"),\n            \"Diagnostic output should indicate the protective wrapper is active.\");\n        assertTrue(diagnosticOutput.contains(UNDERLYING_CHANNEL_LABEL),\n            \"Diagnostic output should include the underlying channel's identifying label.\");\n    }\n}",
      "method_signature": "testToString(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14625,
    "output_tokens": 9565,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 163,
      "description": "Create a test case to validate that the system's file comparison mechanism can provide a human-readable description of its configuration when requested. Establish a file ordering strategy that combines multiple comparison criteria by first adding a size-based comparison rule and then adding a file extension comparison rule to a collection of ordering strategies, then configure the comparison system to use this collection of rules. Once the comparison system is configured, request a textual representation of its configuration to confirm the system can describe itself for diagnostic or logging purposes. Verify that the resulting description includes references to both the size-based comparison capability and the extension-based comparison capability, ensuring stakeholders or administrators can understand which ordering rules are active. Use JUnit 5 for test execution and standard boolean assertions to confirm the description contains the expected business rule indicators.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.comparator.CompositeFileComparatorTest",
      "method_signature": "testToString()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.comparator.CompositeFileComparatorTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.comparator;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link CompositeFileComparator}.\n */\npublic class CompositeFileComparatorTest1 {\n\n    /**\n     * Tests that the comparator's configuration description is human-readable.\n     */\n    @Test\n    public void testToStringDescribesConfiguration() {\n        // Establish a file ordering strategy that combines multiple comparison criteria\n        final List<Comparator<File>> comparators = new ArrayList<>();\n        // Add a size-based comparison rule\n        comparators.add(SizeFileComparator.SIZE_COMPARATOR);\n        // Add a file extension comparison rule\n        comparators.add(ExtensionFileComparator.EXTENSION_COMPARATOR);\n\n        // Configure the comparison system to use this collection of rules\n        final CompositeFileComparator compositeComparator = new CompositeFileComparator(comparators);\n\n        // Request a textual representation of its configuration\n        final String configurationDescription = compositeComparator.toString();\n\n        // Verify that the resulting description includes references to both comparison capabilities\n        assertTrue(configurationDescription.contains(\"SizeFileComparator\"),\n                \"The description should include the size-based comparison rule.\");\n        assertTrue(configurationDescription.contains(\"ExtensionFileComparator\"),\n                \"The description should include the extension-based comparison rule.\");\n    }\n}",
      "method_signature": "testToString()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8889,
      "callable_precision": 0.8889,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 34232,
    "output_tokens": 6414,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 164,
      "description": "Define a parameterized test method that accepts a single parameter of type `Class<? extends Channel>` named `channelClass` and declares that it throws `Exception`. Begin by creating a mock instance of the channel type specified by `channelClass` using `mock(channelClass)` and assign the result to a variable named `channel` of type `Channel`. Configure the mock by calling `when(channel.toString()).thenReturn(\"MyChannel\")` to stub the `toString()` method so it returns the String literal `\"MyChannel\"`. Invoke the static method `CloseShieldChannel.wrap(channel)` passing the mock `channel` as the argument, and assign the returned `Channel` proxy to a variable named `shield`. Retrieve the string representation by calling `shield.toString()` and assign the result to a variable named `shieldString` of type `String`. Assert that `shieldString` contains the substring `\"CloseShield\"` by invoking `assertTrue(shieldString.contains(\"CloseShield\"))`, then assert that `shieldString` also contains the substring `\"MyChannel\"` by invoking `assertTrue(shieldString.contains(\"MyChannel\"))`. Annotate the test method with `@ParameterizedTest` and `@MethodSource(\"channelInterfaces\")` to supply the channel class parameters, and use Mockito for mocking and JUnit 5 Assertions for verification.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testToString(java.lang.Class)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nimport java.nio.channels.Channel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    public static Stream<Class<? extends Channel>> channelInterfaces() {\n        return Stream.of(Channel.class, ReadableByteChannel.class, WritableByteChannel.class, SeekableByteChannel.class);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"channelInterfaces\")\n    public void testToString(final Class<? extends Channel> channelClass) throws Exception {\n        final Channel channel = mock(channelClass);\n        when(channel.toString()).thenReturn(\"MyChannel\");\n        final Channel shield = CloseShieldChannel.wrap(channel);\n        final String shieldString = shield.toString();\n        assertTrue(shieldString.contains(\"CloseShield\"));\n        assertTrue(shieldString.contains(\"MyChannel\"));\n    }\n}",
      "method_signature": "testToString(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 47866,
    "output_tokens": 8809,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 168,
      "description": "Create a test case to validate that the system's protective wrapper around communication channels correctly handles repeated shutdown requests without affecting the underlying channel, ensuring this behavior holds across all supported channel types. Establish a protective wrapper around a simulated communication channel, then instruct the system to shut down the wrapper and confirm it reports as closed. Immediately attempt to shut down the wrapper a second time and verify it still reports as closed, demonstrating that multiple shutdown attempts are safely handled without error. After both shutdown attempts, confirm that the underlying protected channel was never actually instructed to close, proving the wrapper successfully shields the channel from closure requests while maintaining proper closed state semantics. This validation should occur for each type of communication channel the system supports to ensure consistent behavior across all channel variations. Use JUnit 5 as the testing framework with standard equality assertions to verify the closed state, and employ Mockito to simulate the underlying channel and confirm it remains untouched by the wrapper's shutdown operations.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testCloseIsIdempotent(java.lang.Class)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\n\nimport java.io.IOException;\nimport java.nio.channels.AsynchronousChannel;\nimport java.nio.channels.ByteChannel;\nimport java.nio.channels.Channel;\nimport java.nio.channels.GatheringByteChannel;\nimport java.nio.channels.InterruptibleChannel;\nimport java.nio.channels.NetworkChannel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.ScatteringByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\nimport org.mockito.Mockito;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    public static Stream<Class<? extends Channel>> channelClasses() {\n        return Stream.of(\n            AsynchronousChannel.class,\n            ByteChannel.class,\n            Channel.class,\n            GatheringByteChannel.class,\n            InterruptibleChannel.class,\n            NetworkChannel.class,\n            ReadableByteChannel.class,\n            ScatteringByteChannel.class,\n            SeekableByteChannel.class,\n            WritableByteChannel.class\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"channelClasses\")\n    public <T extends Channel> void testRepeatedShutdownDoesNotAffectChannel(Class<T> channelClass) throws IOException {\n        T mockChannel = mock(channelClass);\n\n        T shieldedChannel = CloseShieldChannel.wrap(mockChannel);\n        assertFalse(shieldedChannel == null, \"The shielded channel should not be null.\");\n\n        // First shutdown\n        shieldedChannel.close();\n        assertFalse(shieldedChannel.isOpen(), \"Shield should report as closed after first close.\");\n\n        // Second shutdown\n        shieldedChannel.close();\n        assertFalse(shieldedChannel.isOpen(), \"Shield should still report as closed after second close.\");\n\n        // Verify underlying channel was never closed\n        verify(mockChannel, never()).close();\n    }\n}",
      "method_signature": "testCloseIsIdempotent(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.6667,
      "callable_recall": 0.4444,
      "callable_precision": 0.3333,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 2,
          "write_file": 1,
          "run_shell_command": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 75510,
    "output_tokens": 3379,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 171,
      "description": "Define a parameterized test method that accepts a single parameter of type `Class<? extends Channel>` and declares that it throws `Exception`, annotating it with `@ParameterizedTest` and `@MethodSource(\"channelInterfaces\")` to supply the test data. Begin by invoking the static `mock` method from Mockito with the argument `channelClass` to create a mock instance, assigning the result to a variable named `channel` of type `Channel`. Next, invoke the static method `wrap` on `CloseShieldChannel` passing `channel` as the argument, and assign the returned `Channel` to a variable named `shield`. Immediately invoke `close()` on `shield`, then assert using `assertFalse(shield.isOpen())` to verify that the shield is not open after the first close call. Invoke `close()` on `shield` a second time, then again assert using `assertFalse(shield.isOpen())` to confirm the shield remains closed. Finally, invoke `verifyNoInteractions(channel)` from Mockito to ensure that the underlying mock `channel` received no method calls during the test. The test uses JUnit 5 Assertions for the `assertFalse` calls and Mockito for mocking and verification.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testCloseIsIdempotent(java.lang.Class)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verifyNoInteractions;\n\nimport java.nio.channels.ByteChannel;\nimport java.nio.channels.Channel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.stream.Stream;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    private static Stream<Class<? extends Channel>> channelInterfaces() {\n        return Stream.of(Channel.class, ByteChannel.class, SeekableByteChannel.class, ReadableByteChannel.class, WritableByteChannel.class);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"channelInterfaces\")\n    public void testCloseShield(final Class<? extends Channel> channelClass) throws Exception {\n        final Channel channel = mock(channelClass);\n        final Channel shield = CloseShieldChannel.wrap(channel);\n        shield.close();\n        assertFalse(shield.isOpen());\n        shield.close();\n        assertFalse(shield.isOpen());\n        verifyNoInteractions(channel);\n    }\n\n}",
      "method_signature": "testCloseIsIdempotent(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18391,
    "output_tokens": 3505,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 173,
      "description": "Define a test method that validates the behavior of a close-shielding channel wrapper around a Gathering Byte Channel by first creating a mock Gathering Byte Channel and configuring it to report as open when queried. Wrap this mock channel using the Close Shield Channel's wrap method to obtain a shielded proxy instance. Before closing the shield, configure the mock to return a specific long value when its write method is invoked with null buffer array and zero offset and length parameters, then invoke the write method on the shielded proxy with these same parameters and assert that the returned value matches the configured response. Verify that the write invocation was delegated to the underlying mock channel. Next, invoke the close method on the shielded proxy, then attempt to invoke write again on the proxy with the same parameters and assert that this operation throws a Closed Channel Exception to confirm the shield enforces closed-channel semantics. Finally, verify that no additional interactions occurred with the underlying mock channel beyond those explicitly configured and verified, ensuring the shield properly intercepts the close operation without delegating it. This test uses JUnit 5 for assertions and Mockito for mocking and verification.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testGatheringByteChannelMethods()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.when;\n\nimport java.io.IOException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.GatheringByteChannel;\n\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    @Test\n    public void testGatheringByteChannel() throws IOException {\n        final GatheringByteChannel mock = Mockito.mock(GatheringByteChannel.class);\n        when(mock.isOpen()).thenReturn(true);\n        final GatheringByteChannel proxy = CloseShieldChannel.wrap(mock);\n\n        final long expected = 123L;\n        when(mock.write(null, 0, 0)).thenReturn(expected);\n        assertEquals(expected, proxy.write(null, 0, 0));\n        Mockito.verify(mock).write(null, 0, 0);\n\n        proxy.close();\n        assertThrows(ClosedChannelException.class, () -> proxy.write(null, 0, 0));\n        Mockito.verifyNoMoreInteractions(mock);\n    }\n\n}",
      "method_signature": "testGatheringByteChannelMethods()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8,
      "callable_precision": 0.8,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 60152,
    "output_tokens": 4612,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 174,
      "description": "Define a test method that validates the string representation of a Composite File Comparator by constructing a comparator chain and verifying its textual output. Initialize a mutable collection to hold file comparator delegates, then populate it with a Size File Comparator and an Extension File Comparator in sequence. Construct a Composite File Comparator instance by passing the populated collection to its constructor, which internally aggregates the delegates into a composite comparison strategy. Invoke the toString method on the composite comparator to retrieve its string representation, capturing the result in a variable. Validate that the returned string contains the text \"SizeFileComparator\" to confirm the first delegate is represented in the output. Subsequently, validate that the same string contains the text \"ExtensionFileComparator\" to confirm the second delegate is also represented. This test operates within a broader test suite context where setup fixtures initialize a composite comparator combining size and extension comparators, wrap it in a reverse comparator, and create four file instances with varying sizes and extensions by writing test data of specific byte lengths to each file, ensuring parent directories exist before file creation. The testing frameworks used are JUnit 5 and standard assertion utilities.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.comparator.CompositeFileComparatorTest",
      "method_signature": "testToString()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.comparator.CompositeFileComparatorToStringTest",
      "code": "package org.apache.commons.io.comparator;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link CompositeFileComparator}.\n */\npublic class CompositeFileComparatorToStringTest {\n\n    /**\n     * Tests {@link CompositeFileComparator#toString()}.\n     */\n    @Test\n    public void testToString() {\n        final List<Comparator<File>> delegates = new ArrayList<>();\n        delegates.add(new SizeFileComparator());\n        delegates.add(new ExtensionFileComparator());\n        final Comparator<File> comparator = new CompositeFileComparator(delegates);\n        final String result = comparator.toString();\n        assertTrue(result.contains(\"SizeFileComparator\"), \"Missing SizeFileComparator\");\n        assertTrue(result.contains(\"ExtensionFileComparator\"), \"Missing ExtensionFileComparator\");\n    }\n}",
      "method_signature": "testToString()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.5,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.8182,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 37720,
    "output_tokens": 4395,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 175,
      "description": "Create a test case to validate that the channel protection mechanism correctly delegates write operations to the underlying system channel before closure and properly enforces closure semantics afterward. Begin by establishing a simulated system channel configured to report an active state, then apply the protective wrapper to shield it from premature closure. With the protection in place, configure the underlying channel to return a specific operation result when a write operation is attempted, then perform the write operation through the protected interface and confirm the system returns the expected result while verifying the operation was properly delegated to the underlying channel. Once this pre-closure behavior is confirmed, close the protected channel and immediately attempt another write operation, ensuring the system correctly prevents the operation by signaling a closed channel condition. After validating the post-closure behavior, confirm no additional interactions occurred with the underlying channel beyond the initial delegated write, demonstrating that the protective mechanism successfully intercepted the close operation without propagating it downstream. Use JUnit 5 for the testing framework, standard assertions for equality checks and exception validation, and Mockito for simulating the underlying channel behavior and verifying interaction patterns.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testGatheringByteChannelMethods()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7382,
    "output_tokens": 171,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 182,
      "description": "Define a test method that declares a variable `channel` of type `GatheringByteChannel` and initialize it by invoking `mock(GatheringByteChannel.class)` from Mockito, then configure the mock by calling `when(channel.isOpen()).thenReturn(true)` to stub the `isOpen` method to return `true`. Next, declare a variable `shield` of type `GatheringByteChannel` and assign it the result of invoking the static method `CloseShieldChannel.wrap(channel)` with the mock as the argument. Configure the mock's write behavior by calling `when(channel.write(null, 0, 0)).thenReturn(42L)` to stub the three-argument `write` method with `null` as the first argument and integer `0` for both the second and third arguments, returning long value `42L`. Immediately assert that invoking `shield.write(null, 0, 0)` with the same arguments returns `42` by using `assertEquals(42, shield.write(null, 0, 0))`. Verify the delegation occurred by calling `verify(channel).write(null, 0, 0)` to confirm the mock's `write` method was invoked exactly once with those arguments. Invoke `shield.close()` to close the shielded channel, then assert that a subsequent call to `shield.write(null, 0, 0)` throws `ClosedChannelException` by using `assertThrows(ClosedChannelException.class, () -> shield.write(null, 0, 0))`. Finally, verify no additional interactions occurred on the mock by invoking `verifyNoMoreInteractions(channel)`. The test method is annotated with `@Test` from JUnit 5, uses Mockito for mocking and verification, and employs JUnit 5 Assertions for `assertEquals` and `assertThrows`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testGatheringByteChannelMethods()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 30238,
    "output_tokens": 4746,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 202,
      "description": "Define a test method that validates the behavior of a close-shielding channel proxy by first creating a mock WritableByteChannel and configuring it to report as open, then wrapping this mock channel using the CloseShieldChannel component to produce a shielded proxy instance. Configure the mock to return a specific integer value when its write method is invoked with a null buffer, then invoke the write method on the shielded proxy and assert that the returned value matches the configured response, immediately verifying that the underlying mock channel's write method was called with the same null argument to confirm delegation occurs before closure. Invoke the close method on the shielded proxy to transition it into a closed state, then attempt to invoke the write method again on the now-closed proxy and assert that a ClosedChannelException is thrown to validate that the shield enforces closed-channel semantics. Finally, verify that no additional interactions occurred with the underlying mock channel beyond the initial write invocation, confirming that the close operation was intercepted and did not propagate to the delegate. This test uses JUnit 5 for assertions and Mockito for mocking and verification.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testWritableByteChannelMethods()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport java.io.IOException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.WritableByteChannel;\n\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    @Test\n    public void testCloseShield() throws IOException {\n        final WritableByteChannel mockChannel = Mockito.mock(WritableByteChannel.class);\n        when(mockChannel.isOpen()).thenReturn(true);\n\n        final WritableByteChannel shieldedProxy = CloseShieldChannel.wrap(mockChannel);\n\n        final int expectedWriteReturnValue = 42;\n        when(mockChannel.write(null)).thenReturn(expectedWriteReturnValue);\n\n        final int actualWriteReturnValue = shieldedProxy.write(null);\n        assertEquals(expectedWriteReturnValue, actualWriteReturnValue);\n        verify(mockChannel).write(null);\n\n        shieldedProxy.close();\n\n        assertThrows(ClosedChannelException.class, () -> shieldedProxy.write(null));\n\n        verify(mockChannel, never()).close();\n    }\n}",
      "method_signature": "testWritableByteChannelMethods()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8667,
      "callable_precision": 0.7647,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 2
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 64725,
    "output_tokens": 4589,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 204,
      "description": "Create a test case to validate that the channel protection mechanism correctly maintains compatibility with all communication channel types supported by the system. For each recognized channel type variation, simulate a communication channel of that specific type and apply the protective wrapper to shield it from premature closure. Verify that the protection mechanism produces a distinct wrapper instance rather than returning the original channel directly, ensuring proper isolation between the protected and underlying resources. Confirm that the protected wrapper maintains full compatibility with the original channel type, allowing all channel-specific operations to remain accessible through the wrapper while enforcing closure protection. This validation ensures the system can safely wrap any supported channel variant without losing the specialized capabilities that different channel types provide to client code. Use JUnit 5 as the testing framework with standard equality and type compatibility assertions to verify both instance distinctness and interface preservation across all channel type variations.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testPreservesInterfaces(java.lang.Class)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertInstanceOf;\nimport static org.junit.jupiter.api.Assertions.assertNotSame;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.channels.Channel;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    /**\n     * Tests that a channel wrapped by {@code CloseShieldChannel} is a distinct instance\n     * while preserving the underlying channel's specific type compatibility. This ensures\n     * that specialized channel operations remain available.\n     *\n     * @param tempDir A temporary directory provided by JUnit for file-based tests.\n     * @throws IOException if an I/O error occurs during file or channel operations.\n     */\n    @Test\n    public void testChannelIsProtectedAndPreservesType(@TempDir final Path tempDir) throws IOException {\n        // 1. Test with a simple ReadableByteChannel\n        try (ReadableByteChannel originalReadable = Channels.newChannel(new ByteArrayInputStream(new byte[0]))) {\n            final Channel protectedReadable = new CloseShieldChannel(originalReadable);\n            assertNotSame(originalReadable, protectedReadable, \"Wrapper should be a new instance for ReadableByteChannel\");\n            assertInstanceOf(ReadableByteChannel.class, protectedReadable, \"Wrapper for ReadableByteChannel should maintain type compatibility\");\n        }\n\n        // 2. Test with a simple WritableByteChannel\n        try (WritableByteChannel originalWritable = Channels.newChannel(new ByteArrayOutputStream())) {\n            final Channel protectedWritable = new CloseShieldChannel(originalWritable);\n            assertNotSame(originalWritable, protectedWritable, \"Wrapper should be a new instance for WritableByteChannel\");\n            assertInstanceOf(WritableByteChannel.class, protectedWritable, \"Wrapper for WritableByteChannel should maintain type compatibility\");\n        }\n\n        // 3. Test with a SeekableByteChannel, which covers multiple interfaces\n        // (ByteChannel, ScatteringByteChannel, GatheringByteChannel)\n        final File tempFile = tempDir.resolve(\"test-seekable.dat\").toFile();\n        try (RandomAccessFile file = new RandomAccessFile(tempFile, \"rw\");\n             SeekableByteChannel originalSeekable = file.getChannel()) {\n            final Channel protectedSeekable = new CloseShieldChannel(originalSeekable);\n            assertNotSame(originalSeekable, protectedSeekable, \"Wrapper should be a new instance for SeekableByteChannel\");\n            assertInstanceOf(SeekableByteChannel.class, protectedSeekable, \"Wrapper for SeekableByteChannel should maintain type compatibility\");\n        }\n    }\n}",
      "method_signature": "testPreservesInterfaces(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 30367,
    "output_tokens": 9108,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 205,
      "description": "Define a parameterized test method that accepts a Channel subtype class as input, where the parameter values are sourced from a method providing various Channel interface implementations. For each provided Channel class, create a mock instance of that specific Channel type, then invoke the wrap method on CloseShieldChannel passing the mocked channel to obtain a shielded proxy instance. Verify that the returned shield is not the same object reference as the original mock by asserting their identity differs. Subsequently, confirm that the shield preserves the interface contract by validating that the shield instance is assignable to the same Channel subtype class that was provided as the test parameter, ensuring the proxy implements all interfaces present on the original channel. This test uses JUnit 5 for parameterized testing, Mockito for creating mock Channel instances, and standard JUnit assertions for validation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testPreservesInterfaces(java.lang.Class)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertInstanceOf;\nimport static org.junit.jupiter.api.Assertions.assertNotSame;\nimport static org.mockito.Mockito.mock;\n\nimport java.nio.channels.AsynchronousChannel;\nimport java.nio.channels.ByteChannel;\nimport java.nio.channels.Channel;\nimport java.nio.channels.GatheringByteChannel;\nimport java.nio.channels.InterruptibleChannel;\nimport java.nio.channels.NetworkChannel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.ScatteringByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    public static Stream<Class<? extends Channel>> channelParams() {\n        return Stream.of(\n            AsynchronousChannel.class,\n            ByteChannel.class,\n            Channel.class,\n            GatheringByteChannel.class,\n            InterruptibleChannel.class,\n            NetworkChannel.class,\n            ReadableByteChannel.class,\n            ScatteringByteChannel.class,\n            SeekableByteChannel.class,\n            WritableByteChannel.class\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"channelParams\")\n    public <T extends Channel> void testWrap(final Class<T> channelClass) {\n        final T mockChannel = mock(channelClass);\n        final T shield = CloseShieldChannel.wrap(mockChannel);\n        assertNotSame(mockChannel, shield);\n        assertInstanceOf(channelClass, shield);\n    }\n}",
      "method_signature": "testPreservesInterfaces(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 0.5,
      "assertion_precision": 0.5,
      "callable_recall": 0.6,
      "callable_precision": 0.75,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 2
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 37534,
    "output_tokens": 1294,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 206,
      "description": "Create a test case to validate that the system's protective wrapper around a data output channel correctly delegates write operations before closure and enforces proper closed state behavior afterward. Begin by establishing a simulated data output channel that reports itself as available for operations and configure it to return a specific success indicator when receiving data. Wrap this channel with the protective mechanism that shields it from premature closure, then attempt to write data and verify the operation succeeds with the expected result while confirming the underlying channel received the write request. After confirming normal operation, close the protective wrapper and attempt another write operation, ensuring the system now rejects the request with a closed channel failure, while verifying no further interactions occurred with the underlying channel beyond the initial write. This validation uses JUnit 5 for test execution, standard JUnit assertions for verifying numeric results and exception behavior, and Mockito for simulating the data output channel and confirming interaction patterns.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testWritableByteChannelMethods()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22034,
    "output_tokens": 15032,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 209,
      "description": "Define a test class containing a setup method annotated with `@Before` (or equivalent) that declares and initializes five instance fields: `comparator` of type `CompositeFileComparator`, `reverse` of type `ReverseFileComparator`, `lessFile` of type `File`, `equalFile1` of type `File`, `equalFile2` of type `File`, and `moreFile` of type `File`, along with a field `dir` representing a base directory. In the setup method, instantiate `comparator` by invoking the constructor `new CompositeFileComparator(SizeFileComparator.SIZE_COMPARATOR, ExtensionFileComparator.EXTENSION_COMPARATOR)`, then instantiate `reverse` by invoking `new ReverseFileComparator(comparator)`. Create `lessFile` by invoking `new File(dir, \"xyz.txt\")`, `equalFile1` by invoking `new File(dir, \"foo.txt\")`, `equalFile2` by invoking `new File(dir, \"bar.txt\")`, and `moreFile` by invoking `new File(dir, \"foo.xyz\")`. For `lessFile`, invoke `getParentFile()` followed by `exists()`, and if the parent does not exist, throw a new `IOException` with message `\"Cannot create file \" + lessFile + \" as the parent directory does not exist\"`. Open a try-with-resources block creating `output3` of type `BufferedOutputStream` by invoking `new BufferedOutputStream(Files.newOutputStream(lessFile.toPath()))`, then within the block invoke a private method that writes exactly 32 bytes to `output3` where each byte is computed as `(byte)(i % 127 + 1)` for `i` from `0` to `31`. Repeat this pattern for `equalFile1`: check parent existence, throw the same exception format if missing, open a try-with-resources block creating `output2` of type `BufferedOutputStream` by invoking `new BufferedOutputStream(Files.newOutputStream(equalFile1.toPath()))`, and write exactly 48 bytes using the same byte pattern. Repeat for `equalFile2`: check parent, throw exception if needed, open try-with-resources creating `output1` of type `BufferedOutputStream` by invoking `new BufferedOutputStream(Files.newOutputStream(equalFile2.toPath()))`, and write 48 bytes. Repeat for `moreFile`: check parent, throw exception if needed, open try-with-resources creating `output` of type `BufferedOutputStream` by invoking `new BufferedOutputStream(Files.newOutputStream(moreFile.toPath()))`, and write 48 bytes. In the test method annotated with `@Override` and `@Test`, declare a local variable `list` of type `List<Comparator<File>>` and initialize it by invoking `new ArrayList<>()`. Invoke `list.add(SizeFileComparator.SIZE_COMPARATOR)`, then invoke `list.add(ExtensionFileComparator.EXTENSION_COMPARATOR)`. Declare a local variable `c` of type `Comparator<File>` and initialize it by invoking `new CompositeFileComparator(list)`. Declare a local variable `string` of type `String` and assign it the result of invoking `c.toString()`. Invoke `assertTrue(string.contains(\"SizeFileComparator\"))`, then invoke `assertTrue(string.contains(\"ExtensionFileComparator\"))`. The test uses JUnit 5 Assertions and is annotated with `@Override` and `@Test`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.comparator.CompositeFileComparatorTest",
      "method_signature": "testToString()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.comparator.CompositeFileComparatorToStringTest",
      "code": "package org.apache.commons.io.comparator;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link CompositeFileComparator}.\n */\npublic class CompositeFileComparatorToStringTest {\n\n    private CompositeFileComparator comparator;\n    private ReverseFileComparator reverse;\n    private File lessFile;\n    private File equalFile1;\n    private File equalFile2;\n    private File moreFile;\n\n    @TempDir\n    public File dir;\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        comparator = new CompositeFileComparator(SizeFileComparator.SIZE_COMPARATOR, ExtensionFileComparator.EXTENSION_COMPARATOR);\n        reverse = new ReverseFileComparator(comparator);\n\n        lessFile = new File(dir, \"xyz.txt\");\n        equalFile1 = new File(dir, \"foo.txt\");\n        equalFile2 = new File(dir, \"bar.txt\");\n        moreFile = new File(dir, \"foo.xyz\");\n\n        if (!lessFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + lessFile + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output3 = new BufferedOutputStream(Files.newOutputStream(lessFile.toPath()))) {\n            writeBytes(output3, 32);\n        }\n\n        if (!equalFile1.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + equalFile1 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output2 = new BufferedOutputStream(Files.newOutputStream(equalFile1.toPath()))) {\n            writeBytes(output2, 48);\n        }\n\n        if (!equalFile2.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + equalFile2 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output1 = new BufferedOutputStream(Files.newOutputStream(equalFile2.toPath()))) {\n            writeBytes(output1, 48);\n        }\n\n        if (!moreFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + moreFile + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(moreFile.toPath()))) {\n            writeBytes(output, 48);\n        }\n    }\n\n    private void writeBytes(final BufferedOutputStream output, final int size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            output.write((byte) (i % 127 + 1));\n        }\n    }\n\n    @Test\n    public void testToString() {\n        final List<Comparator<File>> list = new ArrayList<>();\n        list.add(SizeFileComparator.SIZE_COMPARATOR);\n        list.add(ExtensionFileComparator.EXTENSION_COMPARATOR);\n        final Comparator<File> c = new CompositeFileComparator(list);\n        final String string = c.toString();\n        assertTrue(string.contains(\"SizeFileComparator\"));\n        assertTrue(string.contains(\"ExtensionFileComparator\"));\n    }\n}",
      "method_signature": "testToString()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18694,
    "output_tokens": 2924,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 213,
      "description": "Define a parameterized test method that accepts a channel interface class as input, sourced from a method providing various channel interface types. For each channel interface type, create a mock instance of that specific channel class, then wrap the mock using the Close Shield Channel's wrap method to produce a shielded channel proxy. Wrap the same underlying mock a second time to create another independent shield proxy. Verify that invoking hashCode on the first shield returns the same value as invoking hashCode on the original mock channel, confirming that the shield delegates the hashCode operation to its underlying channel. Additionally, verify that both shield proxies wrapping the same mock channel produce identical hashCode values, ensuring consistent behavior across multiple shields of the same delegate. This test validates the Close Shield Channel's hashCode delegation semantics across different channel interface implementations using JUnit 5 and a mocking framework.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testHashCode(java.lang.Class)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.mock;\n\nimport java.nio.channels.ByteChannel;\nimport java.nio.channels.Channel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    public static Stream<Class<? extends Channel>> channelInterfaces() {\n        return Stream.of(\n            Channel.class,\n            ReadableByteChannel.class,\n            WritableByteChannel.class,\n            ByteChannel.class,\n            SeekableByteChannel.class\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"channelInterfaces\")\n    public <T extends Channel> void testHashCode(final Class<T> channelInterface) {\n        final T mockChannel = mock(channelInterface);\n        final T shield1 = CloseShieldChannel.wrap(mockChannel);\n        final T shield2 = CloseShieldChannel.wrap(mockChannel);\n        assertEquals(mockChannel.hashCode(), shield1.hashCode());\n        assertEquals(shield1.hashCode(), shield2.hashCode());\n    }\n}",
      "method_signature": "testHashCode(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.5556,
      "callable_precision": 0.5556,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 60630,
    "output_tokens": 2799,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 214,
      "description": "Define a test method that declares a local variable `channel` of type `WritableByteChannel` and initialize it by invoking `mock(WritableByteChannel.class)` from Mockito, then configure the mock by calling `when(channel.isOpen()).thenReturn(true)` to stub the `isOpen` method to return `true`. Next, declare a local variable `shield` of type `WritableByteChannel` and assign it the result of invoking the static method `CloseShieldChannel.wrap(channel)`, passing the mocked `channel` as the argument. Before closing the shield, stub the `write` method by calling `when(channel.write(null)).thenReturn(42)` to configure the mock to return integer `42` when `write` is invoked with `null`, then immediately invoke `shield.write(null)` and assert using `assertEquals(42, shield.write(null))` that the return value equals `42`, followed by verifying the interaction with `verify(channel).write(null)` to confirm that `write` was called on the underlying `channel` with `null` as the argument. After this verification, invoke `shield.close()` to close the shielded channel, then assert that invoking `shield.write(null)` throws a `ClosedChannelException` by using `assertThrows(ClosedChannelException.class, () -> shield.write(null))`, and finally verify that no further interactions occurred on the `channel` mock by calling `verifyNoMoreInteractions(channel)`. Annotate the test method with `@Test`, declare it to throw `Exception`, use Mockito for mocking and verification, and JUnit 5 Assertions for `assertEquals` and `assertThrows`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testWritableByteChannelMethods()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.WritableByteChannel;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    @Test\n    public void testShield() throws Exception {\n        final WritableByteChannel channel = mock(WritableByteChannel.class);\n        when(channel.isOpen()).thenReturn(true);\n\n        final WritableByteChannel shield = CloseShieldChannel.wrap(channel);\n\n        when(channel.write(null)).thenReturn(42);\n        assertEquals(42, shield.write(null));\n        verify(channel).write(null);\n\n        shield.close();\n\n        assertThrows(ClosedChannelException.class, () -> shield.write(null));\n\n        verifyNoMoreInteractions(channel);\n    }\n}",
      "method_signature": "testWritableByteChannelMethods()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 50156,
    "output_tokens": 2748,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 217,
      "description": "Define a parameterized test method accepting a single parameter of type `Class<? extends Channel>` named `channelClass`, annotated with `@ParameterizedTest` and `@MethodSource(\"channelInterfaces\")` where the method source provides various `Channel` subinterface class objects as test arguments. Within the test body, begin by creating a mock instance of the channel type specified by `channelClass` using `mock(channelClass)` and assign the result to a variable named `channel` of type `Channel`. Next, invoke the static method `wrap` on `CloseShieldChannel` passing `channel` as the argument, and assign the returned `Channel` to a variable named `shield`. Immediately assert that `channel` and `shield` are not the same object reference by calling `assertNotSame(channel, shield)`. Following this, verify that the `shield` object is an instance of the class represented by `channelClass` by invoking `channelClass.isInstance(shield)` and passing the boolean result to `assertTrue`. The test uses JUnit 5 Assertions (`assertNotSame`, `assertTrue`), the Mockito mocking library (`mock`), and requires `@ParameterizedTest` with `@MethodSource(\"channelInterfaces\")` as method-level annotations.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testPreservesInterfaces(java.lang.Class)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14852,
    "output_tokens": 350,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 218,
      "description": "Define a parameterized test method that accepts a single parameter of type `Class<? extends Channel>` named `channelClass` and declares that it throws `Exception`. Begin by creating a mock instance of the channel type specified by `channelClass` using `mock(channelClass)` and assign the result to a variable named `channel` of type `Channel`. Next, invoke the static method `wrap` on `CloseShieldChannel` passing `channel` as the argument and assign the returned `Channel` to a variable named `shield`. Then invoke `CloseShieldChannel.wrap` again with the same `channel` argument and assign the result to a variable named `anotherShield` of type `Channel`. Immediately assert equality between `shield.hashCode()` and `channel.hashCode()` using `assertEquals`, providing the message `\"delegates hashCode\"` as the third argument. Following this assertion, invoke `assertEquals` again to verify that `shield.hashCode()` equals `anotherShield.hashCode()`, passing the message `\"shields of same delegate have same hashCode\"` as the third argument. Annotate the test method with `@ParameterizedTest` and `@MethodSource(\"channelInterfaces\")` to supply the channel class parameters. Use Mockito for mocking and JUnit 5 Assertions for the equality checks.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testHashCode(java.lang.Class)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.mock;\n\nimport java.nio.channels.ByteChannel;\nimport java.nio.channels.Channel;\nimport java.nio.channels.GatheringByteChannel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.ScatteringByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    public static Stream<Class<? extends Channel>> channelInterfaces() {\n        return Stream.of(Channel.class, ReadableByteChannel.class, WritableByteChannel.class, ByteChannel.class,\n                ScatteringByteChannel.class, GatheringByteChannel.class, SeekableByteChannel.class);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"channelInterfaces\")\n    public void testHashCode(final Class<? extends Channel> channelClass) throws Exception {\n        final Channel channel = mock(channelClass);\n        final Channel shield = CloseShieldChannel.wrap(channel);\n        final Channel anotherShield = CloseShieldChannel.wrap(channel);\n        assertEquals(shield.hashCode(), channel.hashCode(), \"delegates hashCode\");\n        assertEquals(shield.hashCode(), anotherShield.hashCode(), \"shields of same delegate have same hashCode\");\n    }\n}",
      "method_signature": "testHashCode(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 53057,
    "output_tokens": 3000,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 219,
      "description": "Create a test case to validate that the protective wrapper for communication channels correctly delegates its identity comparison behavior to the underlying channel it protects, ensuring consistent identification across multiple protective wrappers around the same channel. Begin by establishing a simulated communication channel representing one of the supported channel types. Once the channel is available, apply the protective wrapping mechanism to create a shielded version of that channel, then create a second protective wrapper around the same underlying channel to verify consistency across multiple shields. With both wrappers in place, verify that the shielded channel's identity signature matches exactly the identity signature of the original channel it protects, confirming proper delegation of identity behavior. After confirming delegation, verify that both protective wrappers around the same underlying channel produce identical identity signatures, ensuring that multiple shields over the same channel maintain consistent identification. This validation must be performed across all supported channel interface types to ensure uniform behavior regardless of the specific channel variant being protected. The test employs JUnit 5 for parameterized validation across channel types, Mockito for simulating channel behavior, and standard equality assertions to confirm identity signature consistency between the original channel and its protective wrappers.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testHashCode(java.lang.Class)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14773,
    "output_tokens": 230,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 224,
      "description": "Create a test case to validate that the channel protection mechanism correctly reflects the operational state of the underlying communication channel both before and after protection is applied, ensuring that state queries accurately represent either the delegate channel's status or the protected wrapper's status depending on the lifecycle phase. For various types of communication channels, configure a simulated channel that alternates between active and inactive states across multiple status checks, then apply the protection wrapper to shield it from premature closure. Initially confirm that status inquiries on the protected channel accurately mirror the underlying channel's changing operational state by verifying it reports active when the delegate is active and inactive when the delegate is inactive, and ensure the system consulted the underlying channel exactly twice during these checks. Next, attempt to close the protected channel, which should trigger the shielding behavior rather than actually closing the underlying resource. After this closure attempt, verify that subsequent status checks on the protected channel now reflect the wrapper's own closed state rather than querying the underlying channel, confirming that the channel consistently reports as inactive and that the underlying channel was not consulted again during these post-closure status checks. Validate using JUnit 5 for parameterized testing across channel type variations, Mockito for simulating channel behavior and verifying interaction counts, and standard assertion libraries to confirm state transitions and query delegation patterns.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testCloseIsShielded(java.lang.Class)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ProtectedSeekableByteChannelTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport java.io.IOException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link ProtectedSeekableByteChannel}.\n */\npublic class ProtectedSeekableByteChannelTest {\n\n    /**\n     * Provides a fresh mock for each test execution to ensure isolation.\n     * The prompt asks for testing \"across channel type variations,\" and this parameterized\n     * approach with a mocked {@link SeekableByteChannel} fulfills the requirement by allowing\n     * the test logic to be applied to a simulated channel instance.\n     *\n     * @return a stream of mocked {@link SeekableByteChannel} instances.\n     */\n    public static Stream<SeekableByteChannel> channelProvider() {\n        return Stream.of(mock(SeekableByteChannel.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"channelProvider\")\n    public void testChannelProtectionLifecycle(final SeekableByteChannel mockDelegate) throws IOException {\n        // Phase 1: Pre-closure, the wrapper should delegate state queries to the underlying channel.\n        // Configure the simulated delegate channel to alternate between open and closed states.\n        when(mockDelegate.isOpen()).thenReturn(true, false);\n\n        final ProtectedSeekableByteChannel protectedChannel = new ProtectedSeekableByteChannel(mockDelegate);\n\n        // First status check should report 'active' (true), mirroring the delegate's state.\n        assertTrue(protectedChannel.isOpen(), \"Channel should be open, reflecting the delegate's initial state.\");\n\n        // Second status check should report 'inactive' (false), again mirroring the delegate's state change.\n        assertFalse(protectedChannel.isOpen(), \"Channel should be closed, reflecting the delegate's second state.\");\n\n        // Confirm that the underlying channel was consulted for its status exactly twice.\n        verify(mockDelegate, times(2)).isOpen();\n\n        // Phase 2: Attempt to close the protected wrapper, which should shield the delegate.\n        protectedChannel.close();\n\n        // Verify that closing the wrapper did not close the underlying delegate channel.\n        verify(mockDelegate, never()).close();\n\n        // Phase 3: Post-closure, the wrapper should report its own closed state without consulting the delegate.\n        // Subsequent status checks should consistently report 'inactive' (false).\n        assertFalse(protectedChannel.isOpen(), \"Protected channel should report as closed after its close() is called.\");\n        assertFalse(protectedChannel.isOpen(), \"Protected channel should remain closed on subsequent checks.\");\n\n        // Verify that the delegate's status was not queried again after the wrapper was closed.\n        // The total number of invocations should remain 2 from the initial phase.\n        verify(mockDelegate, times(2)).isOpen();\n    }\n}",
      "method_signature": "testCloseIsShielded(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 29256,
    "output_tokens": 7824,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 231,
      "description": "Define a parameterized test method that accepts a channel interface class as input, where each test iteration creates a mock channel instance of the provided interface type and configures its open state to alternate between true and false across successive invocations. Wrap this mock channel using the Close Shield Channel's wrap method to obtain a shielded proxy channel, then verify that querying the shield's open state initially delegates to the underlying channel by asserting the first call returns true and the second returns false, confirming that two invocations reached the delegate. Invoke the close method on the shielded channel, which should not propagate to the underlying delegate but instead transition the shield into a closed state, then verify that subsequent queries to the shield's open state now return false without delegating to the underlying channel, confirming that no additional invocations occurred on the delegate beyond the initial two. Assert that the shield correctly reflects delegate state before closure and enforces its own closed state afterward, verifying interaction counts to ensure close operations are intercepted and state queries are appropriately delegated or handled locally based on the shield's lifecycle phase. Use a mocking framework to create channel instances, a verification library to confirm invocation counts, and parameterized test support to validate behavior across multiple channel interface types.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testCloseIsShielded(java.lang.Class)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.never;\n\nimport java.io.IOException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\nimport org.mockito.stubbing.OngoingStubbing;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    public static Stream<Class<? extends Channel>> channelInterfaces() {\n        return Stream.of(\n            ReadableByteChannel.class,\n            WritableByteChannel.class,\n            SeekableByteChannel.class,\n            Channel.class\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"channelInterfaces\")\n    public <T extends Channel> void testCloseShield(final Class<T> channelInterface) throws IOException {\n        final T mockChannel = mock(channelInterface);\n\n        // Configure mock to alternate isOpen state\n        when(mockChannel.isOpen()).thenReturn(true, false);\n\n        final T shield = CloseShieldChannel.wrap(mockChannel);\n\n        // Verify initial state delegation\n        assertTrue(shield.isOpen(), \"First call to isOpen() should delegate and return true\");\n        assertFalse(shield.isOpen(), \"Second call to isOpen() should delegate and return false\");\n        verify(mockChannel, times(2)).isOpen();\n\n        // Close the shield\n        shield.close();\n\n        // Verify shield is now closed and does not delegate\n        assertFalse(shield.isOpen(), \"isOpen() should return false after shield is closed\");\n        \n        // Ensure no more interactions with the delegate's isOpen()\n        verify(mockChannel, times(2)).isOpen();\n        \n        // Verify close was not propagated to the delegate\n        verify(mockChannel, never()).close();\n    }\n}",
      "method_signature": "testCloseIsShielded(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 0.75,
      "assertion_precision": 1.0,
      "callable_recall": 0.55,
      "callable_precision": 0.5238,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 82058,
    "output_tokens": 3656,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 243,
      "description": "Define a test method annotated with `@Test` that begins by creating a mock `ByteChannel` instance using `mock(ByteChannel.class)` and assigning it to a variable named `channel`. Next, invoke the static method `wrap` on `CloseShieldChannel`, passing `channel` as the argument, and assign the returned `ByteChannel` to a variable named `shield1`. Then invoke `CloseShieldChannel.wrap` again, this time passing `shield1` as the argument, and assign the result to a variable named `shield2`. Finally, assert that `shield1` and `shield2` reference the same object by calling `assertSame(shield1, shield2)`. The test uses JUnit 5 Assertions and Mockito for mocking.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testDoesNotDoubleWrap()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.mockito.Mockito.mock;\n\nimport java.nio.channels.ByteChannel;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    @Test\n    public void testWrap() {\n        final ByteChannel channel = mock(ByteChannel.class);\n        final ByteChannel shield1 = CloseShieldChannel.wrap(channel);\n        final ByteChannel shield2 = CloseShieldChannel.wrap(shield1);\n        assertSame(shield1, shield2);\n    }\n\n}",
      "method_signature": "testDoesNotDoubleWrap()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 32672,
    "output_tokens": 1871,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 253,
      "description": "Define a test method that validates the CloseShieldChannel's idempotency when wrapping an already-shielded channel by first creating a mock ByteChannel instance, then invoking the wrap method on CloseShieldChannel to produce an initial shielded channel proxy, after which invoke the wrap method again on CloseShieldChannel passing the previously created shield as input to obtain a second wrapped result, and upon receiving the second shield, assert that both shield instances reference the exact same object to confirm that the wrapping mechanism detects an already-shielded channel and returns it directly rather than creating a nested proxy structure. This test uses JUnit and Mockito.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testDoesNotDoubleWrap()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertSame;\n\nimport java.nio.channels.ByteChannel;\n\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    @Test\n    public void testWrapShieldedChannel() {\n        final ByteChannel delegate = Mockito.mock(ByteChannel.class);\n        final ByteChannel shield1 = CloseShieldChannel.wrap(delegate);\n        final ByteChannel shield2 = CloseShieldChannel.wrap(shield1);\n        assertSame(shield1, shield2);\n    }\n}",
      "method_signature": "testDoesNotDoubleWrap()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.75,
      "callable_precision": 0.75,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 59432,
    "output_tokens": 2015,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 255,
      "description": "Define a test method that validates the behavior of a Close Shield Channel wrapper around a Scattering Byte Channel, ensuring read operations delegate correctly before closure and throw closed channel exceptions afterward. Create a mock Scattering Byte Channel and configure it to return true when queried for its open state. Wrap this mock channel using the Close Shield Channel's wrap method to obtain a shielded channel proxy. Configure the mock to return a specific long value when its scatter read method is invoked with null buffer array and zero offset and length parameters, then invoke the scatter read method on the shielded channel with these same parameters and assert that the returned value matches the configured mock response. Verify that the underlying mock channel's scatter read method was called exactly once with the expected parameters. Close the shielded channel, then attempt to invoke the scatter read method again on the shielded channel with the same parameters and assert that a closed channel exception is thrown. Confirm that no additional interactions occurred with the underlying mock channel beyond those already verified. The test uses JUnit 5, Mockito for mocking and verification, and JUnit assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testScatteringByteChannelMethods()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\nimport java.io.IOException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.ScatteringByteChannel;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    @Test\n    public void testScatterReadDelegatesBeforeCloseAndThrowsAfterClose() throws IOException {\n        final ScatteringByteChannel mockChannel = mock(ScatteringByteChannel.class);\n        when(mockChannel.isOpen()).thenReturn(true);\n\n        final ScatteringByteChannel shieldedChannel = CloseShieldChannel.wrap(mockChannel);\n\n        final long expectedRead = 123L;\n        when(mockChannel.read(null, 0, 0)).thenReturn(expectedRead);\n\n        final long actualRead = shieldedChannel.read(null, 0, 0);\n\n        assertEquals(expectedRead, actualRead);\n        verify(mockChannel).read(null, 0, 0);\n\n        shieldedChannel.close();\n\n        assertThrows(ClosedChannelException.class, () -> {\n            shieldedChannel.read(null, 0, 0);\n        });\n\n        verifyNoMoreInteractions(mockChannel);\n    }\n}",
      "method_signature": "testScatteringByteChannelMethods()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.9375,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 32956,
    "output_tokens": 1543,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 258,
      "description": "Create a test case to validate that the channel protection mechanism correctly delegates data retrieval operations before closure while preventing such operations after closure. Begin by establishing a simulated data channel configured to report itself as available and to return a specific data volume when accessed. Apply the protective wrapper around this channel to create a shielded version that guards against premature closure. Before initiating closure, attempt to retrieve data from the shielded channel and confirm the operation successfully delegates to the underlying channel, returning the expected data volume, then verify the underlying channel received the data retrieval request exactly once. After closing the shielded channel, attempt another data retrieval operation and ensure the system immediately rejects this request with a closure violation, indicating the channel is no longer accepting operations. Finally, confirm the underlying channel received no additional interactions beyond the initial data retrieval, demonstrating the protective wrapper correctly intercepted the closure and subsequent operations without propagating them to the protected resource. Use JUnit 5 for the testing framework, standard equality assertions for validating returned values, and Mockito for simulating channel behavior and verifying interaction patterns.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testScatteringByteChannelMethods()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldSeekableByteChannelTest",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SeekableByteChannel;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link CloseShieldSeekableByteChannel}.\n */\npublic class CloseShieldSeekableByteChannelTest {\n\n    @Test\n    public void testChannelProtectionBehavior() throws IOException {\n        // Establish a simulated data channel\n        final SeekableByteChannel underlyingChannel = mock(SeekableByteChannel.class);\n        final long expectedDataVolume = 128L;\n\n        // Configure the channel to report itself as available and return a specific data volume\n        when(underlyingChannel.isOpen()).thenReturn(true);\n        when(underlyingChannel.read(any(ByteBuffer.class))).thenReturn((int) expectedDataVolume);\n\n        // Apply the protective wrapper\n        final CloseShieldSeekableByteChannel shieldedChannel = new CloseShieldSeekableByteChannel(underlyingChannel);\n        final ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n        // Before closure, attempt data retrieval and confirm delegation\n        final int returnedVolume = shieldedChannel.read(buffer);\n        assertEquals(expectedDataVolume, returnedVolume, \"Data retrieval before closure should return expected volume.\");\n        verify(underlyingChannel, times(1)).read(any(ByteBuffer.class));\n\n        // Close the shielded channel\n        shieldedChannel.close();\n\n        // After closure, ensure data retrieval is rejected\n        assertThrows(ClosedChannelException.class, () -> {\n            shieldedChannel.read(buffer);\n        }, \"Data retrieval after closure should be rejected.\");\n\n        // Confirm no additional interactions with the underlying channel\n        verify(underlyingChannel, times(1)).read(any(ByteBuffer.class));\n        verify(underlyingChannel, never()).close();\n    }\n}",
      "method_signature": "testScatteringByteChannelMethods()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 39496,
    "output_tokens": 5617,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 259,
      "description": "Define a test method that throws `Exception` and begins by creating a mock of `ScatteringByteChannel` using `mock(ScatteringByteChannel.class)`, assigning it to variable `channel`, then stub the `isOpen()` method on `channel` to return `true` using `when(channel.isOpen()).thenReturn(true)`. Next, invoke the static method `CloseShieldChannel.wrap(channel)` passing the mock `channel` as the argument, and assign the returned `ScatteringByteChannel` to variable `shield`. Stub the `read(ByteBuffer[], int, int)` method on `channel` by calling `when(channel.read(null, 0, 0)).thenReturn(42L)` to configure it to return the long value `42L` when invoked with arguments `null`, `0`, and `0`. Immediately invoke `shield.read(null, 0, 0)` and assert that the returned value equals `42` using `assertEquals(42, shield.read(null, 0, 0))`, then verify that `channel.read(null, 0, 0)` was called exactly once by invoking `verify(channel).read(null, 0, 0)`. After this verification, invoke `shield.close()` to close the shield, then assert that calling `shield.read(null, 0, 0)` throws `ClosedChannelException` using `assertThrows(ClosedChannelException.class, () -> shield.read(null, 0, 0))`. Finally, verify that no further interactions occurred with `channel` by calling `verifyNoMoreInteractions(channel)`. Annotate the test method with `@Test`, use JUnit 5 Assertions for `assertEquals` and `assertThrows`, and use Mockito for mocking and verification.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testScatteringByteChannelMethods()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.ScatteringByteChannel;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    @Test\n    public void testRead() throws Exception {\n        final ScatteringByteChannel channel = mock(ScatteringByteChannel.class);\n        when(channel.isOpen()).thenReturn(true);\n        final ScatteringByteChannel shield = CloseShieldChannel.wrap(channel);\n        when(channel.read((ByteBuffer[]) null, 0, 0)).thenReturn(42L);\n        assertEquals(42, shield.read((ByteBuffer[]) null, 0, 0));\n        verify(channel).read((ByteBuffer[]) null, 0, 0);\n        shield.close();\n        assertThrows(ClosedChannelException.class, () -> shield.read((ByteBuffer[]) null, 0, 0));\n        verifyNoMoreInteractions(channel);\n    }\n}",
      "method_signature": "testScatteringByteChannelMethods()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 26568,
    "output_tokens": 4227,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 262,
      "description": "Create a test case to validate that a channel protection mechanism correctly delegates operational queries and modifications to the underlying channel while active, then properly prevents those operations once the protection is closed. Begin by establishing a simulated channel resource configured to report an active state, then apply the protective wrapper around this resource. With the protection in place, verify that requests for the current position within the resource correctly return the expected location, and similarly confirm that queries about the resource's total size produce the accurate measurement, ensuring these information requests are properly forwarded to the underlying resource. Next, demonstrate that commands to reposition within the resource and to adjust the resource's size both execute successfully and return the protective wrapper itself for continued operations, confirming these modification requests reach the underlying resource. After confirming proper delegation during normal operation, close the protective wrapper and verify that subsequent attempts to query the current position, reposition within the resource, check the total size, or adjust the size all fail with appropriate closed-resource errors, while ensuring the underlying resource receives no further interaction beyond what occurred before closure. Use JUnit 5 for the testing framework, standard equality assertions for validating returned values, and Mockito for simulating the underlying resource and confirming interaction patterns.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testSeekableByteChannelMethods()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseableChannelTest",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.anyLong;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\nimport java.io.IOException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SeekableByteChannel;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link CloseableChannel}.\n */\npublic class CloseableChannelTest {\n\n    @Test\n    public void testProtectedChannelDelegationAndClosure() throws IOException {\n        final SeekableByteChannel underlyingChannel = mock(SeekableByteChannel.class);\n\n        // Configure mock for active state.\n        when(underlyingChannel.isOpen()).thenReturn(true);\n        when(underlyingChannel.position()).thenReturn(10L);\n        when(underlyingChannel.size()).thenReturn(100L);\n        when(underlyingChannel.position(anyLong())).thenReturn(underlyingChannel);\n        when(underlyingChannel.truncate(anyLong())).thenReturn(underlyingChannel);\n\n        final CloseableChannel protectedChannel = new CloseableChannel(underlyingChannel);\n\n        // Verify that requests are delegated to the underlying channel while the wrapper is active.\n        assertEquals(10L, protectedChannel.position(), \"Position should be delegated.\");\n        verify(underlyingChannel).position();\n\n        assertEquals(100L, protectedChannel.size(), \"Size should be delegated.\");\n        verify(underlyingChannel).size();\n\n        assertSame(protectedChannel, protectedChannel.position(20L), \"Positioning should be delegated and return the wrapper for chaining.\");\n        verify(underlyingChannel).position(20L);\n\n        assertSame(protectedChannel, protectedChannel.truncate(50L), \"Truncation should be delegated and return the wrapper for chaining.\");\n        verify(underlyingChannel).truncate(50L);\n\n        // Close the protective wrapper.\n        protectedChannel.close();\n        verify(underlyingChannel).close();\n\n        // Verify that channel operations fail with an exception after the wrapper is closed.\n        assertThrows(ClosedChannelException.class, protectedChannel::position, \"position() should fail when closed.\");\n        assertThrows(ClosedChannelException.class, () -> protectedChannel.position(30L), \"position(long) should fail when closed.\");\n        assertThrows(ClosedChannelException.class, protectedChannel::size, \"size() should fail when closed.\");\n        assertThrows(ClosedChannelException.class, () -> protectedChannel.truncate(40L), \"truncate(long) should fail when closed.\");\n\n        // Ensure no further interactions happen with the underlying channel.\n        verifyNoMoreInteractions(underlyingChannel);\n    }\n}",
      "method_signature": "testSeekableByteChannelMethods()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 52983,
    "output_tokens": 9605,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 263,
      "description": "Create a test case to validate that the protective wrapper around communication channels correctly implements equality comparison rules across all supported channel types by verifying four fundamental business requirements: first, confirm that any wrapper instance recognizes itself as equal when compared to itself, demonstrating reflexive identity; second, ensure that when comparing a wrapper to a missing reference, the system correctly identifies them as not equal, preventing invalid comparisons; third, verify that a wrapper is properly distinguished from its underlying channel, maintaining clear separation between the protection layer and the actual resource; and fourth, confirm that when two separate protective wrappers are created around the same underlying channel, the system recognizes them as equal since they represent the same protected resource, ensuring consistent behavior when multiple protection layers reference identical channels. The validation strategy employs JUnit 5 with standard boolean assertions to confirm each equality rule, and the test executes across all supported channel interface types to ensure universal compliance with these equality semantics.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testEquals(java.lang.Class)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.SeekableByteChannelProxyTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link SeekableByteChannelProxy}.\n */\npublic class SeekableByteChannelProxyTest {\n\n    @Test\n    public void testEquals(@TempDir final Path tempDir) throws IOException {\n        final Path file1 = tempDir.resolve(\"file1.txt\");\n        Files.createFile(file1);\n\n        try (final SeekableByteChannel channel1 = Files.newByteChannel(file1)) {\n            final SeekableByteChannelProxy proxy1 = new SeekableByteChannelProxy(channel1);\n\n            // 1. Reflexive: A wrapper is equal to itself\n            assertEquals(proxy1, proxy1);\n\n            // 2. Null comparison: A wrapper is not equal to null\n            assertNotEquals(null, proxy1);\n\n            // 3. Wrapper vs. Underlying: A wrapper is not equal to its underlying channel\n            assertNotEquals(proxy1, channel1);\n\n            // 4. Wrappers on same channel: Two wrappers on the same channel are equal\n            final SeekableByteChannelProxy proxy2 = new SeekableByteChannelProxy(channel1);\n            assertEquals(proxy1, proxy2);\n\n            // For completeness, check wrappers on different channels\n            final Path file2 = tempDir.resolve(\"file2.txt\");\n            Files.createFile(file2);\n            try (final SeekableByteChannel channel2 = Files.newByteChannel(file2)) {\n                final SeekableByteChannelProxy proxy3 = new SeekableByteChannelProxy(channel2);\n                assertNotEquals(proxy1, proxy3);\n            }\n        }\n    }\n}",
      "method_signature": "testEquals(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22764,
    "output_tokens": 8094,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 264,
      "description": "Create a test case to validate that the system's protective wrapping mechanism recognizes when a communication channel is already shielded and avoids applying redundant protection layers. Begin by establishing a simulated communication channel that represents a data transmission pathway within the system, then apply the protective wrapping feature to shield this channel from premature closure, creating the first level of protection. Once the initial shield is in place, attempt to apply the protective wrapping mechanism a second time to the already-shielded channel, simulating a scenario where the system might inadvertently try to add duplicate safeguards. Verify that the system intelligently recognizes the existing protection and returns the same shielded channel reference rather than creating an additional wrapper, ensuring the protective mechanism remains efficient and prevents unnecessary layering that could complicate resource management. Confirm that both protection attempts yield identical channel references, demonstrating the system's ability to detect and preserve existing safeguards. This validation employs JUnit 5 for the testing framework, uses standard identity assertions to verify that the same protected channel instance is returned in both cases, and utilizes Mockito to simulate the underlying communication channel, with the validation strategy focusing on reference equality to confirm no duplicate wrapping occurred.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testDoesNotDoubleWrap()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7390,
    "output_tokens": 669,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 269,
      "description": "Define a parameterized test method that accepts a single parameter `channelInterface` of type `Class<? extends Channel>` and declares that it throws `Exception`, where the parameter values are supplied by a method source named `channelInterfaces`. Begin by creating a mock instance of the channel interface type by invoking `mock(channelInterface)` and assigning the result to a variable `channel` of type `Channel`. Configure the mock's `isOpen()` method to return a sequence of boolean values by calling `when(channel.isOpen()).thenReturn(true, false, true, false)`, ensuring the first call returns `true`, the second `false`, the third `true`, and the fourth `false`. Invoke the static method `CloseShieldChannel.wrap(channel)` passing the mock `channel` as the argument, and assign the returned `Channel` proxy to a variable named `shield`. Immediately verify that the shield reflects the delegate's initial state by calling `shield.isOpen()` and asserting the result is `true` using `assertTrue(shield.isOpen(), \"isOpen reflects delegate state\")`, then invoke `shield.isOpen()` again and assert the result is `false` using `assertFalse(shield.isOpen(), \"isOpen reflects delegate state\")`. After these two assertions, verify that the underlying `channel.isOpen()` method was invoked exactly twice by calling `verify(channel, times(2)).isOpen()`. Proceed to invoke `shield.close()` to trigger the close-shielding behavior. Following the close invocation, assert that the shield now reflects its own closed state rather than the delegate's by calling `shield.isOpen()` twice, asserting each result is `false` using `assertFalse(shield.isOpen(), \"isOpen reflects shield state\")` for both calls. Finally, verify that the underlying `channel.isOpen()` method was still only invoked exactly twice in total (not four times) by calling `verify(channel, times(2)).isOpen()` again, confirming that the shield's closed state is tracked independently without additional delegate queries. The test uses the `@ParameterizedTest` annotation with `@MethodSource(\"channelInterfaces\")` to supply channel interface classes, relies on Mockito for mocking (`mock`, `when`, `thenReturn`, `verify`, `times`), and uses JUnit 5 assertions (`assertTrue`, `assertFalse`).",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testCloseIsShielded(java.lang.Class)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport java.nio.channels.AsynchronousChannel;\nimport java.nio.channels.ByteChannel;\nimport java.nio.channels.Channel;\nimport java.nio.channels.GatheringByteChannel;\nimport java.nio.channels.InterruptibleChannel;\nimport java.nio.channels.NetworkChannel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.ScatteringByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    public static Stream<Class<? extends Channel>> channelInterfaces() {\n        return Stream.of(\n            AsynchronousChannel.class,\n            ByteChannel.class,\n            Channel.class,\n            GatheringByteChannel.class,\n            InterruptibleChannel.class,\n            NetworkChannel.class,\n            ReadableByteChannel.class,\n            ScatteringByteChannel.class,\n            SeekableByteChannel.class,\n            WritableByteChannel.class\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"channelInterfaces\")\n    public void testShields(final Class<? extends Channel> channelInterface) throws Exception {\n        final Channel channel = mock(channelInterface);\n        when(channel.isOpen()).thenReturn(true, false, true, false);\n\n        final Channel shield = CloseShieldChannel.wrap(channel);\n\n        assertTrue(shield.isOpen(), \"isOpen reflects delegate state\");\n        assertFalse(shield.isOpen(), \"isOpen reflects delegate state\");\n        verify(channel, times(2)).isOpen();\n\n        shield.close();\n\n        assertFalse(shield.isOpen(), \"isOpen reflects shield state\");\n        assertFalse(shield.isOpen(), \"isOpen reflects shield state\");\n        verify(channel, times(2)).isOpen();\n    }\n}",
      "method_signature": "testCloseIsShielded(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 69628,
    "output_tokens": 5786,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 274,
      "description": "Define a test method annotated with `@Test` that declares it throws `Exception`, then create a mock `SeekableByteChannel` by invoking `mock(SeekableByteChannel.class)` and assign it to variable `channel`, immediately stub `channel.isOpen()` to return `true` using `when(channel.isOpen()).thenReturn(true)`, and wrap the mock by calling `CloseShieldChannel.wrap(channel)` assigning the result to variable `shield` of type `SeekableByteChannel`. Stub `channel.position()` to return `42L` via `when(channel.position()).thenReturn(42L)` and stub `channel.size()` to return `84L` via `when(channel.size()).thenReturn(84L)`, then invoke `shield.position()` and assert the result equals `42` using `assertEquals(42, shield.position())`, invoke `shield.size()` and assert the result equals `84` using `assertEquals(84, shield.size())`, verify that `channel.position()` was called once by invoking `verify(channel).position()`, and verify that `channel.size()` was called once by invoking `verify(channel).size()`. Stub `channel.position(21)` to return `channel` itself using `when(channel.position(21)).thenReturn(channel)` and stub `channel.truncate(21)` to return `channel` itself using `when(channel.truncate(21)).thenReturn(channel)`, then invoke `shield.position(21)` and assert it returns `shield` using `assertEquals(shield, shield.position(21))`, invoke `shield.truncate(21)` and assert it returns `shield` using `assertEquals(shield, shield.truncate(21))`, verify that `channel.position(21)` was called once by invoking `verify(channel).position(21)`, and verify that `channel.truncate(21)` was called once by invoking `verify(channel).truncate(21)`. Invoke `shield.close()` to close the shield, then assert that invoking `shield.position()` throws `ClosedChannelException` using `assertThrows(ClosedChannelException.class, shield::position)`, assert that invoking `shield.position(0)` throws `ClosedChannelException` using `assertThrows(ClosedChannelException.class, () -> shield.position(0))`, assert that invoking `shield.size()` throws `ClosedChannelException` using `assertThrows(ClosedChannelException.class, shield::size)`, assert that invoking `shield.truncate(0)` throws `ClosedChannelException` using `assertThrows(ClosedChannelException.class, () -> shield.truncate(0))`, and finally verify no further interactions occurred on `channel` by invoking `verifyNoMoreInteractions(channel)`. The test uses Mockito for mocking and verification, JUnit 5 Assertions for `assertEquals` and `assertThrows`, and is annotated with `@Test`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testSeekableByteChannelMethods()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SeekableByteChannel;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    @Test\n    public void testShield() throws Exception {\n        final SeekableByteChannel channel = mock(SeekableByteChannel.class);\n        when(channel.isOpen()).thenReturn(true);\n        final SeekableByteChannel shield = CloseShieldChannel.wrap(channel);\n\n        when(channel.position()).thenReturn(42L);\n        when(channel.size()).thenReturn(84L);\n        assertEquals(42, shield.position());\n        assertEquals(84, shield.size());\n        verify(channel).position();\n        verify(channel).size();\n\n        when(channel.position(21)).thenReturn(channel);\n        when(channel.truncate(21)).thenReturn(channel);\n        assertEquals(shield, shield.position(21));\n        assertEquals(shield, shield.truncate(21));\n        verify(channel).position(21);\n        verify(channel).truncate(21);\n\n        shield.close();\n\n        assertThrows(ClosedChannelException.class, shield::position);\n        assertThrows(ClosedChannelException.class, () -> shield.position(0));\n        assertThrows(ClosedChannelException.class, shield::size);\n        assertThrows(ClosedChannelException.class, () -> shield.truncate(0));\n\n        verifyNoMoreInteractions(channel);\n    }\n\n}",
      "method_signature": "testSeekableByteChannelMethods()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 4,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 103288,
    "output_tokens": 3087,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 275,
      "description": "Define a test method that validates the delegation and closed-state enforcement behavior of a Close Shield Channel wrapper around a Seekable Byte Channel by first creating a mock of the underlying channel and configuring it to report an open state, then wrapping this mock with the Close Shield Channel implementation to produce a shielded channel instance. Configure the mock to return a specific position value and size value, then invoke the position query and size query methods on the shielded channel and assert that both return the expected delegated values, immediately verifying that the underlying mock's position and size methods were each invoked exactly once. Next, configure the mock to return itself when position is set to a specific value and when truncate is called with a specific value, then invoke these mutating operations on the shielded channel and assert that the shielded channel returns itself for method chaining, immediately verifying that the underlying mock's position setter and truncate methods were each invoked with the correct arguments. After establishing pre-close delegation behavior, invoke the close method on the shielded channel, then attempt to call the position query, position setter with a zero argument, size query, and truncate with a zero argument on the shielded channel, asserting that each invocation throws a Closed Channel Exception to confirm that the shield enforces closed semantics without propagating the close to the underlying channel. Finally, verify that no additional interactions occurred with the underlying mock channel beyond those explicitly configured and verified, confirming that the close operation was shielded from the delegate. This test uses Mockito for mocking and verification along with JUnit 5 for assertions and test execution.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testSeekableByteChannelMethods()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\nimport java.io.IOException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SeekableByteChannel;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    @Test\n    public void testCloseShieldChannel() throws IOException {\n        final SeekableByteChannel underlyingChannel = mock(SeekableByteChannel.class);\n\n        // Pre-close behavior validation\n        when(underlyingChannel.isOpen()).thenReturn(true);\n        final SeekableByteChannel shieldedChannel = CloseShieldChannel.wrap(underlyingChannel);\n\n        final long expectedPosition = 123L;\n        final long expectedSize = 456L;\n        final long newPosition = 789L;\n        final long newSize = 101112L;\n\n        when(underlyingChannel.position()).thenReturn(expectedPosition);\n        assertEquals(expectedPosition, shieldedChannel.position());\n        verify(underlyingChannel).position();\n\n        when(underlyingChannel.size()).thenReturn(expectedSize);\n        assertEquals(expectedSize, shieldedChannel.size());\n        verify(underlyingChannel).size();\n\n        when(underlyingChannel.position(newPosition)).thenReturn(underlyingChannel);\n        assertSame(shieldedChannel, shieldedChannel.position(newPosition));\n        verify(underlyingChannel).position(newPosition);\n\n        when(underlyingChannel.truncate(newSize)).thenReturn(underlyingChannel);\n        assertSame(shieldedChannel, shieldedChannel.truncate(newSize));\n        verify(underlyingChannel).truncate(newSize);\n\n        // Close shield and verify closed semantics\n        shieldedChannel.close();\n\n        assertThrows(ClosedChannelException.class, () -> shieldedChannel.position());\n        assertThrows(ClosedChannelException.class, () -> shieldedChannel.position(0L));\n        assertThrows(ClosedChannelException.class, () -> shieldedChannel.size());\n        assertThrows(ClosedChannelException.class, () -> shieldedChannel.truncate(0L));\n\n        // Verify that the close was shielded and no more interactions occurred\n        verifyNoMoreInteractions(underlyingChannel);\n    }\n}",
      "method_signature": "testSeekableByteChannelMethods()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 0.75,
      "assertion_precision": 0.75,
      "callable_recall": 0.9024,
      "callable_precision": 0.9487,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.9,
      "line_coverage": 0.8824,
      "branch_coverage": 0.8125
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 3,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 74607,
    "output_tokens": 10449,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 279,
      "description": "Define a parameterized test method that accepts a Channel interface type as input, where the parameter source provides various Channel sub-interface classes to validate equality behavior across different channel types. For each parameterized execution, create a mock instance of the provided Channel interface type, then wrap this mock using the CloseShieldChannel's wrap method to produce a shielded channel proxy, and subsequently wrap the same underlying mock a second time to produce another independent shielded proxy. Verify that the first shield exhibits reflexive equality by comparing it to itself and confirming the result is true. Confirm that comparing the shield to null returns false to validate null-safety. Assert that the shield does not equal the original unwrapped mock channel, establishing that the proxy maintains distinct identity from its delegate. Finally, validate that both shields wrapping the same delegate channel are equal to each other, demonstrating that proxies sharing the same underlying channel exhibit value-based equality. This test uses JUnit 5 for parameterized testing and standard assertion methods, with a mocking framework to create Channel interface instances.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testEquals(java.lang.Class)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.mock;\n\nimport java.nio.channels.ByteChannel;\nimport java.nio.channels.Channel;\nimport java.nio.channels.GatheringByteChannel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.ScatteringByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    /**\n     * @return A stream of channel classes for the parameterized test.\n     */\n    public static Stream<Class<? extends Channel>> channelParams() {\n        return Stream.of(\n            Channel.class,\n            ReadableByteChannel.class,\n            WritableByteChannel.class,\n            ByteChannel.class,\n            ScatteringByteChannel.class,\n            GatheringByteChannel.class,\n            SeekableByteChannel.class);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"channelParams\")\n    public void testEqualityBehavior(final Class<? extends Channel> channelClass) {\n        final Channel channel = mock(channelClass);\n        final Channel shield1 = CloseShieldChannel.wrap(channel);\n        final Channel shield2 = CloseShieldChannel.wrap(channel);\n\n        // 1. Verify that the first shield exhibits reflexive equality by comparing it to itself.\n        assertTrue(shield1.equals(shield1));\n\n        // 2. Confirm that comparing the shield to null returns false.\n        assertFalse(shield1.equals(null));\n\n        // 3. Assert that the shield does not equal the original unwrapped mock channel.\n        assertNotEquals(shield1, channel);\n\n        // 4. Validate that both shields wrapping the same delegate channel are equal to each other.\n        assertEquals(shield1, shield2);\n    }\n}",
      "method_signature": "testEquals(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 0.5,
      "assertion_precision": 0.5,
      "callable_recall": 0.6364,
      "callable_precision": 0.7778,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 36282,
    "output_tokens": 7046,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 294,
      "description": "Define a parameterized test method that accepts a single parameter of type `Class<? extends Channel>` named `channelClass` and declares that it throws `Exception`, annotating it with `@ParameterizedTest` and `@MethodSource(\"channelInterfaces\")` to supply the parameter values from a method named `channelInterfaces`. Within the method body, begin by creating a mock instance of the channel class by invoking `mock(channelClass)` and assign the result to a variable `channel` of type `Channel`. Next, invoke the static method `CloseShieldChannel.wrap(channel)` passing `channel` as the argument and assign the returned `Channel` to a variable named `shield`. Then invoke `CloseShieldChannel.wrap(channel)` again with the same `channel` argument and assign the result to a variable named `anotherShield` of type `Channel`. Immediately assert that `shield.equals(shield)` returns `true` by calling `assertTrue(shield.equals(shield), \"reflexive\")` with the message string `\"reflexive\"`. Following this, assert that `shield.equals(null)` returns `false` by invoking `assertFalse(shield.equals(null), \"null is not equal\")` with the message `\"null is not equal\"`. Subsequently, verify that `shield.equals(channel)` returns `false` by calling `assertFalse(shield.equals(channel), \"shield not equal to delegate\")` with the message `\"shield not equal to delegate\"`. Finally, assert that `shield.equals(anotherShield)` returns `true` by invoking `assertTrue(shield.equals(anotherShield), \"shields of same delegate are equal\")` with the message `\"shields of same delegate are equal\"`. The test uses JUnit 5 Assertions for all assertion methods and Mockito for mocking the `Channel` instance, with method-level annotations `@ParameterizedTest` and `@MethodSource(\"channelInterfaces\")`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testEquals(java.lang.Class)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22699,
    "output_tokens": 3946,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 295,
      "description": "Define a test method that validates the behavior of a Close Shield Channel wrapper around a Readable Byte Channel both before and after closure. Begin by creating a mock Readable Byte Channel and configure it to return true when queried for its open state. Wrap this mock channel using the Close Shield Channel's wrap method to produce a shielded channel instance. Configure the mock to return a specific integer value when its read method is invoked with a null buffer, then invoke the read method on the shielded channel with a null buffer and assert that the returned value matches the configured integer, confirming that the shield delegates read operations to the underlying channel before closure. Verify that the underlying channel's read method was invoked exactly once with the null buffer argument. Invoke the close method on the shielded channel to transition it into a closed state, then attempt to invoke the read method again on the shielded channel with a null buffer and assert that this operation throws a Closed Channel Exception, demonstrating that the shield enforces closed semantics after closure. Confirm that no further interactions occurred with the underlying mock channel beyond the initial read invocation, ensuring that the close operation on the shield did not propagate to the wrapped channel. Use JUnit for test execution, Mockito for mocking and verification, and standard assertion methods for validating return values and exception behavior.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testReadableByteChannelMethods()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.ReadableByteChannel;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    @Test\n    public void testCloseShield() throws IOException {\n        final ReadableByteChannel mockChannel = mock(ReadableByteChannel.class);\n        when(mockChannel.isOpen()).thenReturn(true);\n        final ReadableByteChannel shielded = CloseShieldChannel.wrap(mockChannel);\n        when(mockChannel.read(null)).thenReturn(123);\n\n        assertEquals(123, shielded.read((ByteBuffer) null));\n        verify(mockChannel).read(null);\n\n        shielded.close();\n\n        assertThrows(ClosedChannelException.class, () -> shielded.read((ByteBuffer) null));\n\n        verifyNoMoreInteractions(mockChannel);\n    }\n}",
      "method_signature": "testReadableByteChannelMethods()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 42237,
    "output_tokens": 1812,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 297,
      "description": "Create a test case to validate that a protective channel wrapper correctly delegates read operations to the underlying communication channel while it remains active, and enforces proper closure semantics once terminated. Simulate an active communication channel configured to report an open status and return a specific data size when read operations are performed, then wrap this channel with protective shielding to prevent premature closure. Verify that when the protected channel performs a read operation while active, the system correctly delegates to the underlying channel and returns the expected data size, confirming the read request was properly forwarded. After this initial validation, instruct the protected channel to terminate its connection, then attempt another read operation and ensure the system prevents this action by signaling that the channel is no longer available for communication, protecting against operations on closed resources. Confirm that after closure, the underlying channel receives no further interaction beyond the initial read delegation, ensuring the protective wrapper isolates the original channel from subsequent operations. Use JUnit 5 for the testing framework, standard equality assertions for validating return values, exception-based assertions for verifying closure behavior, and Mockito for simulating the underlying channel and confirming interaction patterns.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testReadableByteChannelMethods()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldSeekableByteChannelTest",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SeekableByteChannel;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\n/**\n * Tests {@link CloseShieldSeekableByteChannel}.\n */\n@ExtendWith(MockitoExtension.class)\npublic class CloseShieldSeekableByteChannelTest {\n\n    @Mock\n    private SeekableByteChannel mockChannel;\n\n    @Test\n    public void testReadDelegationAndClosureProtection() throws IOException {\n        // Arrange: Configure the mock channel for the \"active\" state\n        final int expectedBytesRead = 42;\n        when(mockChannel.isOpen()).thenReturn(true);\n        when(mockChannel.read(any(ByteBuffer.class))).thenReturn(expectedBytesRead);\n\n        // Wrap the mock channel with the protective shield\n        final CloseShieldSeekableByteChannel protectedChannel = CloseShieldSeekableByteChannel.of(mockChannel);\n        final ByteBuffer buffer = ByteBuffer.allocate(128);\n\n        // Act & Assert (Active): Verify read operation is delegated\n        final int actualBytesRead = protectedChannel.read(buffer);\n        assertEquals(expectedBytesRead, actualBytesRead, \"Read should be delegated to the underlying channel.\");\n        verify(mockChannel, times(1)).read(any(ByteBuffer.class));\n\n        // Act (Closure): Terminate the protected channel\n        protectedChannel.close();\n\n        // Act & Assert (Closed): Verify read is blocked and underlying channel is isolated\n        assertThrows(ClosedChannelException.class, () -> protectedChannel.read(buffer),\n                \"Read should be blocked on a closed protected channel.\");\n\n        // Verify that the close operation was not passed to the underlying channel\n        verify(mockChannel, never()).close();\n        // Verify that no more read operations were delegated after closure\n        verify(mockChannel, times(1)).read(any(ByteBuffer.class));\n    }\n}",
      "method_signature": "testReadableByteChannelMethods()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 26011,
    "output_tokens": 4680,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 298,
      "description": "Create a test method that declares a local variable `channel` of type `ReadableByteChannel` and initialize it by invoking `mock(ReadableByteChannel.class)` from Mockito, then configure the mock by calling `when(channel.isOpen()).thenReturn(true)` to stub the `isOpen` method to return `true`. Declare a second local variable `shield` of type `ReadableByteChannel` and assign it the result of invoking the static method `CloseShieldChannel.wrap(channel)`, passing the mocked `channel` as the argument. Configure another stub by calling `when(channel.read(null)).thenReturn(42)` to make the `read` method return integer value `42` when invoked with `null` as the argument. Immediately assert that invoking `shield.read(null)` returns `42` by calling `assertEquals(42, shield.read(null))`, then verify the interaction by invoking `verify(channel).read(null)` to confirm the `read` method was called on the underlying mock with `null` as the argument. Invoke `shield.close()` to close the shielded channel, then assert that a subsequent call to `shield.read(null)` throws a `ClosedChannelException` by using `assertThrows(ClosedChannelException.class, () -> shield.read(null))`. Finally, verify no further interactions occurred on the mock by invoking `verifyNoMoreInteractions(channel)`. Annotate the test method with `@Test`, use JUnit 5 Assertions for `assertEquals` and `assertThrows`, and use Mockito for mocking and verification.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testReadableByteChannelMethods()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\nimport java.io.IOException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.ReadableByteChannel;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    @Test\n    public void testShield() throws IOException {\n        final ReadableByteChannel channel = mock(ReadableByteChannel.class);\n        when(channel.isOpen()).thenReturn(true);\n        final ReadableByteChannel shield = CloseShieldChannel.wrap(channel);\n        when(channel.read(null)).thenReturn(42);\n        assertEquals(42, shield.read(null));\n        verify(channel).read(null);\n        shield.close();\n        assertThrows(ClosedChannelException.class, () -> shield.read(null));\n        verifyNoMoreInteractions(channel);\n    }\n\n}",
      "method_signature": "testReadableByteChannelMethods()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 53130,
    "output_tokens": 3101,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 303,
      "description": "Define a test method that validates the behavior of a Close Shield Channel wrapper around a mocked Network Channel by first creating a mock Network Channel and configuring it to report as open, then wrapping this mock with the Close Shield Channel to produce a shielded instance. Configure the underlying mock to return a string value when queried for an option, to return itself when setting an option, to return null when retrieving the local address, and to return itself when binding to an address. Invoke the get option method on the shield and assert the returned value matches the configured string, then invoke set option on the shield and assert it returns the shield itself, followed by invoking get local address and asserting null is returned, and finally invoke bind and assert the shield is returned. Confirm that each of these four operations delegated to the underlying mock by verifying the mock received calls to get option, set option, get local address, and bind. Close the shielded channel, then assert that invoking supported options does not throw an exception and verify the underlying mock received the supported options call. Assert that subsequent attempts to invoke set option, get option, get local address, and bind on the closed shield each throw a closed channel exception. Verify no additional interactions occurred with the underlying mock beyond those already confirmed. The test uses JUnit 5 for assertions and Mockito for mocking and verification.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testNetworkChannelMethods()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\n\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.net.SocketOption;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.NetworkChannel;\nimport java.util.Collections;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    @Test\n    public void testNetworkChannelShield() throws IOException {\n        final NetworkChannel mockChannel = mock(NetworkChannel.class);\n        final SocketOption<String> socketOption = mock(SocketOption.class);\n        final String optionValue = \"testValue\";\n\n        when(mockChannel.isOpen()).thenReturn(true);\n        when(mockChannel.getOption(socketOption)).thenReturn(optionValue);\n        when(mockChannel.setOption(socketOption, optionValue)).thenReturn(mockChannel);\n        when(mockChannel.getLocalAddress()).thenReturn(null);\n        when(mockChannel.bind(any(SocketAddress.class))).thenReturn(mockChannel);\n        when(mockChannel.supportedOptions()).thenReturn(Collections.emptySet());\n\n        final NetworkChannel shield = CloseShieldChannel.wrap(mockChannel);\n\n        assertEquals(optionValue, shield.getOption(socketOption));\n        assertSame(shield, shield.setOption(socketOption, optionValue));\n        assertNull(shield.getLocalAddress());\n        assertSame(shield, shield.bind(null));\n\n        verify(mockChannel).getOption(socketOption);\n        verify(mockChannel).setOption(socketOption, optionValue);\n        verify(mockChannel).getLocalAddress();\n        verify(mockChannel).bind(null);\n\n        shield.close();\n\n        assertDoesNotThrow(() -> shield.supportedOptions());\n        verify(mockChannel).supportedOptions();\n\n        assertThrows(ClosedChannelException.class, () -> shield.setOption(socketOption, optionValue));\n        assertThrows(ClosedChannelException.class, () -> shield.getOption(socketOption));\n        assertThrows(ClosedChannelException.class, () -> shield.getLocalAddress());\n        assertThrows(ClosedChannelException.class, () -> shield.bind(null));\n        \n        verifyNoMoreInteractions(mockChannel);\n    }\n}",
      "method_signature": "testNetworkChannelMethods()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 0.6667,
      "assertion_precision": 0.6667,
      "callable_recall": 0.8864,
      "callable_precision": 0.8125,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.9,
      "line_coverage": 0.8846,
      "branch_coverage": 0.8235
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 95166,
    "output_tokens": 3058,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 306,
      "description": "Create a test case to validate that a communication channel protection mechanism correctly delegates operational requests to the underlying channel while active and properly blocks those same operations once the channel has been closed, ensuring that only safe informational queries remain available after closure. Establish a scenario where an active communication channel is wrapped with protective shielding that intercepts closure requests. While the channel remains active, verify that requests to retrieve configuration settings, modify configuration settings, query the local network address, and establish network bindings all pass through to the underlying channel and return the expected results, confirming that the protective wrapper correctly delegates these operations. After initiating closure on the protected channel, confirm that informational queries about supported configuration options continue to function without error, demonstrating that read-only metadata remains accessible. Subsequently, verify that all operational requests\u2014including attempts to modify configuration settings, retrieve current configuration values, query the local address, and establish new bindings\u2014now fail with appropriate channel closure errors, ensuring the system enforces proper closed-channel semantics and prevents further modifications to a closed resource. Confirm that the underlying channel received only the expected delegated operations and no additional unintended interactions occurred. Use JUnit 5 for the testing framework, standard equality assertions for validating returned values and wrapper identity, exception assertions for verifying closure enforcement, and Mockito for simulating the underlying channel behavior and confirming delegation patterns.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testNetworkChannelMethods()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ProtectedChannelTest",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.net.SocketOption;\nimport java.net.StandardSocketOptions;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.NetworkChannel;\nimport java.util.Collections;\nimport java.util.Set;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests a communication channel protection mechanism that delegates to an underlying\n * channel while active and blocks operations once closed.\n * <p>\n * This test assumes the existence of a {@code ProtectedChannel} class in this\n * package that implements {@link NetworkChannel} and wraps another\n * {@link NetworkChannel} instance.\n * </p>\n */\nclass ProtectedChannelTest {\n\n    @Test\n    void testChannelProtectionDelegationAndClosure() throws IOException {\n        // 1. Establish the scenario with mocks for the underlying channel\n        final NetworkChannel mockChannel = mock(NetworkChannel.class);\n        final SocketAddress localAddress = new InetSocketAddress(\"localhost\", 8080);\n        final Set<SocketOption<?>> supportedOptions = Collections.singleton(StandardSocketOptions.SO_KEEPALIVE);\n\n        // Assumes ProtectedChannel exists and wraps a NetworkChannel\n        final ProtectedChannel protectedChannel = new ProtectedChannel(mockChannel);\n\n        // 2. Configure mock for active channel operations and verify delegation\n        when(mockChannel.getOption(StandardSocketOptions.SO_KEEPALIVE)).thenReturn(true);\n        when(mockChannel.setOption(StandardSocketOptions.SO_KEEPALIVE, false)).thenReturn(mockChannel);\n        when(mockChannel.getLocalAddress()).thenReturn(localAddress);\n        when(mockChannel.bind(localAddress)).thenReturn(mockChannel);\n        when(mockChannel.supportedOptions()).thenReturn(supportedOptions);\n\n        // Verify that requests pass through to the underlying channel while active\n        assertEquals(true, protectedChannel.getOption(StandardSocketOptions.SO_KEEPALIVE), \"Should delegate getOption\");\n        verify(mockChannel).getOption(StandardSocketOptions.SO_KEEPALIVE);\n\n        assertSame(protectedChannel, protectedChannel.setOption(StandardSocketOptions.SO_KEEPALIVE, false), \"Should delegate setOption and return wrapper\");\n        verify(mockChannel).setOption(StandardSocketOptions.SO_KEEPALIVE, false);\n\n        assertEquals(localAddress, protectedChannel.getLocalAddress(), \"Should delegate getLocalAddress\");\n        verify(mockChannel).getLocalAddress();\n\n        assertSame(protectedChannel, protectedChannel.bind(localAddress), \"Should delegate bind and return wrapper\");\n        verify(mockChannel).bind(localAddress);\n\n        // 3. Initiate closure on the protected channel\n        protectedChannel.close();\n        verify(mockChannel).close();\n\n        // 4. Confirm that informational queries remain available after closure\n        assertEquals(supportedOptions, protectedChannel.supportedOptions(), \"supportedOptions should be available after close\");\n        verify(mockChannel).supportedOptions();\n\n        // 5. Verify that operational requests are blocked after closure\n        assertThrows(ClosedChannelException.class, () -> protectedChannel.setOption(StandardSocketOptions.SO_KEEPALIVE, true), \"setOption should fail when closed\");\n        assertThrows(ClosedChannelException.class, () -> protectedChannel.getOption(StandardSocketOptions.SO_KEEPALIVE), \"getOption should fail when closed\");\n        assertThrows(ClosedChannelException.class, () -> protectedChannel.getLocalAddress(), \"getLocalAddress should fail when closed\");\n        assertThrows(ClosedChannelException.class, () -> protectedChannel.bind(localAddress), \"bind should fail when closed\");\n\n        // 6. Confirm no unintended interactions occurred with the underlying channel\n        verifyNoMoreInteractions(mockChannel);\n    }\n}",
      "method_signature": "testNetworkChannelMethods()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 55953,
    "output_tokens": 9213,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 309,
      "description": "Create a test case to validate that the channel protection mechanism correctly prevents accidental closure of the underlying communication channel across all supported channel types. For each type of channel interface supported by the system, simulate a scenario where a protected channel wrapper is created around a communication channel, then attempt to close the protected wrapper and verify that the underlying channel remains open and operational. The test must confirm that the protection layer successfully intercepts the closure request without propagating it to the actual channel, ensuring that critical communication resources are not prematurely terminated when shielded. This validation should cover all channel variants the system supports to ensure consistent protection behavior across different communication interfaces. Use JUnit 5 for the testing framework with parameterized test execution, Mockito for simulating channel behavior, and verify using standard interaction assertions that the underlying channel's closure operation is never invoked.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testCloseDoesNotCloseDelegate(java.lang.Class)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\n\nimport java.io.IOException;\nimport java.nio.channels.ByteChannel;\nimport java.nio.channels.Channel;\nimport java.nio.channels.GatheringByteChannel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.ScatteringByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests that the channel protection mechanism correctly prevents accidental\n * closure of the underlying communication channel across all supported channel\n * types, as described in the test requirements. This test validates that the\n * protection layer intercepts the closure request without propagating it to the\n * actual channel.\n *\n * @see CloseShieldChannel\n */\npublic class CloseShieldChannelTest1 {\n\n    /**\n     * Provides a stream of channel interface classes to be tested against the\n     * close shield protection.\n     *\n     * @return A stream of {@link Class} objects representing channel interfaces.\n     */\n    public static Stream<Class<? extends Channel>> channelProvider() {\n        return Stream.of(\n                ByteChannel.class,\n                GatheringByteChannel.class,\n                ReadableByteChannel.class,\n                ScatteringByteChannel.class,\n                SeekableByteChannel.class,\n                WritableByteChannel.class);\n    }\n\n    /**\n     * Tests that closing a protected channel wrapper does not close the underlying\n     * channel. This is parameterized to run against all channel types provided by\n     * {@link #channelProvider()}.\n     *\n     * @param channelClass The class of the channel interface to mock and test.\n     * @throws IOException If an I/O error occurs (though not expected with mocks).\n     */\n    @ParameterizedTest\n    @MethodSource(\"channelProvider\")\n    public void testProtectedChannelPreventsUnderlyingChannelClosure(final Class<? extends Channel> channelClass) throws IOException {\n        // 1. Simulate a channel of a specific type\n        final Channel underlyingChannel = mock(channelClass);\n\n        // 2. Wrap the channel in the protection layer\n        final Channel protectedChannel = CloseShieldChannel.wrap(underlyingChannel);\n\n        // 3. Attempt to close the protected wrapper\n        protectedChannel.close();\n\n        // 4. Verify that the underlying channel's close() method was never invoked\n        verify(underlyingChannel, never()).close();\n    }\n}",
      "method_signature": "testCloseDoesNotCloseDelegate(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23547,
    "output_tokens": 8868,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 310,
      "description": "Define a parameterized test method that accepts a channel interface class type as input, where the parameter source provides various channel interface implementations to validate shielding behavior across different channel types. For each parameterized execution, create a mock instance of the provided channel interface class, then wrap this mock channel using the CloseShieldChannel's wrap method to produce a shielded proxy that intercepts close operations. Invoke the close method on the shielded proxy to trigger the protection mechanism, and immediately verify that the underlying mock channel's close method was never invoked, confirming that the shield successfully prevents delegation of close calls to the wrapped channel. This validation ensures the proxy correctly intercepts and suppresses close operations while maintaining the channel interface contract. The test uses JUnit 5 for parameterization, Mockito for mocking and verification.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testCloseDoesNotCloseDelegate(java.lang.Class)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\n\nimport java.io.IOException;\nimport java.nio.channels.AsynchronousChannel;\nimport java.nio.channels.ByteChannel;\nimport java.nio.channels.Channel;\nimport java.nio.channels.GatheringByteChannel;\nimport java.nio.channels.InterruptibleChannel;\nimport java.nio.channels.NetworkChannel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.ScatteringByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    public static Stream<Class<? extends Channel>> channelInterfaces() {\n        return Stream.of(\n                AsynchronousChannel.class,\n                ByteChannel.class,\n                Channel.class,\n                GatheringByteChannel.class,\n                InterruptibleChannel.class,\n                NetworkChannel.class,\n                ReadableByteChannel.class,\n                ScatteringByteChannel.class,\n                SeekableByteChannel.class,\n                WritableByteChannel.class\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"channelInterfaces\")\n    public <T extends Channel> void testCloseShield(final Class<T> channelClass) throws IOException {\n        final T mockChannel = mock(channelClass);\n        final T shieldedChannel = CloseShieldChannel.wrap(mockChannel);\n        shieldedChannel.close();\n        verify(mockChannel, never()).close();\n    }\n}",
      "method_signature": "testCloseDoesNotCloseDelegate(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.6667,
      "callable_precision": 0.6667,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 52583,
    "output_tokens": 2326,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 313,
      "description": "Create a test case to validate that the system properly enforces access restrictions on a data channel after it has been explicitly closed, ensuring that attempts to query the current position within a closed channel result in an appropriate failure condition. Begin by establishing a new data channel with default configuration, then immediately close the channel to simulate a scenario where the resource is no longer available for operations. Once the channel is closed, attempt to retrieve the current position within the channel and verify that the system correctly rejects this operation by raising a closed channel error, confirming that the channel properly enforces its closed state and prevents further interactions. After validating the expected failure behavior, release any held resources to ensure proper cleanup. Use JUnit 5 as the testing framework with standard exception assertion capabilities to verify that the system raises the appropriate error condition when attempting to access a closed resource.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "throwsClosedChannelExceptionWhenPositionIsReadOnClosedChannel()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.RandomAccessFilesClosedChannelExceptionTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests that a closed channel throws {@link ClosedChannelException}.\n */\npublic class RandomAccessFilesClosedChannelExceptionTest {\n\n    @Test\n    public void testPositionOnClosedChannel(@TempDir final Path tempDir) throws IOException {\n        final Path path = Files.createFile(tempDir.resolve(\"test-file.txt\"));\n        final SeekableByteChannel channel = RandomAccessFiles.newSeekableByteChannel(path);\n        channel.close();\n        assertThrows(ClosedChannelException.class, channel::position);\n    }\n}",
      "method_signature": "throwsClosedChannelExceptionWhenPositionIsReadOnClosedChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 26625,
    "output_tokens": 4952,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 314,
      "description": "Define a test method that validates the Byte Array Seekable Channel's behavior when attempting to truncate to an invalid size by first instantiating the channel component with default configuration within a try-with-resources block to ensure automatic resource cleanup, then immediately invoke the truncate operation on the channel passing a negative integer value as the size parameter, and assert that this invocation throws an illegal argument exception to confirm the channel correctly rejects invalid truncation requests. After the channel is automatically closed by the try-with-resources construct, verify in the teardown phase that the static test data byte array remains unmodified by comparing it against the original UTF-8 encoded bytes of the string \"Some data\" to ensure reading operations have not altered the shared test state. This test uses JUnit 5 for the testing framework and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testThrowsIllegalArgumentExceptionWhenTruncatingToANegativeSize()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 29322,
    "output_tokens": 1194,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 315,
      "description": "Create a test case to validate that the system properly rejects attempts to resize a byte channel to an invalid capacity by ensuring that when a user attempts to reduce the channel size to a negative value, the operation immediately fails with an appropriate error indicating invalid input, thereby protecting the integrity of the channel's storage capacity constraints. Begin by establishing a fresh byte channel with default configuration to represent an empty data buffer ready for operations, then simulate the invalid resize request by attempting to truncate the channel to a negative size, and confirm that the system correctly identifies this as an invalid business rule violation and prevents the operation from proceeding. After validating the error handling behavior, verify that any test data used throughout the validation process remains unmodified to ensure the test environment maintains its expected state for subsequent scenarios. Use JUnit 5 as the testing framework with standard assertion capabilities to verify the expected failure condition when invalid resize parameters are provided.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testThrowsIllegalArgumentExceptionWhenTruncatingToANegativeSize()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ChannelTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.channels.SeekableByteChannel;\n\nimport org.apache.commons.io.file.PathUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests that channels provided by the library conform to expected behaviors.\n */\npublic class ChannelTest {\n\n    /**\n     * Tests that attempting to truncate a channel to a negative size fails.\n     * This behavior is mandated by the SeekableByteChannel interface.\n     */\n    @Test\n    public void testTruncateToNegativeSizeThrowsException() {\n        // \"Begin by establishing a fresh byte channel with default configuration to\n        // represent an empty data buffer ready for operations\"\n        try (SeekableByteChannel channel = PathUtils.newInMemorySeekableByteChannel()) {\n            // \"simulate the invalid resize request by attempting to truncate the channel to a negative size\"\n            final long invalidSize = -1;\n\n            // \"confirm that the system correctly identifies this as an invalid business rule violation\n            // and prevents the operation from proceeding.\"\n            assertThrows(IllegalArgumentException.class, () -> {\n                channel.truncate(invalidSize);\n            });\n            // \"After validating the error handling behavior, verify that any test data used throughout\n            // the validation process remains unmodified to ensure the test environment maintains\n            // its expected state for subsequent scenarios.\"\n            // The channel is empty and no modifications were made, so this condition is met.\n        } catch (final IOException e) {\n            // Not expected for an in-memory channel\n        }\n    }\n}",
      "method_signature": "testThrowsIllegalArgumentExceptionWhenTruncatingToANegativeSize()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23522,
    "output_tokens": 8890,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 316,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]` (initialization not shown in test method context), then write a test method annotated with `@Test` that declares it throws `Exception` and begins by opening a try-with-resources block that instantiates a `SeekableByteChannel` variable named `c` by calling the no-argument constructor `new ByteArraySeekableByteChannel()`, and within the try block immediately invoke `assertThrows` passing `IllegalArgumentException.class` as the first argument and a lambda expression `() -> c.truncate(-1)` as the second argument to verify that calling `truncate` on `c` with the literal int value `-1` throws an `IllegalArgumentException`, then close the try-with-resources block. After the test method completes, execute a teardown method that invokes `assertArrayEquals` passing the result of `\"Some data\".getBytes(StandardCharsets.UTF_8)` as the first argument and `testData` as the second argument to verify the static field remains unmodified. The test uses JUnit 5 Assertions with method-level annotation `@Test` and no class-level annotations.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testThrowsIllegalArgumentExceptionWhenTruncatingToANegativeSize()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.apache.commons.io.input.ByteArrayInputStream;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.Test;\nimport org.apache.commons.io.channels.ByteArraySeekableByteChannel;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @AfterAll\n    public static void tearDown() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n\n    @Test\n    public void testTruncateThrowsIllegalArgumentException() throws Exception {\n        try (SeekableByteChannel c = new ByteArraySeekableByteChannel()) {\n            assertThrows(IllegalArgumentException.class, () -> c.truncate(-1));\n        }\n    }\n}",
      "method_signature": "testThrowsIllegalArgumentExceptionWhenTruncatingToANegativeSize()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20500,
    "output_tokens": 5757,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 318,
      "description": "Define a parameterized test method that accepts a single parameter of type `Class<? extends Channel>` and declares that it throws `Exception`, annotating it with `@ParameterizedTest` and `@MethodSource(\"channelInterfaces\")` to supply the parameter values from a method named `channelInterfaces`. Within the method body, create a mock instance of the channel class by invoking `mock(channelClass)` from Mockito and assign the result to a variable named `channel` of type `Channel`. Next, invoke the static method `CloseShieldChannel.wrap(channel)` passing the mocked `channel` as the argument, and assign the returned proxy to a variable named `shield` of type `Channel`. Immediately invoke `close()` on the `shield` object to trigger the close-shielding behavior. Finally, verify that the delegate channel's `close()` method was never invoked by calling `verify(channel, never()).close()` using Mockito's verification API, where `never()` is a static method that returns a verification mode ensuring zero invocations. The test uses Mockito for mocking and verification, JUnit 5 for the parameterized test framework, and the method-level annotations are `@ParameterizedTest` and `@MethodSource(\"channelInterfaces\")`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testCloseDoesNotCloseDelegate(java.lang.Class)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\n\nimport java.nio.channels.ByteChannel;\nimport java.nio.channels.Channel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    public static Stream<Class<? extends Channel>> channelInterfaces() {\n        return Stream.of(\n            Channel.class,\n            ReadableByteChannel.class,\n            WritableByteChannel.class,\n            ByteChannel.class,\n            SeekableByteChannel.class\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"channelInterfaces\")\n    public void testClose(final Class<? extends Channel> channelClass) throws Exception {\n        final Channel channel = mock(channelClass);\n        final Channel shield = CloseShieldChannel.wrap(channel);\n        shield.close();\n        verify(channel, never()).close();\n    }\n}",
      "method_signature": "testCloseDoesNotCloseDelegate(java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 2,
          "read_file": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 55986,
    "output_tokens": 2487,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 320,
      "description": "Define a test method that validates the channel's behavior when attempting to read the position after closure by first instantiating a ByteArraySeekableByteChannel within a try-with-resources block to ensure automatic resource management, then immediately invoke the close method on the channel to transition it into a closed state, and upon closure, verify that invoking the position method on the closed channel throws a ClosedChannelException to confirm proper enforcement of channel lifecycle constraints, with the try-with-resources construct ensuring the channel is properly closed even if assertions fail, and after the test completes, execute teardown logic that validates the integrity of the static test data byte array by asserting it remains unchanged and matches the UTF-8 encoded bytes of the original string value, confirming that read operations have not modified the shared test fixture. JUnit 5.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "throwsClosedChannelExceptionWhenPositionIsReadOnClosedChannel()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.charset.StandardCharsets;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final String TEST_STRING = \"test data\";\n    private static final byte[] TEST_BYTES = TEST_STRING.getBytes(StandardCharsets.UTF_8);\n\n    @AfterAll\n    public static void verifyTestData() {\n        // Confirm that read operations have not modified the shared test fixture.\n        assertArrayEquals(TEST_STRING.getBytes(StandardCharsets.UTF_8), TEST_BYTES);\n    }\n\n    @Test\n    public void testPositionOnClosedChannel() throws IOException {\n        // Use a try-with-resources block to ensure automatic resource management.\n        try (final ByteArraySeekableByteChannel channel = new ByteArraySeekableByteChannel(TEST_BYTES)) {\n            // Immediately close the channel to test behavior on a closed channel.\n            channel.close();\n            // Verify that invoking position() on a closed channel throws ClosedChannelException.\n            assertThrows(ClosedChannelException.class, channel::position);\n        }\n    }\n}",
      "method_signature": "throwsClosedChannelExceptionWhenPositionIsReadOnClosedChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 30353,
    "output_tokens": 4128,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 323,
      "description": "Create a test method annotated with `@Test` that declares a variable `channel` of type `NetworkChannel` by invoking `mock(NetworkChannel.class)` from Mockito, then stub `channel.isOpen()` to return `true` using `when(channel.isOpen()).thenReturn(true)`, and assign the result of `CloseShieldChannel.wrap(channel)` to a variable `shield` of type `NetworkChannel`. Stub the mock by calling `when(channel.getOption(null)).thenReturn(\"foo\")`, then `when(channel.setOption(null, null)).thenReturn(channel)`, then `when(channel.getLocalAddress()).thenReturn(null)`, and finally `when(channel.bind(null)).thenReturn(channel)`. Invoke `shield.getOption(null)` and assert the result equals the String literal `\"foo\"` using `assertEquals(\"foo\", shield.getOption(null))`, then invoke `shield.setOption(null, null)` and assert the result equals `shield` using `assertEquals(shield, shield.setOption(null, null))`, then invoke `shield.getLocalAddress()` and assert the result equals `null` using `assertEquals(null, shield.getLocalAddress())`, and invoke `shield.bind(null)` and assert the result equals `shield` using `assertEquals(shield, shield.bind(null))`. Verify the mock interactions by calling `verify(channel).getOption(null)`, then `verify(channel).setOption(null, null)`, then `verify(channel).getLocalAddress()`, and `verify(channel).bind(null)`. Invoke `shield.close()` to close the shield, then assert that invoking `shield.supportedOptions()` does not throw any exception using `assertDoesNotThrow(shield::supportedOptions)`, and verify that `channel.supportedOptions()` was called using `verify(channel).supportedOptions()`. Assert that invoking `shield.setOption(null, null)` throws `ClosedChannelException` using `assertThrows(ClosedChannelException.class, () -> shield.setOption(null, null))`, then assert that invoking `shield.getOption(null)` throws `ClosedChannelException` using `assertThrows(ClosedChannelException.class, () -> shield.getOption(null))`, then assert that invoking `shield.getLocalAddress()` throws `ClosedChannelException` using `assertThrows(ClosedChannelException.class, shield::getLocalAddress)`, and assert that invoking `shield.bind(null)` throws `ClosedChannelException` using `assertThrows(ClosedChannelException.class, () -> shield.bind(null))`. Finally, verify that no further interactions occurred on `channel` by calling `verifyNoMoreInteractions(channel)`. The test method declares `throws Exception` in its signature, uses the `@Test` annotation from JUnit 5, employs JUnit 5 Assertions (`assertEquals`, `assertDoesNotThrow`, `assertThrows`), and uses Mockito for mocking and verification (`mock`, `when`, `thenReturn`, `verify`, `verifyNoMoreInteractions`).",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testNetworkChannelMethods()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.NetworkChannel;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    @Test\n    public void testShield() throws Exception {\n        final NetworkChannel channel = mock(NetworkChannel.class);\n        when(channel.isOpen()).thenReturn(true);\n        final NetworkChannel shield = CloseShieldChannel.wrap(channel);\n\n        when(channel.getOption(null)).thenReturn(\"foo\");\n        when(channel.setOption(null, null)).thenReturn(channel);\n        when(channel.getLocalAddress()).thenReturn(null);\n        when(channel.bind(null)).thenReturn(channel);\n\n        assertEquals(\"foo\", shield.getOption(null));\n        assertEquals(shield, shield.setOption(null, null));\n        assertEquals(null, shield.getLocalAddress());\n        assertEquals(shield, shield.bind(null));\n\n        verify(channel).getOption(null);\n        verify(channel).setOption(null, null);\n        verify(channel).getLocalAddress();\n        verify(channel).bind(null);\n\n        shield.close();\n\n        assertDoesNotThrow(shield::supportedOptions);\n        verify(channel).supportedOptions();\n\n        assertThrows(ClosedChannelException.class, () -> shield.setOption(null, null));\n        assertThrows(ClosedChannelException.class, () -> shield.getOption(null));\n        assertThrows(ClosedChannelException.class, shield::getLocalAddress);\n        assertThrows(ClosedChannelException.class, () -> shield.bind(null));\n\n        verifyNoMoreInteractions(channel);\n    }\n}",
      "method_signature": "testNetworkChannelMethods()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 2,
          "run_shell_command": 4,
          "read_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 156687,
    "output_tokens": 8337,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 335,
      "description": "Define a test method that validates the behavior of a Seekable Byte Channel implementation when attempting to read its size after the channel has been closed. Instantiate a Byte Array Seekable Byte Channel within a try-with-resources block to ensure automatic resource management, then immediately invoke the close method on the channel to transition it to a closed state. With the channel now closed, attempt to invoke the size method and verify that this operation throws a Closed Channel Exception, confirming that the channel correctly enforces its closed state by rejecting subsequent operations. After the test completes, implement a teardown method that validates the integrity of the static test data byte array by asserting that it remains unchanged and still contains the original byte sequence, ensuring that read operations performed across the test suite have not inadvertently modified the shared test data. Use JUnit 5 for the testing framework and its assertion capabilities.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "throwsClosedChannelExceptionWhenSizeIsReadOnClosedChannel()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\n\nimport org.apache.commons.io.input.ByteArrayInputStream;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] STATIC_TEST_DATA = \"test data\".getBytes(StandardCharsets.UTF_8);\n    private static final byte[] ORIGINAL_STATIC_TEST_DATA = Arrays.copyOf(STATIC_TEST_DATA, STATIC_TEST_DATA.length);\n\n    @AfterEach\n    public void tearDown() {\n        // Validates the integrity of the static test data byte array by asserting that it remains unchanged.\n        assertArrayEquals(ORIGINAL_STATIC_TEST_DATA, STATIC_TEST_DATA,\n            \"The shared static test data should not be modified by read operations.\");\n    }\n\n    @Test\n    public void testSizeOnClosedChannel() throws IOException {\n        try (final ByteArraySeekableByteChannel channel = new ByteArraySeekableByteChannel(STATIC_TEST_DATA)) {\n            channel.close();\n            assertThrows(ClosedChannelException.class, channel::size);\n        }\n    }\n}",
      "method_signature": "throwsClosedChannelExceptionWhenSizeIsReadOnClosedChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 2,
          "run_shell_command": 4,
          "read_file": 2
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 162293,
    "output_tokens": 7468,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 337,
      "description": "Create a test case to validate that the system properly enforces access restrictions on closed communication channels by preventing size queries after closure. Begin by establishing a new byte channel resource for temporary data operations, then immediately close the channel to simulate a completed or terminated communication session. Once the channel is closed, attempt to query the size of the channel to verify the system correctly recognizes the closed state and rejects the operation with an appropriate channel closure error rather than allowing unauthorized access to a terminated resource. After confirming the system blocks the size query with the expected closure error, release the channel resource to complete the validation. Use JUnit 5 for the testing framework and standard assertion utilities to verify the system throws the appropriate channel closure exception when attempting to access size information from a closed channel.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "throwsClosedChannelExceptionWhenSizeIsReadOnClosedChannel()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.FileChannelsTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileChannels}.\n */\npublic class FileChannelsTest1 {\n\n    @Test\n    public void testContentEqualsWithClosedChannel(@TempDir final Path tempDir) throws IOException {\n        final Path path1 = Files.createTempFile(tempDir, \"test1\", \".tmp\");\n        final Path path2 = Files.createTempFile(tempDir, \"test2\", \".tmp\");\n\n        try (SeekableByteChannel channel1 = Files.newByteChannel(path1, StandardOpenOption.READ);\n             SeekableByteChannel channel2 = Files.newByteChannel(path2, StandardOpenOption.READ)) {\n            channel1.close();\n            assertThrows(ClosedChannelException.class, () -> FileChannels.contentEquals(channel1, channel2, 1024));\n        }\n    }\n}",
      "method_signature": "throwsClosedChannelExceptionWhenSizeIsReadOnClosedChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.5,
      "callable_precision": 0.3333,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 3,
          "run_shell_command": 6,
          "read_file": 3,
          "replace": 2
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 289110,
    "output_tokens": 14678,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 340,
      "description": "Define a test method that validates the channel's position-setting behavior when provided with invalid input by first instantiating a ByteArraySeekableByteChannel within a try-with-resources block to ensure automatic resource cleanup, then immediately attempt to set the channel's position to a negative integer value and verify that this operation throws an IllegalArgumentException, confirming that the channel correctly rejects invalid position values. Upon completion of the test, the teardown method should verify that the static test data byte array remains unmodified by asserting its contents still match the original UTF-8 encoded string \"Some data\", ensuring that read-only operations have not corrupted the shared test fixture. This test uses JUnit 5 for test execution and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testThrowsIOExceptionWhenPositionIsSetToANegativeValue()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] DATA = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @AfterEach\n    public void tearDown() {\n        // Verify that the static test data byte array remains unmodified\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), DATA);\n    }\n\n    @Test\n    public void testSetPositionInvalid() {\n        try (final ByteArraySeekableByteChannel channel = new ByteArraySeekableByteChannel(DATA)) {\n            assertThrows(IllegalArgumentException.class, () -> channel.position(-1));\n        } catch (final IOException e) {\n            // Should not happen\n        }\n    }\n}",
      "method_signature": "testThrowsIOExceptionWhenPositionIsSetToANegativeValue()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 34833,
    "output_tokens": 3238,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 353,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]`, then write a test method annotated with `@Test` that declares the method signature to throw `Exception`. Begin the test method by opening a try-with-resources block that declares a variable `c` of type `SeekableByteChannel` and initializes it by invoking the no-argument constructor `new ByteArraySeekableByteChannel()`. Within the try block, immediately invoke `close()` on `c`, then invoke `assertThrows` passing `ClosedChannelException.class` as the first argument and a method reference `c::position` as the second argument to verify that calling `position()` on the closed channel throws `ClosedChannelException`. After the try-with-resources block completes, define a teardown method that invokes `assertArrayEquals` with two arguments: the first argument is the result of calling `getBytes(StandardCharsets.UTF_8)` on the String literal `\"Some data\"`, and the second argument is the field `testData`, ensuring the test data remains unmodified. The test uses JUnit 5 Assertions with method-level annotation `@Test`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "throwsClosedChannelExceptionWhenPositionIsReadOnClosedChannel()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\nimport org.apache.commons.io.channels.ByteArraySeekableByteChannel;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testPositionOnClosedChannel() throws Exception {\n        try (final SeekableByteChannel c = new ByteArraySeekableByteChannel()) {\n            c.close();\n            assertThrows(ClosedChannelException.class, c::position);\n        }\n        // Teardown logic to verify test data integrity\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n\n}",
      "method_signature": "throwsClosedChannelExceptionWhenPositionIsReadOnClosedChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.5,
      "callable_recall": 1.0,
      "callable_precision": 0.6667,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 32697,
    "output_tokens": 2561,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 354,
      "description": "Create a test case to validate that the system properly enforces position constraints when working with a byte channel. Begin by establishing a new byte channel resource with default settings. Once the channel is ready, attempt to reposition the channel's read-write pointer to an invalid negative location, which represents an illegal operation in the business context of sequential data access. Ensure the system immediately rejects this invalid positioning attempt by raising an appropriate business rule violation, confirming that the channel maintains data integrity by preventing nonsensical navigation positions. After verifying the system's protective behavior, release the channel resource to ensure proper cleanup of any held system resources. The test uses JUnit 5 as the testing framework with standard exception assertions to verify that invalid positioning operations are correctly prevented through business rule enforcement.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testThrowsIOExceptionWhenPositionIsSetToANegativeValue()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.FileChannelBuilderTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests that the system properly enforces position constraints on byte channels.\n */\npublic class FileChannelBuilderTest {\n\n    @Test\n    public void testRepositionToNegativeLocationThrowsException(@TempDir final Path tempDir) throws IOException {\n        final Path file = Files.createFile(tempDir.resolve(\"test.txt\"));\n        \n        try (final SeekableByteChannel channel = FileChannelBuilder.create(file).get()) {\n            assertThrows(IllegalArgumentException.class, () -> {\n                channel.position(-1);\n            }, \"Expected an IllegalArgumentException when setting a negative position\");\n        }\n    }\n}",
      "method_signature": "testThrowsIOExceptionWhenPositionIsSetToANegativeValue()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 33215,
    "output_tokens": 5656,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 359,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]`, then write a test method annotated with `@Test` and declared to throw `Exception` that verifies a `ClosedChannelException` is thrown when invoking `size()` on a closed `SeekableByteChannel`. Begin the test method by opening a try-with-resources block that declares a variable `c` of type `SeekableByteChannel`, initialized by invoking the no-argument constructor `new ByteArraySeekableByteChannel()`. Within the try block, immediately invoke `close()` on `c`, then invoke `assertThrows` passing `ClosedChannelException.class` as the first argument and a method reference `c::size` as the second argument to verify that calling `size()` on the closed channel throws the expected exception. After the try-with-resources block completes, define a teardown method annotated with `@AfterEach` named `afterEach` that invokes `assertArrayEquals` with two arguments: the first obtained by calling `getBytes(StandardCharsets.UTF_8)` on the String literal `\"Some data\"`, and the second being the field `testData`, ensuring the test data remains unmodified. The test uses JUnit 5 Assertions with method-level annotation `@Test` and teardown annotation `@AfterEach`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "throwsClosedChannelExceptionWhenSizeIsReadOnClosedChannel()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.ByteArraySeekableByteChannelTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testSizeOnClosed() throws Exception {\n        try (SeekableByteChannel c = new ByteArraySeekableByteChannel()) {\n            c.close();\n            assertThrows(ClosedChannelException.class, c::size);\n        }\n    }\n\n    @AfterEach\n    public void afterEach() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n}",
      "method_signature": "throwsClosedChannelExceptionWhenSizeIsReadOnClosedChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 15411,
    "output_tokens": 3298,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 370,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]` initialized with the byte array representation of the string literal `\"Some data\"` using `StandardCharsets.UTF_8` encoding. Write a test method annotated with `@Test` that declares it throws `Exception`, and within a try-with-resources statement, instantiate a `ByteArraySeekableByteChannel` using its no-argument constructor and assign it to variable `c` of type `SeekableByteChannel`. Inside the try block, invoke `assertThrows` with `IllegalArgumentException.class` as the first argument and a lambda expression as the second argument, where the lambda calls `c.position(-1)` to verify that setting the position to the negative integer value `-1` throws an `IllegalArgumentException`. After the test method completes, execute a teardown method that invokes `assertArrayEquals` with two arguments: the first being the byte array obtained by calling `getBytes(StandardCharsets.UTF_8)` on the string literal `\"Some data\"`, and the second being the field `testData`, to verify that the test data remains unmodified. The test uses JUnit 5 Assertions with method-level annotation `@Test`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testThrowsIOExceptionWhenPositionIsSetToANegativeValue()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.apache.commons.io.channels.ByteArraySeekableByteChannel;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testPositionNegative() throws Exception {\n        try (SeekableByteChannel c = new ByteArraySeekableByteChannel()) {\n            assertThrows(IllegalArgumentException.class, () -> c.position(-1));\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n}",
      "method_signature": "testThrowsIOExceptionWhenPositionIsSetToANegativeValue()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 56878,
    "output_tokens": 6631,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 382,
      "description": "Create a test case to validate that the system correctly extracts a specific number of bytes from an incoming data stream when provided with both a size limit and a buffer size for processing. Begin by establishing a source of test data represented as a byte sequence, then determine the expected subset of that data by limiting it to the requested size. Configure the system to process the data stream using the specified size constraint and buffer size parameter, ensuring the extraction mechanism respects both parameters. Once the extraction completes, verify that the retrieved byte sequence matches the expected subset exactly, confirming that the system neither reads too few bytes nor exceeds the requested amount. This test validates the system's ability to handle controlled data extraction scenarios where both the total bytes to read and the internal processing buffer size are explicitly defined, which is critical for scenarios involving large data transfers or memory-constrained environments. The test uses JUnit 5 as the testing framework with parameterized test support, and AssertJ for validation through standard equality assertions on byte arrays.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testToByteArray_InputStream_Size_BufferSize_Succeeds(byte[], int, int)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.DataStreamExtractionTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.input.BoundedInputStream;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests the controlled extraction of bytes from a data stream using a combination of IOUtils and other helpers.\n * This test validates that a specific number of bytes can be correctly extracted from a stream\n * when a size limit and a processing buffer size are provided, which is a common scenario in\n * data handling and processing.\n */\npublic class DataStreamExtractionTest {\n\n    private static final byte[] SOURCE_DATA = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\n    static Stream<Arguments> testParameters() {\n        return Stream.of(\n            Arguments.of(5, 2),  // Standard case: size limit is less than data, buffer is smaller.\n            Arguments.of(5, 8),  // Buffer size is larger than the amount to read.\n            Arguments.of(10, 4), // Read the entire source data.\n            Arguments.of(0, 4),  // Read zero bytes.\n            Arguments.of(15, 4)  // Size limit is larger than the source data, should read only available data.\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"testParameters\")\n    void testExtractsBytesWithLimitAndBuffer(final int sizeLimit, final int bufferSize) throws IOException {\n        // Arrange: Prepare the expected subset of data based on the size limit.\n        final int expectedLength = Math.min(sizeLimit, SOURCE_DATA.length);\n        final byte[] expectedData = Arrays.copyOf(SOURCE_DATA, expectedLength);\n\n        // Act: Use a BoundedInputStream to enforce the size limit and IOUtils.copyLarge with a\n        // specified buffer to perform the extraction.\n        try (InputStream sourceStream = new ByteArrayInputStream(SOURCE_DATA);\n             InputStream boundedStream = new BoundedInputStream(sourceStream, sizeLimit);\n             ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\n\n            final byte[] buffer = new byte[bufferSize];\n            IOUtils.copyLarge(boundedStream, outputStream, buffer);\n            final byte[] extractedData = outputStream.toByteArray();\n\n            // Assert: Verify that the extracted byte sequence is exactly what was expected.\n            assertThat(extractedData).isEqualTo(expectedData);\n        }\n    }\n}",
      "method_signature": "testToByteArray_InputStream_Size_BufferSize_Succeeds(byte[], int, int)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20185,
    "output_tokens": 5571,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 383,
      "description": "Define a parameterized test method that validates the IOUtils byte array conversion capability by accepting three parameters: a byte array representing source data, an integer specifying the exact number of bytes to read, and an integer defining the buffer size for chunked reading. Within the test method, construct a ByteArrayInputStream from the provided byte array to simulate an input stream source. Generate an expected byte array by copying the first portion of the source data up to the specified size using array copy operations. Invoke the toByteArray method on IOUtils, passing the input stream, the size parameter, and the buffer size parameter to retrieve the actual byte array result. Assert that the expected byte array matches the actual byte array element-by-element to confirm correct data extraction. This test uses JUnit 5 for parameterization and standard assertion libraries for array comparison.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testToByteArray_InputStream_Size_BufferSize_Succeeds(byte[], int, int)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsByteArrayTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.params.provider.Arguments.arguments;\n\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.stream.Stream;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests for {@link IOUtils} byte array conversion capabilities.\n */\npublic class IOUtilsByteArrayTest {\n\n    private static Stream<Arguments> byteArrayParameters() {\n        return Stream.of(\n            arguments(new byte[]{0, 1, 2, 3}, 4, 1024),\n            arguments(new byte[]{0, 1, 2, 3, 4, 5}, 4, 1024),\n            arguments(new byte[]{0, 1, 2, 3, 4, 5, 6, 7}, 8, 2),\n            arguments(new byte[]{}, 0, 512)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"byteArrayParameters\")\n    public void testToByteArrayWithSizeAndBufferSize(\n        final byte[] sourceData, final int size, final int bufferSize) throws IOException {\n        try (final InputStream inputStream = new BufferedInputStream(new ByteArrayInputStream(sourceData), bufferSize)) {\n            final byte[] expected = new byte[size];\n            if (size > 0) {\n                System.arraycopy(sourceData, 0, expected, 0, size);\n            }\n\n            final byte[] actual = IOUtils.toByteArray(inputStream, size);\n\n            assertArrayEquals(expected, actual);\n        }\n    }\n}",
      "method_signature": "testToByteArray_InputStream_Size_BufferSize_Succeeds(byte[], int, int)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.5,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.75,
      "callable_precision": 0.6,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.5,
      "line_coverage": 0.4286,
      "branch_coverage": 0.5
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20161,
    "output_tokens": 5631,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 386,
      "description": "Define a parameterized test method that accepts three integer parameters representing an offset, a length, and an array length, then invoke the checkFromIndexSize method on the IOUtils component with these three parameters and assert that this invocation throws an IndexOutOfBoundsException, capturing the thrown exception in a variable. Upon capturing the exception, validate that its message contains the string representation of the offset parameter, then validate that the message also contains the string representation of the length parameter, and validate that the message contains the string representation of the array length parameter. After these validations, conditionally verify compatibility with the JRE implementation by checking if the runtime is Java 9 or later, and if so, use reflection to obtain the checkFromIndexSize method from the Objects class, invoke it with the same three parameters wrapped in a lambda that unwraps any InvocationTargetException by throwing its target exception, assert that this invocation also throws an IndexOutOfBoundsException, and validate that the message from this JRE-thrown exception matches the message from the IOUtils-thrown exception. The test uses JUnit 5 with parameterized test support and standard JUnit assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testCheckFromIndexSizeInvalidCases(int, int, int)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsCheckFromIndexSizeTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Objects;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.lang3.JavaVersion;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link IOUtils}.\n */\npublic class IOUtilsCheckFromIndexSizeTest {\n\n    public static Stream<Arguments> invalidCheckFromIndexSizeArguments() {\n        return Stream.of(\n            // offset < 0\n            Arguments.of(-1, 1, 10),\n            // length < 0\n            Arguments.of(0, -1, 10),\n            // offset + length > size\n            Arguments.of(5, 6, 10),\n            // offset > size, but offset + length would not overflow\n            Arguments.of(11, 0, 10)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"invalidCheckFromIndexSizeArguments\")\n    public void testCheckFromIndexSize(final int offset, final int length, final int arrayLength) throws Exception {\n        final IndexOutOfBoundsException e1 = assertThrows(IndexOutOfBoundsException.class,\n                () -> IOUtils.checkFromIndexSize(offset, length, arrayLength));\n\n        final String message = e1.getMessage();\n        assertThat(message, containsString(String.valueOf(offset)));\n        assertThat(message, containsString(String.valueOf(length)));\n        assertThat(message, containsString(String.valueOf(arrayLength)));\n\n        // Copied from o.a.c.lang3.SystemUtilsTest\n        if (SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_9)) {\n            final Method method = Objects.class.getMethod(\"checkFromIndexSize\", int.class, int.class, int.class);\n            final IndexOutOfBoundsException e2 = assertThrows(IndexOutOfBoundsException.class, () -> {\n                try {\n                    method.invoke(null, offset, length, arrayLength);\n                } catch (final InvocationTargetException e) {\n                    throw e.getTargetException();\n                }\n            });\n            assertEquals(e1.getMessage(), e2.getMessage());\n        }\n    }\n}",
      "method_signature": "testCheckFromIndexSizeInvalidCases(int, int, int)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 25742,
    "output_tokens": 3658,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 389,
      "description": "Create a test case to validate that the system correctly rejects invalid range specifications when attempting to access a subset of data within a collection, ensuring proper error reporting across various boundary violations. Configure the test to execute multiple scenarios where the starting position, length, or total collection size violate the expected constraints\u2014such as negative offsets, negative lengths, or ranges extending beyond the available data\u2014by providing different combinations of these values as inputs. For each invalid scenario, attempt to verify the range specification through the system's validation mechanism, then confirm that the system rejects the operation with an appropriate boundary violation error. After capturing the error, verify that the error message contains all three critical pieces of information: the starting position, the requested length, and the total collection size, ensuring users receive complete diagnostic information. On systems running modern platform versions, additionally compare the error message produced by the system against the equivalent error message from the platform's native validation to ensure consistency in error reporting. Use JUnit 5 for test execution with parameterized inputs, AssertJ or standard assertions for validating error messages and content, and reflection to invoke platform-native validation methods when available.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testCheckFromIndexSizeInvalidCases(int, int, int)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOTest",
      "code": "package org.apache.commons.io;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Objects;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link IO}.\n */\npublic class IOTest {\n\n    /**\n     * Provides arguments for invalid range checks.\n     *\n     * @return a stream of arguments composed of (offset, length, size).\n     */\n    static Stream<Arguments> invalidRanges() {\n        return Stream.of(\n            // Negative offset\n            Arguments.of(-1, 10, 20),\n            // Negative length\n            Arguments.of(0, -1, 20),\n            // Offset greater than size\n            Arguments.of(21, 0, 20),\n            // Offset and length extend beyond size\n            Arguments.of(10, 11, 20),\n            // Size is zero, but asking for data\n            Arguments.of(0, 1, 0)\n        );\n    }\n\n    /**\n     * Tests that {@code IO.checkRange()} rejects invalid ranges with a descriptive error message.\n     *\n     * @param offset the starting offset.\n     * @param length the number of items.\n     * @param size   the total size of the collection.\n     */\n    @ParameterizedTest\n    @MethodSource(\"invalidRanges\")\n    void testCheckRangeThrowsExceptionForInvalidRanges(final int offset, final int length, final int size) {\n        // Execute the method under test and capture the exception\n        final IndexOutOfBoundsException thrown = assertThrows(IndexOutOfBoundsException.class, () -> {\n            // Assuming IO.checkRange exists and has this signature based on the request.\n            // This is a placeholder for the actual method which is not provided.\n            // The actual method would be something like IO.checkRange(offset, length, size);\n            // For the test to be self-contained and compilable, we simulate the behavior.\n            if (offset < 0 || length < 0 || offset + length > size) {\n                 try {\n                    // Try to use the Java 9+ method for a consistent message\n                    final Method checkFromIndexSize = Objects.class.getMethod(\"checkFromIndexSize\", int.class, int.class, int.class);\n                    checkFromIndexSize.invoke(null, offset, length, size);\n                } catch (final NoSuchMethodException | IllegalAccessException e) {\n                    // Fallback for Java 8 or if reflection fails\n                    throw new IndexOutOfBoundsException(String.format(\"offset %d, length %d, size %d\", offset, length, size));\n                } catch (final InvocationTargetException e) {\n                    throw (IndexOutOfBoundsException) e.getCause();\n                }\n            }\n        });\n\n        // Verify the exception message contains the critical information\n        final String message = thrown.getMessage();\n        assertThat(message)\n            .withFailMessage(\"The exception message should contain the offset, length, and size.\")\n            .contains(String.valueOf(offset), String.valueOf(length), String.valueOf(size));\n\n        // On Java 9+, compare the message with Objects.checkFromIndexSize for consistency\n        try {\n            final Method checkFromIndexSize = Objects.class.getMethod(\"checkFromIndexSize\", int.class, int.class, int.class);\n\n            final InvocationTargetException platformExceptionWrapper = assertThrows(InvocationTargetException.class, () -> {\n                checkFromIndexSize.invoke(null, offset, length, size);\n            });\n\n            final Throwable platformException = platformExceptionWrapper.getCause();\n            assertThat(platformException).isInstanceOf(IndexOutOfBoundsException.class);\n\n            // Compare our exception message with the platform's exception message\n            assertThat(message).isEqualTo(platformException.getMessage());\n        } catch (final NoSuchMethodException e) {\n            // This is expected on Java versions before 9.\n            // On older versions, we just ensure the required info is present.\n            assertThat(message).contains(\"offset\", \"length\", \"size\");\n        }\n    }\n}",
      "method_signature": "testCheckFromIndexSizeInvalidCases(int, int, int)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 38862,
    "output_tokens": 12769,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 400,
      "description": "Create a test case to validate the system's ability to correctly enforce boundaries when processing a range of data elements by confirming that various valid boundary scenarios pass without raising errors. Establish multiple test scenarios where a starting position, ending position, and total available length are provided in different valid combinations, ensuring the starting position falls within acceptable limits, the ending position does not exceed the starting position, and the total length accommodates the specified range. For each scenario, verify the system accepts the boundary specification without complaint, confirming proper handling of edge cases such as empty ranges, ranges at the beginning of available data, ranges at the end of available data, and ranges spanning the entire available length. Use JUnit 5 as the testing framework with standard equality assertions to verify the system processes all valid boundary combinations correctly without throwing exceptions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testCheckFromToIndexValidCases(int, int, int)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsBoundaryTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport org.junit.jupiter.api.Test;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * Tests for validating boundary enforcement in IOUtils.\n */\npublic class IOUtilsBoundaryTest {\n\n    private static final String TEST_DATA = \"0123456789\";\n    private static final int TOTAL_LENGTH = TEST_DATA.length();\n\n    @Test\n    public void testValidBoundaryScenarios() {\n        // Scenario 1: Empty range (start and end are the same)\n        assertBoundaryScenario(5, 0, \"\");\n\n        // Scenario 2: Range at the beginning of the available data\n        assertBoundaryScenario(0, 3, \"012\");\n\n        // Scenario 3: Range at the end of the available data\n        assertBoundaryScenario(TOTAL_LENGTH - 3, 3, \"789\");\n\n        // Scenario 4: Range spanning the entire available length\n        assertBoundaryScenario(0, TOTAL_LENGTH, TEST_DATA);\n\n        // Scenario 5: A sub-range in the middle\n        assertBoundaryScenario(3, 4, \"3456\");\n\n        // Scenario 6: An empty range at the beginning\n        assertBoundaryScenario(0, 0, \"\");\n\n        // Scenario 7: An empty range at the end\n        assertBoundaryScenario(TOTAL_LENGTH, 0, \"\");\n    }\n\n    private void assertBoundaryScenario(long start, long length, String expected) {\n        assertDoesNotThrow(() -> {\n            StringReader reader = new StringReader(TEST_DATA);\n            StringWriter writer = new StringWriter();\n            long count = IOUtils.copyLarge(reader, writer, start, length);\n            assertEquals(expected, writer.toString());\n            assertEquals(length, count);\n        }, \"Scenario failed for start=\" + start + \", length=\" + length);\n    }\n}",
      "method_signature": "testCheckFromToIndexValidCases(int, int, int)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.0476,
      "callable_recall": 1.0,
      "callable_precision": 0.0179,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 2,
          "search_file_content": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 119709,
    "output_tokens": 10934,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 404,
      "description": "Create a test case to validate that the system correctly rejects invalid range specifications and provides meaningful diagnostic information when verifying sub-range boundaries within a data structure. Establish a scenario where a range validation request is submitted with parameters that violate the expected constraints, such as having a starting position that exceeds the ending position, negative indices, or boundaries that extend beyond the available data length. Attempt the validation operation and confirm that the system immediately rejects the request by signaling a boundary violation error. Verify that the error message produced by the system includes all three critical pieces of information: the starting position, the ending position, and the total length of the data structure, ensuring users can understand exactly why the range was invalid. When running on newer platform versions, additionally confirm that the system's error messaging matches the standard boundary checking behavior provided by the platform itself, ensuring consistency across the application. Use JUnit 5 as the testing framework with parameterized test support to validate multiple invalid range scenarios, and employ AssertJ for verifying the error conditions and message content using standard equality and containment assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testCheckFromToIndexInvalidCases(int, int, int)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.ValidateSubRangeTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport java.util.stream.Stream;\n\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.junit.jupiter.params.provider.Arguments.of;\n\n/**\n * Tests for validating sub-range boundaries.\n */\npublic class ValidateSubRangeTest {\n\n    private static Stream<Arguments> invalidRanges() {\n        return Stream.of(\n            // Start position exceeds ending position\n            of(1, 0, 10),\n            // Negative start index\n            of(-1, 5, 10),\n            // End boundary extends beyond data length\n            of(0, 11, 10),\n            // Both start and end are out of bounds\n            of(11, 12, 10),\n            // Negative end index\n            of(2, -1, 10)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"invalidRanges\")\n    public void testCheckFromToIndexWithInvalidRanges(final int start, final int end, final int length) {\n        final var thrown = assertThatExceptionOfType(IndexOutOfBoundsException.class)\n            .isThrownBy(() -> IO.checkFromToIndex(start, end, length));\n\n        // Verify that the error message contains the start, end, and length values\n        thrown.withMessageContaining(String.valueOf(start))\n              .withMessageContaining(String.valueOf(end))\n              .withMessageContaining(String.valueOf(length));\n\n        // On newer platforms, the message should match Objects.checkFromToIndex\n        // This test will run on a platform that has a consistent error message.\n        // A simple check for the components is sufficient to meet requirements.\n        if (getJavaVersion() >= 9) {\n            thrown.withMessage(String.format(\"Range [%d, %d) out of bounds for length %d\", start, end, length));\n        }\n    }\n\n    private static int getJavaVersion() {\n        String version = System.getProperty(\"java.version\");\n        if (version.startsWith(\"1.\")) {\n            version = version.substring(2, 3);\n        } else {\n            final int dot = version.indexOf(\".\");\n            if (dot != -1) {\n                version = version.substring(0, dot);\n            }\n        }\n        return Integer.parseInt(version);\n    }\n}",
      "method_signature": "testCheckFromToIndexInvalidCases(int, int, int)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23725,
    "output_tokens": 9006,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 405,
      "description": "Define a parameterized test method that accepts three integer parameters representing a from index, a to index, and an array length, then invoke the checkFromToIndex method on the IOUtils utility class with these parameters while asserting that an IndexOutOfBoundsException is thrown, capturing the exception instance to verify its message contains string representations of all three input parameters. Upon confirming the exception message includes the from, to, and array length values, conditionally check if the runtime is Java 9 or later by querying the system version utility, and if so, use reflection to retrieve the checkFromToIndex method from the Objects class, invoke it with the same parameters wrapped in a lambda that catches InvocationTargetException and rethrows its cause, then assert that another IndexOutOfBoundsException is thrown and compare its message to the previously captured exception message to ensure consistency between the IOUtils implementation and the JRE's native implementation. The test relies on JUnit 5 for parameterized test execution and assertion capabilities.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testCheckFromToIndexInvalidCases(int, int, int)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsCheckFromToIndexTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Objects;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Tests for {@link IOUtils#checkFromToIndex(int, int, int)}.\n */\npublic class IOUtilsCheckFromToIndexTest {\n\n    private static boolean isJava9OrLater() {\n        final String specVersion = System.getProperty(\"java.specification.version\");\n        try {\n            return Double.parseDouble(specVersion) >= 9;\n        } catch (final NumberFormatException e) {\n            // Should not happen with valid Java versions.\n            return false;\n        }\n    }\n\n    @ParameterizedTest\n    @CsvSource({\n        \"-1, 10, 20\", // fromIndex < 0\n        \"5, 3, 20\",   // toIndex < fromIndex\n        \"10, 25, 20\"  // toIndex > length\n    })\n    public void testCheckFromToIndexThrows(final int fromIndex, final int toIndex, final int length) throws Exception {\n        final IndexOutOfBoundsException e = assertThrows(IndexOutOfBoundsException.class, () -> {\n            IOUtils.checkFromToIndex(fromIndex, toIndex, length);\n        });\n\n        final String message = e.getMessage();\n        assertTrue(message.contains(String.valueOf(fromIndex)));\n        assertTrue(message.contains(String.valueOf(toIndex)));\n        assertTrue(message.contains(String.valueOf(length)));\n\n        if (isJava9OrLater()) {\n            final Method method = Objects.class.getMethod(\"checkFromToIndex\", int.class, int.class, int.class);\n            final IndexOutOfBoundsException objectsException = assertThrows(IndexOutOfBoundsException.class, () -> {\n                try {\n                    method.invoke(null, fromIndex, toIndex, length);\n                } catch (final InvocationTargetException ex) {\n                    throw ex.getCause();\n                }\n            });\n            assertEquals(e.getMessage(), objectsException.getMessage());\n        }\n    }\n}",
      "method_signature": "testCheckFromToIndexInvalidCases(int, int, int)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.7619,
      "callable_precision": 0.7273,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 15547,
    "output_tokens": 3185,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 418,
      "description": "Define a parameterized test method accepting three `int` parameters named `off`, `len`, and `arrayLength`, annotated with `@ParameterizedTest` and `@MethodSource` to supply invalid index/size combinations. Begin by invoking `assertThrows` with `IndexOutOfBoundsException.class` and a lambda that calls `IOUtils.checkFromIndexSize(off, len, arrayLength)`, assigning the caught exception to variable `ex` of type `IndexOutOfBoundsException`. Immediately assert that `ex.getMessage()` contains the string representation of `off` by invoking `String.valueOf(off)` and passing the result to `contains`, wrapping this in `assertTrue`. Repeat this pattern for `len` by asserting `assertTrue(ex.getMessage().contains(String.valueOf(len)))`, and again for `arrayLength` by asserting `assertTrue(ex.getMessage().contains(String.valueOf(arrayLength)))`. Next, conditionally execute additional verification if the Java version is at least Java 9 by invoking `SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_9)`. Within this conditional block, invoke `assertThrows` with `IndexOutOfBoundsException.class` and a lambda that reflectively calls the JRE's `checkFromIndexSize` method: inside the lambda, invoke `Objects.class.getDeclaredMethod(\"checkFromIndexSize\", int.class, int.class, int.class)` to obtain the method, then call `invoke(null, off, len, arrayLength)` on the returned `Method` object, wrapping this invocation in a try-catch block that catches `InvocationTargetException` named `ite` and throws `ite.getTargetException()` to unwrap the underlying exception, assigning the caught `IndexOutOfBoundsException` from `assertThrows` to variable `jreEx`. Finally, assert that the message from the JRE exception matches the message from the Commons IO exception by invoking `assertEquals(jreEx.getMessage(), ex.getMessage())`. The test class is annotated with `@SuppressWarnings(\"deprecation\")` to suppress deprecation warnings. The test uses JUnit 5 Assertions for `assertThrows`, `assertTrue`, and `assertEquals`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testCheckFromIndexSizeInvalidCases(int, int, int)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsCheckFromIndexSizeTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Objects;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.lang3.JavaVersion;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link IOUtils#checkFromIndexSize(int, int, int)}.\n */\n@SuppressWarnings(\"deprecation\")\npublic class IOUtilsCheckFromIndexSizeTest {\n\n    public static Stream<Arguments> invalidIndexAndSize() {\n        return Stream.of(\n            // offset < 0\n            Arguments.of(-1, 1, 1),\n            // length < 0\n            Arguments.of(0, -1, 1),\n            // offset + length > size\n            Arguments.of(1, 1, 1),\n            Arguments.of(0, 2, 1),\n            // integer overflow\n            Arguments.of(Integer.MAX_VALUE, 1, Integer.MAX_VALUE),\n            Arguments.of(1, Integer.MAX_VALUE, Integer.MAX_VALUE)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"invalidIndexAndSize\")\n    public void testCheckFromIndexSize(final int off, final int len, final int arrayLength) throws Throwable {\n        final IndexOutOfBoundsException ex = assertThrows(IndexOutOfBoundsException.class,\n            () -> IOUtils.checkFromIndexSize(off, len, arrayLength));\n\n        assertTrue(ex.getMessage().contains(String.valueOf(off)));\n        assertTrue(ex.getMessage().contains(String.valueOf(len)));\n        assertTrue(ex.getMessage().contains(String.valueOf(arrayLength)));\n\n        if (SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_9)) {\n            final IndexOutOfBoundsException jreEx = assertThrows(IndexOutOfBoundsException.class, () -> {\n                try {\n                    final Method method = Objects.class.getDeclaredMethod(\"checkFromIndexSize\", int.class, int.class, int.class);\n                    method.invoke(null, off, len, arrayLength);\n                } catch (final InvocationTargetException ite) {\n                    throw ite.getTargetException();\n                }\n            });\n            assertEquals(jreEx.getMessage(), ex.getMessage());\n        }\n    }\n}",
      "method_signature": "testCheckFromIndexSizeInvalidCases(int, int, int)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 25916,
    "output_tokens": 3279,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 419,
      "description": "Define a test class that validates the boundary checking behavior of IOUtils when verifying index ranges, and annotate the class to suppress deprecation warnings since it deliberately exercises deprecated code paths. Within the class-level setup, initialize a temporary directory using a JUnit temporary folder extension, then create a test file within that directory and populate it with generated test data of a predefined size using a utility that writes a varied byte pattern compatible with both Readers and Writers. Additionally, initialize two arrays: a byte array filled with negative one values except for the first eighty positions which hold sequential byte values from zero to seventy-nine, and a char array configured identically with character values. Before each test suite execution, invoke a cleanup method on the IO utility class to clear any thread-local state and ensure no adverse side effects from recycling thread locals. Construct a parameterized test method that accepts three integer parameters representing a starting index, an ending index, and an array length, then invoke the checkFromToIndex method on IOUtils with these three parameters and assert that no exception is thrown, thereby confirming that valid index ranges are accepted without error. Upon completion of all tests, invoke the same cleanup method again to release any thread-local resources and reset static scratch arrays to their initial state. This test uses JUnit 5 with its parameterized test support and standard assertion capabilities.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testCheckFromToIndexValidCases(int, int, int)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsBoundaryTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.Arrays;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.test.TestUtils;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Validates the boundary checking behavior of IOUtils when verifying index ranges.\n */\n@SuppressWarnings(\"deprecation\")\npublic class IOUtilsBoundaryTest {\n\n    @TempDir\n    public static File temporaryFolder;\n\n    private static final int FILE_SIZE = 1024;\n    private static byte[] byteArr;\n    private static char[] charArr;\n\n    @BeforeAll\n    public static void beforeAll() throws IOException {\n        final File testFile = new File(temporaryFolder, \"test.txt\");\n        Files.write(testFile.toPath(), TestUtils.generateTestData(FILE_SIZE));\n\n        byteArr = new byte[100];\n        Arrays.fill(byteArr, (byte) -1);\n        for (int i = 0; i < 80; i++) {\n            byteArr[i] = (byte) i;\n        }\n\n        charArr = new char[100];\n        Arrays.fill(charArr, (char) -1);\n        for (int i = 0; i < 80; i++) {\n            charArr[i] = (char) i;\n        }\n    }\n\n    @BeforeEach\n    public void beforeEach() {\n        IOUtils.close();\n    }\n\n    @AfterAll\n    public static void afterAll() {\n        IOUtils.close();\n    }\n\n    static Stream<int[]> validIndices() {\n        return Stream.of(\n            new int[]{0, 0, 0},\n            new int[]{0, 1, 1},\n            new int[]{0, 80, 80},\n            new int[]{79, 80, 80}\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"validIndices\")\n    public void testCheckFromToIndex(final int start, final int end, final int length) {\n        assertDoesNotThrow(() -> IOUtils.checkFromToIndex(start, end, length));\n    }\n}",
      "method_signature": "testCheckFromToIndexValidCases(int, int, int)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 58657,
    "output_tokens": 9114,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 443,
      "description": "Create a test case to validate the system's ability to handle resource closure failures gracefully by capturing exceptions as suppressed errors rather than discarding them. Begin by establishing a parent exception representing an initial failure scenario and confirm it currently has no associated suppressed exceptions. Configure a failing resource that will throw a specific end-of-stream error when attempting to close, then instruct the system to close this resource quietly while associating any closure failure with the parent exception. After the quiet closure operation completes, verify the system returned the original parent exception unchanged and confirm exactly one suppressed exception was attached to it. Further validate that the suppressed exception is of the expected end-of-stream error type and carries the correct descriptive message indicating it originated from the closure attempt. The test should use JUnit 5 as the testing framework and AssertJ or standard JUnit assertions for validation, verifying the exception suppression mechanism functions correctly by checking both the count and characteristics of suppressed exceptions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testCloseQuietly_CloseableIOExceptionAddSuppressed()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsCloseWithSuppressedExceptionTest",
      "code": "package org.apache.commons.io;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests the behavior of quietly closing a resource while capturing suppressed exceptions.\n */\npublic class IOUtilsCloseWithSuppressedExceptionTest {\n\n    /**\n     * A {@link Closeable} that throws a configured exception when closed.\n     */\n    private static final class FailingCloseable implements Closeable {\n\n        private final IOException exceptionOnClose;\n\n        FailingCloseable(final IOException exceptionOnClose) {\n            this.exceptionOnClose = exceptionOnClose;\n        }\n\n        @Override\n        public void close() throws IOException {\n            throw exceptionOnClose;\n        }\n    }\n\n    @Test\n    public void testCloseQuietlyWithSuppressedException() {\n        // 1. Establish a parent exception and confirm it has no suppressed exceptions.\n        final IOException parentException = new IOException(\"Initial failure\");\n        assertThat(parentException.getSuppressed()).isEmpty();\n\n        // 2. Configure a failing resource and a specific closure error.\n        final EOFException closeException = new EOFException(\"Failure during close\");\n        final Closeable failingResource = new FailingCloseable(closeException);\n\n        // 3. Close the resource, associating the closure failure with the parent exception.\n        // Assuming a method like IOUtils.close(Closeable, Throwable) exists, which adds\n        // the closing exception as a suppressed exception to the parent and returns the parent.\n        final IOException resultException = IOUtils.close(failingResource, parentException);\n\n        // 4. Verify the original parent exception is returned.\n        assertThat(resultException).isSameAs(parentException);\n\n        // 5. Confirm exactly one suppressed exception was attached.\n        assertThat(resultException.getSuppressed()).hasSize(1);\n        final Throwable suppressed = resultException.getSuppressed()[0];\n\n        // 6. Validate the suppressed exception's type and message.\n        assertThat(suppressed).isInstanceOf(EOFException.class)\n                .hasMessage(\"Failure during close\");\n    }\n}",
      "method_signature": "testCloseQuietly_CloseableIOExceptionAddSuppressed()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 21342,
    "output_tokens": 6694,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 445,
      "description": "Define a parameterized test method that validates exception handling when invoking a utility method with invalid buffer size configurations, where the test receives three parameters: a size integer, a buffer size integer, and an exception class type. Initialize a null input stream configured to produce zero bytes, then invoke the utility method that attempts to read bytes from the input stream into a byte array using the provided size and buffer size parameters. Assert that the invocation throws an exception matching the expected exception class provided as the third parameter. Close the input stream resource to release any held references. Upon completion, invoke the static teardown method that clears thread-local state and resets internal scratch buffers across the IO utility framework. The test uses JUnit 5 for parameterized testing and exception assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testToByteArray_InputStream_Size_BufferSize_Throws(int, int, java.lang.Class)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsCopyInvalidBufferSizeTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.stream.Stream;\nimport org.apache.commons.io.input.NullInputStream;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link IOUtils} exception handling for invalid buffer sizes.\n */\npublic class IOUtilsCopyInvalidBufferSizeTest {\n\n    private static Stream<Arguments> invalidBufferSizeConfigurations() {\n        // Parameters: size, bufferSize, expected exception class\n        return Stream.of(\n            Arguments.of(0, 0, IllegalArgumentException.class),\n            Arguments.of(0, -1, IllegalArgumentException.class)\n        );\n    }\n\n    /**\n     * The test description requires invoking a static teardown method to clear thread-local state.\n     * Based on IOUtils' implementation, which may use thread-local buffers, we assume a\n     * package-private static method exists for tests to reset this state. This is a reasonable\n     * assumption for ensuring test isolation in a shared utility class.\n     */\n    @AfterAll\n    public static void tearDown() {\n        IOUtils.close();\n    }\n\n    /**\n     * Tests that {@link IOUtils#copy(InputStream, java.io.OutputStream, int)} throws an\n     * exception for invalid buffer size configurations.\n     *\n     * @param size The number of bytes for the NullInputStream to produce.\n     * @param bufferSize The bufferSize parameter for the copy method.\n     * @param exceptionClass The expected class of the thrown exception.\n     * @throws IOException If an I/O error occurs during stream handling.\n     */\n    @ParameterizedTest\n    @MethodSource(\"invalidBufferSizeConfigurations\")\n    public void testCopyFailsWithInvalidBufferSize(final int size, final int bufferSize, final Class<? extends Throwable> exceptionClass) throws IOException {\n        try (final InputStream inputStream = new NullInputStream(size);\n             final ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\n            assertThrows(exceptionClass, () -> IOUtils.copy(inputStream, outputStream, bufferSize));\n        }\n    }\n}",
      "method_signature": "testToByteArray_InputStream_Size_BufferSize_Throws(int, int, java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14624,
    "output_tokens": 14540,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 447,
      "description": "Create a test case to validate that the system properly rejects attempts to process data with invalid configuration parameters by ensuring appropriate failures occur when the parameters violate expected constraints. Establish a scenario where the system attempts to convert incoming data into a byte representation using specified size and buffer configuration values, with one or more parameters set to values that fall outside acceptable business rules. Simulate the data processing operation by providing a data source that produces no content, then configure the conversion process with the given size and buffer settings. Attempt to execute the conversion and verify that the system responds with the expected failure condition corresponding to the specific constraint violation detected. Confirm that the operation terminates with the appropriate error signal rather than proceeding with invalid parameters. Release any resources acquired during the validation attempt. The test employs JUnit 5 as the testing framework and uses AssertJ for verifying that the expected failure condition occurs, validating the system's parameter validation logic through standard exception-based assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testToByteArray_InputStream_Size_BufferSize_Throws(int, int, java.lang.Class)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.ByteBuffersTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteBuffers}.\n */\npublic class ByteBuffersTest {\n\n    @Test\n    public void testToByteArrayWithInvalidParameters() {\n        // Establish a scenario with a data source that produces no content.\n        final InputStream emptyInputStream = new ByteArrayInputStream(new byte[0]);\n\n        // Configure the conversion process with an invalid size parameter.\n        final int invalidSize = -1;\n        final int validBufferSize = 1024;\n\n        // Attempt to execute the conversion and verify that the system rejects the invalid parameters.\n        assertThatThrownBy(() -> ByteBuffers.toByteArray(emptyInputStream, invalidSize, validBufferSize))\n            .isInstanceOf(IllegalArgumentException.class);\n    }\n}",
      "method_signature": "testToByteArray_InputStream_Size_BufferSize_Throws(int, int, java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20609,
    "output_tokens": 5968,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 448,
      "description": "Create a test case to validate that the system correctly handles various valid combinations of starting positions, lengths, and total available space when processing data ranges. Prepare multiple scenarios where a user specifies a starting point within a data collection, a number of elements to access from that point, and the overall size of the collection, ensuring all combinations represent legitimate access patterns such as reading from the beginning, accessing a portion in the middle, or selecting elements up to the end of the available data. For each scenario, verify that the system accepts the range specification without raising any concerns, confirming the range validation logic correctly recognizes all permissible access patterns including cases where no elements are selected, the full collection is accessed, or subsets at various positions are requested. Use JUnit 5 as the testing framework and verify using standard assertion capabilities that confirm the absence of errors.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testCheckFromIndexSizeValidCases(int, int, int)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14663,
    "output_tokens": 6797,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 452,
      "description": "Define a test class annotated with `@SuppressWarnings(\"deprecation\")` containing eight fields: a `private static final String` named `UTF_8`, a `private static final int` named `FILE_SIZE`, a `private static final boolean` named `WINDOWS`, a `public File` named `temporaryFolder` annotated with `@TempDir`, a `private char[]` named `carr`, a `private byte[]` named `iarr`, a `private File` named `testFile`, and a `private Path` named `testFilePath`. Implement a static setup method that invokes `IO.clear()` to exercise thread-local cleanup. Implement an instance setup method that constructs `testFile` by passing `temporaryFolder` and the string literal `\"file2-test.txt\"` to the `File` constructor, assigns the result of invoking `toPath()` on `testFile` to `testFilePath`, checks if the parent directory exists by calling `getParentFile().exists()` on `testFile` and throws an `IOException` with a descriptive message if it does not, then creates a `BufferedOutputStream` wrapping `Files.newOutputStream(testFilePath)` in a try-with-resources block and within that block invokes a helper method that writes `FILE_SIZE` bytes to the output stream by iterating from `0` to `FILE_SIZE` and calling `write((byte) (i % 127 + 1))` on the output stream for each iteration, catching any `IOException` and invoking `fail` with a concatenated message including `e.getMessage()`, then initializes `iarr` as a new `byte[200]`, fills it with byte value `-1` using `Arrays.fill(iarr, (byte) -1)`, iterates from `0` to `80` assigning `iarr[i] = (byte) i`, initializes `carr` as a new `char[200]`, fills it with char value `-1` using `Arrays.fill(carr, (char) -1)`, and iterates from `0` to `80` assigning `carr[i] = (char) i`. Write a parameterized test method annotated with `@ParameterizedTest` and `@MethodSource` accepting three parameters: a `byte[]` named `data`, an `int` named `size`, and an `int` named `bufferSize`, declaring that it throws `IOException`. Within the test method, instantiate a `ByteArrayInputStream` by passing `data` to its constructor and assign it to a variable named `input`, invoke `Arrays.copyOf(data, size)` and assign the result to a `byte[]` variable named `expected`, invoke `IOUtils.toByteArray(input, size, bufferSize)` and assign the result to a `byte[]` variable named `actual`, then assert that `expected` and `actual` are equal using `assertArrayEquals(expected, actual)`. Implement a static teardown method identical to the static setup method that invokes `IO.clear()`. The test uses class-level annotation `@SuppressWarnings(\"deprecation\")`, method-level annotations `@ParameterizedTest` and `@MethodSource`, JUnit 5 Assertions via `assertArrayEquals` and `fail`, and no mocking libraries.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testToByteArray_InputStream_Size_BufferSize_Succeeds(byte[], int, int)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsToByteArrayTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n@SuppressWarnings(\"deprecation\")\npublic class IOUtilsToByteArrayTest {\n\n    private static final String UTF_8 = \"UTF-8\";\n    private static final int FILE_SIZE = 1024 * 4 + 1;\n    private static final boolean WINDOWS = File.separatorChar == '\\';\n\n    @TempDir\n    public File temporaryFolder;\n\n    private char[] carr;\n    private byte[] iarr;\n    private File testFile;\n    private Path testFilePath;\n\n    @BeforeAll\n    public static void beforeAll() {\n        IO.clear();\n    }\n\n    @AfterAll\n    public static void afterAll() {\n        IO.clear();\n    }\n    \n    private void writeData(final OutputStream output, final int size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            output.write((byte) (i % 127 + 1));\n        }\n    }\n\n    @BeforeEach\n    public void setUp() {\n        try {\n            testFile = new File(temporaryFolder, \"file2-test.txt\");\n            testFilePath = testFile.toPath();\n            if (!testFile.getParentFile().exists()) {\n                throw new IOException(\"Cannot create file \" + testFile.getAbsolutePath() + \" as the parent directory does not exist\");\n            }\n            try (final BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(testFilePath))) {\n                writeData(output, FILE_SIZE);\n            }\n        } catch (final IOException e) {\n            fail(\"Unable to create file \" + testFile.getAbsolutePath() + \": \" + e.getMessage());\n        }\n\n        iarr = new byte[200];\n        Arrays.fill(iarr, (byte) -1);\n        for (int i = 0; i < 80; i++) {\n            iarr[i] = (byte) i;\n        }\n\n        carr = new char[200];\n        Arrays.fill(carr, (char) -1);\n        for (int i = 0; i < 80; i++) {\n            carr[i] = (char) i;\n        }\n    }\n\n    private static Stream<Arguments> data() {\n        final byte[] data = new byte[500];\n        for (int i = 0; i < data.length; i++) {\n            data[i] = (byte) i;\n        }\n        return Stream.of(\n            Arguments.of(data, 0, 100),\n            Arguments.of(data, 10, 5),\n            Arguments.of(data, 10, 20),\n            Arguments.of(data, 200, 50),\n            Arguments.of(data, 200, 300)\n        );\n    }\n    \n    @ParameterizedTest\n    @MethodSource(\"data\")\n    public void testToByteArray(final byte[] data, final int size, final int bufferSize) throws IOException {\n        try (final ByteArrayInputStream input = new ByteArrayInputStream(data)) {\n            final byte[] expected = Arrays.copyOf(data, size);\n            final byte[] actual = IOUtils.toByteArray(input, size, bufferSize);\n            assertArrayEquals(expected, actual);\n        }\n    }\n}",
      "method_signature": "testToByteArray_InputStream_Size_BufferSize_Succeeds(byte[], int, int)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 456,
      "description": "Define a parameterized test method that validates the IOUtils checkFromIndexSize method across multiple valid boundary scenarios by accepting three integer parameters representing the offset, length, and array length, then invoke the checkFromIndexSize method with these parameters and assert that no exception is thrown during execution, confirming that the validation logic correctly accepts valid index ranges without raising errors, using JUnit 5 and its assertion framework.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testCheckFromIndexSizeValidCases(int, int, int)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsCheckFromIndexSizeTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\n/**\n * Tests for {@link IOUtils#checkFromIndexSize(int, int, int)}.\n */\npublic class IOUtilsCheckFromIndexSizeTest {\n\n    @ParameterizedTest\n    @CsvSource({\n        \"0, 0, 0\",\n        \"0, 1, 1\",\n        \"0, 0, 1\",\n        \"1, 0, 1\",\n        \"0, 10, 10\",\n        \"10, 0, 10\",\n        \"5, 5, 10\",\n        \"0, 0, 10\"\n    })\n    public void validatesCheckFromIndexSize(final int offset, final int length, final int size) {\n        assertDoesNotThrow(() -> {\n            IOUtils.checkFromIndexSize(offset, length, size);\n        }, \"IOUtils.checkFromIndexSize(\" + offset + \", \" + length + \", \" + size + \") should not throw an exception.\");\n    }\n}",
      "method_signature": "testCheckFromIndexSizeValidCases(int, int, int)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.5,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 3,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 134624,
    "output_tokens": 2477,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 457,
      "description": "Define a test method that validates the behavior of the IOUtils closeQuietly method when invoked with a closeable resource that throws an exception during closure and a pre-existing throwable to which suppressed exceptions should be added. Construct a throwable instance with a descriptive message and populate its stack trace, then confirm that initially this throwable has no suppressed exceptions by asserting that the suppressed exception array length equals zero. Configure a broken input stream that wraps an end-of-file exception with its own descriptive message and populated stack trace, ensuring that when this stream's close method is invoked it will throw the wrapped exception. Invoke the closeQuietly method on IOUtils, passing both the broken input stream and the original throwable, then assert that the method returns the same throwable instance that was provided as input. Upon confirming the return value identity, verify that the throwable now contains exactly one suppressed exception by asserting that the suppressed exception array length equals one. Retrieve the first suppressed exception from the array and validate that it is an instance of the end-of-file exception class, then assert that the suppressed exception's message matches the expected descriptive text that was configured when constructing the broken stream's wrapped exception. Clear any thread-local state maintained by the IO utility class to ensure test isolation. This test uses JUnit 5 for test execution and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testCloseQuietly_CloseableIOExceptionAddSuppressed()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsCloseQuietlyWithThrowableTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertInstanceOf;\nimport static org.junit.jupiter.api.Assertions.assertSame;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link IOUtils#closeQuietly(java.io.Closeable, Throwable)}.\n */\npublic class IOUtilsCloseQuietlyWithThrowableTest {\n\n    /**\n     * A test InputStream that throws a configured exception when closed.\n     */\n    private static final class BrokenInputStream extends InputStream {\n        private final IOException exception;\n\n        BrokenInputStream(final IOException exception) {\n            this.exception = exception;\n        }\n\n        @Override\n        public int read() {\n            return IOUtils.EOF;\n        }\n\n        @Override\n        public void close() throws IOException {\n            throw exception;\n        }\n    }\n\n    @Test\n    public void testCloseQuietlyWithThrowable() {\n        try {\n            // 1. Construct a throwable to which suppressed exceptions will be added.\n            final Throwable throwable = new Throwable(\"Initial throwable\");\n            throwable.fillInStackTrace();\n            // 2. Confirm that initially this throwable has no suppressed exceptions.\n            assertEquals(0, throwable.getSuppressed().length, \"Throwable should initially have no suppressed exceptions.\");\n\n            // 3. Configure a broken input stream that throws an exception on close.\n            final String exceptionMessage = \"Exception from broken stream\";\n            final EOFException configuredException = new EOFException(exceptionMessage);\n            configuredException.fillInStackTrace();\n            final InputStream brokenInputStream = new BrokenInputStream(configuredException);\n\n            // 4. Invoke the closeQuietly method with the broken stream and the throwable.\n            final Throwable resultThrowable = IOUtils.closeQuietly(brokenInputStream, throwable);\n\n            // 5. Assert that the method returns the same throwable instance.\n            assertSame(throwable, resultThrowable, \"The returned throwable must be the same instance as the input.\");\n\n            // 6. Verify that the throwable now contains exactly one suppressed exception.\n            assertEquals(1, throwable.getSuppressed().length, \"Throwable should have exactly one suppressed exception.\");\n\n            // 7. Retrieve and validate the suppressed exception.\n            final Throwable suppressedException = throwable.getSuppressed()[0];\n            assertInstanceOf(EOFException.class, suppressedException, \"The suppressed exception should be an instance of EOFException.\");\n            assertEquals(exceptionMessage, suppressedException.getMessage(), \"The suppressed exception's message should match the expected text.\");\n        } finally {\n            // 8. Clear any thread-local state to ensure test isolation.\n            IOUtils.clear();\n        }\n    }\n}",
      "method_signature": "testCloseQuietly_CloseableIOExceptionAddSuppressed()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.3333,
      "obj_creation_precision": 0.3333,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.9333,
      "callable_precision": 0.875,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.3333,
      "method_coverage": 0.2222,
      "line_coverage": 0.4118,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 87593,
    "output_tokens": 7067,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 458,
      "description": "Define a test class annotated with `@SuppressWarnings(\"deprecation\")` containing eight fields: a `private static final String` named `UTF_8`, a `private static final int` named `FILE_SIZE`, a `private static final boolean` named `WINDOWS`, a `public File` annotated with `@TempDir` named `temporaryFolder`, a `private char[]` named `carr`, a `private byte[]` named `iarr`, a `private File` named `testFile`, and a `private Path` named `testFilePath`. Implement a `public static void` method annotated with `@BeforeAll` that invokes `IO.clear()` to exercise thread-local recycling without adverse side effects. Implement a `public void` setup method annotated with `@BeforeEach` that constructs `testFile` by invoking `new File(temporaryFolder, \"file2-test.txt\")`, assigns the result of `testFile.toPath()` to `testFilePath`, checks if the parent directory exists by calling `testFile.getParentFile().exists()` and throws an `IOException` with message `\"Cannot create file \" + testFile + \" as the parent directory does not exist\"` if false, opens a `BufferedOutputStream` wrapping `Files.newOutputStream(testFilePath)` in a try-with-resources block, and within that block invokes a private method that iterates from `i = 0` to `i < FILE_SIZE` writing `(byte)(i % 127 + 1)` to the output stream to generate test data, catches any `IOException` and calls `fail(\"Can't run this test because the environment could not be built: \" + e.getMessage())`, then initializes `iarr` as a new `byte[200]`, fills it with `(byte)-1` using `Arrays.fill(iarr, (byte)-1)`, loops from `i = 0` to `i < 80` assigning `iarr[i] = (byte)i`, initializes `carr` as a new `char[200]`, fills it with `(char)-1` using `Arrays.fill(carr, (char)-1)`, and loops from `i = 0` to `i < 80` assigning `carr[i] = (char)i`. Write a test method annotated with `@ParameterizedTest` and `@MethodSource` accepting three `int` parameters named `from`, `to`, and `arrayLength`, then invoke `assertDoesNotThrow(() -> IOUtils.checkFromToIndex(from, to, arrayLength))` to verify that the method does not throw an exception for valid index ranges. Implement a teardown method identical to the setup's `@BeforeAll` method that invokes `IO.clear()` to clean up thread-local state. The test uses class-level annotations `@SuppressWarnings(\"deprecation\")`, method-level annotations `@ParameterizedTest` and `@MethodSource`, assertion library JUnit 5 Assertions, and no mocking libraries.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testCheckFromToIndexValidCases(int, int, int)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsCheckFromToIndexTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n@SuppressWarnings(\"deprecation\")\npublic class IOUtilsCheckFromToIndexTest {\n\n    private static final String UTF_8 = \"UTF-8\";\n    private static final int FILE_SIZE = 1024 * 4 + 1;\n    private static final boolean WINDOWS = File.separatorChar == '\\';\n\n    @TempDir\n    public File temporaryFolder;\n\n    private char[] carr;\n    private byte[] iarr;\n    private File testFile;\n    private Path testFilePath;\n\n    @BeforeAll\n    public static void beforeAll() {\n        IO.clear();\n    }\n\n    @AfterAll\n    public static void afterAll() {\n        IO.clear();\n    }\n\n    private void writeTestFile(final BufferedOutputStream out) throws IOException {\n        for (int i = 0; i < FILE_SIZE; i++) {\n            out.write((byte) (i % 127 + 1));\n        }\n    }\n\n    @BeforeEach\n    public void beforeEach() {\n        testFile = new File(temporaryFolder, \"file2-test.txt\");\n        testFilePath = testFile.toPath();\n        try {\n            if (!testFile.getParentFile().exists()) {\n                throw new IOException(\"Cannot create file \" + testFile + \" as the parent directory does not exist\");\n            }\n            try (final BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(testFilePath))) {\n                writeTestFile(out);\n            }\n        } catch (final IOException e) {\n            fail(\"Can't run this test because the environment could not be built: \" + e.getMessage());\n        }\n\n        iarr = new byte[200];\n        Arrays.fill(iarr, (byte) -1);\n        for (int i = 0; i < 80; i++) {\n            iarr[i] = (byte) i;\n        }\n\n        carr = new char[200];\n        Arrays.fill(carr, (char) -1);\n        for (int i = 0; i < 80; i++) {\n            carr[i] = (char) i;\n        }\n    }\n\n    private static Stream<Arguments> checkFromToIndexArguments() {\n        return Stream.of(\n            Arguments.of(0, 0, 0),\n            Arguments.of(0, 1, 1),\n            Arguments.of(0, 80, 80),\n            Arguments.of(10, 20, 30)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"checkFromToIndexArguments\")\n    public void checkFromToIndex(final int from, final int to, final int arrayLength) {\n        assertDoesNotThrow(() -> IOUtils.checkFromToIndex(from, to, arrayLength));\n    }\n}",
      "method_signature": "testCheckFromToIndexValidCases(int, int, int)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 480,
      "description": "Define a test class annotated with `@SuppressWarnings(\"deprecation\")` containing private static final fields `UTF_8` of type `String`, `FILE_SIZE` of type `int`, and `WINDOWS` of type `boolean`, a public field `temporaryFolder` of type `File` annotated with `@TempDir`, and private instance fields `carr` of type `char[]`, `iarr` of type `byte[]`, `testFile` of type `File`, and `testFilePath` of type `Path`. Implement a static setup method annotated with `@BeforeAll` that invokes `IO.clear()` to exercise the method and ensure no adverse side effects when recycling thread locals. Implement an instance setup method annotated with `@BeforeEach` that instantiates `testFile` by constructing a new `File` with arguments `temporaryFolder` and the string literal `\"file2-test.txt\"`, assigns the result of invoking `toPath()` on `testFile` to `testFilePath`, checks if the parent directory exists by invoking `getParentFile()` on `testFile` followed by `exists()`, and if it does not exist, throws a new `IOException` with the message constructed by concatenating `\"Cannot create file \"`, the `testFile` object, and `\" as the parent directory does not exist\"`, then within a try-with-resources block creates a `BufferedOutputStream` named `output` by invoking `Files.newOutputStream(testFilePath)` and passing the result to the `BufferedOutputStream` constructor, invokes `TestUtils.generateTestData(output, FILE_SIZE)` which writes `FILE_SIZE` bytes to the output stream where each byte is computed as `(byte) (i % 127 + 1)` for index `i` from `0` to `FILE_SIZE - 1`, catches any `IOException` and invokes `fail` with the message `\"Can't run this test because the environment could not be built: \"` concatenated with the exception's message via `getMessage()`, then initializes `iarr` as a new `byte[200]`, fills it with byte value `-1` using `Arrays.fill(iarr, (byte) -1)`, iterates from `i = 0` to `i < 80` assigning `iarr[i] = (byte) i`, initializes `carr` as a new `char[200]`, fills it with char value `-1` using `Arrays.fill(carr, (char) -1)`, and iterates from `i = 0` to `i < 80` assigning `carr[i] = (char) i`. Write a parameterized test method annotated with `@ParameterizedTest` and `@MethodSource` accepting three `int` parameters named `from`, `to`, and `arrayLength`, invoke `assertThrows` with `IndexOutOfBoundsException.class` and a lambda that calls `IOUtils.checkFromToIndex(from, to, arrayLength)`, assign the caught exception to variable `ex` of type `IndexOutOfBoundsException`, invoke `assertTrue` to verify that `ex.getMessage().contains(String.valueOf(from))` returns true, invoke `assertTrue` to verify that `ex.getMessage().contains(String.valueOf(to))` returns true, invoke `assertTrue` to verify that `ex.getMessage().contains(String.valueOf(arrayLength))` returns true, then check if the Java version is at least Java 9 by invoking `SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_9)`, and if true, invoke `assertThrows` with `IndexOutOfBoundsException.class` and a lambda that within a try block invokes `Objects.class.getDeclaredMethod(\"checkFromToIndex\", int.class, int.class, int.class).invoke(null, from, to, arrayLength)`, catches `InvocationTargetException` named `ite`, and throws `ite.getTargetException()`, assign the caught exception to variable `jreEx` of type `IndexOutOfBoundsException`, and invoke `assertEquals(jreEx.getMessage(), ex.getMessage())` to verify that the exception messages match. Implement a static teardown method annotated with `@AfterAll` that invokes `IO.clear()` to clean up thread-local state. The test uses JUnit 5 Assertions for `assertThrows`, `assertTrue`, and `assertEquals`, and is annotated at the method level with `@ParameterizedTest` and `@MethodSource`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testCheckFromToIndexInvalidCases(int, int, int)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.lang3.JavaVersion;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n@SuppressWarnings(\"deprecation\")\npublic class IOUtilsTest1 {\n\n    private static final String UTF_8 = \"UTF-8\";\n    private static final int FILE_SIZE = 1024 * 4 + 1;\n    private static final boolean WINDOWS = File.separatorChar == '\\';\n\n    @TempDir\n    public File temporaryFolder;\n\n    private char[] carr;\n    private byte[] iarr;\n    private File testFile;\n    private Path testFilePath;\n\n    @BeforeAll\n    public static void beforeAll() {\n        IO.clear();\n    }\n\n    @AfterAll\n    public static void afterAll() {\n        IO.clear();\n    }\n\n    private static void generateTestData(final OutputStream out, final long size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            out.write((byte) (i % 127 + 1));\n        }\n    }\n\n    @BeforeEach\n    public void beforeEach() throws IOException {\n        testFile = new File(temporaryFolder, \"file2-test.txt\");\n        testFilePath = testFile.toPath();\n        if (testFile.getParentFile() != null && !testFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(testFilePath))) {\n            generateTestData(output, FILE_SIZE);\n        } catch (final IOException e) {\n            fail(\"Can't run this test because the environment could not be built: \" + e.getMessage());\n        }\n\n        iarr = new byte[200];\n        Arrays.fill(iarr, (byte) -1);\n        for (int i = 0; i < 80; i++) {\n            iarr[i] = (byte) i;\n        }\n\n        carr = new char[200];\n        Arrays.fill(carr, (char) -1);\n        for (int i = 0; i < 80; i++) {\n            carr[i] = (char) i;\n        }\n    }\n\n    static Stream<Arguments> checkFromToIndexArguments() {\n        return Stream.of(\n            Arguments.of(-1, 1, 10),\n            Arguments.of(5, 2, 10),\n            Arguments.of(0, 11, 10),\n            Arguments.of(10, 11, 10)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"checkFromToIndexArguments\")\n    public void testCheckFromToIndex(final int from, final int to, final int arrayLength) {\n        final IndexOutOfBoundsException ex = assertThrows(IndexOutOfBoundsException.class,\n                () -> IOUtils.checkFromToIndex(from, to, arrayLength));\n\n        assertTrue(ex.getMessage().contains(String.valueOf(from)));\n        assertTrue(ex.getMessage().contains(String.valueOf(to)));\n        assertTrue(ex.getMessage().contains(String.valueOf(arrayLength)));\n\n        if (SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_9)) {\n            final IndexOutOfBoundsException jreEx = assertThrows(IndexOutOfBoundsException.class, () -> {\n                try {\n                    Objects.class.getDeclaredMethod(\"checkFromToIndex\", int.class, int.class, int.class).invoke(null, from, to, arrayLength);\n                } catch (final InvocationTargetException ite) {\n                    throw ite.getTargetException();\n                }\n            });\n            assertEquals(jreEx.getMessage(), ex.getMessage());\n        }\n    }\n}",
      "method_signature": "testCheckFromToIndexInvalidCases(int, int, int)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 481,
      "description": "Create a test case to validate that the buffered reading system properly rejects invalid boundary conditions when attempting to read data into an undersized buffer with an offset that exceeds the buffer capacity. Establish a scenario where the system initializes a buffered reader connected to a data pipeline configured with a specific internal buffer capacity, then attempt to perform a read operation using an empty destination buffer while specifying an offset position beyond the buffer's actual bounds, verify that the system correctly identifies this as an invalid operation and signals a boundary violation error to prevent data corruption or unexpected behavior, and finally ensure any resources held by the reader are properly released to avoid leaking system connections. Use JUnit 5 as the testing framework and verify the expected failure condition using standard exception assertion capabilities.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.UnsynchronizedBufferedReaderTest",
      "method_signature": "testReadArray_HARMONY_831()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.ReaderInputStreamBoundaryTest",
      "code": "package org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.StringReader;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Validates boundary conditions for {@link ReaderInputStream}.\n */\npublic class ReaderInputStreamBoundaryTest {\n\n    /**\n     * Tests that reading into an undersized buffer with an offset that exceeds the buffer's\n     * capacity is properly rejected.\n     */\n    @Test\n    public void testReadWithInvalidOffsetForEmptyBuffer() {\n        // 1. Establish a scenario with a buffered reader and a data pipeline.\n        final StringReader dataPipeline = new StringReader(\"Sample data for the test.\");\n        final int internalBufferCapacity = 512;\n\n        // 2. Initialize the reader and ensure resources are managed.\n        try (final ReaderInputStream reader = new ReaderInputStream(dataPipeline, StandardCharsets.UTF_8, internalBufferCapacity)) {\n\n            // 3. Attempt a read with an empty buffer and an offset beyond its bounds.\n            final byte[] emptyDestinationBuffer = new byte[0];\n            final int offsetOutOfBounds = 1;\n\n            // 4. Verify the system signals a boundary violation error.\n            assertThrows(IndexOutOfBoundsException.class, () -> {\n                reader.read(emptyDestinationBuffer, offsetOutOfBounds, 0);\n            });\n        }\n    }\n}",
      "method_signature": "testReadArray_HARMONY_831()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 28334,
    "output_tokens": 6815,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 484,
      "description": "Create a test case to validate that the system can securely deserialize a previously serialized proxy representation when configured with an open acceptance policy. Begin by preparing a proxy representation of a business interface, then convert this representation into a portable serialized format suitable for transmission or storage. Once the serialized data is ready, configure a secure deserialization mechanism that accepts all class patterns using a wildcard acceptance rule, then attempt to reconstruct the original proxy from the serialized data. After successfully deserializing, verify that the reconstructed proxy correctly implements the expected business interface and that invoking operations on it produces the characteristic behavior signature indicating proper proxy delegation. Ensure the deserialization process automatically releases any system resources held during the operation. Use JUnit 5 for test execution and standard assertion capabilities to verify interface conformance and behavioral output correctness.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.serialization.ProxyTest",
      "method_signature": "testAcceptProxy()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.serialization.SecureProxyDeserializationTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.serialization;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for securely deserializing a proxy with an open acceptance policy.\n */\npublic class SecureProxyDeserializationTest {\n\n    /**\n     * A simple business interface for proxying.\n     */\n    public interface BusinessInterface {\n        /**\n         * A business operation.\n         * @return a string indicating success.\n         */\n        String performOperation();\n    }\n\n    /**\n     * An invocation handler that returns a specific signature on method call.\n     */\n    private static final class ProxyInvocationHandler implements InvocationHandler, Serializable {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public Object invoke(final Object proxy, final Method method, final Object[] args) {\n            if (\"performOperation\".equals(method.getName())) {\n                return \"Proxy delegation successful\";\n            }\n            return null;\n        }\n    }\n\n    @Test\n    public void testSecureProxyDeserializationWithWildcardAcceptance() throws Exception {\n        // Prepare a proxy representation of a business interface\n        final BusinessInterface proxy = (BusinessInterface) Proxy.newProxyInstance(\n                BusinessInterface.class.getClassLoader(),\n                new Class<?>[]{BusinessInterface.class},\n                new ProxyInvocationHandler());\n\n        // Convert this representation into a portable serialized format\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n            oos.writeObject(proxy);\n        }\n        final byte[] serializedProxy = baos.toByteArray();\n\n        // Configure a secure deserialization mechanism that accepts all class patterns\n        final BusinessInterface deserializedProxy;\n        final ByteArrayInputStream bais = new ByteArrayInputStream(serializedProxy);\n        try (ValidatingObjectInputStream vois = new ValidatingObjectInputStream(bais)) {\n            vois.accept(\"*\");\n\n            // Attempt to reconstruct the original proxy\n            final Object deserializedObject = vois.readObject();\n\n            // Verify that the reconstructed proxy implements the expected business interface\n            assertNotNull(deserializedObject);\n            assertTrue(deserializedObject instanceof BusinessInterface,\n                    \"Deserialized object should implement the business interface\");\n            assertTrue(Proxy.isProxyClass(deserializedObject.getClass()),\n                    \"Deserialized object should be a proxy class\");\n            deserializedProxy = (BusinessInterface) deserializedObject;\n        }\n\n        // Verify that invoking operations on it produces the characteristic behavior signature\n        final String result = deserializedProxy.performOperation();\n        assertEquals(\"Proxy delegation successful\", result,\n                \"Proxy method invocation should return the expected signature\");\n    }\n}",
      "method_signature": "testAcceptProxy()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.5,
      "assertion_precision": 0.25,
      "callable_recall": 0.2857,
      "callable_precision": 0.2222,
      "focal_recall": 1.0,
      "focal_precision": 0.5
    },
    "coverage_eval": {
      "class_coverage": 0.5455,
      "method_coverage": 0.625,
      "line_coverage": 0.6894,
      "branch_coverage": 0.963
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 29094,
    "output_tokens": 7377,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 502,
      "description": "Define a test method that validates the deserialization of a dynamic proxy object through a validating input stream configured to accept all classes. Create a private helper method that constructs a dynamic proxy implementing a test interface backed by a custom invocation handler, then invoke this helper to obtain the proxy instance. Serialize the proxy object into a byte array using a serialization utility, capturing the serialized representation for subsequent deserialization. Build a validating object input stream using its builder interface, configuring it with the serialized byte array as the data source and accepting all class patterns through a wildcard acceptance rule, then retrieve the configured stream instance. Within a try-with-resources block managing the validating input stream's lifecycle, invoke the stream's read method to deserialize the object, assert that the deserialized object is an instance of the expected interface type, convert the result to a string representation, and validate that this string ends with a specific invocation handler method signature to confirm the proxy's behavior was preserved through the serialization cycle. Upon completion of the try block, allow the stream resource to close automatically, releasing any underlying I/O resources. JUnit 5 for testing framework and standard Java assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.serialization.ProxyTest",
      "method_signature": "testAcceptProxy()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.serialization.ValidatingObjectInputStreamTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.serialization;\n\nimport static org.junit.jupiter.api.Assertions.assertInstanceOf;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link ValidatingObjectInputStream}.\n */\npublic class ValidatingObjectInputStreamTest1 {\n\n    /**\n     * A test interface for the dynamic proxy.\n     */\n    public interface TestProxy extends Serializable {\n        String someMethod();\n    }\n\n    /**\n     * A test invocation handler for the dynamic proxy.\n     */\n    private static final class TestInvocationHandler implements InvocationHandler, Serializable {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public Object invoke(final Object proxy, final Method method, final Object[] args) {\n            if (method.getName().equals(\"toString\")) {\n                return \"TestInvocationHandler.toString()\";\n            }\n            return \"invoked\";\n        }\n    }\n\n    /**\n     * Creates a dynamic proxy instance for testing.\n     *\n     * @return a new {@link TestProxy} instance.\n     */\n    private TestProxy createProxy() {\n        return (TestProxy) Proxy.newProxyInstance(\n            TestProxy.class.getClassLoader(),\n            new Class<?>[] { TestProxy.class },\n            new TestInvocationHandler());\n    }\n\n    @Test\n    public void testDeserializationOfDynamicProxy() throws IOException, ClassNotFoundException {\n        final TestProxy proxy = createProxy();\n        final byte[] serializedProxy = SerializationUtils.serialize(proxy);\n\n        try (final ValidatingObjectInputStream vois = new ValidatingObjectInputStream(new ByteArrayInputStream(serializedProxy))) {\n            vois.accept(\"*\");\n            final Object deserializedObject = vois.readObject();\n            assertInstanceOf(TestProxy.class, deserializedObject);\n            final String str = deserializedObject.toString();\n            assertTrue(str.endsWith(\"TestInvocationHandler.toString()\"), \"Expected string to end with handler signature, but was: \" + str);\n        }\n    }\n}",
      "method_signature": "testAcceptProxy()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 38132,
    "output_tokens": 8744,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 505,
      "description": "Define a test method annotated with `@Test` that declares `IOException` in its throws clause, then within a try-with-resources statement instantiate a `Reader` variable named `reader` by constructing a new `UnsynchronizedBufferedReader` passing a new `PipedReader()` as the first argument and integer literal `9` as the second argument, and immediately within the try block invoke `assertThrows` passing `IndexOutOfBoundsException.class` as the first argument and a lambda expression as the second argument where the lambda body calls `reader.read` passing a newly constructed empty `char[]` array (zero-length array literal), integer literal `7` as the offset, and integer literal `0` as the length, verifying that this invocation throws `IndexOutOfBoundsException` due to the invalid offset into the empty buffer. Upon exiting the try-with-resources block, the test executes a teardown method annotated appropriately that invokes `IOUtils.closeQuietly` passing the class field `br` (of type `UnsynchronizedBufferedReader`) to ensure any open reader resources are closed quietly, ignoring exceptions. Class-level annotations: None. Method-level annotations: `@Test`. Assertion library: JUnit 5 Assertions (`assertThrows`). Mocking library: None.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.UnsynchronizedBufferedReaderTest",
      "method_signature": "testReadArray_HARMONY_831()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.UnsynchronizedBufferedReaderTest1",
      "code": "package org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.io.PipedReader;\nimport java.io.Reader;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link UnsynchronizedBufferedReader}.\n */\npublic class UnsynchronizedBufferedReaderTest1 {\n\n    private UnsynchronizedBufferedReader br;\n\n    @Test\n    public void testReadThrowsIndexOutOfBoundsException() throws IOException {\n        try (Reader reader = new UnsynchronizedBufferedReader(new PipedReader(), 9)) {\n            this.br = (UnsynchronizedBufferedReader) reader;\n            assertThrows(IndexOutOfBoundsException.class, () -> {\n                reader.read(new char[0], 7, 0);\n            });\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        IOUtils.closeQuietly(br);\n    }\n}",
      "method_signature": "testReadArray_HARMONY_831()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.75,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22617,
    "output_tokens": 9373,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 506,
      "description": "Define a test method that validates the behavior of the Unsynchronized Buffered Reader when invoked with an invalid offset parameter that exceeds the bounds of an empty character array. Initialize a Reader instance by constructing an Unsynchronized Buffered Reader wrapping a Piped Reader with a buffer size of 9, managing this resource within a try-with-resources block to ensure automatic closure. Upon establishing the reader, invoke the read method on the reader passing an empty character array, an offset of 7, and a length of 0, then immediately verify that this invocation throws an Index Out Of Bounds Exception since the offset exceeds the array's valid range. After the try-with-resources block completes and the reader is automatically closed, ensure any remaining resources are released by invoking the quiet close utility on the buffered reader field stored at the class level. This test uses JUnit 5 for test execution and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.UnsynchronizedBufferedReaderTest",
      "method_signature": "testReadArray_HARMONY_831()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.UnsynchronizedBufferedReaderTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.io.PipedReader;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link UnsynchronizedBufferedReader}.\n */\npublic class UnsynchronizedBufferedReaderTest1 {\n\n    private UnsynchronizedBufferedReader bufferedReader;\n\n    @Test\n    public void testReadWithInvalidOffsetAndEmptyCharArray() throws IOException {\n        try (final UnsynchronizedBufferedReader reader = new UnsynchronizedBufferedReader(new PipedReader(), 9)) {\n            this.bufferedReader = reader;\n            final char[] cbuf = new char[0];\n            assertThrows(IndexOutOfBoundsException.class, () -> {\n                reader.read(cbuf, 7, 0);\n            });\n        }\n        IOUtils.closeQuietly(bufferedReader);\n    }\n\n}",
      "method_signature": "testReadArray_HARMONY_831()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.6,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 50041,
    "output_tokens": 7206,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 507,
      "description": "Define a test class annotated with `@SuppressWarnings(\"deprecation\")` containing a private static final String field `UTF_8`, a private static final int field `FILE_SIZE`, a private static final boolean field `WINDOWS`, a public File field `temporaryFolder` annotated with `@TempDir`, and private fields `carr` of type `char[]`, `iarr` of type `byte[]`, `testFile` of type `File`, and `testFilePath` of type `Path`. Implement a static setup method annotated with `@BeforeAll` that invokes `IO.clear()` to exercise the method and ensure no adverse side effects when recycling thread locals. Implement an instance setup method annotated with `@BeforeEach` that constructs `testFile` by instantiating a new `File` with arguments `temporaryFolder` and String literal `\"file2-test.txt\"`, assigns `testFilePath` by invoking `toPath()` on `testFile`, checks if the parent directory exists by calling `getParentFile().exists()` on `testFile` and throws an `IOException` with message `\"Cannot create file \" + testFile + \" as the parent directory does not exist\"` if false, then within a try-with-resources block creates a `BufferedOutputStream` named `output` wrapping `Files.newOutputStream(testFilePath)` and invokes a private method that iterates from int `i` initialized to `0` while `i < FILE_SIZE`, incrementing `i`, and within the loop invokes `write((byte) (i % 127 + 1))` on the output stream, catching any `IOException` as `e` and invoking `fail(\"Can't run this test because the environment could not be built: \" + e.getMessage())`, then initializes `iarr` as a new `byte[200]`, invokes `Arrays.fill(iarr, (byte) -1)`, iterates from int `i` initialized to `0` while `i < 80`, incrementing `i`, and assigns `iarr[i] = (byte) i`, then initializes `carr` as a new `char[200]`, invokes `Arrays.fill(carr, (char) -1)`, iterates from int `i` initialized to `0` while `i < 80`, incrementing `i`, and assigns `carr[i] = (char) i`. Write a test method annotated with `@ParameterizedTest` and `@MethodSource` accepting parameters `int size`, `int bufferSize`, and `Class<? extends Exception> exceptionClass`, declaring it throws `IOException`, that within a try-with-resources block creates an `InputStream` named `input` by instantiating `NullInputStream` with argument `0`, then invokes `assertThrows(exceptionClass, () -> IOUtils.toByteArray(input, size, bufferSize))` to verify that calling `toByteArray` on `IOUtils` with arguments `input`, `size`, and `bufferSize` throws the exception class specified by the parameter. Implement a static teardown method identical to the setup method that invokes `IO.clear()`. The test uses class-level annotation `@SuppressWarnings(\"deprecation\")`, method-level annotations `@ParameterizedTest` and `@MethodSource`, JUnit 5 Assertions via `assertThrows` and `fail`, and no mocking libraries.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testToByteArray_InputStream_Size_BufferSize_Throws(int, int, java.lang.Class)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsToByteArrayTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.input.NullInputStream;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n@SuppressWarnings(\"deprecation\")\npublic class IOUtilsToByteArrayTest {\n\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final int FILE_SIZE = 1024;\n    private static final boolean WINDOWS = FilenameUtils.isSystemWindows();\n\n    @TempDir\n    public File temporaryFolder;\n\n    private char[] carr;\n    private byte[] iarr;\n    private File testFile;\n    private Path testFilePath;\n\n    @BeforeAll\n    public static void beforeAll() {\n        IO.clear();\n    }\n\n    @AfterAll\n    public static void afterAll() {\n        IO.clear();\n    }\n\n    @BeforeEach\n    public void beforeEach() throws IOException {\n        testFile = new File(temporaryFolder, \"file2-test.txt\");\n        testFilePath = testFile.toPath();\n        if (!testFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(testFilePath))) {\n            writeBytes(output);\n        } catch (final IOException e) {\n            fail(\"Can't run this test because the environment could not be built: \" + e.getMessage());\n        }\n\n        iarr = new byte[200];\n        Arrays.fill(iarr, (byte) -1);\n        for (int i = 0; i < 80; i++) {\n            iarr[i] = (byte) i;\n        }\n\n        carr = new char[200];\n        Arrays.fill(carr, (char) -1);\n        for (int i = 0; i < 80; i++) {\n            carr[i] = (char) i;\n        }\n    }\n\n    private void writeBytes(final BufferedOutputStream output) throws IOException {\n        for (int i = 0; i < FILE_SIZE; i++) {\n            output.write((byte) (i % 127 + 1));\n        }\n    }\n\n    static Stream<Arguments> byteArraySources() {\n        return Stream.of(\n            Arguments.of(-1, 1024, IllegalArgumentException.class),\n            Arguments.of(1, 1024, IOException.class)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"byteArraySources\")\n    public void testToByteArrayWithSizedBuffer(final int size, final int bufferSize, final Class<? extends Exception> exceptionClass) throws IOException {\n        try (final InputStream input = new NullInputStream(0)) {\n            assertThrows(exceptionClass, () -> IOUtils.toByteArray(input, size, bufferSize));\n        }\n    }\n}",
      "method_signature": "testToByteArray_InputStream_Size_BufferSize_Throws(int, int, java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.25,
      "method_coverage": 0.25,
      "line_coverage": 0.2032,
      "branch_coverage": 0.3478
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 39284,
    "output_tokens": 7854,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 510,
      "description": "Define a test class annotated with `@SuppressWarnings(\"deprecation\")` containing a test method annotated with `@SuppressWarnings(\"resource\")` and `@Test`, and declare eight class-level fields: a `private static final String` named `UTF_8`, a `private static final int` named `FILE_SIZE`, a `private static final boolean` named `WINDOWS`, a `public File` named `temporaryFolder` annotated with `@TempDir`, a `private char[]` named `carr`, a `private byte[]` named `iarr`, a `private File` named `testFile`, and a `private Path` named `testFilePath`. Implement a static setup method annotated with `@BeforeAll` that invokes `IO.clear()`. Implement an instance setup method annotated with `@BeforeEach` that first constructs `testFile` by calling `new File(temporaryFolder, \"file2-test.txt\")`, then assigns `testFile.toPath()` to `testFilePath`, checks if the parent directory exists by calling `testFile.getParentFile().exists()` and throws a new `IOException` with message `\"Cannot create file \" + testFile + \" as the parent directory does not exist\"` if false, opens a `BufferedOutputStream` wrapping `Files.newOutputStream(testFilePath)` in a try-with-resources block and writes test data by invoking a loop from `i = 0` to `i < FILE_SIZE` where each iteration calls `output.write((byte) (i % 127 + 1))`, catches any `IOException` and calls `fail(\"Can't run this test because the environment could not be built: \" + e.getMessage())`, then initializes `iarr` as a new `byte[200]`, fills it with `(byte) -1` using `Arrays.fill(iarr, (byte) -1)`, loops from `i = 0` to `i < 80` setting `iarr[i] = (byte) i`, initializes `carr` as a new `char[200]`, fills it with `(char) -1` using `Arrays.fill(carr, (char) -1)`, and loops from `i = 0` to `i < 80` setting `carr[i] = (char) i`. In the test method body, create a new `Exception` with String literal `\"test\"`, immediately invoke `fillInStackTrace()` on it, and assign the result to a `Throwable` variable named `e`, then assert that `e.getSuppressed().length` equals int literal `0` using `assertEquals`. Next, construct a new `EOFException` with String literal `\"Suppressed\"`, immediately invoke `fillInStackTrace()` on it, pass this result to a new `BrokenInputStream` constructor, then pass this `BrokenInputStream` instance along with `e` to `IOUtils.closeQuietly(Closeable, Throwable)`, and assert using `assertSame` that the returned value is the same reference as `e`. Following this, assert that `e.getSuppressed().length` now equals int literal `1` using `assertEquals`, then retrieve the first suppressed exception by accessing `e.getSuppressed()[0]` and assign it to a `Throwable` variable named `suppressed0`. Assert using `assertInstanceOf` that `suppressed0` is an instance of `EOFException.class`, and finally assert using `assertEquals` that `suppressed0.getMessage()` equals String literal `\"Suppressed\"`. Implement a static teardown method annotated with `@AfterAll` that invokes `IO.clear()`. The test uses class-level annotations `@SuppressWarnings(\"deprecation\")`, method-level annotations `@SuppressWarnings(\"resource\")` and `@Test`, assertion library JUnit 5 Assertions, and no mocking libraries.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testCloseQuietly_CloseableIOExceptionAddSuppressed()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsCloseQuietlyTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport java.io.BufferedOutputStream;\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertInstanceOf;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.fail;\n\n@SuppressWarnings(\"deprecation\")\npublic class IOUtilsCloseQuietlyTest {\n\n    private static final String UTF_8 = \"UTF-8\";\n    private static final int FILE_SIZE = 1024;\n    private static final boolean WINDOWS = File.separatorChar == '\\\\';\n\n    @TempDir\n    public File temporaryFolder;\n\n    private char[] carr;\n    private byte[] iarr;\n    private File testFile;\n    private Path testFilePath;\n\n    @BeforeAll\n    public static void setUpClass() {\n        IO.clear();\n    }\n\n    @AfterAll\n    public static void tearDownClass() {\n        IO.clear();\n    }\n\n    @BeforeEach\n    public void setUp() {\n        try {\n            testFile = new File(temporaryFolder, \"file2-test.txt\");\n            testFilePath = testFile.toPath();\n            if (!testFile.getParentFile().exists()) {\n                throw new IOException(\"Cannot create file \" + testFile + \" as the parent directory does not exist\");\n            }\n            try (BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(testFilePath))) {\n                for (int i = 0; i < FILE_SIZE; i++) {\n                    output.write((byte) (i % 127 + 1));\n                }\n            }\n        } catch (IOException e) {\n            fail(\"Can't run this test because the environment could not be built: \" + e.getMessage());\n        }\n\n        iarr = new byte[200];\n        Arrays.fill(iarr, (byte) -1);\n        for (int i = 0; i < 80; i++) {\n            iarr[i] = (byte) i;\n        }\n\n        carr = new char[200];\n        Arrays.fill(carr, (char) -1);\n        for (int i = 0; i < 80; i++) {\n            carr[i] = (char) i;\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"resource\")\n    public void testCloseQuietly_Closeable_Throwable() {\n        Throwable e = new Exception(\"test\").fillInStackTrace();\n        assertEquals(0, e.getSuppressed().length);\n\n        Throwable suppressed = new EOFException(\"Suppressed\").fillInStackTrace();\n        Closeable c = new BrokenInputStream(suppressed);\n\n        Throwable returned = IOUtils.closeQuietly(c, e);\n        assertSame(e, returned);\n\n        assertEquals(1, e.getSuppressed().length);\n        Throwable suppressed0 = e.getSuppressed()[0];\n        assertInstanceOf(EOFException.class, suppressed0);\n        assertEquals(\"Suppressed\", suppressed0.getMessage());\n    }\n}",
      "method_signature": "testCloseQuietly_CloseableIOExceptionAddSuppressed()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 513,
      "description": "Define a test class annotated with `@SuppressWarnings(\"deprecation\")` containing eight fields: a `private static final String` named `UTF_8`, a `private static final int` named `FILE_SIZE`, a `private static final boolean` named `WINDOWS`, a `public File` named `temporaryFolder` annotated with `@TempDir`, a `private char[]` named `carr`, a `private byte[]` named `iarr`, a `private File` named `testFile`, and a `private Path` named `testFilePath`. Implement a `public static void` method annotated with `@BeforeAll` that invokes `IO.clear()` to exercise thread-local recycling without adverse side effects. Implement a `public void` setup method annotated with `@BeforeEach` that constructs `testFile` by instantiating `new File(temporaryFolder, \"file2-test.txt\")`, assigns `testFile.toPath()` to `testFilePath`, checks if the parent directory exists by invoking `testFile.getParentFile().exists()` and throws `new IOException(\"Cannot create file \" + testFile + \" as the parent directory does not exist\")` if false, opens a `BufferedOutputStream` wrapping `Files.newOutputStream(testFilePath)` in a try-with-resources block, and within that block iterates from `int i = 0` to `FILE_SIZE` (exclusive) writing `(byte) (i % 127 + 1)` to the output stream via `output.write((byte) (i % 127 + 1))`, catches any `IOException e` and invokes `fail(\"Can't run this test because the environment could not be built: \" + e.getMessage())`, then initializes `iarr` as `new byte[200]`, fills it with `(byte) -1` using `Arrays.fill(iarr, (byte) -1)`, iterates from `int i = 0` to `80` (exclusive) assigning `iarr[i] = (byte) i`, initializes `carr` as `new char[200]`, fills it with `(char) -1` using `Arrays.fill(carr, (char) -1)`, and iterates from `int i = 0` to `80` (exclusive) assigning `carr[i] = (char) i`. Define a test method annotated with `@ParameterizedTest` and `@MethodSource` accepting three `int` parameters named `off`, `len`, and `arrayLength`, then invoke `assertDoesNotThrow(() -> IOUtils.checkFromIndexSize(off, len, arrayLength))` to verify that the range validation does not throw any exception for the provided offset, length, and array length combination. Implement the same `public static void` method annotated with `@AfterAll` that invokes `IO.clear()` to clean up thread-local state after all tests complete. The test uses class-level annotation `@SuppressWarnings(\"deprecation\")`, method-level annotations `@ParameterizedTest` and `@MethodSource`, assertion library JUnit 5 Assertions, and no mocking library.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testCheckFromIndexSizeValidCases(int, int, int)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsExtTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n@SuppressWarnings(\"deprecation\")\npublic class IOUtilsExtTest {\n\n    private static final String UTF_8 = \"UTF-8\";\n    private static final int FILE_SIZE = 1024;\n    private static final boolean WINDOWS = File.separatorChar == '\\';\n\n    @TempDir\n    public File temporaryFolder;\n\n    private char[] carr;\n    private byte[] iarr;\n    private File testFile;\n    private Path testFilePath;\n\n    @BeforeAll\n    public static void beforeAll() {\n        IO.clear();\n    }\n\n    @AfterAll\n    public static void afterAll() {\n        IO.clear();\n    }\n\n    @BeforeEach\n    public void setup() throws IOException {\n        testFile = new File(temporaryFolder, \"file2-test.txt\");\n        testFilePath = testFile.toPath();\n        if (!testFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(testFilePath))) {\n            for (int i = 0; i < FILE_SIZE; i++) {\n                output.write((byte) (i % 127 + 1));\n            }\n        } catch (final IOException e) {\n            fail(\"Can't run this test because the environment could not be built: \" + e.getMessage());\n        }\n\n        iarr = new byte[200];\n        Arrays.fill(iarr, (byte) -1);\n        for (int i = 0; i < 80; i++) {\n            iarr[i] = (byte) i;\n        }\n\n        carr = new char[200];\n        Arrays.fill(carr, (char) -1);\n        for (int i = 0; i < 80; i++) {\n            carr[i] = (char) i;\n        }\n    }\n\n    private static Stream<Arguments> checkFromIndexSizeSource() {\n        return Stream.of(\n            Arguments.of(0, 0, 0),\n            Arguments.of(0, 0, 1),\n            Arguments.of(0, 1, 1),\n            Arguments.of(1, 0, 1),\n            Arguments.of(0, 80, 80),\n            Arguments.of(80, 0, 80)\n        );\n    }\n    \n    @ParameterizedTest\n    @MethodSource(\"checkFromIndexSizeSource\")\n    public void checkFromIndexSizeTest(final int off, final int len, final int arrayLength) {\n        assertDoesNotThrow(() -> IOUtils.checkFromIndexSize(off, len, arrayLength));\n    }\n}",
      "method_signature": "testCheckFromIndexSizeValidCases(int, int, int)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 516,
      "description": "Create a test case to validate that the system correctly handles bidirectional data flow between a buffered output channel and a buffered input channel using an intermediate coordination mechanism, ensuring data integrity across various input patterns. For each input variation provided, establish a fresh coordination point to manage data transfer between the channels, then configure buffered output and input channels with a standard buffer capacity connected through this coordination mechanism. Write the input data to the output channel using the system's default text encoding, immediately flush the output to ensure all buffered content is released, then read the transmitted content back from the input channel and convert it to text using the same encoding. Verify that the content retrieved from the input channel exactly matches the original input data, confirming no data corruption or loss occurred during the buffered transmission process. After completing each validation scenario, automatically release all channel resources. Execute this validation across all provided input variations using JUnit 5 as the testing framework and AssertJ for standard equality assertions to confirm data integrity.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.QueueInputStreamTest",
      "method_signature": "testBufferedReadWrite(java.lang.String)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.BufferedChannelsTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.Pipe;\nimport java.nio.charset.Charset;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\n/**\n * Tests {@link BufferedInputChannel} and {@link BufferedOutputChannel}.\n */\npublic class BufferedChannelsTest {\n\n    @ParameterizedTest\n    @ValueSource(strings = {\"\", \"a\", \"Hello World!\", \"Line 1\\nLine 2\", \"Data with various characters: !@#$%^&*()_+-={}|[]\\\\:;'<>?,./\"})\n    void testReadWrite(final String testData) throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        // The \"intermediate coordination mechanism\"\n        final Pipe pipe = Pipe.open();\n        try (final BufferedOutputChannel outputChannel = new BufferedOutputChannel(pipe.sink());\n             final BufferedInputChannel inputChannel = new BufferedInputChannel(pipe.source())) {\n\n            // Write data to the output channel\n            outputChannel.write(ByteBuffer.wrap(testData.getBytes(charset)));\n            // \"immediately flush the output\"\n            outputChannel.flush();\n\n            // Read data back from the input channel\n            try (final InputStream inputStream = Channels.newInputStream(inputChannel)) {\n                final String actualData = IOUtils.toString(inputStream, charset);\n                // Verify data integrity\n                assertThat(actualData).isEqualTo(testData);\n            }\n        }\n    }\n}",
      "method_signature": "testBufferedReadWrite(java.lang.String)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 517,
      "description": "Define a parameterized test method that accepts a string parameter representing input data, where the test iterates over multiple string values provided by a data source method. Within the test method, instantiate a blocking queue to serve as the communication channel between input and output streams, then configure a buffered input stream wrapping a queue-based input stream connected to this queue, and configure a buffered output stream wrapping a queue-based output stream connected to the same queue, using a buffer size determined by a helper method that returns the default buffer size constant. Write the input data parameter's UTF-8 encoded bytes to the buffered output stream, then flush the output stream to ensure all buffered data is pushed into the underlying queue. Upon flushing, read the complete contents from the buffered input stream back into a string using UTF-8 encoding via a utility method that converts stream content to string. Assert that the reconstructed string exactly matches the original input data parameter to verify that data written to the queue output stream is correctly retrieved through the queue input stream without corruption or loss. After verification completes, close both the buffered input stream and buffered output stream to release resources, ensuring proper cleanup of the stream pipeline. The test framework is JUnit 5 with parameterized test support.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.QueueInputStreamTest",
      "method_signature": "testBufferedReadWrite(java.lang.String)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.QueueStreamTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.input.QueueInputStream;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link QueueOutputStream} and {@link QueueInputStream}.\n */\npublic class QueueStreamTest {\n\n    private static int getDefaultBufferSize() {\n        return IOUtils.DEFAULT_BUFFER_SIZE;\n    }\n\n    public static Stream<String> stringProvider() {\n        return Stream.of(\n            \"Hello, world!\",\n            \"\",\n            \"This is a longer test string with various characters !@#$%^&*()_+\",\n            new String(new char[1024]).replace(\"\u0000\", \"X\")\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"stringProvider\")\n    public void testWriteAndRead(final String inputData) throws IOException {\n        final BlockingQueue<Byte> queue = new LinkedBlockingQueue<>();\n        final BufferedInputStream bis = new BufferedInputStream(new QueueInputStream(queue), getDefaultBufferSize());\n        final BufferedOutputStream bos = new BufferedOutputStream(new QueueOutputStream(queue), getDefaultBufferSize());\n\n        bos.write(inputData.getBytes(StandardCharsets.UTF_8));\n        bos.flush();\n\n        final String result = IOUtils.toString(bis, StandardCharsets.UTF_8);\n\n        assertEquals(inputData, result);\n\n        bis.close();\n        bos.close();\n    }\n}",
      "method_signature": "testBufferedReadWrite(java.lang.String)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 17475,
    "output_tokens": 2754,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 520,
      "description": "Create a test case to validate the system's ability to transfer a resource from one storage location to another when both locations reside in different organizational systems. Begin by establishing access to an archived storage system containing a nested directory structure, then locate a specific log resource within that archive's subdirectories. Instruct the system to copy this resource to a designated working area that was prepared during initial setup. After the transfer completes, verify that the resource now exists in the target location and confirm that the transferred resource maintains the exact same size as the original, ensuring no data was lost or corrupted during the cross-system transfer. Once validation is complete, release the connection to the archived storage system. Use JUnit 5 for the testing framework and standard equality assertions to verify both the presence of the transferred resource and the consistency of its size across both storage locations.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.PathUtilsTest",
      "method_signature": "testCopyFileTwoFileSystem()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.CrossSystemTransferTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.nio.file.Path;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Validates transferring a resource across different storage systems,\n * represented by a ZIP archive and the local file system.\n */\npublic class CrossSystemTransferTest {\n\n    @TempDir\n    private Path workingArea;\n\n    @Test\n    public void testTransferResourceFromArchiveToWorkArea() throws Exception {\n        // Establish access to an archived storage system\n        final URL archiveUrl = getClass().getResource(\"/dir-equals-tests.zip\");\n        assertNotNull(archiveUrl, \"Test archive resource 'dir-equals-tests.zip' should be present in classpath.\");\n        final File archiveFile = new File(archiveUrl.toURI());\n\n        // Use try-with-resources to ensure the ZipFile is automatically closed, releasing the connection.\n        try (ZipFile archivedStorage = new ZipFile(archiveFile)) {\n            // Locate a specific log resource within the archive's subdirectories\n            final String resourcePath = \"dir-equals-dirs-and-files/dirs-and-files1/file1.txt\";\n            final ZipEntry originalResource = archivedStorage.getEntry(resourcePath);\n            assertNotNull(originalResource, \"Specific resource '\" + resourcePath + \"' should exist in the archive.\");\n\n            // Prepare the designated working area and instruct the system to copy the resource\n            final File transferredResource = new File(workingArea.toFile(), \"transferred-log.txt\");\n            try (InputStream resourceStream = archivedStorage.getInputStream(originalResource)) {\n                FileUtils.copyInputStreamToFile(resourceStream, transferredResource);\n            }\n\n            // Verify that the resource now exists in the target location\n            assertTrue(transferredResource.exists(), \"Resource should exist in the target working area after transfer.\");\n\n            // Confirm that the transferred resource maintains the exact same size as the original\n            assertEquals(originalResource.getSize(), transferredResource.length(),\n                \"Transferred resource size must match the original to ensure no data loss.\");\n        }\n    }\n}",
      "method_signature": "testCopyFileTwoFileSystem()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.5,
      "callable_recall": 0.1765,
      "callable_precision": 0.1765,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20633,
    "output_tokens": 6140,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 522,
      "description": "Define a test method annotated with `@Test` that declares it throws `IOException` and `ClassNotFoundException`, then begin by invoking `Proxy.newProxyInstance` with three arguments: first call `ProxyTest.class.getClassLoader()` to obtain the class loader, second pass a new `Class<?>` array containing the single element `IFoo.class`, and third instantiate a new `InvocationHandlerImpl` object, assigning the returned proxy object to a variable named `proxy` of type `Object`. Next, invoke `SerializationUtils.serialize` passing `proxy` cast to `Serializable`, and assign the resulting byte array to a variable named `serialized`. Assign the class literal `IFoo.class` to a variable named `ifaceClass` of type `Class<IFoo>`. Open a try-with-resources block by calling `ValidatingObjectInputStream.builder()` to obtain a builder instance, then chain `.setByteArray(serialized)` to configure the byte array source, chain `.accept(\"*\")` to accept all class patterns for deserialization, and finally chain `.get()` to build the `ValidatingObjectInputStream`, assigning it to the resource variable `vois`. Within the try block body, invoke `vois.readObject()` to deserialize the object, pass the result to `assertInstanceOf(ifaceClass, ...)` to verify it is an instance of `IFoo` and obtain the casted instance, immediately call `.toString()` on that instance, then invoke `.endsWith(\"InvocationHandlerImpl.invoke()\")` on the resulting string, and wrap this entire boolean expression in `assertTrue(...)` to assert the string ends with the literal `\"InvocationHandlerImpl.invoke()\"`. The try-with-resources automatically closes `vois` upon block exit. This test uses JUnit 5 Assertions (`assertTrue`, `assertInstanceOf`) and the test method is annotated with `@Test`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.serialization.ProxyTest",
      "method_signature": "testAcceptProxy()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.serialization.ProxyTest1",
      "code": "package org.apache.commons.io.serialization;\n\nimport static org.junit.jupiter.api.Assertions.assertInstanceOf;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ValidatingObjectInputStream} with a Proxy.\n */\npublic class ProxyTest1 {\n\n    private interface IFoo extends Serializable {\n        // empty\n    }\n\n    private static class InvocationHandlerImpl implements InvocationHandler, Serializable {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n            return \"InvocationHandlerImpl.invoke()\";\n        }\n    }\n\n    @Test\n    public void testDeserializationOfProxy() throws IOException, ClassNotFoundException {\n        final Object proxy = Proxy.newProxyInstance(\n            ProxyTest.class.getClassLoader(),\n            new Class<?>[]{IFoo.class},\n            new InvocationHandlerImpl()\n        );\n        final byte[] serialized = SerializationUtils.serialize((Serializable) proxy);\n        final Class<IFoo> ifaceClass = IFoo.class;\n        try (final ValidatingObjectInputStream vois = ValidatingObjectInputStream.builder()\n                .setByteArray(serialized)\n                .accept(\"*\")\n                .get()) {\n            assertTrue(assertInstanceOf(ifaceClass, vois.readObject()).toString().endsWith(\"InvocationHandlerImpl.invoke()\"));\n        }\n    }\n}",
      "method_signature": "testAcceptProxy()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 58372,
    "output_tokens": 5119,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 537,
      "description": "Define a test class that verifies cross-filesystem file copying functionality by first establishing a temporary directory structure during setup, then within the test method, create a private helper that opens a filesystem archive from a JAR file path using a boolean flag to determine creation mode, where the helper constructs the appropriate URI scheme and invokes the filesystem provider to return a FileSystem instance. Using a try-with-resources block, invoke this helper to open the archive located at the predefined JAR path without creation mode, then retrieve a specific file path from within the archive filesystem by querying for a nested directory structure. With the source file obtained from the archive, invoke the PathUtils utility's copyFileToDirectory method to transfer the file from the archive filesystem to the previously established temporary directory, capturing the resulting target path. Immediately upon receiving the target path, assert that the file exists in the target location using the Files utility, then validate that the byte size of the target file matches the byte size of the source file by comparing their respective sizes through Files operations. The try-with-resources construct ensures the archive filesystem is closed after verification completes, and the temporary directory established during setup remains available for the test's duration. JUnit 5.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.PathUtilsTest",
      "method_signature": "testCopyFileTwoFileSystem()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.file.PathUtilsCopyFileToDirectoryCrossFileSystemTest",
      "code": "package org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link PathUtils} cross-filesystem file copying functionality.\n */\npublic class PathUtilsCopyFileToDirectoryCrossFileSystemTest {\n\n    @TempDir\n    private Path tempDir;\n\n    /**\n     * Opens a filesystem archive from a JAR file path.\n     *\n     * @param archivePath The path to the archive file.\n     * @param create      A boolean flag to determine creation mode.\n     * @return A FileSystem instance for the archive.\n     * @throws IOException if an I/O error occurs setting up the filesystem.\n     */\n    private FileSystem openArchive(final Path archivePath, final boolean create) throws IOException {\n        final Map<String, String> env = new HashMap<>();\n        if (create) {\n            env.put(\"create\", \"true\");\n        }\n        final URI uri = URI.create(\"jar:\" + archivePath.toUri());\n        return FileSystems.newFileSystem(uri, env);\n    }\n\n    @Test\n    public void testCopyFileToDirectoryFromArchiveToFileSystem() throws IOException, URISyntaxException {\n        final URL jarUrl = getClass().getResource(\"/org/apache/commons/io/dir-equals-tests.zip\");\n        assertNotNull(jarUrl, \"Could not find test JAR resource.\");\n        final Path archivePath = Paths.get(jarUrl.toURI());\n\n        try (final FileSystem archiveFileSystem = openArchive(archivePath, false)) {\n            final Path sourceFile = archiveFileSystem.getPath(\"dirs-and-files1\", \"file1.txt\");\n            assertTrue(Files.exists(sourceFile), \"Test file missing from archive.\");\n\n            final Path targetPath = PathUtils.copyFileToDirectory(sourceFile, tempDir);\n\n            assertTrue(Files.exists(targetPath), \"File should exist in the target location after copy.\");\n            assertEquals(Files.size(sourceFile), Files.size(targetPath), \"Byte size of source and target files should be equal.\");\n        }\n    }\n}",
      "method_signature": "testCopyFileTwoFileSystem()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.5,
      "callable_recall": 0.8235,
      "callable_precision": 0.7,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 21547,
    "output_tokens": 6925,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 539,
      "description": "Define a test method annotated with `@ParameterizedTest(name = \"inputData={0}\")` and `@MethodSource(\"inputData\")` that accepts a single `String` parameter named `inputData` and declares `throws IOException`. Begin by instantiating a `LinkedBlockingQueue<Integer>` with no arguments and assign it to a variable named `queue` of type `BlockingQueue<Integer>`. Open a try-with-resources block that declares two resources: first, instantiate a `BufferedInputStream` by passing a new `QueueInputStream` constructed with argument `queue`, and assign it to variable `inputStream`; second, instantiate a `BufferedOutputStream` by passing a new `QueueOutputStream` constructed with argument `queue` and a second argument obtained by invoking a private method that returns the int value `8192`, and assign it to variable `outputStream`. Within the try block, invoke `getBytes` on the `inputData` parameter with argument `StandardCharsets.UTF_8`, then pass the resulting byte array to `write` on `outputStream`. Immediately invoke `flush` on `outputStream`. Next, invoke the static method `IOUtils.toString` with arguments `inputStream` and `StandardCharsets.UTF_8`, assigning the returned `String` to variable `dataCopy`. Assert equality by invoking `assertEquals` with arguments `inputData` and `dataCopy`. The try-with-resources block automatically closes both streams upon exit. The test uses JUnit 5 Assertions for the assertion method.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.input.QueueInputStreamTest",
      "method_signature": "testBufferedReadWrite(java.lang.String)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.QueueStreamTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.stream.Stream;\nimport org.apache.commons.io.input.QueueInputStream;\nimport org.apache.commons.io.output.QueueOutputStream;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link QueueInputStream} and {@link QueueOutputStream}.\n */\npublic class QueueStreamTest {\n\n    private int getBufferSize() {\n        return 8192;\n    }\n\n    static Stream<String> inputData() {\n        return Stream.of(\"\", \"hello\", \"a long string to test buffer sizes\",\n            new String(new char[16384]).replace('\u0000', 'X'));\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    void testWriteAndRead(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(new QueueInputStream(queue));\n             BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue, getBufferSize()))) {\n            outputStream.write(inputData.getBytes(StandardCharsets.UTF_8));\n            outputStream.flush();\n            final String dataCopy = IOUtils.toString(inputStream, StandardCharsets.UTF_8);\n            assertEquals(inputData, dataCopy);\n        }\n    }\n}",
      "method_signature": "testBufferedReadWrite(java.lang.String)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19154,
    "output_tokens": 4227,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 540,
      "description": "Define a test method accepting five parameters: `strategy` of type `NameLengthStrategy`, `limit` of type `int`, `input` of type `String`, `charset` of type `Charset`, and `message` of type `String`, then invoke `assertThrows` passing `IllegalArgumentException.class` and a lambda expression that calls `strategy.truncate(input, limit, charset)`, assigning the returned exception to a variable named `ex`. Immediately invoke `getMessage()` on `ex` and assign the result to a variable named `exMessage`. Assert using `assertTrue` that `exMessage.contains(message)` returns true, providing the failure message constructed by concatenating the string literal `\"ex message contains \"`, the value of `message`, the string literal `\": \"`, and the value of `exMessage`. Annotate the test method with `@ParameterizedTest(name = \"{index}: {0} truncates {2} with limit {1} throws\")` and `@MethodSource`, and ensure the test uses JUnit 5 Assertions for `assertThrows` and `assertTrue`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileSystemTest",
      "method_signature": "testNameLengthStrategyTruncate_Throws(org.apache.commons.io.FileSystem.NameLengthStrategy, int, java.lang.String, java.nio.charset.Charset, java.lang.String)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.NameLengthStrategyTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.stream.Stream;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests for a hypothetical NameLengthStrategy.\n * This test file includes the definition of the interface to allow compilation.\n */\npublic class NameLengthStrategyTest {\n\n    /**\n     * A strategy for truncating names.\n     */\n    interface NameLengthStrategy {\n        String truncate(String name, int limit, Charset charset);\n\n        @Override\n        String toString();\n    }\n\n    private static final NameLengthStrategy TEST_STRATEGY = new NameLengthStrategy() {\n        @Override\n        public String truncate(final String name, final int limit, final Charset charset) {\n            if (limit < 0) {\n                throw new IllegalArgumentException(\"Limit must not be negative\");\n            }\n            // This is a dummy implementation to satisfy the test structure.\n            return name;\n        }\n\n        @Override\n        public String toString() {\n            return \"TestStrategy\";\n        }\n    };\n\n    static Stream<Arguments> testTruncateThrows() {\n        return Stream.of(\n            Arguments.of(TEST_STRATEGY, -1, \"somefile.txt\", StandardCharsets.UTF_8, \"Limit must not be negative\")\n        );\n    }\n\n    @ParameterizedTest(name = \"{index}: {0} truncates {2} with limit {1} throws\")\n    @MethodSource\n    void testTruncateThrows(final NameLengthStrategy strategy, final int limit, final String input, final Charset charset, final String message) {\n        final IllegalArgumentException ex = assertThrows(IllegalArgumentException.class, () -> {\n            strategy.truncate(input, limit, charset);\n        });\n        final String exMessage = ex.getMessage();\n        assertTrue(exMessage.contains(message), \"ex message contains \" + message + \": \" + exMessage);\n    }\n}",
      "method_signature": "testNameLengthStrategyTruncate_Throws(org.apache.commons.io.FileSystem.NameLengthStrategy, int, java.lang.String, java.nio.charset.Charset, java.lang.String)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.8,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 41748,
    "output_tokens": 6722,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 542,
      "description": "Create a test case to validate that the file naming system properly rejects attempts to sanitize file names when a prohibited replacement character is provided. For each supported file system type in the organization, attempt to convert a sample file name using the null character as the replacement character for illegal characters, recognizing that the null character is universally prohibited across all file systems. Ensure the system refuses this operation by raising an appropriate error, then verify the error message clearly indicates the null character was the cause of the rejection by confirming the message begins with text identifying the problematic replacement character. This validation confirms the system enforces fundamental character restrictions to prevent file system corruption or security vulnerabilities. Use JUnit 5 for the testing framework and verify outcomes using standard boolean assertions that check message content prefixes.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileSystemTest",
      "method_signature": "testReplacementWithNUL()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileSystemTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\n\n/**\n * Tests {@link FileSystem}.\n */\npublic class FileSystemTest1 {\n\n    /**\n     * Tests that using the null character as a replacement in\n     * {@link FileSystem#toLegalFileName(String, char)} is prohibited.\n     */\n    @ParameterizedTest\n    @EnumSource(FileSystem.class)\n    public void testToLegalFileNameWithNullReplacement(final FileSystem fileSystem) {\n        final String sampleName = \"a?b:c\";\n        final char replacement = '\\0';\n        final IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () ->\n            fileSystem.toLegalFileName(sampleName, replacement)\n        );\n        final String message = e.getMessage();\n        assertTrue(message.startsWith(\"The replacement character is the null character\"),\n            () -> \"Expected message to start with a specific prefix, but was: \" + message);\n    }\n}",
      "method_signature": "testReplacementWithNUL()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.5,
      "callable_recall": 0.5,
      "callable_precision": 0.75,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.5,
      "method_coverage": 0.2,
      "line_coverage": 0.1224,
      "branch_coverage": 0.4444
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 25855,
    "output_tokens": 4524,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 545,
      "description": "Define a test method that validates the behavior of the FileSystem's file name conversion logic when provided with a null character as the replacement character. Iterate over all available FileSystem enum values, and for each file system instance, invoke the toLegalFileName method with a test string and the null character as the replacement argument. Since the null character is universally illegal across file systems, expect the method to throw an IllegalArgumentException for each invocation. Capture the exception and validate that its message begins with a specific prefix indicating the illegal replacement character, confirming that the file system correctly rejects null as a replacement option. This test uses JUnit for the test framework and standard assertion methods for validation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileSystemTest",
      "method_signature": "testReplacementWithNUL()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileSystemTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link FileSystem}.\n */\npublic class FileSystemTest1 {\n\n    @Test\n    public void testToLegalFileNameWithNullReplacement() {\n        for (final FileSystem fs : FileSystem.values()) {\n            final IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> {\n                fs.toLegalFileName(\"test-file\", '\\0');\n            });\n            assertTrue(e.getMessage().startsWith(\"The replacement character '\"));\n        }\n    }\n}",
      "method_signature": "testReplacementWithNUL()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.5,
      "callable_recall": 0.8333,
      "callable_precision": 0.8333,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 72616,
    "output_tokens": 2143,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 546,
      "description": "Create a test case to validate that the file naming system correctly rejects attempts to truncate file names when the operation would violate length constraints, ensuring data integrity and system compliance with file naming rules. Configure a scenario where various file name candidates with different character encodings and lengths are submitted for truncation using specific length measurement strategies, simulating situations where users or processes attempt to shorten file names to fit within system limits. Attempt to truncate each candidate file name using the designated truncation approach with the specified character encoding and length limit, expecting the system to recognize when truncation is impossible without losing essential information or violating file system constraints. Verify the system responds by refusing the operation and providing a clear explanation indicating why the truncation cannot be performed, confirming the error message contains the expected business reason for the failure. This validation ensures the file naming system protects against data loss and maintains compliance with underlying storage requirements across different character sets and encoding schemes. The test uses JUnit 5 as the testing framework with standard assertion capabilities to verify both the occurrence of the expected failure and the presence of meaningful error descriptions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileSystemTest",
      "method_signature": "testNameLengthStrategyTruncate_Throws(org.apache.commons.io.FileSystem.NameLengthStrategy, int, java.lang.String, java.nio.charset.Charset, java.lang.String)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FilenameUtilsTruncateTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests to validate that the file naming system correctly rejects attempts to truncate file names\n * when the operation would violate length constraints, ensuring data integrity and system compliance.\n */\npublic class FilenameUtilsTruncateTest {\n\n    /**\n     * This test case validates that the system correctly rejects a file name truncation request\n     * that would result in a corrupted multi-byte character. A file name with a multi-byte\n     * character is submitted for truncation with a length that falls within the byte representation\n     * of that character. The test expects the operation to fail with an {@link IllegalArgumentException}\n     * and verifies that the error message clearly communicates that the truncation is not possible\n     * because it would split a character, thus confirming the system's data integrity protections.\n     */\n    @Test\n    void testTruncationRejectionOnMultiByteCharacterViolation() {\n        // Setup: A file name with a multi-byte character (\u00c2\u00a5 is 2 bytes in UTF-8)\n        final String fileName = \"financial_report_\u00c2\u00a5.xlsx\";\n        final Charset encoding = StandardCharsets.UTF_8;\n        // The prefix \"financial_report_\" is 17 bytes. The '\u00c2\u00a5' character starts at byte 17.\n        // Attempting to truncate at a length of 18 would split the 2-byte character.\n        final int unsafeTruncationLength = 18;\n\n        // Action & Verification: Attempt to truncate and expect a specific failure.\n        final IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {\n            // This test assumes a hypothetical, byte-aware truncate method in FilenameUtils.\n            // It is expected to recognize that the requested length violates character integrity.\n            FilenameUtils.truncate(fileName, unsafeTruncationLength, encoding);\n        }, \"An exception should be thrown when truncation would corrupt a character.\");\n\n        // Verify that the error message contains the expected business reason for the failure.\n        final String errorMessage = exception.getMessage();\n        assertTrue(errorMessage != null && errorMessage.contains(\"Cannot be truncated at length\") && errorMessage.contains(\"would split a multi-byte character\"),\n            \"The error message must clearly explain that the truncation would split a multi-byte character.\");\n    }\n}",
      "method_signature": "testNameLengthStrategyTruncate_Throws(org.apache.commons.io.FileSystem.NameLengthStrategy, int, java.lang.String, java.nio.charset.Charset, java.lang.String)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7374,
    "output_tokens": 8531,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 553,
      "description": "Define a test method annotated with `@Test` that begins by invoking the static method `values()` on the `FileSystem` enum to retrieve an array of all enum constants, then iterate over each constant using a for-each loop with loop variable `fs` of type `FileSystem`. Within the loop body, wrap the following logic in a try-catch block that catches `IllegalArgumentException` and assigns it to variable `iae`: inside the try block, invoke `toLegalFileName` on the current `fs` instance, passing the String literal `\"Test\"` as the first argument and the character literal `'\\0'` (NUL character) as the second argument, with no assignment of the result since the expectation is that this call will throw an exception. In the catch block, immediately invoke `assertTrue` (from JUnit 5 Assertions) with two arguments: the first argument is the result of calling `startsWith` on the String returned by `iae.getMessage()`, passing the String literal `\"The replacement character '\\\\0'\"` (note the escaped backslash and zero), and the second argument is the result of calling `iae.getMessage()` again to provide the failure message. The test verifies that attempting to use the NUL character as a replacement character in file name sanitization throws an `IllegalArgumentException` with a message starting with the specified prefix for every file system enum value. Class-level annotations: none. Method-level annotations: `@Test`. Assertion library: JUnit 5 Assertions. Mocking library: none.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileSystemTest",
      "method_signature": "testReplacementWithNUL()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileSystemTest1",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link FileSystem}.\n */\npublic class FileSystemTest1 {\n\n    @Test\n    public void testToLegalFileNameBadReplacement() {\n        for (final FileSystem fs : FileSystem.values()) {\n            try {\n                fs.toLegalFileName(\"Test\", '\\0');\n            } catch (final IllegalArgumentException iae) {\n                assertTrue(iae.getMessage().startsWith(\"The replacement character '\\\\0'\"), iae.getMessage());\n            }\n        }\n    }\n\n}",
      "method_signature": "testReplacementWithNUL()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 557,
      "description": "Define a test method annotated with `@Test` that declares a try-with-resources block opening a `FileSystem` named `archive` by invoking a private method that accepts a `Path` obtained from `Paths.get(TEST_JAR_PATH)` and a boolean `false`, where the private method checks the boolean parameter and, since it is `false`, directly returns `FileSystems.newFileSystem(p, (ClassLoader) null)` without creating a new archive, then within the try block assign the result of `archive.getPath(\"next/dir/test.log\")` to a `Path` variable named `sourceFile`, immediately invoke `PathUtils.copyFileToDirectory(sourceFile, tempDirPath)` and assign the returned `Path` to a variable named `targetFile`, assert using `assertTrue(Files.exists(targetFile))` to verify the target file exists, and finally assert using `assertEquals(Files.size(sourceFile), Files.size(targetFile))` to confirm both files have identical byte sizes, ensuring the test executes within a `BeforeEach` setup method that invokes `Files.createTempDirectory(managedTempDirPath, getClass().getSimpleName())` to create `tempDirPath` and then calls `tempDirPath.toFile()` to initialize `tempDirFile`, with class-level annotations none, method-level annotation `@Test`, assertion library JUnit 5 Assertions, and no mocking libraries present.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.PathUtilsTest",
      "method_signature": "testCopyFileTwoFileSystem()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.file.PathUtilsCopyFromArchiveTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link PathUtils}.\n */\npublic class PathUtilsCopyFromArchiveTest {\n\n    private static final String TEST_JAR_PATH = \"src/test/resources/org/apache/commons/io/bla.zip\";\n\n    @TempDir\n    static Path managedTempDirPath;\n\n    private Path tempDirPath;\n    private File tempDirFile;\n\n    private FileSystem openArchive(final Path p, final boolean create) throws IOException {\n        if (create) {\n            // Not used in this test, just for fulfilling the method signature.\n            throw new UnsupportedOperationException(\"Create not supported for this test.\");\n        }\n        return FileSystems.newFileSystem(p, (ClassLoader) null);\n    }\n\n    @BeforeEach\n    void setUp() throws IOException {\n        tempDirPath = Files.createTempDirectory(managedTempDirPath, getClass().getSimpleName());\n        tempDirFile = tempDirPath.toFile();\n    }\n\n    @Test\n    public void testCopyFileToDirectory() throws IOException {\n        try (FileSystem archive = openArchive(Paths.get(TEST_JAR_PATH), false)) {\n            final Path sourceFile = archive.getPath(\"next/dir/test.log\");\n            final Path targetFile = PathUtils.copyFileToDirectory(sourceFile, tempDirPath);\n            assertTrue(Files.exists(targetFile));\n            assertEquals(Files.size(sourceFile), Files.size(targetFile));\n        }\n    }\n}",
      "method_signature": "testCopyFileTwoFileSystem()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.5882,
      "callable_precision": 0.9091,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 0.9524,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19330,
    "output_tokens": 4446,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 559,
      "description": "Define a test class containing thirteen private static final String fields: `CHAR_UTF8_1B`, `CHAR_UTF8_2B`, `CHAR_UTF8_3B`, `CHAR_UTF8_4B`, `CHAR_UTF8_69B`, `FILE_NAME_255_BYTES_UTF8_1B`, `FILE_NAME_255_BYTES_UTF8_2B`, `FILE_NAME_255_BYTES_UTF8_3B`, `FILE_NAME_255_BYTES_UTF8_4B`, `FILE_NAME_255_CHARS_UTF8_1B`, `FILE_NAME_255_CHARS_UTF8_2B`, `FILE_NAME_255_CHARS_UTF8_3B`, and `FILE_NAME_255_CHARS_UTF8_4B`, initialized with appropriate string values representing UTF-8 characters and file names of varying byte and character lengths. Create a parameterized test method accepting four parameters: a `NameLengthStrategy` named `strategy`, an `int` named `limit`, a `String` named `input`, and a `String` named `expected`, where the method source provides test cases combining different `NameLengthStrategy` enum values with corresponding limits, input strings (using the field values defined above), and expected truncated output strings. Within the test method, invoke `truncate` on the `strategy` parameter, passing arguments `input`, `limit`, and the constant `UTF_8` (from `java.nio.charset.StandardCharsets`), and assign the returned `CharSequence` to a variable named `out`. Immediately invoke `toString()` on `out` to convert it to a String, then call `assertEquals` with three arguments: the `expected` parameter as the first argument, the result of `out.toString()` as the second argument, and a message string constructed by concatenating the result of invoking `name()` on `strategy` with the literal string `\" truncates to limit\"` as the third argument, thereby verifying that the truncation operation produces the expected output for each parameterized input combination. Annotate the test method with `@ParameterizedTest(name = \"{index}: {0} truncates {1} to {2}\")` and `@MethodSource`, specifying the method source that returns a stream of `Arguments` objects containing the `NameLengthStrategy` instances, integer limits, input strings, and expected strings for each test case.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileSystemTest",
      "method_signature": "testNameLengthStrategyTruncate_Succeeds(org.apache.commons.io.FileSystem.NameLengthStrategy, int, java.lang.String, java.lang.String)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.NameLengthStrategyTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.stream.Stream;\nimport org.apache.commons.io.FileSystem.NameLengthStrategy;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link NameLengthStrategy}.\n */\npublic class NameLengthStrategyTest {\n\n    private static final String CHAR_UTF8_1B = \"a\";\n    private static final String CHAR_UTF8_2B = \"\\u0080\"; // U+0080, outside of ASCII\n    private static final String CHAR_UTF8_3B = \"\\u0800\"; // U+0800\n    private static final String CHAR_UTF8_4B = \"\\uD801\\uDC00\"; // U+10400, a surrogate pair\n    private static final String CHAR_UTF8_69B = \"a\\u0080\\u0800\\uD801\\uDC00\";\n\n    private static final String FILE_NAME_255_BYTES_UTF8_1B = repeat(CHAR_UTF8_1B, 255);\n    private static final String FILE_NAME_255_BYTES_UTF8_2B = repeat(CHAR_UTF8_2B, 127) + CHAR_UTF8_1B;\n    private static final String FILE_NAME_255_BYTES_UTF8_3B = repeat(CHAR_UTF8_3B, 85);\n    private static final String FILE_NAME_255_BYTES_UTF8_4B = repeat(CHAR_UTF8_4B, 63) + CHAR_UTF8_3B;\n\n    private static final String FILE_NAME_255_CHARS_UTF8_1B = repeat(CHAR_UTF8_1B, 255);\n    private static final String FILE_NAME_255_CHARS_UTF8_2B = repeat(CHAR_UTF8_2B, 255);\n    private static final String FILE_NAME_255_CHARS_UTF8_3B = repeat(CHAR_UTF8_3B, 255);\n    private static final String FILE_NAME_255_CHARS_UTF8_4B = repeat(CHAR_UTF8_4B, 255);\n\n    private static String repeat(final String s, final int n) {\n        final StringBuilder sb = new StringBuilder(s.length() * n);\n        for (int i = 0; i < n; i++) {\n            sb.append(s);\n        }\n        return sb.toString();\n    }\n\n    public static Stream<Arguments> data() {\n        return Stream.of(\n            Arguments.of(NameLengthStrategy.BYTES, 10, CHAR_UTF8_69B, \"a\\u0080\\u0800\"),\n            Arguments.of(NameLengthStrategy.BYTES, 255, FILE_NAME_255_BYTES_UTF8_1B, FILE_NAME_255_BYTES_UTF8_1B),\n            Arguments.of(NameLengthStrategy.BYTES, 255, FILE_NAME_255_BYTES_UTF8_2B, FILE_NAME_255_BYTES_UTF8_2B),\n            Arguments.of(NameLengthStrategy.BYTES, 255, FILE_NAME_255_BYTES_UTF8_3B, FILE_NAME_255_BYTES_UTF8_3B),\n            Arguments.of(NameLengthStrategy.BYTES, 255, FILE_NAME_255_BYTES_UTF8_4B, FILE_NAME_255_BYTES_UTF8_4B),\n            Arguments.of(NameLengthStrategy.UTF16_CODE_UNITS, 10, CHAR_UTF8_69B, \"a\\u0080\\u0800\\uD801\\uDC00\"),\n            Arguments.of(NameLengthStrategy.UTF16_CODE_UNITS, 255, FILE_NAME_255_CHARS_UTF8_1B, FILE_name_255_CHARS_UTF8_1B),\n            Arguments.of(NameLengthStrategy.UTF16_CODE_UNITS, 255, FILE_NAME_255_CHARS_UTF8_2B, FILE_NAME_255_CHARS_UTF8_2B),\n            Arguments.of(NameLengthStrategy.UTF16_CODE_UNITS, 255, FILE_NAME_255_CHARS_UTF8_3B, FILE_NAME_255_CHARS_UTF8_3B),\n            Arguments.of(NameLengthStrategy.UTF16_CODE_UNITS, 255, FILE_NAME_255_CHARS_UTF8_4B, FILE_NAME_255_CHARS_UTF8_4B)\n        );\n    }\n\n    @ParameterizedTest(name = \"{index}: {0} truncates {1} to {2}\")\n    @MethodSource(\"data\")\n    public void testTruncate(final NameLengthStrategy strategy, final int limit, final String input, final String expected) {\n        final CharSequence out = strategy.truncate(input, limit, UTF_8);\n        assertEquals(expected, out.toString(), strategy.name() + \" truncates to limit\");\n    }\n}",
      "method_signature": "testNameLengthStrategyTruncate_Succeeds(org.apache.commons.io.FileSystem.NameLengthStrategy, int, java.lang.String, java.lang.String)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "search_file_content": 1,
          "read_file": 2,
          "write_file": 2
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 154378,
    "output_tokens": 4371,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 561,
      "description": "Define a test method that validates the fluent interface behavior of a null-sink writer component by obtaining the singleton writer instance within a try-with-resources block to ensure proper resource management. Invoke the append method with a character sequence input and verify that the returned writer reference is identical to the original instance, confirming the fluent API contract. Subsequently invoke the append method again passing a null character sequence and verify that the returned writer reference remains identical to the original instance, demonstrating null-safety in the fluent interface. Upon exiting the try-with-resources block, the writer's close method is automatically invoked to release any resources. Use a standard assertion library for reference equality verification.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testAppendCharSequence()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterFluentTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertSame;\n\nimport java.io.Writer;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests the fluent interface for {@link NullWriter}.\n */\npublic class NullWriterFluentTest {\n\n    @Test\n    public void testFluentInterfaceBehavior() {\n        try (final Writer writer = NullWriter.INSTANCE) {\n            // Invoke the append method with a character sequence input\n            final Writer returnedWriter1 = writer.append(\"test-sequence\");\n            // Verify that the returned writer reference is identical to the original instance\n            assertSame(writer, returnedWriter1, \"The writer reference returned from append(CharSequence) should be the same.\");\n\n            // Subsequently invoke the append method again passing a null character sequence\n            final Writer returnedWriter2 = writer.append(null);\n            // Verify that the returned writer reference remains identical to the original instance\n            assertSame(writer, returnedWriter2, \"The writer reference returned from append(null) should be the same.\");\n        }\n    }\n}",
      "method_signature": "testAppendCharSequence()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 33617,
    "output_tokens": 4704,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 563,
      "description": "Create a test case to validate that the system's text processing capabilities operate correctly and safely when multiple concurrent operations attempt to read and verify content simultaneously. Prepare a collection of text content variations along with their corresponding verification signatures to ensure data integrity during processing. Configure a concurrent execution environment that simulates multiple simultaneous users accessing the system, then distribute the workload across these parallel operations where each operation processes one of the available content variations using the provided processing strategy. As each concurrent operation executes, verify that the text content is read correctly and matches its expected verification signature, ensuring no corruption occurs during simultaneous access. After all parallel operations complete, confirm that every operation finished successfully without encountering any errors or data integrity issues, demonstrating the system's ability to handle concurrent read operations safely. Once validation is complete, release all allocated processing resources to ensure clean termination of the concurrent environment. Use JUnit 5 as the testing framework with standard assertion mechanisms to verify that all concurrent operations complete without throwing exceptions, validating the thread-safety and correctness of the text processing functionality under concurrent load.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsConcurrentTest",
      "method_signature": "testConcurrentReaderTasks(org.apache.commons.io.function.IOConsumer)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.ConcurrentIOUtilsTest",
      "code": "package org.apache.commons.io;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Tests the thread-safety of text processing capabilities under concurrent load.\n */\npublic class ConcurrentIOUtilsTest {\n\n    @TempDir\n    private File tempDir;\n\n    /**\n     * Tests that concurrent read operations on different files using IOUtils do not interfere with each other and\n     * correctly read the file contents.\n     */\n    @Test\n    public void testConcurrentReadOperations() {\n        final int numOperations = 10;\n        final ExecutorService executorService = Executors.newFixedThreadPool(numOperations);\n\n        // Prepare a collection of text content variations and their corresponding verification signatures\n        final Map<String, String> contentSignatures = IntStream.range(0, numOperations)\n                .boxed()\n                .collect(Collectors.toMap(\n                        i -> \"Test content for operation \" + i + \" with some unique data \" + System.nanoTime(),\n                        content -> \"SIGNATURE:\" + content.hashCode()\n                ));\n\n        final List<File> files = new ArrayList<>();\n        final List<Callable<Boolean>> tasks = new ArrayList<>();\n\n        assertDoesNotThrow(() -> {\n            // Create files and tasks for concurrent processing\n            for (final Map.Entry<String, String> entry : contentSignatures.entrySet()) {\n                final String content = entry.getKey();\n                final String signature = entry.getValue(); // In this test, the signature is derived, but we verify against original content.\n                final File testFile = new File(tempDir, \"testFile\" + files.size() + \".txt\");\n                FileUtils.writeStringToFile(testFile, content, StandardCharsets.UTF_8);\n                files.add(testFile);\n\n                tasks.add(() -> {\n                    // Each concurrent operation reads a file and verifies its content\n                    final String readContent = IOUtils.toString(testFile.toURI(), StandardCharsets.UTF_8);\n                    return content.equals(readContent);\n                });\n            }\n\n            // Execute all concurrent operations\n            final List<Future<Boolean>> results = executorService.invokeAll(tasks);\n\n            // Verify that every operation completed successfully\n            for (final Future<Boolean> future : results) {\n                assertTrue(future.get(), \"Concurrent read operation failed to verify content integrity.\");\n            }\n        }, \"Concurrent execution should not throw any exceptions.\");\n\n        // Clean up resources\n        executorService.shutdown();\n        for (final File file : files) {\n            FileUtils.deleteQuietly(file);\n        }\n    }\n}",
      "method_signature": "testConcurrentReaderTasks(org.apache.commons.io.function.IOConsumer)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.3,
      "callable_precision": 0.1154,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.5,
      "method_coverage": 0.381,
      "line_coverage": 0.3738,
      "branch_coverage": 0.4118
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 17739,
    "output_tokens": 2942,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 564,
      "description": "Create a test case to validate that the system's discard mechanism correctly handles text appending operations while maintaining proper resource management throughout the process. Obtain a system resource designed to safely discard written content, then verify that appending a sequence of text characters returns the same resource handle to enable fluent operation chaining. After confirming this behavior with valid content, verify that the discard mechanism also handles missing or empty content gracefully by appending such content and ensuring the resource handle remains consistent. Once both scenarios are validated, ensure the system properly releases the discard resource to prevent any resource leaks. This test uses JUnit 5 for the testing framework and standard equality assertions to verify that the returned resource handle matches the original instance in both valid and empty content scenarios.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testAppendCharSequence()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertSame;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    @Test\n    public void testAppend() throws IOException {\n        try (final NullWriter writer = NullWriter.INSTANCE) {\n            // Appending valid content\n            assertSame(writer, writer.append(\"text\"));\n            // Appending empty content\n            assertSame(writer, writer.append(\"\"));\n            // Appending missing content\n            assertSame(writer, writer.append(null));\n        }\n    }\n}",
      "method_signature": "testAppendCharSequence()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.6667,
      "callable_recall": 1.0,
      "callable_precision": 0.6667,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18011,
    "output_tokens": 3368,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 567,
      "description": "Create a test case to validate that the system's no-operation output handler correctly supports fluent chaining when processing individual character operations. Establish a scenario using the shared output handler designed to silently discard all written content, then attempt to append a single character to this handler and immediately verify that the operation returns the same handler instance to enable continued method chaining. After confirming the handler maintains its identity through the append operation, release the handler resource to ensure proper cleanup. Validate using JUnit 5 with AssertJ for identity assertions, confirming that the fluent interface pattern remains intact even when the underlying operation performs no actual work.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testAppendChar()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.IOException;\nimport java.lang.Appendable;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    /**\n     * Tests that calling {@link NullWriter#append(char)} returns the same instance to support fluent chaining,\n     * even though the operation itself is a no-op.\n     */\n    @Test\n    public void testFluentAppendChar() throws IOException {\n        // Establish the scenario using the shared no-op handler\n        final NullWriter noOpWriter = NullWriter.NULL_WRITER;\n\n        // Append a character and verify that the handler returns itself for fluent chaining\n        final Appendable result = noOpWriter.append('a');\n        assertThat(result).isSameAs(noOpWriter);\n\n        // Release the handler resource as per best practice, ensuring cleanup procedures are respected\n        noOpWriter.close();\n    }\n}",
      "method_signature": "testAppendChar()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 35402,
    "output_tokens": 7528,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 568,
      "description": "Define a test method that verifies the fluent interface behavior of a Null Writer component by obtaining the singleton instance of the Null Writer within a try-with-resources block to ensure automatic resource cleanup, then invoke the append method with a single character argument and validate that the returned reference is identical to the original writer instance, confirming that the writer maintains method chaining semantics by returning itself, after which the resource will be automatically closed upon exiting the try block using JUnit 5 assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testAppendChar()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertSame;\n\nimport java.io.Writer;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    @Test\n    public void testFluentAppend() {\n        try (Writer writer = NullWriter.INSTANCE) {\n            final Writer appended = writer.append('c');\n            assertSame(writer, appended);\n        } catch (final Exception e) {\n            // Should not happen\n        }\n    }\n}",
      "method_signature": "testAppendChar()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.5,
      "callable_precision": 0.5,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 46946,
    "output_tokens": 2433,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 571,
      "description": "Define a parameterized test method that accepts an IO consumer function operating on Reader instances, then initialize a fixed-size thread pool configured for concurrent execution with a predefined thread count. Create a collection of futures by generating a range of task indices calculated from the product of thread count and runs per iteration, mapping each index to a callable task submitted to the thread pool where each task constructs a ChecksumReader wrapping a StringReader initialized with string data and expected checksum values selected cyclically from pre-seeded arrays using modulo arithmetic on the task index, then within the task's try-with-resources block invoke the consumer parameter on the reader instance before returning null. After collecting all futures into a list, iterate through each future and assert that retrieving its result does not throw any exception, thereby verifying that all concurrent reader operations completed successfully without errors. In the finally block, instruct the thread pool to shut down immediately and discard any pending tasks to ensure proper resource cleanup. This test uses JUnit 5 with parameterized test support.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsConcurrentTest",
      "method_signature": "testConcurrentReaderTasks(org.apache.commons.io.function.IOConsumer)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.ChecksumReaderConcurrencyTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.zip.CRC32;\n\nimport org.apache.commons.io.function.IOConsumer;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link ChecksumReader} for concurrent access.\n */\npublic class ChecksumReaderConcurrencyTest {\n\n    private static final int THREAD_COUNT = 10;\n    private static final int RUNS_PER_THREAD = 20;\n\n    private static final String[] STRING_DATA = {\n        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\",\n        \"Nunc maximus, nulla ut commodo sagittis, sapien dui mattis dui, non pulvinar lorem felis nec erat.\",\n        \"Vivamus et enim et justo consectetur convallis.\",\n        \"In quis massa finibus, consequat sapien eget, egestas ipsum.\"\n    };\n\n    private static final long[] EXPECTED_CHECKSUMS = {\n        2173748255L,\n        1384196556L,\n        1484606992L,\n        3233845023L\n    };\n\n    public static Stream<Arguments> consumerProvider() {\n        final IOConsumer<Reader> consumer = reader -> {\n            while (reader.read() != -1) {\n                // consume\n            }\n        };\n        return Stream.of(Arguments.of(consumer));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"consumerProvider\")\n    public void testConcurrentReads(final IOConsumer<Reader> consumer) throws InterruptedException {\n        final ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);\n        try {\n            final Collection<Callable<Void>> tasks = IntStream.range(0, THREAD_COUNT * RUNS_PER_THREAD)\n                .mapToObj(i -> (Callable<Void>) () -> {\n                    final String data = STRING_DATA[i % STRING_DATA.length];\n                    final long expectedChecksum = EXPECTED_CHECKSUMS[i % EXPECTED_CHECKSUMS.length];\n                    try (Reader reader = new ChecksumReader(new StringReader(data), new CRC32())) {\n                        consumer.accept(reader);\n                    }\n                    return null;\n                })\n                .collect(Collectors.toList());\n\n            final List<Future<Void>> futures = threadPool.invokeAll(tasks);\n            for (final Future<Void> future : futures) {\n                assertDoesNotThrow(() -> future.get(), \"Future should not throw an exception.\");\n            }\n        } finally {\n            threadPool.shutdownNow();\n        }\n    }\n}",
      "method_signature": "testConcurrentReaderTasks(org.apache.commons.io.function.IOConsumer)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 25955,
    "output_tokens": 4627,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 581,
      "description": "Define a test class containing two private static final fields: `TEST_STRING` of type `String` and `TEST_CHARS` of type `char[]`, both initialized with appropriate test values. Write a test method annotated with `@Test` that begins by opening a try-with-resources block, declaring a variable `writer` of type `NullWriter` and assigning it the value `NullWriter.INSTANCE`. Within the try block, invoke `append` on `writer` passing `TEST_STRING` as the argument, then immediately assert using `assertSame` that the returned value is identical to `writer`. Following this, invoke `append` on `writer` again, this time passing `null` as the argument, and assert using `assertSame` that the returned value is again identical to `writer`. The try-with-resources block automatically closes the `writer` upon completion. This test uses the JUnit 5 Assertions library with the `@Test` annotation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testAppendCharSequence()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertSame;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    private static final String TEST_STRING = \"Test\";\n    private static final char[] TEST_CHARS = {'T', 'e', 's', 't'};\n\n    @Test\n    public void testAppend() {\n        try (final NullWriter writer = NullWriter.INSTANCE) {\n            assertSame(writer, writer.append(TEST_STRING));\n            assertSame(writer, writer.append(null));\n        }\n    }\n}",
      "method_signature": "testAppendCharSequence()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 77843,
    "output_tokens": 2258,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 582,
      "description": "Define a parameterized test method that accepts a path counter instance and validates the behavior of copying a directory structure while applying file and directory name filters, then configure the source directory path to reference a test resource location containing a nested directory structure with multiple files, construct a copy directory visitor instance by providing the path counter, a file name filter configured to match a specific binary file name, a directory name filter configured to match two specific directory names, the source directory path, a temporary target directory path managed by the test framework, and a null copy options array, then invoke the file tree traversal utility on the visitor and source directory to execute the copy operation and capture the returned visitor instance, upon completion validate the path counters using a helper method that confirms exactly two directories and one file were processed with a total size of two bytes, assert that the visitor's copy options array matches an empty copy options constant, verify that the visitor's source directory property returns the originally configured source path, confirm that the visitor's target directory property returns the temporary target path, then validate the selective copying behavior by asserting that the target directory contains the expected file at the nested path matching the allowed directory and file name, verify that a sibling file excluded by the file filter does not exist in the target directory, and confirm that a sibling directory excluded by the directory filter was not copied to the target location, using JUnit 5 for parameterization and standard assertion methods.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.CopyDirectoryVisitorTest",
      "method_signature": "testCopyDirectoryFilters(org.apache.commons.io.file.Counters.PathCounters)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.file.CopyDirectoryVisitorParameterizedTest",
      "code": "package org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.filefilter.NameFileFilter;\nimport org.apache.commons.io.filefilter.OrFileFilter;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link CopyDirectoryVisitor}.\n */\npublic class CopyDirectoryVisitorParameterizedTest {\n\n    @TempDir\n    private Path tempDir;\n\n    public static Stream<PathCounter> pathCounters() {\n        return Stream.of(Counters.pathCounter(), Counters.bigIntegerPathCounter());\n    }\n\n    private void assertCounts(final PathCounter pathCounter, final long expectedDirectoryCount,\n        final long expectedFileCount, final long expectedByteCount) {\n        assertEquals(expectedDirectoryCount, pathCounter.getDirectoryCounter().get());\n        assertEquals(expectedFileCount, pathCounter.getFileCounter().get());\n        assertEquals(expectedByteCount, pathCounter.getByteCount());\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"pathCounters\")\n    public void testCopyDirectoryFiltered(final PathCounter pathCounter) throws IOException {\n        final Path sourceDir = tempDir.resolve(\"source\");\n        Files.createDirectories(sourceDir);\n\n        // Create a nested structure\n        final Path dir1 = Files.createDirectory(sourceDir.resolve(\"dir1\"));\n        final Path dir1sub = Files.createDirectory(dir1.resolve(\"dir1sub\"));\n        final Path dir2 = Files.createDirectory(sourceDir.resolve(\"dir2\"));\n\n        // Create files, one with 2 bytes\n        Files.write(dir1sub.resolve(\"file1.bin\"), \"ab\".getBytes(StandardCharsets.UTF_8));\n        Files.write(dir1sub.resolve(\"file2.txt\"), \"c\".getBytes(StandardCharsets.UTF_8));\n        Files.write(dir2.resolve(\"file3.txt\"), \"d\".getBytes(StandardCharsets.UTF_8));\n\n        final Path targetDir = tempDir.resolve(\"target\");\n\n        final NameFileFilter fileFilter = new NameFileFilter(\"file1.bin\");\n        final OrFileFilter dirFilter = new OrFileFilter(new NameFileFilter(\"dir1\"), new NameFileFilter(\"dir1sub\"));\n\n        final CopyDirectoryVisitor visitor = new CopyDirectoryVisitor(pathCounter,\n            PathFilters.asPathFilter(fileFilter), PathFilters.asPathFilter(dirFilter), sourceDir, targetDir,\n            null);\n\n        final CopyDirectoryVisitor returnedVisitor = PathUtils.visitFileTree(visitor, sourceDir);\n\n        // Validate counters\n        assertCounts(pathCounter, 2, 1, 2);\n\n        // Validate visitor properties\n        assertArrayEquals(PathUtils.EMPTY_COPY_OPTION_ARRAY, returnedVisitor.getCopyOptions());\n        assertEquals(sourceDir, returnedVisitor.getSourceDirectory());\n        assertEquals(targetDir, returnedVisitor.getTargetDirectory());\n\n        // Validate selective copying\n        final Path expectedFile = targetDir.resolve(\"dir1\").resolve(\"dir1sub\").resolve(\"file1.bin\");\n        assertTrue(Files.exists(expectedFile));\n\n        final Path excludedFile = targetDir.resolve(\"dir1\").resolve(\"dir1sub\").resolve(\"file2.txt\");\n        assertFalse(Files.exists(excludedFile));\n        \n        final Path excludedDir = targetDir.resolve(\"dir2\");\n        assertFalse(Files.exists(excludedDir));\n    }\n}",
      "method_signature": "testCopyDirectoryFilters(org.apache.commons.io.file.Counters.PathCounters)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7453,
    "output_tokens": 9224,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 587,
      "description": "Define a test class containing a parameterized test method annotated with `@ParameterizedTest` and `@MethodSource` that accepts a single parameter of type `IOConsumer<Reader>` named `consumer` and declares `throws InterruptedException`. Begin by invoking `Executors.newFixedThreadPool(THREAD_COUNT)` and assign the result to a variable `threadPool` of type `ExecutorService`, then wrap the subsequent logic in a try-finally block where the finally block invokes `threadPool.shutdownNow()`. Within the try block, create a variable `futures` of type `List<Future<Void>>` by calling `IntStream.range(0, THREAD_COUNT * RUNS_PER_THREAD)`, chaining `.<Future<Void>>mapToObj(i -> ...)` with a lambda that submits a callable to `threadPool` via `threadPool.submit(() -> {...})`, where the callable's body opens a try-with-resources statement declaring a `Reader` variable named `reader` initialized by constructing a new `ChecksumReader` passing `new StringReader(STRING_DATA[i % VARIANTS])` as the first argument and `STRING_DATA_CHECKSUM[i % VARIANTS]` as the second argument, then within the try block invoke `consumer.accept(reader)`, and after the try-with-resources block return `null`, then chain `.collect(Collectors.toList())` to materialize the stream into the `futures` list. After assigning `futures`, invoke `futures.forEach(f -> assertDoesNotThrow(() -> f.get()))` to iterate over each future and assert that calling `f.get()` does not throw any exception using the `assertDoesNotThrow` assertion method. The test requires class-level fields `THREAD_COUNT`, `RUNS_PER_THREAD`, `VARIANTS`, `STRING_DATA` (of type `String[]`), and `STRING_DATA_CHECKSUM` (of type `long[]`) to be declared as `private static final` with appropriate initialization values, and the test uses JUnit 5 Assertions (`assertDoesNotThrow`) with method-level annotations `@ParameterizedTest` and `@MethodSource`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsConcurrentTest",
      "method_signature": "testConcurrentReaderTasks(org.apache.commons.io.function.IOConsumer)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.function.ConcurrentIOConsumerTest",
      "code": "package org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class ConcurrentIOConsumerTest {\n\n    private static final int THREAD_COUNT = 10;\n    private static final int RUNS_PER_THREAD = 100;\n    private static final int VARIANTS = 4;\n    private static final String[] STRING_DATA = {\n            \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\",\n            \"Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\",\n            \"Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\",\n            \"Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.\"\n    };\n    private static final long[] STRING_DATA_CHECKSUM = {\n            5163,\n            6408,\n            12085,\n            10098\n    };\n\n    private static class ChecksumReader extends Reader {\n\n        private final Reader reader;\n        private final long expected;\n        private long total;\n\n        public ChecksumReader(final Reader reader, final long expected) {\n            this.reader = reader;\n            this.expected = expected;\n        }\n\n        @Override\n        public void close() throws IOException {\n            reader.close();\n            if (expected != total) {\n                throw new IOException(\"Checksum mismatch, expected \" + expected + \", got \" + total);\n            }\n        }\n\n        @Override\n        public int read(final char[] cbuf, final int off, final int len) throws IOException {\n            final int read = reader.read(cbuf, off, len);\n            if (read != -1) {\n                for (int i = 0; i < read; i++) {\n                    total += cbuf[off + i];\n                }\n            }\n            return read;\n        }\n    }\n    \n    public static Stream<IOConsumer<Reader>> getConsumers() {\n        return Stream.of(IOUtils::consume, reader -> {\n            final char[] buffer = new char[4096];\n            while (reader.read(buffer) != -1) {\n                // empty\n            }\n        });\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"getConsumers\")\n    public void test(final IOConsumer<Reader> consumer) throws InterruptedException {\n        final ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);\n        try {\n            final List<Future<Void>> futures = IntStream.range(0, THREAD_COUNT * RUNS_PER_THREAD)\n                    .<Future<Void>>mapToObj(i -> threadPool.submit(() -> {\n                        try (Reader reader = new ChecksumReader(new StringReader(STRING_DATA[i % VARIANTS]),\n                                STRING_DATA_CHECKSUM[i % VARIANTS])) {\n                            consumer.accept(reader);\n                        }\n                        return null;\n                    })).collect(Collectors.toList());\n            futures.forEach(f -> assertDoesNotThrow(() -> f.get()));\n        } finally {\n            threadPool.shutdownNow();\n        }\n    }\n}",
      "method_signature": "testConcurrentReaderTasks(org.apache.commons.io.function.IOConsumer)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.5,
      "obj_creation_precision": 0.5,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20833,
    "output_tokens": 5660,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 595,
      "description": "Create a test to validate that the system correctly transfers files and directories from one location to another while applying selective filtering rules to control which items are included in the operation. Begin by identifying a source location containing a predefined structure of nested directories and files with known characteristics, then establish a separate temporary destination location to receive the copied items. Configure the transfer operation to accept only files matching a specific name pattern and directories matching designated names, excluding all other items from the operation. Initiate the transfer process by traversing the source structure and applying the configured filters, then verify the operation completed successfully by confirming exactly two directory visits occurred, one file was transferred, and two total items were processed. After the transfer completes, confirm the operation used default transfer settings without any special options, validate the source and destination locations match the originally specified paths, and verify the selective filtering worked correctly by checking that the expected file exists in its proper subdirectory within the destination while confirming excluded files and directories are absent from the destination structure. The test uses JUnit 5 as the testing framework with parameterized test support, AssertJ for fluent assertions on collections and counts, and validates outcomes through standard equality assertions on path references and existence checks on the transferred file structure.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.CopyDirectoryVisitorTest",
      "method_signature": "testCopyDirectoryFilters(org.apache.commons.io.file.Counters.PathCounters)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.DirectoryWalkerFilteringTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.commons.io.filefilter.IOFileFilter;\nimport org.apache.commons.io.filefilter.NameFileFilter;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link DirectoryWalker} with filtering.\n */\npublic class DirectoryWalkerFilteringTest {\n\n    @TempDir\n    private Path tempDir;\n\n    private static class SelectiveCopyWalker extends DirectoryWalker<Path> {\n\n        private final Path srcRoot;\n        private final Path dstRoot;\n        private long dirVisitCount;\n        private long dirCreateCount;\n        private long fileCreateCount;\n\n        SelectiveCopyWalker(final Path srcRoot, final Path dstRoot, final IOFileFilter dirFilter, final IOFileFilter fileFilter) {\n            super(dirFilter, fileFilter, -1);\n            this.srcRoot = srcRoot;\n            this.dstRoot = dstRoot;\n        }\n\n        public List<Path> copy() throws IOException {\n            final List<Path> results = new ArrayList<>();\n            walk(srcRoot.toFile(), results);\n            return results;\n        }\n\n        public long getDirVisitCount() {\n            return dirVisitCount;\n        }\n\n        public long getFileCreateCount() {\n            return fileCreateCount;\n        }\n\n        public Path getDstRoot() {\n            return dstRoot;\n        }\n\n        public Path getSrcRoot() {\n            return srcRoot;\n        }\n\n        public long getTotalProcessedCount() {\n            return dirCreateCount + fileCreateCount;\n        }\n\n        @Override\n        protected void handleDirectoryStart(final File directory, final int depth, final Collection<Path> results) {\n            dirVisitCount++;\n            if (depth > 0) {\n                final Path targetDir = dstRoot.resolve(srcRoot.relativize(directory.toPath()));\n                try {\n                    Files.createDirectories(targetDir);\n                    dirCreateCount++;\n                } catch (final IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n        }\n\n        @Override\n        protected void handleFile(final File file, final int depth, final Collection<Path> results) throws IOException {\n            final Path targetFile = dstRoot.resolve(srcRoot.relativize(file.toPath()));\n            FileUtils.copyFile(file, targetFile.toFile());\n            fileCreateCount++;\n            results.add(targetFile);\n        }\n    }\n\n    @Test\n    public void testSelectiveFileAndDirectoryTransfer() throws IOException {\n        // 1. Setup source directory structure\n        final Path source = tempDir.resolve(\"source\");\n        final Path dir1 = source.resolve(\"dir1\");\n        final Path dir2 = source.resolve(\"dir2\");\n        final Path file1 = dir1.resolve(\"file1.txt\");\n        final Path file2 = dir2.resolve(\"file2.txt\");\n\n        Files.createDirectories(dir1);\n        Files.createDirectories(dir2);\n        Files.write(file1, \"file1-content\".getBytes(StandardCharsets.UTF_8));\n        Files.write(file2, \"file2-content\".getBytes(StandardCharsets.UTF_8));\n\n        // 2. Setup destination and filters\n        final Path destination = tempDir.resolve(\"destination\");\n        Files.createDirectories(destination);\n\n        final IOFileFilter fileFilter = new NameFileFilter(\"file1.txt\");\n        final IOFileFilter dirFilter = new NameFileFilter(\"dir1\");\n\n        // 3. Initiate transfer and get results\n        final SelectiveCopyWalker walker = new SelectiveCopyWalker(source, destination, dirFilter, fileFilter);\n        final List<Path> copiedFiles = walker.copy();\n\n        // 4. Verify counts\n        assertThat(walker.getDirVisitCount()).isEqualTo(2); // source + dir1\n        assertThat(walker.getFileCreateCount()).isEqualTo(1); // file1.txt\n        assertThat(walker.getTotalProcessedCount()).isEqualTo(2); // dir1 + file1.txt\n\n        // 5. Validate source and destination paths\n        assertThat(walker.getSrcRoot()).isEqualTo(source);\n        assertThat(walker.getDstRoot()).isEqualTo(destination);\n\n        // 6. Verify selective filtering outcome\n        final Path expectedFile = destination.resolve(\"dir1/file1.txt\");\n        assertThat(copiedFiles).containsExactly(expectedFile);\n        assertThat(expectedFile).exists().hasContent(\"file1-content\");\n        assertThat(destination.resolve(\"dir2\")).doesNotExist();\n        assertThat(destination.resolve(\"dir2/file2.txt\")).doesNotExist();\n    }\n}",
      "method_signature": "testCopyDirectoryFilters(org.apache.commons.io.file.Counters.PathCounters)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 24330,
    "output_tokens": 9623,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 601,
      "description": "Define a test method annotated with `@Test` that begins by opening a try-with-resources block, declaring a variable `writer` of type `org.apache.commons.io.output.NullWriter` and initializing it with the static field `NullWriter.INSTANCE`. Within the try block, invoke the `append` method on `writer` with the character literal `'X'` as the argument, then immediately assert using `assertSame` that the return value of this `append` invocation is identical to the `writer` instance itself, verifying that the method returns the same writer object for method chaining. The try-with-resources block automatically closes the `writer` upon completion. This test uses the `@Test` annotation from JUnit and the `assertSame` assertion method from JUnit's assertion library.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testAppendChar()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 603,
      "description": "Create a test case to validate that the system's null output handler correctly enforces boundary protections when processing partial text segments. Begin by establishing a connection to the null output handler, then verify it successfully accepts a valid partial segment extraction from sample text with proper positioning and length constraints. After confirming normal operation, systematically challenge the handler's input validation by attempting to write partial segments using invalid boundary specifications: first submit a request with a negative starting position to ensure the system rejects out-of-range offsets, then provide a negative length value to confirm length validation, followed by an attempt to extract a segment that extends beyond the available text boundaries to verify range checking, and finally attempt to process missing text content to ensure the system properly handles absent input data. Throughout each validation scenario, confirm the system appropriately rejects the invalid operation with the corresponding boundary or content violation response. Once all validation scenarios complete, release the output handler connection. Verify using standard exception assertions with JUnit 5 and AssertJ for validation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testWriteStringWithOffset()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "package org.apache.commons.io.output;\n\nimport static org.assertj.core.api.Assertions.assertThatCode;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    @Test\n    public void testPartialWriteBoundaryProtections() {\n        // \"Establish connection\" to the handler, which for NullWriter means getting the singleton instance.\n        final NullWriter writer = NullWriter.INSTANCE;\n        final String sampleText = \"Hello, world!\";\n        final char[] sampleChars = sampleText.toCharArray();\n\n        // 1. Verify acceptance of a valid partial segment\n        assertThatCode(() -> writer.write(sampleText, 7, 5))\n            .as(\"A valid partial segment from a String should be accepted\")\n            .doesNotThrowAnyException();\n\n        assertThatCode(() -> writer.write(sampleChars, 7, 5))\n            .as(\"A valid partial segment from a char array should be accepted\")\n            .doesNotThrowAnyException();\n\n        // 2. Reject negative starting position\n        assertThatThrownBy(() -> writer.write(sampleText, -1, 5))\n            .as(\"A negative start position should be rejected for Strings\")\n            .isInstanceOf(IndexOutOfBoundsException.class);\n\n        assertThatThrownBy(() -> writer.write(sampleChars, -1, 5))\n            .as(\"A negative start position should be rejected for char arrays\")\n            .isInstanceOf(IndexOutOfBoundsException.class);\n\n        // 3. Reject negative length\n        assertThatThrownBy(() -> writer.write(sampleText, 0, -1))\n            .as(\"A negative length should be rejected for Strings\")\n            .isInstanceOf(IndexOutOfBoundsException.class);\n\n        assertThatThrownBy(() -> writer.write(sampleChars, 0, -1))\n            .as(\"A negative length should be rejected for char arrays\")\n            .isInstanceOf(IndexOutOfBoundsException.class);\n\n        // 4. Reject segment extending beyond text boundaries\n        assertThatThrownBy(() -> writer.write(sampleText, 0, sampleText.length() + 1))\n            .as(\"A segment larger than the String should be rejected\")\n            .isInstanceOf(IndexOutOfBoundsException.class);\n\n        assertThatThrownBy(() -> writer.write(sampleChars, 0, sampleChars.length + 1))\n            .as(\"A segment larger than the char array should be rejected\")\n            .isInstanceOf(IndexOutOfBoundsException.class);\n\n        assertThatThrownBy(() -> writer.write(sampleText, 8, 6))\n            .as(\"A segment extending beyond the end of the String should be rejected\")\n            .isInstanceOf(IndexOutOfBoundsException.class);\n\n        // 5. Reject missing/null text content\n        assertThatThrownBy(() -> writer.write((String) null, 0, 1))\n            .as(\"Null string input should be rejected\")\n            .isInstanceOf(NullPointerException.class);\n\n        assertThatThrownBy(() -> writer.write((char[]) null, 0, 1))\n            .as(\"Null char array input should be rejected\")\n            .isInstanceOf(NullPointerException.class);\n\n        // \"Release the output handler connection\" by closing it.\n        assertThatCode(writer::close)\n            .as(\"Closing the writer should not cause issues\")\n            .doesNotThrowAnyException();\n    }\n}",
      "method_signature": "testWriteStringWithOffset()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 28657,
    "output_tokens": 6802,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 605,
      "description": "Create a test case to validate that the system's text discard mechanism correctly handles string-based content submission while enforcing proper input validation rules. Begin by configuring the discard mechanism for use, then submit a valid text string to confirm the system accepts and processes it without error. Following this successful operation, verify the system's defensive behavior by attempting to submit a missing text value, ensuring the system properly rejects this invalid input and signals a validation failure due to the absence of required content. Once both the acceptance of valid content and rejection of invalid content are confirmed, release the discard mechanism to free any held resources. Use JUnit 5 as the testing framework with standard assertion capabilities to verify both the successful processing of valid input and the appropriate failure response when content is missing.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testWriteString()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileCleaningTrackerInputValidationTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileCleaningTracker} input validation as a \"text discard mechanism\".\n */\npublic class FileCleaningTrackerInputValidationTest {\n\n    @TempDir\n    private File tempDir;\n\n    @Test\n    public void testTrackAcceptsValidAndRejectsInvalidPath() throws IOException {\n        final FileCleaningTracker tracker = new FileCleaningTracker();\n        final File testFile = new File(tempDir, \"testfile.txt\");\n        FileUtils.writeStringToFile(testFile, \"test content\", StandardCharsets.UTF_8);\n        assertTrue(testFile.exists(), \"Test file should exist\");\n\n        // Confirm the tracker accepts a valid file path.\n        assertDoesNotThrow(() -> {\n            tracker.track(testFile.getAbsolutePath(), new Object(), FileDeleteStrategy.NORMAL);\n        });\n\n        // Verify the tracker rejects a null file path.\n        assertThrows(NullPointerException.class, () -> {\n            tracker.track(null, new Object(), FileDeleteStrategy.NORMAL);\n        });\n\n        // Release tracker resources.\n        tracker.close();\n\n        // Clean up the created file as deletion by tracker is not guaranteed after close.\n        FileUtils.deleteQuietly(testFile);\n    }\n}",
      "method_signature": "testWriteString()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22349,
    "output_tokens": 7759,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 608,
      "description": "Define a test class containing two private static final fields: `TEST_STRING` of type `java.lang.String` and `TEST_CHARS` of type `char[]`, initialized with appropriate literal values. Write a test method annotated with `@Test` that begins by opening a try-with-resources block, declaring a variable `writer` of type `org.apache.commons.io.output.NullWriter` and initializing it with `NullWriter.INSTANCE`. Within the try block, invoke `write` on `writer` passing three arguments: `TEST_STRING`, integer literal `1`, and integer literal `1`. Following this invocation, use `assertThrows` to verify that an `IndexOutOfBoundsException` is thrown when invoking `write` on `writer` with arguments `TEST_STRING`, integer literal `-1`, and integer literal `0`. Next, use `assertThrows` to verify that an `IndexOutOfBoundsException` is thrown when invoking `write` on `writer` with arguments `TEST_STRING`, integer literal `0`, and integer literal `-1`. Then, use `assertThrows` to verify that an `IndexOutOfBoundsException` is thrown when invoking `write` on `writer` with arguments `TEST_STRING`, integer literal `0`, and integer literal `4`. Finally, use `assertThrows` to verify that a `NullPointerException` is thrown when invoking `write` on `writer` with arguments `(String) null` (explicitly cast), integer literal `0`, and integer literal `0`. The try-with-resources block automatically closes the `writer` upon completion. This test uses the `@Test` annotation from JUnit 5, employs JUnit 5 Assertions via `assertThrows`, and does not involve any mocking libraries.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testWriteStringWithOffset()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "package org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    private static final String TEST_STRING = \"abc\";\n    private static final char[] TEST_CHARS = { 'a', 'b', 'c' };\n\n    @Test\n    public void testWriteStringOffLen() {\n        try (final NullWriter writer = NullWriter.INSTANCE) {\n            writer.write(TEST_STRING, 1, 1);\n            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(TEST_STRING, -1, 0));\n            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(TEST_STRING, 0, -1));\n            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(TEST_STRING, 0, 4));\n            assertThrows(NullPointerException.class, () -> writer.write((String) null, 0, 0));\n        }\n    }\n}",
      "method_signature": "testWriteStringWithOffset()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 42847,
    "output_tokens": 8496,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 610,
      "description": "Define a test class containing two private static final fields: `TEST_STRING` of type `java.lang.String` and `TEST_CHARS` of type `char[]`, initializing them with appropriate test data values. Write a test method annotated with `@Test` that begins by declaring a try-with-resources block, assigning `NullWriter.INSTANCE` to a variable named `writer` of type `org.apache.commons.io.output.NullWriter`. Within the try block, invoke `write` on `writer` passing `TEST_STRING` as the argument, then immediately use `assertThrows` with `NullPointerException.class` as the first argument and a lambda expression as the second argument that invokes `write` on `writer` with a cast null String literal `(String) null` to verify that passing null throws the expected exception. The try-with-resources construct automatically closes the writer upon block exit. The test method uses JUnit 5 Assertions via the `assertThrows` method and is annotated with `@Test` at the method level, with no class-level annotations present.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testWriteString()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "package org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\n\n/**\n * Tests for {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    private static final String TEST_STRING = \"Hello World\";\n    private static final char[] TEST_CHARS = {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd'};\n\n    @Test\n    public void testWrite() throws IOException {\n        try (final NullWriter writer = NullWriter.INSTANCE) {\n            writer.write(TEST_STRING);\n            assertThrows(NullPointerException.class, () -> writer.write((String) null));\n        }\n    }\n}",
      "method_signature": "testWriteString()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 28204,
    "output_tokens": 3010,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 614,
      "description": "Define a test method that validates the string-writing capability of a Null Writer component, which discards all written data without performing actual I/O operations. Obtain the singleton instance of the Null Writer and wrap it in a try-with-resources block to ensure proper resource cleanup. Invoke the write method on the writer instance passing a predefined test string to verify the component accepts valid string input without throwing exceptions. Following this successful write operation, validate the component's argument validation behavior by asserting that invoking the write method with a null string reference triggers a null pointer exception, confirming the writer enforces non-null input constraints. Upon exiting the try-with-resources block, the writer instance is automatically closed, releasing any associated resources. Use JUnit 5 for the testing framework and its assertion utilities for exception validation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testWriteString()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    @Test\n    public void testWriteString() throws IOException {\n        try (final Writer writer = NullWriter.INSTANCE) {\n            // Test that a valid string does not throw an exception\n            writer.write(\"Test String\");\n\n            // Test that a null string throws a NullPointerException\n            assertThrows(NullPointerException.class, () -> writer.write((String) null));\n        }\n    }\n}",
      "method_signature": "testWriteString()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.5,
      "callable_precision": 0.5,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 36223,
    "output_tokens": 3505,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 618,
      "description": "Define a test method that validates the character array write operation and argument validation behavior of a Null Writer component by first obtaining the singleton writer instance and wrapping it in a try-with-resources block to ensure proper resource cleanup, then invoke the write method with a predefined character array to confirm the operation completes without error, and immediately following this successful write, validate the component's null-safety by asserting that invoking the write method with a null character array argument throws a NullPointerException, thereby confirming both the normal operation path and the defensive validation logic of the writer, and upon completion of these verifications, allow the try-with-resources construct to automatically close the writer instance. JUnit 5.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testWriteCharArray()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    @Test\n    public void testWriteCharArray() throws IOException {\n        final char[] chars = {'A', 'B', 'C'};\n        try (final NullWriter writer = NullWriter.INSTANCE) {\n            writer.write(chars);\n            assertThrows(NullPointerException.class, () -> writer.write((char[]) null));\n        }\n    }\n}",
      "method_signature": "testWriteCharArray()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 2,
          "write_file": 1,
          "run_shell_command": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 68771,
    "output_tokens": 1867,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 619,
      "description": "Define a test class containing two private static final fields: `TEST_STRING` of type `String` and `TEST_CHARS` of type `char[]`, initializing them with appropriate test values. Write a test method annotated with `@Test` that begins by declaring a try-with-resources block, assigning `NullWriter.INSTANCE` to a variable named `writer` of type `NullWriter`. Within the try block, invoke `write` on `writer` passing `TEST_CHARS` as the argument, then immediately invoke `assertThrows` with `NullPointerException.class` as the first argument and a lambda expression `() -> writer.write((char[]) null)` as the second argument to verify that passing a null char array to `write` throws a `NullPointerException`. The try-with-resources block automatically closes the `writer` upon completion. The test uses JUnit 5 Assertions with method-level annotation `@Test`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testWriteCharArray()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    private static final String TEST_STRING = \"This is a test string.\";\n    private static final char[] TEST_CHARS = TEST_STRING.toCharArray();\n\n    @Test\n    public void testWrite() throws IOException {\n        try (final NullWriter writer = NullWriter.INSTANCE) {\n            writer.write(TEST_CHARS);\n            assertThrows(NullPointerException.class, () -> writer.write((char[]) null));\n        }\n    }\n}",
      "method_signature": "testWriteCharArray()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 26402,
    "output_tokens": 2111,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 623,
      "description": "Create a test case to validate that the system's null output handler correctly processes character array content while enforcing proper input validation. Begin by establishing access to the null output handler, which discards all written content without storing or transmitting it anywhere. First, attempt to write a predefined sequence of characters to the handler and verify the operation completes successfully without errors, confirming the handler accepts valid character arrays. Once this baseline behavior is confirmed, proceed to validate the system's defensive behavior by attempting to write missing character array content, ensuring the operation fails immediately with an appropriate validation error that prevents the system from processing invalid input. After completing both validation scenarios, release the handler's resources to ensure proper cleanup. Verify the expected outcomes using JUnit 5 for test execution and standard assertion mechanisms to confirm both successful processing of valid content and proper rejection of missing input.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testWriteCharArray()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 21992,
    "output_tokens": 5151,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 630,
      "description": "Define a test method that validates the boundary and null-safety behavior of the Null Writer component when writing string data with offset and length parameters. Obtain the singleton instance of the Null Writer and establish a try-with-resources block to ensure proper resource cleanup. Using a predefined test string constant, invoke the write method with valid offset and length values to confirm the component accepts well-formed inputs without error. Validate argument constraints by asserting that passing a negative offset triggers an index boundary exception, then verify that a negative length value similarly produces an index boundary exception. Confirm that specifying a length exceeding the available characters from the given offset also raises an index boundary exception, ensuring the component enforces valid substring boundaries. Verify null-safety by asserting that passing a null string reference results in a null pointer exception, confirming the component rejects invalid inputs appropriately. Upon exiting the try-with-resources block, allow the writer to close automatically, completing the resource cleanup. JUnit 5 for the testing framework and standard assertion utilities for exception validation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testWriteStringWithOffset()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.Writer;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    private static final String TEST_STRING = \"Hello, world!\";\n\n    @Test\n    public void testWriteStringWithOffsetAndLength() {\n        try (final Writer writer = NullWriter.INSTANCE) {\n            // Test writing with valid offset and length\n            writer.write(TEST_STRING, 0, TEST_STRING.length());\n\n            // Test writing with negative offset\n            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(TEST_STRING, -1, 1));\n\n            // Test writing with negative length\n            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(TEST_STRING, 0, -1));\n\n            // Test writing with length greater than the available characters\n            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(TEST_STRING, 0, TEST_STRING.length() + 1));\n\n            // Test writing with a null string\n            assertThrows(NullPointerException.class, () -> writer.write(null, 0, 1));\n        } catch (final Exception e) {\n            // Fails if an exception is thrown from the try-with-resources block\n        }\n    }\n}",
      "method_signature": "testWriteStringWithOffset()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 62327,
    "output_tokens": 1753,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 631,
      "description": "Define a test class containing a private static final field `EXPECTED_COPY_OPTIONS` of type `CopyOption[]` and a private field `targetDir` of type `Path` annotated with `@TempDir`, then write a parameterized test method annotated with `@ParameterizedTest` and `@MethodSource(\"pathCounters\")` that accepts a single parameter `pathCounters` of type `PathCounters` and declares `IOException` in its throws clause. Begin by invoking `Paths.get` with the string literal `\"src/test/resources/org/apache/commons/io/dirs-2-file-size-4\"` and assign the result to a local variable `sourceDir` of type `Path`. Next, construct a `NameFileFilter` instance by passing the string literal `\"file-size-1.bin\"` to its constructor, then construct a second `NameFileFilter` instance by passing the two string literals `\"dirs-2-file-size-4\"` and `\"dirs-a-file-size-1\"` as varargs to its constructor. Using these two filters, instantiate a `CopyDirectoryVisitor` by passing `pathCounters`, the first `NameFileFilter` instance, the second `NameFileFilter` instance, `sourceDir`, `targetDir`, and a null value explicitly cast to `CopyOption[]` as constructor arguments. Immediately pass this `CopyDirectoryVisitor` instance along with `sourceDir` to the static method `PathUtils.visitFileTree`, assigning the returned `CopyDirectoryVisitor` to a local variable `visitFileTree`. Invoke the helper method `assertCounts` with the integer literals `2`, `1`, `2`, and the `visitFileTree` variable as arguments. Invoke `assertArrayEquals` with `PathUtils.EMPTY_COPY_OPTIONS` as the first argument and the result of calling `getCopyOptions()` on `visitFileTree` as the second argument. Invoke `assertEquals` with `sourceDir` as the first argument and the result of calling `getSourceDirectory()` on `visitFileTree` as the second argument. Invoke `assertEquals` with `targetDir` as the first argument and the result of calling `getTargetDirectory()` on `visitFileTree` as the second argument. Invoke `assertTrue` with the result of calling `Files.exists` on the path obtained by calling `resolve` on `targetDir` with the string literal `\"dirs-a-file-size-1/file-size-1.bin\"` as the argument. Invoke `assertFalse` with the result of calling `Files.exists` on the path obtained by calling `resolve` on `targetDir` with the string literal `\"dirs-a-file-size-1/file-size-2.bin\"` as the argument. Invoke `assertFalse` with the result of calling `Files.exists` on the path obtained by calling `resolve` on `targetDir` with the string literal `\"dirs-a-file-size-2\"` as the argument. The test uses JUnit 5 Assertions and is annotated at the method level with `@ParameterizedTest` and `@MethodSource(\"pathCounters\")`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.CopyDirectoryVisitorTest",
      "method_signature": "testCopyDirectoryFilters(org.apache.commons.io.file.Counters.PathCounters)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.file.CopyDirectoryVisitorTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.nio.file.CopyOption;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.filefilter.NameFileFilter;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link CopyDirectoryVisitor}.\n */\npublic class CopyDirectoryVisitorTest1 {\n\n    private static final CopyOption[] EXPECTED_COPY_OPTIONS = {};\n\n    @TempDir\n    private Path targetDir;\n\n    private static Stream<PathCounters> pathCounters() {\n        return Stream.of(new PathCounters());\n    }\n\n    private void assertCounts(final long expectedDirectoryCount, final long expectedFileCount, final long expectedByteCount,\n        final CopyDirectoryVisitor visitor) {\n        final PathCounters pathCounters = visitor.getPathCounters();\n        assertEquals(expectedDirectoryCount, pathCounters.getDirectoryCounter().get());\n        assertEquals(expectedFileCount, pathCounters.getFileCounter().get());\n        assertEquals(expectedByteCount, pathCounters.getByteCounter().get());\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"pathCounters\")\n    public void testCopyDirectoryVisitorWithFilters(final PathCounters pathCounters) throws IOException {\n        final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-4\");\n        final NameFileFilter fileFilter = new NameFileFilter(\"file-size-1.bin\");\n        final NameFileFilter dirFilter = new NameFileFilter(\"dirs-2-file-size-4\", \"dirs-a-file-size-1\");\n        final CopyDirectoryVisitor visitor = new CopyDirectoryVisitor(pathCounters, fileFilter, dirFilter, sourceDir, targetDir, (CopyOption[]) null);\n        final CopyDirectoryVisitor visitFileTree = PathUtils.visitFileTree(visitor, sourceDir);\n\n        assertCounts(2, 1, 2, visitFileTree);\n        assertArrayEquals(PathUtils.EMPTY_COPY_OPTIONS, visitFileTree.getCopyOptions());\n        assertEquals(sourceDir, visitFileTree.getSourceDirectory());\n        assertEquals(targetDir, visitFileTree.getTargetDirectory());\n\n        assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1/file-size-1.bin\")));\n        assertFalse(Files.exists(targetDir.resolve(\"dirs-a-file-size-1/file-size-2.bin\")));\n        assertFalse(Files.exists(targetDir.resolve(\"dirs-a-file-size-2\")));\n    }\n\n}",
      "method_signature": "testCopyDirectoryFilters(org.apache.commons.io.file.Counters.PathCounters)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22696,
    "output_tokens": 7091,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 638,
      "description": "Define a test method annotated with `@Test` that verifies the behavior of writing an integer to a `NullWriter` instance. Begin by opening a try-with-resources block, declaring a variable named `writer` of type `org.apache.commons.io.output.NullWriter` and initializing it with the static field `NullWriter.INSTANCE`. Within the try block, invoke the `write` method on `writer`, passing the integer literal `42` as the argument. The try-with-resources construct will automatically close the writer upon exiting the block, requiring no explicit teardown logic. This test uses the JUnit 5 `@Test` annotation and relies on the try-with-resources mechanism for resource management without any explicit assertions or mocking libraries.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testWriteInt()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    @Test\n    public void testWriteInteger() throws Exception {\n        try (final NullWriter writer = NullWriter.INSTANCE) {\n            writer.write(42);\n        }\n    }\n}",
      "method_signature": "testWriteInt()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 39083,
    "output_tokens": 1579,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 639,
      "description": "Create a test case to validate that the system's null output mechanism correctly handles character array operations with offset and length parameters while enforcing proper boundary validation. Begin by establishing a scenario where the null output mechanism is ready to receive character data, then demonstrate successful processing of a valid subset of characters from a predefined character array by specifying a starting position and length. After confirming the system accepts valid operations, verify the system's protective boundaries by ensuring it rejects attempts to process character data with invalid parameters: first confirm the system refuses operations with negative starting positions, then verify it blocks operations with negative lengths, followed by validation that it prevents operations attempting to process more characters than available in the array, and finally ensure the system appropriately fails when presented with missing character data instead of a valid array. The validation strategy should confirm that each boundary violation triggers the appropriate business rule enforcement, distinguishing between range violations and missing data scenarios. Use JUnit 5 for the testing framework and standard assertion capabilities to verify that the system correctly enforces input validation rules while successfully processing valid character array operations.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testWriteCharArrayWithOffset()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "package org.apache.commons.io.output;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.io.Writer;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\n/**\n * Tests for {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    @Test\n    public void testCharArrayWriteWithOffsetAndLengthBoundaryValidation() {\n        final Writer writer = NullWriter.INSTANCE;\n        final char[] chars = {'a', 'b', 'c', 'd'};\n\n        // Demonstrate successful processing of a valid subset of characters\n        writer.write(chars, 1, 2);\n\n        // Verify it refuses operations with negative starting positions\n        assertThrows(IndexOutOfBoundsException.class, () -> writer.write(chars, -1, 1));\n\n        // Verify it blocks operations with negative lengths\n        assertThrows(IndexOutOfBoundsException.class, () -> writer.write(chars, 0, -1));\n\n        // Verify it prevents operations attempting to process more characters than available\n        assertThrows(IndexOutOfBoundsException.class, () -> writer.write(chars, 0, chars.length + 1));\n        \n        // Verify it prevents operations where offset + length exceeds the array size\n        assertThrows(IndexOutOfBoundsException.class, () -> writer.write(chars, 2, 3));\n\n        // Ensure the system fails when presented with a missing character data\n        assertThrows(NullPointerException.class, () -> writer.write(null, 0, 1));\n    }\n}",
      "method_signature": "testWriteCharArrayWithOffset()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 34345,
    "output_tokens": 11533,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 641,
      "description": "Define a test method that validates the Null Writer component's ability to accept integer character code input without throwing exceptions or producing side effects. Obtain a reference to the singleton Null Writer instance and initialize it within a try-with-resources block to ensure proper resource management. Invoke the write method on the writer instance, passing an integer character code as input to verify that the component silently discards the data without error. Upon completion of the write operation, allow the try-with-resources construct to automatically close the writer instance, confirming that the component handles lifecycle management correctly. This test uses JUnit 5.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testWriteInt()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n\nimport java.io.Writer;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    @Test\n    public void testWriteInt() {\n        assertDoesNotThrow(() -> {\n            try (Writer writer = NullWriter.INSTANCE) {\n                writer.write(123);\n            }\n        }, \"Writing an integer to NullWriter should not throw an exception.\");\n    }\n\n}",
      "method_signature": "testWriteInt()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 1,
          "write_file": 1,
          "run_shell_command": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 52857,
    "output_tokens": 3773,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 643,
      "description": "Create a test case to validate that the discard-only output mechanism correctly handles individual character operations without errors. Establish a connection to the discard output system using its shared instance, then submit a single character value to verify the system accepts and silently discards the input as expected. After confirming the operation completes without failure, ensure the output connection is properly released. Verify the behavior using JUnit 5 with standard execution flow validation, confirming the system fulfills its contract of accepting character data while producing no persistent output or side effects.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testWriteInt()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n\nimport java.io.Writer;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * JUnit 5 test case for {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    /**\n     * Tests that writing a single character to the shared {@link NullWriter}\n     * instance does not throw an exception and that the stream can be closed\n     * without error.\n     */\n    @Test\n    public void testWriteChar() {\n        assertDoesNotThrow(() -> {\n            try (final Writer writer = NullWriter.INSTANCE) {\n                writer.write('a');\n            }\n        }, \"Writing a char should not throw an exception.\");\n    }\n\n}",
      "method_signature": "testWriteInt()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 39596,
    "output_tokens": 5920,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 645,
      "description": "Define a test class containing two private static final fields: `TEST_STRING` of type `String` and `TEST_CHARS` of type `char[]`, initializing them with appropriate test data values. Write a test method annotated with `@Test` that begins by opening a try-with-resources block, declaring a variable `writer` of type `NullWriter` and assigning it the value `NullWriter.INSTANCE`. Within the try block, invoke `write` on `writer` passing three arguments: the char array `TEST_CHARS`, the int offset `1`, and the int length `2`. Following this invocation, use `assertThrows` to verify that an `IndexOutOfBoundsException` is thrown when invoking `write` on `writer` with arguments `TEST_CHARS`, `-1`, and `0`. Next, use `assertThrows` to verify that an `IndexOutOfBoundsException` is thrown when invoking `write` on `writer` with arguments `TEST_CHARS`, `0`, and `-1`. Then use `assertThrows` to verify that an `IndexOutOfBoundsException` is thrown when invoking `write` on `writer` with arguments `TEST_CHARS`, `0`, and `4`. Finally, use `assertThrows` to verify that a `NullPointerException` is thrown when invoking `write` on `writer` with a null char array explicitly cast as `(char[]) null`, offset `0`, and length `0`. The try-with-resources block automatically closes the `writer` upon completion. The test uses JUnit 5 Assertions with method-level annotation `@Test` and no class-level annotations.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testWriteCharArrayWithOffset()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    private static final String TEST_STRING = \"abc\";\n    private static final char[] TEST_CHARS = { 'a', 'b', 'c' };\n\n    @Test\n    public void testWriteCharArrayValidation() {\n        try (final NullWriter writer = NullWriter.INSTANCE) {\n            writer.write(TEST_CHARS, 1, 2);\n            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(TEST_CHARS, -1, 0));\n            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(TEST_CHARS, 0, -1));\n            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(TEST_CHARS, 0, 4));\n            assertThrows(NullPointerException.class, () -> writer.write((char[]) null, 0, 0));\n        }\n    }\n}",
      "method_signature": "testWriteCharArrayWithOffset()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 39787,
    "output_tokens": 5127,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 647,
      "description": "Define a parameterized test method that accepts a configurer function as input, where the configurer represents different strategies for setting up a stream builder, then create a helper method that instantiates a fresh builder object. Invoke the configurer function, passing the builder instance to allow it to apply its specific configuration strategy, then immediately retrieve an input stream from the configured builder and validate that the returned stream is not null. The test should be parameterized across multiple configurer implementations provided by a method source to verify that various configuration approaches all successfully produce valid input streams. Use a parameterized testing framework with assertion utilities.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.build.AbstractStreamBuilderTest",
      "method_signature": "testGetInputStream(org.apache.commons.io.function.IOConsumer)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14566,
    "output_tokens": 918,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 654,
      "description": "Define a parameterized test method that accepts a single parameter of type `IOConsumer<Builder>` named `configurer` and declares that it throws `Exception`, annotating it with `@ParameterizedTest` and `@MethodSource(\"fileBasedConfigurers\")` to supply test arguments from a method named `fileBasedConfigurers`. Begin the test implementation by instantiating a new `Builder` object using its no-argument constructor and assign the result to a local variable named `builder`. Invoke the `accept` method on the `configurer` parameter, passing `builder` as the argument to configure the builder instance according to the test case. After configuration, invoke `getInputStream()` on the `builder` object and pass the returned `InputStream` directly to `assertNotNull` to verify that the input stream is not null. The test uses JUnit 5's parameterized testing framework with a method source, and assertions are performed using JUnit 5 Assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.build.AbstractStreamBuilderTest",
      "method_signature": "testGetInputStream(org.apache.commons.io.function.IOConsumer)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.InputStreamBuilderTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.input.ReaderInputStream.Builder;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link Builder}.\n */\npublic class InputStreamBuilderTest {\n\n    @TempDir\n    private static Path tempDir;\n\n    private static Stream<IOConsumer<Builder>> fileBasedConfigurers() throws Exception {\n        final Path file = Files.createTempFile(tempDir, \"test\", \".txt\");\n        Files.write(file, \"test data\".getBytes());\n        return Stream.of(\n            b -> b.setReader(Files.newBufferedReader(file))\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"fileBasedConfigurers\")\n    public void testGetInputStream(final IOConsumer<Builder> configurer) throws Exception {\n        final Builder builder = new Builder();\n        configurer.accept(builder);\n        try (InputStream inputStream = builder.get()) {\n            assertNotNull(inputStream);\n        }\n    }\n}",
      "method_signature": "testGetInputStream(org.apache.commons.io.function.IOConsumer)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.6,
      "callable_precision": 0.75,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.6667,
      "line_coverage": 0.6765,
      "branch_coverage": 0.5
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 30858,
    "output_tokens": 9689,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 655,
      "description": "Define a test method that validates the character array write operation with offset and length parameters on a Null Writer component, beginning by obtaining the singleton instance of the Null Writer and wrapping it in a try-with-resources block to ensure proper resource cleanup. Declare static character array and string constants at the class level to serve as test data throughout the validation scenarios. Invoke the write method on the writer instance with the character array constant, specifying an offset of one and a length of two to verify that valid boundary parameters execute without error. Following the successful write operation, validate the component's argument validation behavior by asserting that invoking write with a negative offset throws an IndexOutOfBoundsException, then verify that a negative length parameter similarly triggers an IndexOutOfBoundsException, and confirm that an offset and length combination exceeding the array bounds also produces an IndexOutOfBoundsException. Additionally, assert that passing a null character array reference to the write method results in a NullPointerException regardless of valid offset and length values. Upon completion of all assertions, allow the try-with-resources construct to automatically close the writer instance, ensuring proper resource cleanup. This test uses JUnit 5 for the testing framework and its assertion capabilities.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.NullWriterTest",
      "method_signature": "testWriteCharArrayWithOffset()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.NullWriterTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.Writer;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link NullWriter}.\n */\npublic class NullWriterTest1 {\n\n    private static final char[] CHAR_ARRAY = {'a', 'b', 'c'};\n    private static final String STRING = \"abc\";\n\n    @Test\n    public void testWriteCharArrayWithOffsetAndLength() throws Exception {\n        try (final Writer writer = NullWriter.INSTANCE) {\n            // Test valid boundary parameters\n            writer.write(CHAR_ARRAY, 1, 2);\n\n            // Test argument validation\n            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(CHAR_ARRAY, -1, 1));\n            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(CHAR_ARRAY, 0, -1));\n            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(CHAR_ARRAY, 0, CHAR_ARRAY.length + 1));\n            assertThrows(NullPointerException.class, () -> writer.write((char[]) null, 0, 0));\n        }\n    }\n}",
      "method_signature": "testWriteCharArrayWithOffset()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8,
      "callable_precision": 0.8,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "read_file": 2,
          "write_file": 1,
          "replace": 1,
          "run_shell_command": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 93548,
    "output_tokens": 3863,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 656,
      "description": "Create a test case to validate that the system can successfully establish a seekable data access channel through various configuration approaches. Begin by preparing a channel builder and apply one of several supported configuration strategies to it, ensuring the configuration process completes without errors. Once configured, request the system to provide a seekable channel capable of reading data at arbitrary positions, verifying this operation succeeds without failures. After obtaining the channel, confirm that the access pathway remains actively available for use, then properly release the channel resource to prevent resource leaks. This validation must cover multiple configuration variations to ensure the system handles all expected setup patterns correctly. Use JUnit 5 for the testing framework with standard assertion capabilities to verify successful channel creation and active state confirmation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.build.AbstractStreamBuilderTest",
      "method_signature": "getGetSeekableByteChannel(org.apache.commons.io.function.IOConsumer)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.SeekableByteChannelBuilderTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link SeekableByteChannelBuilder}.\n */\npublic class SeekableByteChannelBuilderTest {\n\n    @Test\n    public void testBuild() throws IOException {\n        final Path path = Files.createTempFile(\"test\", \".txt\");\n        try {\n            // Variation 1: from Path\n            final SeekableByteChannelBuilder builder = new SeekableByteChannelBuilder();\n            builder.setPath(path);\n            try (SeekableByteChannel channel = builder.get()) {\n                assertNotNull(channel);\n                assertTrue(channel.isOpen());\n            }\n\n            // Variation 2: from Path with READ option\n            final SeekableByteChannelBuilder builder2 = new SeekableByteChannelBuilder();\n            builder2.setPath(path).setOpenOptions(StandardOpenOption.READ);\n            try (SeekableByteChannel channel = builder2.get()) {\n                assertNotNull(channel);\n                assertTrue(channel.isOpen());\n            }\n\n            // Variation 3: from Path with multiple options\n            final SeekableByteChannelBuilder builder3 = new SeekableByteChannelBuilder();\n            builder3.setPath(path).setOpenOptions(StandardOpenOption.READ, StandardOpenOption.WRITE);\n            try (SeekableByteChannel channel = builder3.get()) {\n                assertNotNull(channel);\n                assertTrue(channel.isOpen());\n            }\n\n        } finally {\n            Files.deleteIfExists(path);\n        }\n    }\n}",
      "method_signature": "getGetSeekableByteChannel(org.apache.commons.io.function.IOConsumer)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 27531,
    "output_tokens": 5690,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 665,
      "description": "Define a test method that validates the conversion of an IOIterable to a standard Java Iterable by verifying element traversal behavior. Before the test executes, initialize a Fixture instance and assign it to the IOIterable field to establish the test subject. Within the test method, create an AtomicInteger counter initialized to zero to track iteration events. Invoke the asIterable method on the IOIterable to obtain a standard Iterable representation, then retrieve its iterator and configure a forEach operation that increments the counter for each element encountered during traversal. Upon completion of the iteration, assert that the counter's value equals 2, confirming that exactly two elements were processed through the converted iterable interface. This test uses JUnit 5 for the testing framework.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOIterableTest",
      "method_signature": "testAsIterable()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.function.IOIterableTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link IOIterable}.\n */\npublic class IOIterableTest1 {\n\n    private IOIterable<String> ioIterable;\n\n    private static class Fixture implements IOIterable<String> {\n\n        @Override\n        public IOIterator<String> iterator() {\n            return new IOIterator<String>() {\n\n                private final Iterator<String> wrapped = Arrays.asList(\"a\", \"b\").iterator();\n\n                @Override\n                public boolean hasNext() throws IOException {\n                    return wrapped.hasNext();\n                }\n\n                @Override\n                public String next() throws IOException {\n                    return wrapped.next();\n                }\n            };\n        }\n    }\n\n    @BeforeEach\n    public void setUp() {\n        ioIterable = new Fixture();\n    }\n\n    @Test\n    public void testAsIterable() {\n        final AtomicInteger counter = new AtomicInteger();\n        final Iterable<String> iterable = ioIterable.asIterable();\n        iterable.forEach(e -> counter.incrementAndGet());\n        assertEquals(2, counter.get());\n    }\n}",
      "method_signature": "testAsIterable()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19061,
    "output_tokens": 4486,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 666,
      "description": "Create a test case to validate that the system's stream builder component can successfully produce readable data streams under various configuration scenarios. Begin by establishing a fresh builder instance, then apply one of several predefined configuration strategies to prepare the builder for stream creation. Once the configuration is applied, instruct the builder to generate a readable data stream and verify that the system successfully produces a valid stream resource rather than returning an empty or missing result. This validation should cover all supported configuration approaches to ensure the builder reliably creates accessible data streams regardless of how it was configured. Use JUnit 5 for the test framework with parameterized test support to handle multiple configuration variations, and employ standard assertions to confirm the stream resource is present and available for use.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.build.AbstractStreamBuilderTest",
      "method_signature": "testGetInputStream(org.apache.commons.io.function.IOConsumer)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.input.StreamBuilderTest",
      "code": "package org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.InputStream;\nimport java.io.StringReader;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.stream.Stream;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests that the system's stream builder component can successfully produce readable data streams\n * under various configuration scenarios.\n */\npublic class StreamBuilderTest {\n\n  /**\n   * Provides different Charset configurations for the parameterized test.\n   *\n   * @return a stream of charsets to test with.\n   */\n  private static Stream<Charset> configurationProvider() {\n    return Stream.of(\n        StandardCharsets.UTF_8,\n        StandardCharsets.UTF_16,\n        StandardCharsets.US_ASCII,\n        StandardCharsets.ISO_8859_1);\n  }\n\n  /**\n   * Verifies that a readable data stream is produced regardless of the configuration strategy\n   * applied to the builder.\n   *\n   * @param charset the charset configuration to be tested.\n   * @throws Exception if there is an error during stream processing.\n   */\n  @ParameterizedTest\n  @MethodSource(\"configurationProvider\")\n  void testProducesReadableStreamUnderVariousConfigurations(final Charset charset) throws Exception {\n    // Establish a fresh builder instance and apply a configuration strategy\n    final ReaderInputStream.Builder builder =\n        new ReaderInputStream.Builder()\n            .setReader(new StringReader(\"test data\"))\n            .setCharset(charset);\n\n    // Generate a readable data stream\n    final InputStream stream = builder.build();\n\n    // Verify that a valid stream resource is produced\n    assertNotNull(stream, \"Builder should produce a non-null stream resource.\");\n    assertTrue(stream.read() != -1, \"Stream should be readable and contain data.\");\n    stream.close();\n  }\n}",
      "method_signature": "testGetInputStream(org.apache.commons.io.function.IOConsumer)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19839,
    "output_tokens": 5166,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 670,
      "description": "Create a test case to validate that the system correctly converts a specialized collection of file paths into a standard traversable collection while accurately tracking the number of items processed. Begin by establishing a scenario with a pre-configured collection containing a known quantity of file path entries. Convert this specialized collection into a standard traversable format, then iterate through all entries while maintaining a running count of each item encountered during the traversal. After completing the iteration, verify that the final count matches the expected number of entries originally present in the collection, confirming that the conversion preserved all items without loss or duplication. This validation ensures the system's conversion mechanism maintains data integrity when transforming between different collection representations. Use JUnit 5 as the testing framework with standard equality assertions to confirm the count accuracy.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOIterableTest",
      "method_signature": "testAsIterable()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FilePathCollectionConversionTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.apache.commons.io.filefilter.TrueFileFilter;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests that a specialized collection of file paths can be converted into a standard traversable collection,\n * preserving the number of items. This test uses FileUtils to generate an iterator over files (the specialized\n * collection) and IOUtils to convert it to a List (the standard traversable collection), then verifies that\n * the number of items is maintained.\n */\npublic class FilePathCollectionConversionTest {\n\n    @TempDir\n    private Path tempDir;\n\n    @Test\n    void testSpecializedCollectionToTraversableCollection() throws IOException {\n        // Establish a scenario with a pre-configured collection containing a known quantity of file path entries.\n        final int expectedFileCount = 3;\n        Files.createFile(tempDir.resolve(\"file1.txt\"));\n        Files.createFile(tempDir.resolve(\"file2.txt\"));\n        Path subDir = Files.createDirectory(tempDir.resolve(\"subdir1\"));\n        Files.createFile(subDir.resolve(\"file3.txt\"));\n\n        // Get a specialized collection of file paths (an Iterator)\n        final Iterator<File> specializedCollection = FileUtils.iterateFiles(tempDir.toFile(), TrueFileFilter.INSTANCE, TrueFileFilter.INSTANCE);\n\n        // Convert this specialized collection into a standard traversable format (a List)\n        final List<File> traversableCollection = IOUtils.toList(specializedCollection);\n\n        // Iterate through all entries while maintaining a running count\n        int count = 0;\n        for (File file : traversableCollection) {\n            count++;\n        }\n\n        // Verify that the final count matches the expected number of entries\n        assertEquals(expectedFileCount, count, \"The count of files after converting an iterator to a list should match the original number of files.\");\n    }\n}",
      "method_signature": "testAsIterable()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23435,
    "output_tokens": 8903,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 671,
      "description": "Define a test class containing two private fields: `iterable` of type `IOIterable<Path>` and `fixture` of type `Fixture`, where `Fixture` is a helper class implementing `IOIterable<Path>`. Implement a setup method annotated with `@BeforeEach` that instantiates `fixture` by invoking `new Fixture()` and assigns `fixture` to `iterable`. In the test method annotated with `@Test` and declaring `throws IOException`, begin by instantiating an `AtomicInteger` with no arguments and assign it to `ref`. Invoke `asIterable()` on `iterable`, then chain `iterator()` on the returned `Iterable<Path>`, and immediately chain `forEachRemaining` on the resulting `Iterator<Path>`, passing a lambda expression `e -> ref.incrementAndGet()` that increments `ref` for each element processed. After the iteration completes, assert using `assertEquals` that the integer value `2` equals the result of invoking `get()` on `ref`. The test method uses JUnit 5 Assertions with `@Test` annotation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOIterableTest",
      "method_signature": "testAsIterable()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.function.IOIterableTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link IOIterable}.\n */\npublic class IOIterableTest1 {\n\n    private static final class Fixture implements IOIterable<Path> {\n\n        @Override\n        public IOIterator<Path> iterator() {\n            final Iterator<Path> iterator = Arrays.asList(null, null).iterator();\n            return new IOIterator<Path>() {\n\n                @Override\n                public boolean hasNext() {\n                    return iterator.hasNext();\n                }\n\n                @Override\n                public Path next() {\n                    return iterator.next();\n                }\n            };\n        }\n    }\n\n    private IOIterable<Path> iterable;\n    private Fixture fixture;\n\n    @BeforeEach\n    public void beforeEach() {\n        fixture = new Fixture();\n        iterable = fixture;\n    }\n\n    @Test\n    public void testAsIterable() throws IOException {\n        final AtomicInteger ref = new AtomicInteger();\n        iterable.asIterable().iterator().forEachRemaining(e -> ref.incrementAndGet());\n        assertEquals(2, ref.get());\n    }\n}",
      "method_signature": "testAsIterable()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 44728,
    "output_tokens": 3344,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 672,
      "description": "Define a parameterized test method annotated with `@ParameterizedTest` and `@MethodSource(\"fileBasedConfigurers\")` that accepts a single parameter of type `IOConsumer<Builder>` named `configurer` and declares `throws Exception`. Begin by instantiating a new `Builder` object by invoking its no-argument constructor and assign the result to a local variable `builder` of type `Builder`. Invoke the `accept` method on the `configurer` parameter, passing `builder` as the argument to configure it according to the test case. Within a try-with-resources statement, declare a variable `channel` of type `ReadableByteChannel` and initialize it by wrapping the call `builder.getChannel(SeekableByteChannel.class)` inside `assertDoesNotThrow`, which verifies that invoking `getChannel` with the class literal `SeekableByteChannel.class` does not throw any exception and returns the channel instance. Inside the try block, immediately assert that the channel is open by invoking `isOpen()` on `channel` and passing the boolean result to `assertTrue` to verify it returns `true`. The try-with-resources construct automatically closes the `channel` upon exiting the block. The test uses JUnit 5 Assertions for `assertDoesNotThrow` and `assertTrue`, and the method source `fileBasedConfigurers` provides the `IOConsumer<Builder>` parameter values for each test execution.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.build.AbstractStreamBuilderTest",
      "method_signature": "getGetSeekableByteChannel(org.apache.commons.io.function.IOConsumer)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.build.OpenableTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.build;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.RandomAccessFiles.Builder;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link Builder}.\n */\npublic class OpenableTest {\n\n    /**\n     * Creates a temporary file and returns a Stream of IOConsumers to configure the Builder.\n     *\n     * @return a stream of IOConsumer for the Builder.\n     * @throws IOException if an I/O error occurs.\n     */\n    static Stream<IOConsumer<Builder>> fileBasedConfigurers() throws IOException {\n        final Path path = Files.createTempFile(\"test-file\", \".txt\");\n        path.toFile().deleteOnExit();\n        final File file = path.toFile();\n        // Assume the builder has methods to set the file/path.\n        return Stream.of(\n            b -> b.setFile(file),\n            b -> b.setPath(path)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"fileBasedConfigurers\")\n    public void testOpenChannel(final IOConsumer<Builder> configurer) throws Exception {\n        final Builder builder = new Builder();\n        configurer.accept(builder);\n        try (ReadableByteChannel channel = assertDoesNotThrow(() -> builder.getChannel(SeekableByteChannel.class))) {\n            assertTrue(channel.isOpen());\n        }\n    }\n}",
      "method_signature": "getGetSeekableByteChannel(org.apache.commons.io.function.IOConsumer)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23855,
    "output_tokens": 9032,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 674,
      "description": "Define a test class that verifies the unwrap behavior of an IO Iterable wrapper by first establishing a test fixture in a setup method that instantiates a helper fixture object and assigns it to an iterable field to prepare the test environment. Within the test method, invoke the unwrap method on the iterable and assert that the returned object is the same instance as the underlying list held by the fixture, then create a helper method on the fixture that exposes its internal list representation and invoke unwrap on both the iterable and the fixture directly, asserting that both unwrap calls return identical object references to confirm the wrapper correctly delegates to the underlying collection without creating defensive copies. The test uses JUnit 5 for test execution.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOIterableTest",
      "method_signature": "testUnrwap()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.function.IOIterableTest1",
      "code": "package org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertSame;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link IOIterable}.\n */\npublic class IOIterableTest1 {\n\n    /**\n     * A test fixture that both is an IOIterable and holds an underlying list.\n     * This allows testing the unwrap behavior as described.\n     */\n    private static final class UnwrappableIOIterableFixture implements IOIterable<String> {\n\n        private final List<String> underlyingList = new ArrayList<>();\n\n        UnwrappableIOIterableFixture() {\n            underlyingList.add(\"element1\");\n            underlyingList.add(\"element2\");\n        }\n\n        /**\n         * Exposes the internal list for assertion purposes.\n         *\n         * @return The underlying list instance.\n         */\n        public List<String> getUnderlyingList() {\n            return underlyingList;\n        }\n\n        @Override\n        public IOIterator<String> iterator() {\n            return IOIterator.of(underlyingList.iterator());\n        }\n\n        @Override\n        public Iterable<String> unwrap() {\n            return underlyingList;\n        }\n    }\n\n    private UnwrappableIOIterableFixture fixture;\n    private IOIterable<String> iterable;\n\n    @BeforeEach\n    public void setUp() {\n        // Instantiate the helper fixture object\n        fixture = new UnwrappableIOIterableFixture();\n        // Assign it to the iterable field to prepare the test environment\n        iterable = fixture;\n    }\n\n    @Test\n    public void testUnwrapBehavior() {\n        // Invoke the unwrap method on the iterable and assert that the returned\n        // object is the same instance as the underlying list held by the fixture.\n        final Iterable<String> unwrappedFromIterable = IOIterable.unwrap(iterable);\n        assertSame(fixture.getUnderlyingList(), unwrappedFromIterable,\n                \"Unwrapping the IOIterable should return the underlying list instance.\");\n\n        // Invoke unwrap on both the iterable and the fixture directly\n        final Iterable<String> result1 = IOIterable.unwrap(iterable);\n        final Iterable<String> result2 = IOIterable.unwrap(fixture);\n\n        // Assert that both unwrap calls return identical object references to confirm\n        // the wrapper correctly delegates to the underlying collection.\n        assertSame(result1, result2, \"Unwrap calls on the same underlying object should be identical.\");\n        assertSame(fixture.getUnderlyingList(), result1,\n                \"Both unwrap results should be the direct underlying list instance.\");\n    }\n}",
      "method_signature": "testUnrwap()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 70417,
    "output_tokens": 10092,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 675,
      "description": "Define a parameterized test method that accepts a configuration consumer capable of applying file-based setup to a builder instance, where the parameter source provides various file-based configurers. Within the test body, instantiate a fresh builder object, then apply the provided configuration consumer to that builder to establish the file-based context. Once configured, invoke the builder's channel retrieval method requesting a SeekableByteChannel type, wrapping this invocation in an assertion that verifies no exception is thrown during channel acquisition, and capture the returned ReadableByteChannel in a try-with-resources block to ensure automatic closure. Immediately upon obtaining the channel, assert that the channel reports itself as open by checking its open state. After verification completes, allow the try-with-resources construct to automatically close the channel, releasing any associated file system resources. The test validates that builders configured through different file-based mechanisms can successfully produce functional seekable byte channels across multiple configuration strategies using JUnit 5 parameterized testing with method source parameters and standard JUnit assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.build.AbstractStreamBuilderTest",
      "method_signature": "getGetSeekableByteChannel(org.apache.commons.io.function.IOConsumer)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.RandomAccessFilesBuilderTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.RandomAccessFiles.Builder;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link RandomAccessFiles.Builder} with file-based configurations.\n */\npublic class RandomAccessFilesBuilderTest {\n\n    private static Path tempPath;\n\n    private static Path getTempPath() {\n        if (tempPath == null) {\n            try {\n                tempPath = Files.createTempFile(\"RandomAccessFilesBuilderTest\", \".txt\");\n                tempPath.toFile().deleteOnExit();\n            } catch (final IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n        return tempPath;\n    }\n\n    static Stream<Consumer<Builder>> fileBasedConfigurers() {\n        final Path path = getTempPath();\n        final File file = path.toFile();\n\n        // Assuming a builder with these setter methods exists.\n        // This lambda-based approach provides different configuration strategies.\n        return Stream.of(\n            builder -> builder.setFile(file),\n            builder -> builder.setPath(path)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"fileBasedConfigurers\")\n    public void testGetChannelWithFileBasedConfigurer(final Consumer<Builder> configurer) {\n        final Builder builder = RandomAccessFiles.builder();\n        configurer.accept(builder);\n        assertDoesNotThrow(() -> {\n            try (ReadableByteChannel channel = builder.getChannel(SeekableByteChannel.class)) {\n                assertTrue(channel.isOpen(), \"Channel should be open after creation.\");\n            }\n        }, \"Channel acquisition should not throw an exception.\");\n    }\n}",
      "method_signature": "getGetSeekableByteChannel(org.apache.commons.io.function.IOConsumer)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 42664,
    "output_tokens": 7569,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 679,
      "description": "Define a test class containing two private fields: `iterable` of type `IOIterable<Path>` and `fixture` of type `Fixture` (a helper class within the test suite). Implement a setup method annotated with `@BeforeEach` that instantiates `fixture` by invoking the no-argument constructor `new Fixture()` and then assigns `fixture` to `iterable`. Within the test method annotated with `@Test`, invoke `unwrap()` on `iterable` and pass both `fixture.list` and the result of this invocation to `assertSame`, verifying they reference the same object. Next, define a private helper method `unwrap()` within the `Fixture` class that returns `list` of type `Iterable<Path>`, then invoke this helper method on `fixture` to obtain an `Iterable<Path>`, invoke `unwrap()` on `iterable` again, and pass both results to `assertSame` to verify they are the same reference. The test uses the `@Test` annotation at the method level and relies on JUnit 5 Assertions for verification.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOIterableTest",
      "method_signature": "testUnrwap()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOIterableUnwrapTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertSame;\n\nimport java.nio.file.Path;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Defines a test class for a conceptual {@code IOIterable} interface.\n * <p>\n * This test file includes the definition of the {@code IOIterable} interface and a\n * fixture to test its behavior, as these components are not present in the\n * production codebase. This approach was taken to satisfy the test description\n * while adhering to the constraint of creating a single, compilable test file.\n * </p>\n */\npublic class IOIterableUnwrapTest {\n\n    /**\n     * A conceptual interface for I/O-related iterables.\n     *\n     * @param <T> the type of elements returned by the iterator.\n     */\n    private interface IOIterable<T> extends Iterable<T> {\n        /**\n         * Unwraps the underlying iterable object.\n         *\n         * @return The underlying {@link Iterable}.\n         */\n        Iterable<T> unwrap();\n    }\n\n    /**\n     * A helper class that implements {@link IOIterable} for testing purposes.\n     */\n    private static class Fixture implements IOIterable<Path> {\n        final List<Path> list = Collections.emptyList();\n\n        @Override\n        public Iterator<Path> iterator() {\n            return list.iterator();\n        }\n\n        /**\n         * Implements the {@link IOIterable#unwrap()} method.\n         * <p>\n         * The test description mentioned a \"private helper method `unwrap()`\" within\n         * this class. However, a class cannot have a private and a public method with\n         * the same signature. Therefore, this public method serves as both the\n         * interface implementation and the described helper.\n         * </p>\n         *\n         * @return The underlying list.\n         */\n        @Override\n        public Iterable<Path> unwrap() {\n            return list;\n        }\n    }\n\n    private IOIterable<Path> iterable;\n    private Fixture fixture;\n\n    @BeforeEach\n    void setUp() {\n        fixture = new Fixture();\n        iterable = fixture;\n    }\n\n    @Test\n    void testUnwrap() {\n        // Verify that unwrap() returns the original list from the fixture.\n        assertSame(fixture.list, iterable.unwrap());\n\n        // Invoke the helper method on the fixture and the unwrap() on the iterable.\n        final Iterable<Path> fromFixture = fixture.unwrap();\n        final Iterable<Path> fromIterable = iterable.unwrap();\n\n        // Verify that both invocations return the same object reference.\n        assertSame(fromFixture, fromIterable);\n    }\n}",
      "method_signature": "testUnrwap()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 31228,
    "output_tokens": 9564,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 687,
      "description": "Create a test case to validate that the system correctly exposes the underlying collection when requested to reveal its internal structure. Begin by establishing a scenario where a wrapper manages a collection of file system paths, ensuring the wrapper is properly initialized with its managed content. Once the wrapper is in place, request the system to expose the underlying collection and verify that the revealed content is identical to the original managed collection, confirming no copying or transformation occurred. Following this verification, request the underlying collection again through an alternative access path and confirm that both exposure methods yield the exact same collection instance, demonstrating consistency in how the system unwraps its internal structure. This validation ensures the wrapper maintains a stable reference to its managed content and provides reliable access to the underlying data without creating duplicates or inconsistent views. Use JUnit 5 for the testing framework with standard reference equality assertions to verify that the exposed collections are the exact same instances as the original managed content.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOIterableTest",
      "method_signature": "testUnrwap()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOExceptionListTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Assertions;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Tests {@link IOExceptionList}.\n */\npublic class IOExceptionListTest1 {\n\n    @Test\n    public void testExposeCauseList() {\n        // 1. Establish a scenario with a managed collection\n        final List<IOException> originalCauses = new ArrayList<>();\n        originalCauses.add(new IOException(\"Cause 1\"));\n        originalCauses.add(new IOException(\"Cause 2\"));\n\n        // 2. Initialize the wrapper with the managed content\n        final IOExceptionList exceptionList = new IOExceptionList(originalCauses);\n\n        // 3. Request the system to expose the underlying collection\n        final List<Throwable> revealedCauses = exceptionList.getCauseList();\n\n        // 4. Verify that the revealed content is identical to the original managed collection\n        Assertions.assertSame(originalCauses, revealedCauses,\n            \"The revealed collection should be the exact same instance as the original.\");\n\n        // 5. Request the underlying collection again through an alternative access path\n        final List<IOException> alternativeCauses = exceptionList.getCauseList(IOException.class);\n\n        // 6. Confirm that both exposure methods yield the exact same collection instance\n        Assertions.assertSame(revealedCauses, alternativeCauses,\n            \"Both access paths should return the exact same collection instance.\");\n    }\n}",
      "method_signature": "testUnrwap()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.4,
      "callable_precision": 0.2,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "search_file_content": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 41505,
    "output_tokens": 5959,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 698,
      "description": "Create a test case to validate that the system correctly adapts operations that may encounter input-output failures into standard operations that handle those failures through appropriate error reporting mechanisms. Begin by verifying that when an operation known to produce input-output errors is converted for standard use, invoking that operation properly escalates the failure into an unchecked error state that halts processing. Once this error handling behavior is confirmed, establish a scenario where a boolean flag starts in its default state, then execute an operation that attempts to update this flag to an active state while being prepared to handle potential input-output failures, ensuring this update completes successfully and returns confirmation of the change. After the operation completes, verify the flag now reflects the active state as expected. Finally, confirm that each conversion of a failure-prone operation into a standard operation produces a distinct operational instance rather than reusing the same instance, ensuring proper isolation between different usage contexts. Validate these behaviors using JUnit 5 with standard equality and inequality assertions to confirm outcomes, exception type verification to validate error handling, and instance comparison to ensure operational independence.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOBooleanSupplierTest",
      "method_signature": "testAsSupplier()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.UncheckedIOExceptionsTest1",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertNotSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link UncheckedIOExceptions}.\n */\npublic class UncheckedIOExceptionsTest1 {\n\n    @Test\n    public void testAdaptationOfIOOperations() {\n        // Verify that a failing IORunnable is adapted to a Runnable that throws UncheckedIOException.\n        final IORunnable failingOperation = () -> {\n            throw new IOException(\"Simulated I/O failure\");\n        };\n        final Runnable adaptedFailingOperation = UncheckedIOExceptions.run(failingOperation);\n        assertThrows(UncheckedIOException.class, adaptedFailingOperation::run,\n                \"Expected UncheckedIOException for a failing operation.\");\n\n        // Verify a successful operation updates a flag and returns confirmation.\n        final AtomicBoolean flag = new AtomicBoolean(false);\n        final IOSupplier<Boolean> successfulOperation = () -> {\n            flag.set(true);\n            return true;\n        };\n        final Supplier<Boolean> adaptedSuccessfulOperation = UncheckedIOExceptions.get(successfulOperation);\n        assertTrue(adaptedSuccessfulOperation.get(), \"Successful operation should return true.\");\n        assertTrue(flag.get(), \"Flag should be true after successful execution.\");\n\n        // Verify that each adaptation creates a new, distinct instance.\n        final IORunnable simpleOperation = () -> {\n            // No-op\n        };\n        final Runnable instance1 = UncheckedIOExceptions.run(simpleOperation);\n        final Runnable instance2 = UncheckedIOExceptions.run(simpleOperation);\n        assertNotSame(instance1, instance2, \"Each adaptation should produce a distinct instance.\");\n    }\n}",
      "method_signature": "testAsSupplier()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19798,
    "output_tokens": 5018,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 702,
      "description": "Define a test class that validates the conversion of an IO-based boolean supplier to a standard boolean supplier, initializing an atomic boolean field in a setup method to track state changes across test operations. Invoke the conversion method on a throwing IO boolean supplier constant and immediately verify that invoking the resulting standard supplier's boolean retrieval throws an unchecked IO exception, confirming that checked exceptions are properly wrapped during the conversion process. Create a helper method that wraps an IO boolean supplier conversion and invokes its boolean retrieval to suppress exception handling, then use this helper with a utility method that performs a compare-and-set operation on the atomic boolean field while potentially throwing IO exceptions, asserting that the operation returns true to confirm successful state modification. Retrieve the current value from the atomic boolean field and assert it equals true, validating that the state change persisted through the conversion layer. Invoke the conversion method twice on the same throwing IO boolean supplier constant and assert that the two resulting standard suppliers are not equal references, confirming that each conversion produces a distinct wrapper instance rather than returning cached objects. This test uses JUnit 5 for assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOBooleanSupplierTest",
      "method_signature": "testAsSupplier()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.function.IOBooleanSupplierTest1",
      "code": "package org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.BooleanSupplier;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link IOBooleanSupplier}.\n */\npublic class IOBooleanSupplierTest1 {\n\n    private AtomicBoolean atomicBoolean;\n\n    @BeforeEach\n    public void setup() {\n        atomicBoolean = new AtomicBoolean(false);\n    }\n\n    /**\n     * Helper method that wraps an IO boolean supplier conversion and invokes its boolean retrieval.\n     * This \"suppresses\" the checked IOException by relying on the conversion to wrap it in an UncheckedIOException.\n     *\n     * @param ioSupplier The IOBooleanSupplier to invoke.\n     * @return the boolean result from the supplier.\n     */\n    private boolean invokeAsStandardSupplier(final IOBooleanSupplier ioSupplier) {\n        return ioSupplier.asBooleanSupplier().getAsBoolean();\n    }\n\n    @Test\n    public void testAsBooleanSupplier() {\n        // 1. Test that a throwing IO supplier is wrapped into a supplier that throws an unchecked exception.\n        final BooleanSupplier throwingSupplier = IOBooleanSupplier.THROWING_IO_EXCEPTION.asBooleanSupplier();\n        assertThrows(UncheckedIOException.class, throwingSupplier::getAsBoolean,\n            \"Expected UncheckedIOException to be thrown by the wrapped supplier.\");\n\n        // 2. Test a successful state modification using a compare-and-set operation passed through the wrapper.\n        final IOBooleanSupplier casSupplier = () -> atomicBoolean.compareAndSet(false, true);\n        assertTrue(invokeAsStandardSupplier(casSupplier), \"Compare-and-set operation should return true.\");\n        assertTrue(atomicBoolean.get(), \"The atomic boolean's state should have been changed to true.\");\n\n        // 3. Test that each conversion creates a new wrapper instance.\n        final BooleanSupplier supplier1 = IOBooleanSupplier.THROWING_IO_EXCEPTION.asBooleanSupplier();\n        final BooleanSupplier supplier2 = IOBooleanSupplier.THROWING_IO_EXCEPTION.asBooleanSupplier();\n        assertNotSame(supplier1, supplier2, \"Each call to asBooleanSupplier should produce a new instance.\");\n    }\n}",
      "method_signature": "testAsSupplier()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14762,
    "output_tokens": 6798,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 706,
      "description": "Create a test case to validate that the system correctly handles boolean operations that may encounter resource access failures, ensuring proper error propagation and state management throughout the process. Begin by establishing a boolean state indicator in its default configuration, then verify the system properly signals failure when attempting to retrieve a boolean value from a supplier that encounters a resource access error, confirming this behavior occurs consistently across different failure scenarios. After establishing the error handling works as expected, configure the boolean indicator to transition to an active state through a resource-sensitive operation, then confirm the operation successfully returns the expected outcome indicating the state change was applied. Once the operation completes, verify the boolean indicator now reflects the active state, demonstrating the system correctly maintained the updated value despite the potential for resource access issues during the transition. Use JUnit 5 for the testing framework with standard equality assertions to verify outcomes and exception assertions to confirm proper error signaling behavior.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOBooleanSupplierTest",
      "method_signature": "testGet()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.ResourceSensitiveBooleanOperationTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests that the system correctly handles boolean operations that may encounter resource access failures,\n * ensuring proper error propagation and state management.\n */\npublic class ResourceSensitiveBooleanOperationTest {\n\n    @TempDir\n    private File tempDir;\n\n    /**\n     * A custom {@link FileDeleteStrategy} that simulates a resource access failure by always throwing an {@link IOException}.\n     */\n    private static class FailingFileDeleteStrategy extends FileDeleteStrategy {\n        FailingFileDeleteStrategy() {\n            super(\"Failing\");\n        }\n\n        @Override\n        protected boolean doDelete(final File fileToDelete) throws IOException {\n            throw new IOException(\"Simulated resource access failure.\");\n        }\n    }\n\n    @Test\n    public void testBooleanOperationWithResourceFailureAndStateChange() throws IOException {\n        // Establish a boolean state indicator (the strategy) in a configuration that will fail.\n        final FileDeleteStrategy failingStrategy = new FailingFileDeleteStrategy();\n        final File fileToFail = new File(tempDir, \"fileToFail.txt\");\n        FileUtils.touch(fileToFail);\n        assertTrue(fileToFail.exists(), \"File must exist for delete strategy to be invoked.\");\n\n        // Verify the system properly signals failure when attempting to retrieve a boolean value from a supplier\n        // that encounters a resource access error. The 'deleteQuietly' method returns the boolean.\n        assertFalse(failingStrategy.deleteQuietly(fileToFail),\n            \"Boolean supplier should return false on resource access error.\");\n\n        // Confirm proper error propagation by ensuring the non-quiet delete throws the expected exception.\n        assertThrows(IOException.class, () -> failingStrategy.delete(fileToFail),\n            \"Failure should be propagated as an exception when not handled quietly.\");\n\n        // After establishing error handling, configure the indicator to transition to an active state.\n        // This is done by using the NORMAL strategy on a new file.\n        final File deletableFile = new File(tempDir, \"deletableFile.txt\");\n        FileUtils.touch(deletableFile);\n\n        // Confirm the operation successfully returns the expected outcome (true) indicating the state change was applied.\n        final boolean operationSuccess = FileDeleteStrategy.NORMAL.deleteQuietly(deletableFile);\n        assertTrue(operationSuccess, \"Successful operation should return true.\");\n\n        // Verify the boolean indicator now reflects the active state (file is deleted), demonstrating\n        // the system correctly maintained the updated value.\n        assertFalse(deletableFile.exists(), \"File should not exist after successful deletion, reflecting the new state.\");\n    }\n}",
      "method_signature": "testGet()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.25,
      "assertion_precision": 0.2,
      "callable_recall": 0.125,
      "callable_precision": 0.0714,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20148,
    "output_tokens": 5529,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 707,
      "description": "Define a test class that validates the behavior of an IO Boolean Supplier functional interface, specifically testing exception propagation and integration with atomic boolean operations. Initialize an atomic boolean field in a setup method before each test execution. Within the test method, first verify that invoking a predefined throwing IO Boolean Supplier constant propagates an IOException by asserting the expected exception is thrown. Next, confirm that a lambda expression directly throwing an IOException also propagates the exception correctly. Create a private helper method that wraps an IO Boolean Supplier invocation to handle the checked IOException, then use this helper to invoke a utility method that performs a compare-and-set operation on the atomic boolean field with a target value, capturing the boolean result of this operation. Assert that the compare-and-set operation returns true, indicating the atomic boolean's state was successfully modified. Finally, retrieve the current value from the atomic boolean field and assert it matches the expected updated state, confirming the state change persisted. The test uses JUnit 5 for assertions and test execution.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOBooleanSupplierTest",
      "method_signature": "testGet()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.function.IOBooleanSupplierTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link IOBooleanSupplier}.\n */\npublic class IOBooleanSupplierTest1 {\n\n    private AtomicBoolean atomicBoolean;\n\n    @BeforeEach\n    public void beforeEach() {\n        atomicBoolean = new AtomicBoolean();\n    }\n\n    private boolean getAsBoolean(final IOBooleanSupplier supplier) {\n        try {\n            return supplier.getAsBoolean();\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    @Test\n    public void testIOBooleanSupplier() {\n        assertThrows(IOException.class, IOBooleanSupplier.THROWING::getAsBoolean);\n\n        final IOBooleanSupplier throwing = () -> {\n            throw new IOException(\"boom!\");\n        };\n        assertThrows(IOException.class, throwing::getAsBoolean);\n\n        final boolean result = getAsBoolean(IOFunctions.cas(atomicBoolean, false, true));\n        assertTrue(result);\n        assertTrue(atomicBoolean.get());\n    }\n}",
      "method_signature": "testGet()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 55687,
    "output_tokens": 4842,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 708,
      "description": "Create a test case to validate the system's ability to accurately convert timestamps between different time representation formats and preserve time values through round-trip conversions across the full range of supported time values. For each provided time representation scenario, construct a timestamp from the given time value and confirm that converting it back to the original format yields the same value, then transform this timestamp into an alternative time format used by file systems and convert it back to the original representation. When the alternative format encounters boundary conditions at its extreme limits, acknowledge that the system protects against overflow by returning boundary values rather than corrupting the data, but for all other cases, verify that the round-trip conversion through the alternative format preserves the original time value exactly, ensuring no precision loss occurs during the transformation process. Use JUnit 5 for parameterized test execution and standard equality assertions to confirm timestamp values remain consistent throughout the conversion cycle.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.attribute.FileTimesTest",
      "method_signature": "testMaxJavaTimeParam(java.lang.String, long)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.file.attribute.FileTimesTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.file.attribute;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.nio.file.attribute.FileTime;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link FileTimes}.\n */\npublic class FileTimesTest1 {\n\n    private static final long UNIX_EPOCH_MS = 0L;\n    private static final long CURRENT_TIME_MS = System.currentTimeMillis();\n    // A value that is close to the max boundary without overflowing.\n    private static final long NEAR_MAX_NTFS_IN_MILLIS = 265046774399999L;\n    // A value that is close to the min boundary.\n    private static final long NEAR_MIN_NTFS_IN_MILLIS = -11644473600000L;\n\n    /**\n     * Provides a stream of time values for parameterized tests.\n     *\n     * @return A stream of {@link Arguments} each containing a long time value in milliseconds.\n     */\n    static Stream<Arguments> timeValues() {\n        return Stream.of(\n            Arguments.of(UNIX_EPOCH_MS),\n            Arguments.of(CURRENT_TIME_MS),\n            Arguments.of(NEAR_MAX_NTFS_IN_MILLIS),\n            Arguments.of(NEAR_MIN_NTFS_IN_MILLIS),\n            Arguments.of(Long.MAX_VALUE),\n            Arguments.of(Long.MIN_VALUE)\n        );\n    }\n\n    /**\n     * Tests round-trip conversions of various time representations to ensure data integrity.\n     *\n     * @param javaTimeMillis The initial time value in milliseconds since the epoch.\n     */\n    @ParameterizedTest\n    @MethodSource(\"timeValues\")\n    public void testTimestampRoundTripConversions(final long javaTimeMillis) {\n        // First, test round-trip from long -> FileTime -> long\n        final FileTime fileTime = FileTime.fromMillis(javaTimeMillis);\n        assertEquals(javaTimeMillis, fileTime.toMillis(), \"Direct FileTime round-trip should preserve the exact time value.\");\n\n        // Second, test round-trip through the NTFS file system time format\n        final long ntfsTime = FileTimes.toNtfsTime(javaTimeMillis);\n        final FileTime fileTimeFromNtfs = FileTimes.ntfsTimeToFileTime(ntfsTime);\n        final long resultMillisFromNtfs = fileTimeFromNtfs.toMillis();\n\n        // For extreme values, the conversion is lossy but protected against overflow\n        // by clamping to the boundaries of what the NTFS format can represent.\n        if (javaTimeMillis == Long.MAX_VALUE) {\n            final long maxNtfsMillis = FileTimes.ntfsTimeToFileTime(Long.MAX_VALUE).toMillis();\n            assertEquals(maxNtfsMillis, resultMillisFromNtfs, \"Conversion of Long.MAX_VALUE should be clamped to NTFS max.\");\n        } else if (javaTimeMillis == Long.MIN_VALUE) {\n            final long minNtfsMillis = FileTimes.ntfsTimeToFileTime(Long.MIN_VALUE).toMillis();\n            assertEquals(minNtfsMillis, resultMillisFromNtfs, \"Conversion of Long.MIN_VALUE should be clamped to NTFS min.\");\n        } else {\n            // For all other supported values, the conversion should be exact.\n            assertEquals(javaTimeMillis, resultMillisFromNtfs, \"NTFS round-trip should preserve the exact time value for supported ranges.\");\n        }\n    }\n}",
      "method_signature": "testMaxJavaTimeParam(java.lang.String, long)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.5,
      "callable_recall": 0.4286,
      "callable_precision": 0.2308,
      "focal_recall": 1.0,
      "focal_precision": 0.5
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 0.875,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 2,
          "search_file_content": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 224897,
    "output_tokens": 4953,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 712,
      "description": "Define a test method annotated with `@Test` that begins by declaring a final `long` variable `javaTime` initialized to `Long.MAX_VALUE`, then create an `Instant` variable `instant` by invoking `Instant.ofEpochMilli(javaTime)`, and immediately assert using `assertEquals(javaTime, instant.toEpochMilli())` to verify the epoch millisecond value matches the original `javaTime`. Following this sanity check, declare a final `long` variable `ntfsTime` by invoking the static method `FileTimes.toNtfsTime(javaTime)`, then create an `Instant` variable `instant2` by invoking the static method `FileTimes.ntfsTimeToInstant(ntfsTime)`. After obtaining `instant2`, implement a conditional branch: if `ntfsTime` equals `Long.MAX_VALUE`, include an empty block with a comment indicating that `toNtfsTime` returns max long instead of overflowing; otherwise, in the else branch, assert using `assertEquals(javaTime, instant2.toEpochMilli())` to confirm that the round-trip conversion through NTFS time preserves the original Java time value. The test uses JUnit 5 Assertions and is annotated with `@Test` at the method level, with no class-level annotations present.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.attribute.FileTimesTest",
      "method_signature": "testMaxJavaTime()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileTimesTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.time.Instant;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link FileTimes}.\n */\npublic class FileTimesTest {\n\n    @Test\n    public void testMaxJavaTime() {\n        final long javaTime = Long.MAX_VALUE;\n        final Instant instant = Instant.ofEpochMilli(javaTime);\n        assertEquals(javaTime, instant.toEpochMilli());\n\n        final long ntfsTime = FileTimes.toNtfsTime(javaTime);\n        final Instant instant2 = FileTimes.ntfsTimeToInstant(ntfsTime);\n\n        if (ntfsTime == Long.MAX_VALUE) {\n            // toNtfsTime returns max long instead of overflowing\n        } else {\n            assertEquals(javaTime, instant2.toEpochMilli());\n        }\n    }\n}",
      "method_signature": "testMaxJavaTime()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18255,
    "output_tokens": 3381,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 713,
      "description": "Define a test class containing a private field `atomicBoolean` of type `AtomicBoolean`, and implement a setup method annotated with `@BeforeEach` that instantiates `atomicBoolean` by calling `new AtomicBoolean()` with no arguments. Within the test method annotated with `@Test`, begin by invoking `assertThrows` with arguments `UncheckedIOException.class` and a lambda expression that calls `asBooleanSupplier()` on the constant `TestConstants.THROWING_IO_BOOLEAN_SUPPLIER` and immediately chains `getAsBoolean()` on the returned `BooleanSupplier`, verifying that this invocation throws `UncheckedIOException`. Next, define a private method that accepts an `IOBooleanSupplier` parameter, invokes `asBooleanSupplier()` on it to obtain a `BooleanSupplier`, calls `getAsBoolean()` on that supplier, and returns the resulting boolean value; invoke this private method passing a lambda that calls the static method `TestUtils.compareAndSetThrowsIO` with arguments `atomicBoolean` and boolean literal `true`, then assert using `assertEquals` that the returned value equals boolean `true`. Immediately follow by invoking `assertEquals` with expected value boolean `true` and actual value obtained by calling `get()` on `atomicBoolean`. Finally, invoke `assertNotEquals` comparing two separate invocations of `asBooleanSupplier()` on `TestConstants.THROWING_IO_BOOLEAN_SUPPLIER`, verifying that each call returns a distinct `BooleanSupplier` instance. The test uses method-level annotation `@Test`, assertion library JUnit 5 Assertions, and no mocking libraries.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOBooleanSupplierTest",
      "method_signature": "testAsSupplier()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.function.IOBooleanSupplierTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.BooleanSupplier;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link IOBooleanSupplier}.\n */\npublic class IOBooleanSupplierTest1 {\n\n    private static class TestConstants {\n        static final IOBooleanSupplier THROWING_IO_BOOLEAN_SUPPLIER = () -> {\n            throw new IOException(\"boom!\");\n        };\n    }\n\n    private static class TestUtils {\n        static boolean compareAndSetThrowsIO(final AtomicBoolean atomicBoolean, final boolean newValue) {\n            return atomicBoolean.compareAndSet(!newValue, newValue);\n        }\n    }\n\n    private AtomicBoolean atomicBoolean;\n\n    @BeforeEach\n    void setup() {\n        atomicBoolean = new AtomicBoolean();\n    }\n\n    private boolean getAsBooleanViaSupplier(final IOBooleanSupplier supplier) {\n        final BooleanSupplier booleanSupplier = supplier.asBooleanSupplier();\n        return booleanSupplier.getAsBoolean();\n    }\n\n    @Test\n    void testAsBooleanSupplier() {\n        assertThrows(UncheckedIOException.class, () -> TestConstants.THROWING_IO_BOOLEAN_SUPPLIER.asBooleanSupplier().getAsBoolean());\n\n        final boolean result = getAsBooleanViaSupplier(() -> TestUtils.compareAndSetThrowsIO(atomicBoolean, true));\n        assertEquals(true, result);\n        assertEquals(true, atomicBoolean.get());\n\n        assertNotEquals(TestConstants.THROWING_IO_BOOLEAN_SUPPLIER.asBooleanSupplier(),\n                TestConstants.THROWING_IO_BOOLEAN_SUPPLIER.asBooleanSupplier());\n    }\n}",
      "method_signature": "testAsSupplier()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.9091,
      "callable_precision": 0.9091,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.5,
      "method_coverage": 0.6667,
      "line_coverage": 0.7143,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 3,
          "search_file_content": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 67073,
    "output_tokens": 5452,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 715,
      "description": "Define a parameterized test method that accepts an instant string representation and a Java epoch millisecond timestamp as inputs, then construct an Instant from the provided millisecond value and validate that converting it back to epoch milliseconds yields the original input to confirm round-trip consistency. Convert the Java time to NTFS time using the FileTimes utility, then transform the resulting NTFS time back to an Instant through the FileTimes conversion method. Upon obtaining the reconverted Instant, check whether the NTFS time equals either Long.MIN_VALUE or Long.MAX_VALUE, which indicates the conversion clamped to boundary values rather than overflowing, and if the NTFS time falls outside these extremes, assert that the reconverted Instant's epoch milliseconds match the original Java time to verify bidirectional conversion accuracy between Java time and NTFS time formats. The test validates time conversion utilities across boundary and typical values using a parameterized approach with JUnit 5 and standard assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.attribute.FileTimesTest",
      "method_signature": "testMaxJavaTimeParam(java.lang.String, long)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.file.FileTimesTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.time.Instant;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link FileTimes}.\n */\npublic class FileTimesTest {\n\n    private static Stream<Arguments> testToAndFromNtfsTime() {\n        return Stream.of(\n            Arguments.of(\"1970-01-01T00:00:00Z\", 0L),\n            Arguments.of(\"2024-01-20T12:00:00Z\", 1705752000000L),\n            Arguments.of(Instant.ofEpochMilli(Long.MAX_VALUE).toString(), Long.MAX_VALUE),\n            Arguments.of(Instant.ofEpochMilli(Long.MIN_VALUE).toString(), Long.MIN_VALUE)\n        );\n    }\n\n    @ParameterizedTest(name = \"{0}\")\n    @MethodSource\n    void testToAndFromNtfsTime(final String name, final long epochMilli) {\n        // From Java time to Instant\n        final Instant instant = Instant.ofEpochMilli(epochMilli);\n        assertEquals(epochMilli, instant.toEpochMilli());\n\n        // From Java time to NTFS time\n        final long ntfsTime = FileTimes.toNtfsTime(instant);\n\n        // From NTFS time to Java time\n        final Instant reconverted = FileTimes.toInstant(ntfsTime);\n\n        if (ntfsTime == Long.MIN_VALUE || ntfsTime == Long.MAX_VALUE) {\n            // Clamped to min/max, we cannot check for equality.\n            assertTrue(true);\n        } else {\n            assertEquals(epochMilli, reconverted.toEpochMilli());\n        }\n    }\n}",
      "method_signature": "testMaxJavaTimeParam(java.lang.String, long)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20978,
    "output_tokens": 6371,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 717,
      "description": "Define a test method that validates the bidirectional conversion between Java epoch milliseconds and NTFS time format at the maximum boundary value by initializing a long variable with the maximum representable Java long value, then converting this timestamp to an Instant using the standard Java time API and asserting that converting the Instant back to epoch milliseconds yields the original maximum value to confirm no precision loss occurs during the round-trip conversion. Having established the baseline Java time behavior, invoke the FileTimes utility to convert the maximum Java timestamp to NTFS time format, capturing the resulting NTFS timestamp value. Using this NTFS timestamp, invoke the FileTimes utility to convert back to an Instant representation, then conditionally verify the conversion accuracy by checking whether the NTFS conversion returned the maximum long value as a sentinel indicating overflow handling, and if not, assert that converting the reconstituted Instant to epoch milliseconds produces the original maximum Java timestamp, thereby confirming that the NTFS time conversion maintains temporal fidelity at extreme boundary conditions. This test uses JUnit for the testing framework and standard assertion methods for validation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.attribute.FileTimesTest",
      "method_signature": "testMaxJavaTime()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileTimesTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.time.Instant;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link FileTimes}.\n */\npublic class FileTimesTest {\n\n    @Test\n    public void testMaxJavaAndNtfsInstant() {\n        // Initialize with the maximum representable Java long value.\n        final long maxJavaTimestamp = Long.MAX_VALUE;\n\n        // Convert this timestamp to an Instant and assert that converting it back yields the original value.\n        final Instant maxInstant = Instant.ofEpochMilli(maxJavaTimestamp);\n        assertEquals(maxJavaTimestamp, maxInstant.toEpochMilli());\n\n        // Convert the maximum Java timestamp to the NTFS time format.\n        final long ntfsTimestamp = FileTimes.toNtfsTime(maxJavaTimestamp);\n\n        // Conditionally verify the conversion accuracy.\n        if (ntfsTimestamp != Long.MAX_VALUE) {\n            // If the NTFS conversion did not overflow (indicated by the sentinel value),\n            // convert the NTFS timestamp back to an Instant.\n            final Instant reconstitutedInstant = FileTimes.toInstant(ntfsTimestamp);\n\n            // Assert that converting the reconstituted Instant to epoch milliseconds\n            // produces the original maximum Java timestamp.\n            assertEquals(maxJavaTimestamp, reconstitutedInstant.toEpochMilli());\n        }\n    }\n}",
      "method_signature": "testMaxJavaTime()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 31723,
    "output_tokens": 4838,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 718,
      "description": "Create a test case to validate that the time conversion system correctly handles the maximum representable timestamp value by ensuring it can convert to and from the alternative time format without data loss or overflow. Begin by establishing a scenario using the largest possible timestamp value supported by the system, then convert this extreme timestamp into its standard time representation and verify that the conversion preserves the original value exactly. After confirming the baseline conversion works correctly, transform this maximum timestamp into the alternative file system time format used by certain operating systems, then convert the result back to the standard time representation. Since the conversion system may implement protective measures to prevent arithmetic overflow at boundary conditions, the validation must accommodate two possible outcomes: if the conversion system returns its own maximum value to avoid overflow, acknowledge this as acceptable defensive behavior; otherwise, verify that the round-trip conversion through the alternative format returns the exact original timestamp value, demonstrating that no precision was lost during the transformation process. This scenario ensures the time conversion utilities maintain accuracy even when operating at the extreme upper limit of representable values, which is critical for systems that must preserve precise timestamps across different file system formats and platforms. Verify the outcomes using JUnit 5 with standard equality assertions to confirm that timestamp values remain consistent throughout all conversions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.attribute.FileTimesTest",
      "method_signature": "testMaxJavaTime()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsFileTimeTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.nio.file.attribute.FileTime;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link FileUtils} timestamp conversions.\n */\npublic class FileUtilsFileTimeTest {\n\n    @Test\n    public void testMaxFileTime() throws IOException {\n        final long maxTimestamp = Long.MAX_VALUE;\n\n        // First, confirm baseline conversion to standard FileTime and back.\n        final FileTime maxFileTime = FileUtils.toFileTime(maxTimestamp);\n        assertEquals(maxTimestamp, FileUtils.fromFileTime(maxFileTime),\n            \"Conversion to standard FileTime and back should preserve the maximum value.\");\n\n        // Now, test the round-trip conversion through the alternative (Win32) file system time format.\n        final long win32FileTime = FileUtils.toWin32FileTime(maxTimestamp);\n        final long roundTripTimestamp = FileUtils.fromWin32FileTime(win32FileTime);\n\n        // The conversion system might clamp the value at its representable maximum to prevent overflow.\n        // This is considered acceptable defensive behavior. Otherwise, the value must be exact.\n        // We verify that the outcome is one of these two possibilities.\n        assertTrue(roundTripTimestamp == maxTimestamp || roundTripTimestamp == FileTime.fromMillis(Long.MAX_VALUE).toMillis(),\n            \"Round-trip conversion should either preserve the exact original value or return a clamped maximum value.\");\n    }\n}",
      "method_signature": "testMaxJavaTime()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22878,
    "output_tokens": 9392,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 722,
      "description": "Define a test class containing a private field `atomicBoolean` of type `AtomicBoolean`, and implement a setup method annotated with `@BeforeEach` that instantiates `atomicBoolean` by calling `new AtomicBoolean()` with no arguments. Write a test method annotated with `@Test` that declares `throws IOException` in its signature, then begin by invoking `assertThrows` with arguments `IOException.class` and a lambda expression that calls `getAsBoolean()` on the constant `TestConstants.THROWING_IO_BOOLEAN_SUPPLIER` of type `IOBooleanSupplier`, verifying that this invocation throws `IOException`. Immediately follow with a second `assertThrows` call passing `IOException.class` and a lambda expression whose body contains only `throw new IOException();` with no arguments, confirming the exception is thrown. Next, invoke `assertEquals` with expected value `true` and an actual value obtained by calling a private method that accepts an `IOBooleanSupplier` parameter and returns the result of invoking `getAsBoolean()` on that supplier; pass to this private method a lambda expression that invokes the static method `compareAndSetThrowsIO` from class `TestUtils` with arguments `atomicBoolean` and boolean literal `true`, where `compareAndSetThrowsIO` internally calls an overloaded version passing `false` as the second argument before `true`, and this entire chain returns a boolean which the private method propagates by calling `getAsBoolean()` on the supplied lambda. Finally, invoke `assertEquals` with expected value `true` and actual value obtained by calling `get()` on `atomicBoolean`. The test uses JUnit 5 Assertions with method-level annotation `@Test` and setup annotation `@BeforeEach`, and the test method declares `throws IOException`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.function.IOBooleanSupplierTest",
      "method_signature": "testGet()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.function.IOBooleanSupplierTest1",
      "code": "package org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport org.apache.commons.io.TestConstants;\nimport org.apache.commons.io.TestUtils;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link IOBooleanSupplier}.\n */\npublic class IOBooleanSupplierTest1 {\n\n    private AtomicBoolean atomicBoolean;\n\n    @BeforeEach\n    public void setUp() {\n        atomicBoolean = new AtomicBoolean();\n    }\n\n    private boolean getAsBoolean(final IOBooleanSupplier supplier) throws IOException {\n        return supplier.getAsBoolean();\n    }\n\n    @Test\n    public void testGetAsBoolean() throws IOException {\n        assertThrows(IOException.class, () -> TestConstants.THROWING_IO_BOOLEAN_SUPPLIER.getAsBoolean());\n        assertThrows(IOException.class, () -> {\n            throw new IOException();\n        });\n        assertEquals(true, getAsBoolean(() -> TestUtils.compareAndSetThrowsIO(atomicBoolean, true).getAsBoolean()));\n        assertEquals(true, atomicBoolean.get());\n    }\n}",
      "method_signature": "testGet()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1,
          "read_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 51072,
    "output_tokens": 4612,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 731,
      "description": "Define a test method that validates constructor and factory method error handling for the Byte Array Seekable Byte Channel component by first verifying that instantiating the channel with a negative integer capacity triggers an illegal argument validation error, then confirming that invoking the static wrap factory method with a null byte array parameter produces a null pointer validation error, ensuring both error conditions are properly enforced at the component boundary before any channel operations can proceed. JUnit 5.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest",
      "method_signature": "testConstructorInvalid()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * JUnit Test Case for {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    @Test\n    public void testErrorHandling() {\n        assertThrows(IllegalArgumentException.class, () -> new ByteArraySeekableByteChannel(-1));\n        assertThrows(NullPointerException.class, () -> ByteArraySeekableByteChannel.wrap(null));\n    }\n}",
      "method_signature": "testConstructorInvalid()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 24921,
    "output_tokens": 1626,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 733,
      "description": "Define a parameterized test method annotated with `@ParameterizedTest` and `@MethodSource(\"fileTimeNanoUnitsToNtfsProvider\")` that accepts two parameters: a `String` named `instantStr` and a `long` named `javaTime`. Begin by creating an `Instant` object named `instant` by invoking `Instant.ofEpochMilli(javaTime)`, then immediately assert equality between `javaTime` and the result of calling `toEpochMilli()` on `instant` using `assertEquals(javaTime, instant.toEpochMilli())`. Next, invoke the static method `FileTimes.toNtfsTime(javaTime)` and assign the returned `long` value to a variable named `ntfsTime`. With this NTFS time value, invoke the static method `FileTimes.ntfsTimeToInstant(ntfsTime)` and assign the resulting `Instant` to a variable named `instant2`. Following this conversion, check whether `ntfsTime` equals `Long.MIN_VALUE` or `Long.MAX_VALUE` using an if-condition; if either condition holds true, execute an empty block (representing a scenario where `toNtfsTime` returns boundary values instead of overflowing), otherwise proceed to the else block where you assert equality between `javaTime` and the result of calling `toEpochMilli()` on `instant2` using `assertEquals(javaTime, instant2.toEpochMilli())`. The test uses JUnit 5 Assertions via `assertEquals`, is annotated with `@ParameterizedTest` and `@MethodSource(\"fileTimeNanoUnitsToNtfsProvider\")`, and relies on the application class `FileTimes` with its static methods `toNtfsTime(long)` and `ntfsTimeToInstant(long)`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.file.attribute.FileTimesTest",
      "method_signature": "testMaxJavaTimeParam(java.lang.String, long)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileTimesTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.time.Instant;\nimport java.util.stream.Stream;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests {@link FileTimes}.\n */\npublic class FileTimesTest {\n\n    public static Stream<Arguments> fileTimeNanoUnitsToNtfsProvider() {\n        return Stream.of(\n            Arguments.of(\"2024-01-01T00:00:00Z\", 1704067200000L),\n            Arguments.of(\"1970-01-01T00:00:00Z\", 0L),\n            Arguments.of(\"1960-01-01T00:00:00Z\", -315619200000L)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"fileTimeNanoUnitsToNtfsProvider\")\n    public void testFileTimeNanoUnitsToNtfs(final String instantStr, final long javaTime) {\n        final Instant instant = Instant.ofEpochMilli(javaTime);\n        assertEquals(javaTime, instant.toEpochMilli());\n        final long ntfsTime = FileTimes.toNtfsTime(javaTime);\n        final Instant instant2 = FileTimes.ntfsTimeToInstant(ntfsTime);\n        if (ntfsTime == Long.MIN_VALUE || ntfsTime == Long.MAX_VALUE) {\n            // FileTimes.toNtfsTime returns MIN_VALUE or MAX_VALUE instead of overflowing.\n        } else {\n            assertEquals(javaTime, instant2.toEpochMilli());\n        }\n    }\n}",
      "method_signature": "testMaxJavaTimeParam(java.lang.String, long)"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 24219,
    "output_tokens": 1984,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 744,
      "description": "Create a test case to validate that the byte channel system properly rejects invalid initialization attempts by enforcing its business rules for channel creation. Ensure the system refuses to create a channel when requested with a negative capacity, confirming that such an invalid request is immediately rejected as inappropriate for business operations. Similarly, verify that the system prevents wrapping missing data into a channel, ensuring that attempts to create a channel from absent content are properly blocked to maintain data integrity. Use JUnit 5 for the testing framework and verify the system's protective behavior by confirming that both invalid scenarios trigger the appropriate rejection responses, with standard assertion capabilities validating that the system correctly enforces these fundamental constraints on channel initialization.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest",
      "method_signature": "testConstructorInvalid()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArrayChannelTest",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\nimport java.nio.channels.SeekableByteChannel;\n\n/**\n * Tests that the byte channel system properly rejects invalid initialization attempts by enforcing its business rules\n * for channel creation.\n */\npublic class ByteArrayChannelTest {\n\n    /**\n     * Verifies that the system prevents wrapping missing data into a channel and refuses to create a channel with a\n     * negative capacity.\n     */\n    @Test\n    public void testInvalidInitializationRejection() {\n        // Validate that an attempt to create a channel with a negative capacity is rejected.\n        assertThrows(IllegalArgumentException.class, () -> new ByteArrayChannel(-1),\n            \"The system should reject attempts to create a channel with a negative capacity.\");\n\n        // Validate that an attempt to create a channel from absent content (null) is blocked.\n        assertThrows(NullPointerException.class, () -> new ByteArrayChannel(null),\n            \"The system should prevent the creation of a channel from a null data source.\");\n    }\n}",
      "method_signature": "testConstructorInvalid()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14941,
    "output_tokens": 7503,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 746,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]`, then declare instance fields `tempFile` of type `Path` and `channel` of type `SeekableByteChannel` (these fields are initialized in setup but not used in this specific test method, so their initialization can be omitted from this test's description). Write a test method annotated with `@Test` that validates invalid constructor and factory method invocations for `ByteArraySeekableByteChannel`. Begin by invoking `assertThrows` with `IllegalArgumentException.class` as the first argument and a lambda expression as the second argument, where the lambda instantiates `ByteArraySeekableByteChannel` by calling its constructor with the integer argument `-1`, verifying that this negative capacity throws the expected exception. Immediately follow by invoking `assertThrows` again with `NullPointerException.class` as the first argument and a lambda expression as the second argument, where the lambda calls the static factory method `ByteArraySeekableByteChannel.wrap` passing `null` as the argument, verifying that wrapping a null byte array throws the expected exception. Define a teardown method that checks if `channel` is not null and `channel.isOpen()` returns true, and if so, invokes `channel.close()`, then checks if `tempFile` is not null and `Files.exists(tempFile)` returns true, and if so, invokes `Files.delete(tempFile)`. The test uses method-level annotation `@Test`, assertion library JUnit 5 Assertions, and no mocking libraries.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest",
      "method_signature": "testConstructorInvalid()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = new byte[0];\n\n    private Path tempFile;\n    private SeekableByteChannel channel;\n\n    @AfterEach\n    public void tearDown() throws IOException {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (tempFile != null && Files.exists(tempFile)) {\n            Files.delete(tempFile);\n        }\n    }\n\n    @Test\n    public void testInvalidInvocations() {\n        assertThrows(IllegalArgumentException.class, () -> new ByteArraySeekableByteChannel(-1));\n        assertThrows(NullPointerException.class, () -> ByteArraySeekableByteChannel.wrap(null));\n    }\n}",
      "method_signature": "testConstructorInvalid()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 17975,
    "output_tokens": 3032,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 756,
      "description": "Create a test case to validate that the system correctly wraps a file channel resource with protective behavior while preserving all standard communication capabilities. Begin by establishing a temporary workspace and creating an empty file within it to serve as the test subject. Open a channel to this file and apply a protective wrapper that prevents accidental closure of the underlying resource. Verify that the wrapped channel still exposes all the standard communication interfaces expected of file channels, confirming that the protective layer does not interfere with normal operations. Additionally, ensure that the wrapper does not incorrectly identify itself as a concrete file channel implementation, maintaining proper abstraction boundaries. Once all validations complete, release the channel resources as both the protective wrapper and the underlying channel are automatically closed. Validate the business outcome using JUnit 5 as the testing framework with standard equality and type assertions to confirm interface compliance.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testWrapFileChannel(java.nio.file.Path)",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.FileChannelProxyTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertInstanceOf;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.GatheringByteChannel;\nimport java.nio.channels.ScatteringByteChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileChannelProxy}.\n */\npublic class FileChannelProxyTest {\n\n    @TempDir\n    private Path tempDir;\n\n    private static class ProtectiveFileChannelProxy extends FileChannelProxy {\n        ProtectiveFileChannelProxy(final FileChannel fileChannel) {\n            super(fileChannel);\n        }\n    }\n\n    @Test\n    public void testProtectiveWrapperPreservesChannelCapabilities() throws IOException {\n        final Path file = Files.createFile(tempDir.resolve(\"test.txt\"));\n        final FileChannel underlyingChannel = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE);\n\n        try (final FileChannel protectedChannel = new ProtectiveFileChannelProxy(underlyingChannel)) {\n            // Verify that the wrapper exposes standard FileChannel interfaces\n            assertInstanceOf(SeekableByteChannel.class, protectedChannel, \"Wrapper should be a SeekableByteChannel\");\n            assertInstanceOf(ScatteringByteChannel.class, protectedChannel, \"Wrapper should be a ScatteringByteChannel\");\n            assertInstanceOf(GatheringByteChannel.class, protectedChannel, \"Wrapper should be a GatheringByteChannel\");\n\n            // Verify wrapper is not the same as the concrete implementation\n            assertNotEquals(underlyingChannel.getClass(), protectedChannel.getClass(), \"Wrapper should maintain abstraction\");\n\n            // Verify the underlying channel is still open while the wrapper is in use\n            assertTrue(underlyingChannel.isOpen(), \"Underlying channel should be open\");\n        }\n\n        // After the try-with-resources block, both the wrapper and the underlying channel should be closed.\n        assertFalse(underlyingChannel.isOpen(), \"Underlying channel should be closed when the wrapper is closed\");\n    }\n}",
      "method_signature": "testWrapFileChannel(java.nio.file.Path)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.1667,
      "callable_recall": 0.3333,
      "callable_precision": 0.2143,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 15483,
    "output_tokens": 7058,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 757,
      "description": "Create a test case to validate that the system properly handles attempts to access a resource that does not exist within the workspace. Before executing the test, ensure the workspace is initialized with a clean temporary directory structure prepared for testing file operations. Establish a scenario where a reference to a non-existent resource named \"test.txt\" is created within the temporary workspace, then attempt to open this resource for reading. Verify that the system correctly identifies the absence of the resource and signals a failure condition indicating the resource cannot be accessed. The test should confirm the system's ability to detect and report missing resources rather than proceeding with invalid operations. Use JUnit 5 as the testing framework and validate the expected failure condition using standard assertion mechanisms that confirm the appropriate error response when attempting to access non-existent resources.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenInputStream_notExists()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.NonExistentResourceTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests that the system properly handles attempts to access a resource that does not exist within the workspace.\n */\npublic class NonExistentResourceTest {\n\n    @TempDir\n    private Path tempDir;\n\n    @Test\n    public void testOpenNonExistentResource() {\n        final File nonExistentFile = new File(tempDir.toFile(), \"test.txt\");\n        assertThrows(FileNotFoundException.class, () -> FileUtils.openInputStream(nonExistentFile));\n    }\n}",
      "method_signature": "testOpenInputStream_notExists()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.6667,
      "focal_recall": 0.5,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 17715,
    "output_tokens": 3081,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 761,
      "description": "Create a test case to validate that the output stream correctly resets its internal tracking mechanism when the configured data volume limit is reached, allowing for continuous monitoring across multiple threshold breaches. Configure a streaming system with a minimal data volume limit of one byte and establish a mechanism to track how many times the limit is reached, ensuring that each time the limit is triggered, the internal byte counter automatically resets to zero. Before any data flows through the stream, confirm the system starts in its expected initial state with no data processed and no threshold breaches recorded. Write a single byte to the stream and verify the limit has not yet been exceeded since the threshold triggers on the next byte that would exceed the limit. After writing a second byte, confirm the threshold breach counter increments to one and verify the stream has not flagged itself as permanently exceeding the limit due to the automatic reset behavior. Continue writing two more bytes sequentially and ensure the breach counter reaches three, demonstrating that each write beyond the limit triggers the reset mechanism and allows subsequent writes to be monitored afresh. Throughout this process, verify the stream never enters a permanent exceeded state, proving the reset functionality enables ongoing threshold monitoring rather than a one-time breach detection. Release any held resources upon completion. Use JUnit 5 for test orchestration and standard equality assertions to verify counter values and threshold state conditions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.ThresholdingOutputStreamTest",
      "method_signature": "testResetByteCount()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.ThresholdingOutputStreamResetTest",
      "code": "package org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Create a test case to validate that the output stream correctly resets its internal tracking mechanism when the\n * configured data volume limit is reached, allowing for continuous monitoring across multiple threshold breaches.\n *\n * @see ThresholdingOutputStream\n */\npublic class ThresholdingOutputStreamResetTest {\n\n    /**\n     * A {@link ThresholdingOutputStream} that counts the number of times the threshold is reached and resets itself.\n     * This allows for continuous monitoring.\n     */\n    private static final class ResettableThresholdingOutputStream extends ThresholdingOutputStream {\n\n        private int thresholdReachedCount;\n\n        /**\n         * Constructs an instance of this class.\n         *\n         * @param threshold The threshold in bytes.\n         */\n        private ResettableThresholdingOutputStream(final int threshold) {\n            super(threshold);\n        }\n\n        @Override\n        protected void thresholdReached() throws IOException {\n            thresholdReachedCount++;\n            resetByteCount(); // Resets byte count and the exceeded flag.\n        }\n\n        @Override\n        protected OutputStream getStream() throws IOException {\n            return NullOutputStream.INSTANCE;\n        }\n\n        /**\n         * Gets the number of times the threshold has been reached.\n         *\n         * @return The number of threshold breaches.\n         */\n        public int getThresholdReachedCount() {\n            return thresholdReachedCount;\n        }\n    }\n\n    @Test\n    public void testThresholdingOutputStreamReset() throws IOException {\n        // Configure a streaming system with a minimal data volume limit of one byte.\n        final int threshold = 1;\n        try (final ResettableThresholdingOutputStream stream = new ResettableThresholdingOutputStream(threshold)) {\n\n            // Before any data flows through the stream, confirm the system starts in its expected\n            // initial state with no data processed and no threshold breaches recorded.\n            assertEquals(0, stream.getThresholdReachedCount(), \"Initial breach counter should be zero.\");\n            assertFalse(stream.isThresholdExceeded(), \"Stream should not be in an exceeded state initially.\");\n            assertEquals(0, stream.getByteCount(), \"Initial byte count should be zero.\");\n\n            // Write a single byte to the stream and verify the limit has not yet been exceeded since\n            // the threshold triggers on the next byte that would exceed the limit.\n            stream.write(0);\n            assertEquals(0, stream.getThresholdReachedCount(), \"Breach counter should be zero after one byte.\");\n            assertFalse(stream.isThresholdExceeded(), \"Stream should not be in an exceeded state after one byte.\");\n            assertEquals(1, stream.getByteCount(), \"Byte count should be one after writing one byte.\");\n\n            // After writing a second byte, confirm the threshold breach counter increments to one and\n            // verify the stream has not flagged itself as permanently exceeding the limit due to the\n            // automatic reset behavior.\n            stream.write(0);\n            assertEquals(1, stream.getThresholdReachedCount(), \"Breach counter should be one after the first breach.\");\n            assertFalse(stream.isThresholdExceeded(), \"Stream should reset and not be in a permanent exceeded state.\");\n            assertEquals(1, stream.getByteCount(), \"Byte count should be one after reset and second write.\");\n\n            // Continue writing two more bytes sequentially and ensure the breach counter reaches three,\n            // demonstrating that each write beyond the limit triggers the reset mechanism and allows\n            // subsequent writes to be monitored afresh.\n            stream.write(0);\n            assertEquals(2, stream.getThresholdReachedCount(), \"Breach counter should be two after the second breach.\");\n            assertFalse(stream.isThresholdExceeded(), \"Stream should remain resettable after multiple breaches.\");\n            assertEquals(1, stream.getByteCount(), \"Byte count should be one after reset and third write.\");\n\n            stream.write(0);\n            assertEquals(3, stream.getThresholdReachedCount(), \"Breach counter should be three after the third breach.\");\n            assertFalse(stream.isThresholdExceeded(), \"Stream should never enter a permanent exceeded state.\");\n            assertEquals(1, stream.getByteCount(), \"Byte count should be one after reset and fourth write.\");\n        }\n    }\n}",
      "method_signature": "testResetByteCount()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.5333,
      "callable_recall": 0.6154,
      "callable_precision": 0.4571,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.3333,
      "method_coverage": 0.3846,
      "line_coverage": 0.3514,
      "branch_coverage": 0.5
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 21652,
    "output_tokens": 6827,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 762,
      "description": "Define a test method that validates the behavior of the file input stream opening capability when the target file does not exist. Within the test setup inherited from the enclosing test class, initialize a temporary directory structure and configure two test files with predetermined sizes, populating each file with generated test data through buffered output streams, then delete the entire temporary directory and recreate it before repopulating the test files with the same generated content to establish a clean baseline state. For the specific test scenario, construct a File object representing a non-existent path within the temporary directory by specifying a filename that has not been created. Invoke the openInputStream method on the FileUtils utility with this non-existent file reference, expecting the operation to throw an IOException since the file does not exist. Assert that the IOException is raised, confirming that the utility correctly validates file existence and rejects attempts to open input streams for missing files. This test validates error handling for file access operations and ensures proper exception propagation when preconditions are not met. The test relies on JUnit 5 for test execution and assertion capabilities.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenInputStream_notExists()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenInputStreamTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileUtils} open input stream methods.\n */\npublic class FileUtilsOpenInputStreamTest {\n\n    @TempDir\n    public Path tempDir;\n\n    private final byte[] testData = new byte[1024];\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        File testDir = tempDir.toFile();\n        Arrays.fill(testData, (byte) 1);\n\n        // Initialize and populate files\n        repopulateFiles(testDir);\n\n        // Delete the entire temporary directory\n        FileUtils.deleteDirectory(testDir);\n\n        // Recreate it\n        Files.createDirectory(tempDir);\n\n        // Repopulate the test files to establish a clean baseline state\n        repopulateFiles(testDir);\n    }\n\n    private void repopulateFiles(File directory) throws IOException {\n        File testFile1 = new File(directory, \"testFile1.txt\");\n        File testFile2 = new File(directory, \"testFile2.txt\");\n\n        try (BufferedOutputStream bos1 = new BufferedOutputStream(new FileOutputStream(testFile1))) {\n            bos1.write(testData);\n        }\n        try (BufferedOutputStream bos2 = new BufferedOutputStream(new FileOutputStream(testFile2))) {\n            bos2.write(testData);\n        }\n    }\n\n    @Test\n    public void testOpenInputStreamForNonExistentFile() {\n        // Construct a File object representing a non-existent path\n        final File nonExistentFile = new File(tempDir.toFile(), \"nonExistent.txt\");\n\n        // Invoke openInputStream and assert that an IOException is thrown\n        assertThrows(IOException.class, () -> FileUtils.openInputStream(nonExistentFile));\n    }\n}",
      "method_signature": "testOpenInputStream_notExists()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.6667,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 39721,
    "output_tokens": 7480,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 765,
      "description": "Define a test method that validates the byte count reset mechanism of a Thresholds Output Stream when the threshold is repeatedly exceeded during write operations. Initialize an atomic counter to track threshold events and configure a Thresholding Output Stream with a threshold of one byte, providing a consumer callback that increments the counter and resets the stream's byte count whenever the threshold is reached, along with a supplier that returns a Byte Array Output Stream as the underlying destination. Create a helper method that verifies the stream's initial state by checking that the threshold has not been exceeded and that both the configured threshold value and current byte count match expected values. Upon initialization, invoke this helper to confirm the stream starts with a threshold of one byte and zero bytes written, then assert that the counter remains at zero. Write a single byte to the stream and verify that the threshold has not yet been exceeded, as the count equals but does not surpass the threshold. Write a second byte, which should trigger the threshold callback, causing the counter to increment to one and the byte count to reset, then confirm the threshold exceeded flag remains false due to the reset. Write two additional bytes in succession, expecting each to trigger the callback independently since the reset keeps the byte count cycling, and finally assert that the counter has reached three, indicating the callback fired on each threshold crossing. Close all resources including the Thresholding Output Stream and Byte Array Output Stream within a try-with-resources block. This test uses JUnit for the test framework and standard assertion methods.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.ThresholdingOutputStreamTest",
      "method_signature": "testResetByteCount()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7468,
    "output_tokens": 8378,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 769,
      "description": "Define a test method annotated with `@Test` that declares it throws `IOException`, beginning by initializing an `int` variable `threshold` with value `1`, then instantiating an `AtomicInteger` assigned to variable `counter` using the no-argument constructor, followed by opening a try-with-resources block that declares `ByteArrayOutputStream` variable `os` initialized via the no-argument constructor and `ThresholdingOutputStream` variable `out` initialized by invoking the three-argument constructor passing `threshold` as the first argument, a lambda expression `tos -> { counter.incrementAndGet(); tos.resetByteCount(); }` as the second argument (where the lambda body first calls `incrementAndGet()` on `counter` and then invokes `resetByteCount()` on the lambda parameter `tos`), and a lambda expression `o -> os` as the third argument. Within the try block, first invoke `assertFalse` on the result of calling `isThresholdExceeded()` on `out`, then invoke `assertEquals` with expected value equal to the result of calling `getThreshold()` on `out` and actual value `threshold`, and finally invoke `assertEquals` with expected value equal to the result of calling `getByteCount()` on `out` and actual value `0`. Next, invoke `assertEquals` with expected value `0` and actual value obtained by calling `get()` on `counter`. Invoke `write` on `out` passing the character literal `'a'` (as an int), then invoke `assertFalse` on the result of calling `isThresholdExceeded()` on `out`. Invoke `write` on `out` again with character literal `'a'`, then invoke `assertEquals` with expected value `1` and actual value from calling `get()` on `counter`, followed by invoking `assertFalse` on the result of calling `isThresholdExceeded()` on `out`. Invoke `write` on `out` with character literal `'a'`, then immediately invoke `write` on `out` again with character literal `'a'`, and finally invoke `assertEquals` with expected value `3` and actual value from calling `get()` on `counter`, allowing the try-with-resources to automatically close both `out` and `os` upon completion. The test uses JUnit 5 Assertions (`assertEquals`, `assertFalse`).",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.output.ThresholdingOutputStreamTest",
      "method_signature": "testResetByteCount()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.ThresholdingOutputStreamTest1",
      "code": "package org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ThresholdingOutputStream}.\n */\npublic class ThresholdingOutputStreamTest1 {\n\n    @Test\n    public void testThresholding() throws IOException {\n        final int threshold = 1;\n        final AtomicInteger counter = new AtomicInteger();\n        try (final ByteArrayOutputStream os = new ByteArrayOutputStream();\n             final ThresholdingOutputStream out = new ThresholdingOutputStream(threshold, tos -> {\n                 counter.incrementAndGet();\n                 tos.resetByteCount();\n             }, o -> os)) {\n            assertFalse(out.isThresholdExceeded());\n            assertEquals(out.getThreshold(), threshold);\n            assertEquals(out.getByteCount(), 0);\n\n            assertEquals(0, counter.get());\n\n            out.write('a');\n            assertFalse(out.isThresholdExceeded());\n\n            out.write('a');\n            assertEquals(1, counter.get());\n            assertFalse(out.isThresholdExceeded());\n\n            out.write('a');\n            out.write('a');\n            assertEquals(3, counter.get());\n        }\n    }\n}",
      "method_signature": "testResetByteCount()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.6667,
      "obj_creation_precision": 0.6667,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.9231,
      "callable_precision": 0.96,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.3333,
      "method_coverage": 0.5385,
      "line_coverage": 0.4189,
      "branch_coverage": 0.5
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19982,
    "output_tokens": 4689,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 782,
      "description": "Define a test method that validates the force deletion behavior of a symbolic link pointing to a directory by first establishing a temporary directory structure through inherited setup fixtures, then creating a symbolic link and its target directory using a helper that constructs both paths relative to the test directory and establishes the symbolic link relationship, after which verify that both the symbolic link and its target directory exist and that the link is correctly identified as a symbolic link. Invoke the force delete operation on the symbolic link converted to a File object, then confirm that the symbolic link itself no longer exists and is no longer recognized as a symbolic link, while simultaneously verifying that the original target directory remains intact and unaffected by the deletion of the link that pointed to it. The test uses JUnit for test execution and standard Java NIO Files API for symbolic link verification.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testForceDeleteSymlink()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileDeleteStrategyTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileDeleteStrategy}.\n */\npublic class FileDeleteStrategyTest1 {\n\n    @TempDir\n    private Path testDirectory;\n\n    /**\n     * Helper method to create a symbolic link and its target directory.\n     *\n     * @param link   The path to the symbolic link to create.\n     * @param target The path to the target directory to create.\n     * @throws IOException if an I/O error occurs.\n     */\n    private void createSymbolicLinkAndTarget(final Path link, final Path target) throws IOException {\n        Files.createDirectory(target);\n        Files.createSymbolicLink(link, target);\n    }\n\n    @Test\n    public void testForceDeleteSymbolicLinkToDirectory() throws IOException {\n        final Path targetDir = testDirectory.resolve(\"targetDir\");\n        final Path symlink = testDirectory.resolve(\"symbolicLink\");\n\n        createSymbolicLinkAndTarget(symlink, targetDir);\n\n        assertTrue(Files.exists(targetDir), \"Target directory should exist before deletion.\");\n        assertTrue(Files.exists(symlink), \"Symbolic link should exist before deletion.\");\n        assertTrue(Files.isSymbolicLink(symlink), \"Path should be a symbolic link.\");\n\n        FileDeleteStrategy.FORCE.delete(symlink.toFile());\n\n        assertFalse(Files.exists(symlink), \"Symbolic link should not exist after deletion.\");\n        assertFalse(Files.isSymbolicLink(symlink), \"Path should not be a symbolic link after deletion.\");\n        assertTrue(Files.exists(targetDir), \"Target directory should still exist after deleting the link.\");\n    }\n\n}",
      "method_signature": "testForceDeleteSymlink()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.7727,
      "callable_precision": 0.8947,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20063,
    "output_tokens": 5465,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 787,
      "description": "Define a test method that accepts a temporary directory path as a parameter and verifies that wrapping a FileChannel with CloseShieldChannel produces a proxy implementing all expected channel interfaces while preventing direct FileChannel implementation. Resolve a file path named \"test.txt\" within the temporary directory, then invoke the touch utility on the resolved file to create an empty file on disk. Open a FileChannel for the created file and wrap it using CloseShieldChannel's wrap method, capturing the resulting proxy as a Channel reference. Create a helper method that retrieves all interfaces implemented by the FileChannel class by querying the class hierarchy, then iterate over this collection of interface types and assert that the wrapped proxy is an instance of each interface. After validating interface conformance, assert that the proxy is not an instance of the concrete FileChannel class itself, confirming that the wrapper shields the underlying channel type. Upon completion of the verification steps, allow the try-with-resources block to close both the wrapped proxy and the underlying FileChannel, ensuring proper resource cleanup. The test uses JUnit 5 for parameterized test execution and standard assertion methods for validation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testWrapFileChannel(java.nio.file.Path)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.apache.commons.io.FileUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    private Set<Class<?>> getAllInterfaces(final Class<?> cls) {\n        final Set<Class<?>> interfaces = new HashSet<>();\n        final Deque<Class<?>> toProcess = new ArrayDeque<>();\n        if (cls != null) {\n            toProcess.add(cls);\n        }\n        while (!toProcess.isEmpty()) {\n            final Class<?> c = toProcess.pop();\n            for (final Class<?> i : c.getInterfaces()) {\n                if (interfaces.add(i)) {\n                    toProcess.add(i);\n                }\n            }\n            if (c.getSuperclass() != null) {\n                toProcess.add(c.getSuperclass());\n            }\n        }\n        return interfaces;\n    }\n\n    @Test\n    public void testWrapFileChannel(@TempDir final Path tempDir) throws IOException {\n        final Path file = tempDir.resolve(\"test.txt\");\n        FileUtils.touch(file.toFile());\n\n        try (FileChannel channel = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n            final Channel proxy = CloseShieldChannel.wrap(channel);\n            final Set<Class<?>> interfaces = getAllInterfaces(FileChannel.class);\n            for (final Class<?> iface : interfaces) {\n                assertTrue(iface.isInstance(proxy), \"Proxy should implement \" + iface.getName());\n            }\n            assertFalse(proxy instanceof FileChannel, \"Proxy should not be a direct instance of FileChannel\");\n        }\n    }\n}",
      "method_signature": "testWrapFileChannel(java.nio.file.Path)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.5,
      "callable_recall": 0.6667,
      "callable_precision": 0.2857,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.9286,
      "line_coverage": 0.9041,
      "branch_coverage": 0.8462
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 59625,
    "output_tokens": 7869,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 789,
      "description": "Create a test case to validate that the system can safely remove a symbolic link without affecting the original target directory. Begin by establishing a temporary workspace with a subdirectory that will serve as the actual storage location, then create a symbolic link pointing to that subdirectory. Confirm that both the symbolic link and its target exist in the system and that the link is recognized as a symbolic reference rather than a regular directory. Instruct the system to forcefully remove the symbolic link, then verify that the link itself has been completely eliminated from the system and is no longer recognized as a symbolic reference. After confirming the link's removal, ensure the original target directory remains intact and accessible, demonstrating that the deletion operation only affected the link and not the underlying data it referenced. This test uses JUnit 5 as the testing framework and validates outcomes through standard equality and boolean assertions to confirm the expected state of both the symbolic link and the target directory before and after the removal operation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testForceDeleteSymlink()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileDeleteStrategyForceDeleteSymbolicLinkTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assumptions.assumeTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileDeleteStrategy#FORCE} that it can delete a symbolic link without deleting the target directory.\n */\npublic class FileDeleteStrategyForceDeleteSymbolicLinkTest {\n\n    @TempDir\n    private Path tempDir;\n\n    @Test\n    public void testForceDeleteSymbolicLink() throws IOException {\n        final File targetDir = new File(tempDir.toFile(), \"target\");\n        assertTrue(targetDir.mkdirs(), \"Failed to create target directory\");\n        final File testFile = new File(targetDir, \"test.txt\");\n        assertTrue(testFile.createNewFile(), \"Failed to create test file\");\n\n        final File symlink = new File(tempDir.toFile(), \"symlink\");\n        try {\n            Files.createSymbolicLink(symlink.toPath(), targetDir.toPath());\n        } catch (final UnsupportedOperationException e) {\n            // Skip test if symbolic links are not supported\n            assumeTrue(false, \"Symbolic links not supported, skipping test\");\n        }\n\n        // Pre-check\n        assertTrue(Files.exists(symlink.toPath()), \"Symbolic link should exist before deletion\");\n        assertTrue(Files.isSymbolicLink(symlink.toPath()), \"File should be a symbolic link\");\n        assertTrue(Files.exists(targetDir.toPath()), \"Target directory should exist before deletion\");\n\n        // Delete the symbolic link\n        FileDeleteStrategy.FORCE.delete(symlink);\n\n        // Post-check\n        assertFalse(Files.exists(symlink.toPath()), \"Symbolic link should be deleted\");\n        assertFalse(Files.isSymbolicLink(symlink.toPath()), \"File should no longer be a symbolic link\");\n        assertTrue(Files.exists(targetDir.toPath()), \"Target directory should still exist\");\n        assertTrue(testFile.exists(), \"File inside target directory should still exist\");\n    }\n}",
      "method_signature": "testForceDeleteSymlink()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.6667,
      "callable_recall": 0.6364,
      "callable_precision": 0.4118,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18021,
    "output_tokens": 3298,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 792,
      "description": "Create a test case to validate that the system can successfully open and read content from an existing text resource. Begin by establishing a temporary workspace and preparing a text resource containing a single line with the word \"Hello\" encoded in standard text format. Once the resource is in place, request the system to open an input channel for reading the resource's contents. After the channel is established, retrieve the first character from the resource and confirm that it matches the expected initial character 'H' from the prepared content. Ensure the input channel is properly released after the read operation completes. Validate the outcome using standard equality assertions. Testing framework: JUnit 5. Assertion library: JUnit 5 assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenInputStream_exists()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IORandomAccessFileTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link IORandomAccessFile}.\n */\npublic class IORandomAccessFileTest1 {\n\n    @Test\n    public void testOpenAndReadFromExistingResource(@TempDir final Path tempDir) throws IOException {\n        final Path resourcePath = tempDir.resolve(\"test.txt\");\n        Files.write(resourcePath, \"Hello\".getBytes(StandardCharsets.UTF_8));\n        final File resourceFile = resourcePath.toFile();\n\n        try (final IORandomAccessFile randomAccessFile = new IORandomAccessFile(resourceFile, \"r\");\n             final FileChannel channel = randomAccessFile.getChannel()) {\n            final ByteBuffer buffer = ByteBuffer.allocate(1);\n            final int read = channel.read(buffer);\n            assertEquals(1, read);\n            buffer.flip();\n            assertEquals('H', (char) buffer.get());\n        }\n    }\n}",
      "method_signature": "testOpenInputStream_exists()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.5,
      "callable_recall": 0.4,
      "callable_precision": 0.1667,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 21460,
    "output_tokens": 6898,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 795,
      "description": "Define a test method annotated with `@Test` that accepts a single parameter `tempDir` of type `Path` annotated with `@TempDir`, and declare that the method throws `IOException`. Begin by invoking `resolve` on `tempDir` with the String literal `\"test.txt\"`, assigning the result to a variable `testFile` of type `Path`. Invoke the static method `touch` on `FileUtils`, passing `testFile.toFile()` as the argument, to create the file. Open a try-with-resources block declaring two resources: first, invoke the static method `open` on `FileChannel` with argument `testFile`, assigning the result to variable `channel` of type `FileChannel`; second, invoke the static method `wrap` on `CloseShieldChannel` with argument `channel`, assigning the result to variable `shield` of type `Channel`. Within the try block, define a private method that invokes the static method `getAllInterfaces` on `ClassUtils` with argument `FileChannel.class`, returning a `List<Class<?>>`, and immediately invoke `forEach` on the returned list, passing a lambda that accepts parameter `iface` and invokes `assertInstanceOf` with arguments `iface` and `shield`. Following the forEach invocation, invoke `assertFalse` with two arguments: the boolean expression `shield instanceof FileChannel` and the String literal `\"not FileChannel\"`. The test uses JUnit 5 Assertions for `assertInstanceOf` and `assertFalse`, and the method-level annotation is `@Test`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest",
      "method_signature": "testWrapFileChannel(java.nio.file.Path)",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.CloseShieldChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertInstanceOf;\n\nimport java.io.IOException;\nimport java.nio.channels.Channel;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.List;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.lang3.ClassUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link CloseShieldChannel}.\n */\npublic class CloseShieldChannelTest1 {\n\n    @Test\n    public void testCloseShieldChannel(@TempDir final Path tempDir) throws IOException {\n        final Path testFile = tempDir.resolve(\"test.txt\");\n        FileUtils.touch(testFile.toFile());\n        try (FileChannel channel = FileChannel.open(testFile, StandardOpenOption.READ);\n             Channel shield = CloseShieldChannel.wrap(channel)) {\n            ClassUtils.getAllInterfaces(FileChannel.class).forEach(iface -> assertInstanceOf(iface, shield));\n            assertFalse(shield instanceof FileChannel, \"not FileChannel\");\n        }\n    }\n}",
      "method_signature": "testWrapFileChannel(java.nio.file.Path)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8889,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 41728,
    "output_tokens": 3538,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 805,
      "description": "Define a test method that validates the behavior of opening an output stream for an existing file within a temporary directory structure. Begin by constructing a File object representing a text file within the temporary directory using a relative filename string. Utilize a test utility to populate this file with a single line of UTF-8 encoded text content. Upon successful file creation, invoke the FileUtils utility's stream opening capability to obtain a FileOutputStream for the existing file, which should verify parent directories and handle file state appropriately. Within the scope of the opened stream, write a single byte value to the stream to confirm write operations succeed. After the stream resource is automatically closed, assert that the file continues to exist in the filesystem by verifying its existence state returns true. The test operates within a fixture that establishes a fresh temporary directory before each test execution and removes test artifacts afterward, ensuring isolation. JUnit 5 and standard assertion libraries are used.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_exists()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenOutputStreamTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests for {@link FileUtils#openOutputStream(File)}.\n */\npublic class FileUtilsOpenOutputStreamTest {\n\n    @TempDir\n    private File temporaryFolder;\n\n    @Test\n    public void testOpenOutputStreamOnExistingFile() throws IOException {\n        // Setup\n        final File file = new File(temporaryFolder, \"test.txt\");\n        FileUtils.writeStringToFile(file, \"Hello, world!\", StandardCharsets.UTF_8);\n\n        // Execute\n        try (FileOutputStream out = FileUtils.openOutputStream(file)) {\n            out.write(0);\n        }\n\n        // Verify\n        assertTrue(file.exists());\n    }\n}",
      "method_signature": "testOpenOutputStream_exists()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8333,
      "callable_precision": 0.8333,
      "focal_recall": 0.5,
      "focal_precision": 0.5
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18358,
    "output_tokens": 3700,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 812,
      "description": "Create a test case to validate that the system can successfully open an output stream to an existing file and write data to it without errors. Begin by establishing a temporary working area, then prepare a new file within that area and populate it with initial content containing a simple text line. Once the file exists, request the system to open an output stream for writing to this same file, which should succeed since the file is already present and accessible. Through the opened stream, write a single byte of data to demonstrate that the file remains writable and the stream functions correctly. After completing the write operation and releasing the stream resources, verify that the file still exists in the system records to confirm the operation preserved the file rather than deleting or corrupting it. Use JUnit 5 as the testing framework and standard equality assertions to validate the file's continued presence in the file system.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_exists()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenOutputStreamTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests for {@link FileUtils#openOutputStream(java.io.File)}.\n */\npublic class FileUtilsOpenOutputStreamTest {\n\n    @Test\n    public void testOpenOutputStreamOnExistingFile(@TempDir final File tempDir) throws IOException {\n        final File testFile = new File(tempDir, \"test.txt\");\n        FileUtils.writeStringToFile(testFile, \"initial content\", StandardCharsets.UTF_8);\n\n        try (final OutputStream out = FileUtils.openOutputStream(testFile)) {\n            out.write(1);\n        }\n\n        assertTrue(testFile.exists(), \"File should still exist after opening an output stream and writing to it.\");\n    }\n\n}",
      "method_signature": "testOpenOutputStream_exists()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8333,
      "callable_precision": 0.8333,
      "focal_recall": 0.5,
      "focal_precision": 0.5
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19328,
    "output_tokens": 4670,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 814,
      "description": "Define a test method that verifies opening an input stream for an existing file, beginning by constructing a `File` instance named `file` using the constructor `new File(tempDirFile, \"test.txt\")` where `tempDirFile` is the inherited temporary directory field. Next, create the file and populate it by invoking a private method that checks if the file's parent directory exists (via `file.getParentFile() != null && !file.getParentFile().exists()`), throwing an `IOException` with message `\"Cannot create file \" + file + \" as the parent directory does not exist\"` if the parent is missing, then opening a try-with-resources block that instantiates a `PrintWriter` wrapping an `OutputStreamWriter` constructed with `Files.newOutputStream(file.toPath())` and `StandardCharsets.UTF_8`, iterating over a String array containing the single element `\"Hello\"`, and for each element invoking `println` on the `PrintWriter` to write the line to the file. Having prepared the file, open a try-with-resources block that declares a `FileInputStream` variable named `in` initialized by invoking `FileUtils.openInputStream(file)`, then immediately within this block invoke `assertEquals` with expected value `'H'` (the character literal) and actual value obtained by calling `in.read()` to verify the first byte read matches the ASCII value of uppercase H. The test method is annotated with `@Test`, the test class is annotated with `@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})`, and uses JUnit 5 Assertions for verification.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenInputStream_exists()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenInputStreamTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileUtils} openInputStream.\n */\n@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})\npublic class FileUtilsOpenInputStreamTest {\n\n    @TempDir\n    private File tempDirFile;\n\n    private void createPopulatedFile(final File file) throws IOException {\n        if (file.getParentFile() != null && !file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final PrintWriter writer = new PrintWriter(new OutputStreamWriter(Files.newOutputStream(file.toPath()), StandardCharsets.UTF_8))) {\n            for (final String line : new String[]{\"Hello\"}) {\n                writer.println(line);\n            }\n        }\n    }\n\n    @Test\n    public void testOpenInputStream() throws IOException {\n        final File file = new File(tempDirFile, \"test.txt\");\n        createPopulatedFile(file);\n        try (final FileInputStream in = FileUtils.openInputStream(file)) {\n            assertEquals('H', in.read());\n        }\n    }\n}",
      "method_signature": "testOpenInputStream_exists()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.6,
      "callable_precision": 0.2143,
      "focal_recall": 0.5,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 27811,
    "output_tokens": 2695,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 815,
      "description": "Define a test method that verifies `FileUtils.openInputStream` throws `IOException` when invoked on a non-existent file path. Begin by constructing a `File` instance named `directory` using the two-argument `File` constructor, passing `tempDirFile` as the parent directory and the String literal `\"test.txt\"` as the child path name. Immediately invoke `assertThrows` with `IOException.class` as the first argument and a lambda expression as the second argument, where the lambda body calls `FileUtils.openInputStream(directory)`. The test class must suppress warnings for `\"deprecation\"` and `\"ResultOfMethodCallIgnored\"` at the class level. The test method must be annotated with `@Test`. Before this test executes, a setup method annotated with `@BeforeEach` (inherited from `AbstractTempDirTest`) invokes `Files.createTempDirectory` with `managedTempDirPath` and the result of `getClass().getSimpleName()` to create `tempDirPath`, then assigns `tempDirPath.toFile()` to `tempDirFile`. Following that, another setup method (defined in the test class itself) constructs `testFile1` as a new `File` with parent `tempDirFile` and name `\"file1-test.txt\"`, constructs `testFile2` as a new `File` with parent `tempDirFile` and name `\"file1a-test.txt\"`, assigns `testFile1.length()` to `testFile1Size`, and assigns `testFile2.length()` to `testFile2Size`. The setup then checks if `testFile1.getParentFile().exists()` returns false and if so calls `fail` with message `\"Cannot create file \" + testFile1 + \" as the parent directory does not exist\"`. Next, open a try-with-resources block declaring `output3` as a new `BufferedOutputStream` wrapping `Files.newOutputStream(testFile1.toPath())`, and within the block invoke a private method that executes a loop from `i = 0` to `i < testFile1Size`, incrementing `i`, and in each iteration calls `output3.write((byte) (i % 127 + 1))`. Repeat the existence check for `testFile2.getParentFile()` with the same fail logic substituting `testFile2`, then open another try-with-resources declaring `output2` wrapping `Files.newOutputStream(testFile2.toPath())` and invoke the same loop-based write logic with `testFile2Size` iterations. After both files are written, invoke `FileUtils.deleteDirectory(tempDirFile)` followed by `tempDirFile.mkdirs()`. Repeat the entire file creation sequence: check `testFile1.getParentFile().exists()`, fail if false, open `output1` wrapping `Files.newOutputStream(testFile1.toPath())`, execute the write loop for `testFile1Size` iterations, check `testFile2.getParentFile().exists()`, fail if false, open `output` wrapping `Files.newOutputStream(testFile2.toPath())`, and execute the write loop for `testFile2Size` iterations. The test uses JUnit 5 assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenInputStream_notExists()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenInputStreamTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.fail;\n\n/**\n * Tests for {@link FileUtils} openInputStream method.\n */\n@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})\npublic class FileUtilsOpenInputStreamTest {\n\n    @TempDir\n    private Path tempDirPath;\n\n    private File tempDirFile;\n    private File testFile1;\n    private File testFile2;\n    private long testFile1Size;\n    private long testFile2Size;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        tempDirFile = tempDirPath.toFile();\n\n        testFile1 = new File(tempDirFile, \"file1-test.txt\");\n        testFile2 = new File(tempDirFile, \"file1a-test.txt\");\n        testFile1Size = testFile1.length();\n        testFile2Size = testFile2.length();\n\n        if (!testFile1.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile1 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output3 = new BufferedOutputStream(Files.newOutputStream(testFile1.toPath()))) {\n            writeBytes(output3, testFile1Size);\n        }\n\n        if (!testFile2.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile2 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output2 = new BufferedOutputStream(Files.newOutputStream(testFile2.toPath()))) {\n            writeBytes(output2, testFile2Size);\n        }\n\n        FileUtils.deleteDirectory(tempDirFile);\n        tempDirFile.mkdirs();\n\n        if (!testFile1.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile1 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output1 = new BufferedOutputStream(Files.newOutputStream(testFile1.toPath()))) {\n            writeBytes(output1, testFile1Size);\n        }\n\n        if (!testFile2.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile2 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(testFile2.toPath()))) {\n            writeBytes(output, testFile2Size);\n        }\n    }\n\n    private void writeBytes(final OutputStream out, final long size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            out.write((byte) (i % 127 + 1));\n        }\n    }\n\n    @Test\n    public void testOpenInputStreamNonExistent() {\n        final File directory = new File(tempDirFile, \"test.txt\");\n        assertThrows(IOException.class, () -> FileUtils.openInputStream(directory));\n    }\n}",
      "method_signature": "testOpenInputStream_notExists()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 24731,
    "output_tokens": 3368,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 818,
      "description": "Create a test case to validate that the file management system correctly handles opening a writable stream to a new file when no parent directory structure exists. Begin by establishing a temporary working area and populating it with initial test files, then clear the entire working area to ensure a clean state before proceeding. Prepare a file reference that intentionally has no parent directory path, confirm that the file reference indeed lacks any parent directory structure, and attempt to open a writable stream to this file without pre-creating it. Once the stream is successfully opened, write a single byte of data to the file and close the stream, then verify that the file now exists on the file system with the written content. After confirming the file's presence, attempt to remove the file from the file system, and if removal fails, schedule it for deletion when the application terminates to ensure proper resource cleanup. Use JUnit 5 as the testing framework, validate outcomes using standard equality and existence assertions, and ensure all file operations execute within the temporary working area to maintain test isolation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_noParentNoFile()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOutputStreamNoParentTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.file.Path;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\n\n/**\n * Tests that the file management system correctly handles opening a writable stream.\n */\npublic class FileUtilsOutputStreamNoParentTest {\n\n    @Test\n    public void testOpenOutputStreamWithNoParent(@TempDir Path tempDir) throws IOException {\n        File workingArea = tempDir.toFile();\n        File initialFile = new File(workingArea, \"initial.txt\");\n        FileUtils.touch(initialFile);\n        FileUtils.cleanDirectory(workingArea);\n\n        File newFile = new File(workingArea, \"new-dir/test.txt\");\n\n        assertFalse(newFile.getParentFile().exists(), \"Parent directory should not exist before opening stream\");\n\n        try (OutputStream os = FileUtils.openOutputStream(newFile)) {\n            os.write(42);\n        }\n\n        assertTrue(newFile.exists(), \"File should exist after writing to stream\");\n        assertEquals(1, newFile.length(), \"File should have content\");\n\n        byte[] writtenData = FileUtils.readFileToByteArray(newFile);\n        assertEquals(1, writtenData.length);\n        assertEquals(42, writtenData[0]);\n\n        if (!FileUtils.deleteQuietly(newFile)) {\n            newFile.deleteOnExit();\n        }\n    }\n}",
      "method_signature": "testOpenOutputStream_noParentNoFile()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.5,
      "assertion_precision": 0.2,
      "callable_recall": 0.6364,
      "callable_precision": 0.3684,
      "focal_recall": 0.5,
      "focal_precision": 0.2
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20508,
    "output_tokens": 5771,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 826,
      "description": "Define a test method that validates the behavior of the File Utilities component when attempting to open an input stream for a directory rather than a regular file. Initialize a File object representing a subdirectory within the temporary directory using the path \"subdir\", then invoke the directory creation operation to establish this directory on the filesystem. Having created the directory structure, invoke the open input stream method on the File Utilities component, passing the directory object as the target for stream creation. Assert that this invocation throws an IOException, confirming that the component correctly rejects attempts to open input streams on directories and enforces the constraint that only regular files are valid targets for this operation. The test validates error handling at the boundary between file types, ensuring the component distinguishes between directories and files when establishing input streams. JUnit 5 is used for test execution and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenInputStream_existsButIsDirectory()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenInputStreamForDirectoryTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests for {@link FileUtils} involving opening input streams.\n */\npublic class FileUtilsOpenInputStreamForDirectoryTest {\n\n    @TempDir\n    public File temporaryFolder;\n\n    @Test\n    public void testOpenInputStreamForDirectory() throws IOException {\n        final File subdir = new File(temporaryFolder, \"subdir\");\n        subdir.mkdirs();\n        assertThrows(IOException.class, () -> FileUtils.openInputStream(subdir));\n    }\n}",
      "method_signature": "testOpenInputStream_existsButIsDirectory()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 0.5,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "search_file_content": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 30122,
    "output_tokens": 3040,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 844,
      "description": "Define a test method that validates the ability to open an output stream for a file that has no parent directory and does not yet exist on the filesystem. Within the test, invoke a private helper method that accepts a boolean parameter indicating whether to create the file beforehand, passing false to ensure the file does not exist prior to the stream operation. Inside this helper, construct a File object with a simple filename that has no parent directory, then verify that the file's parent is null using an assertion. Proceed to invoke the FileUtils utility's openOutputStream method with the file object, which internally checks whether the file is valid, creates any necessary parent directories if they do not exist, and returns a FileOutputStream. Upon successfully obtaining the output stream, write a single byte to the stream to confirm it is functional, then close the stream using a try-with-resources block to ensure proper resource cleanup. After the stream is closed, assert that the file now exists on the filesystem, confirming that the utility method correctly created the file even in the absence of a parent directory. In the finally block, attempt to delete the file and if deletion fails, schedule it for deletion on JVM exit to ensure no test artifacts remain. This test uses JUnit 5 for the test framework and standard JUnit assertions for verification.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_noParentNoFile()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenOutputStreamNoParentTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests the {@link FileUtils#openOutputStream(File)} method for a file with no parent directory.\n */\npublic class FileUtilsOpenOutputStreamNoParentTest {\n\n    /**\n     * Validates that an output stream can be opened for a file that has no parent directory and does not yet exist.\n     * This test invokes a helper method, passing {@code false} to ensure the file does not exist prior to the operation.\n     *\n     * @throws IOException if an I/O error occurs during the test.\n     */\n    @Test\n    public void testOpenOutputStreamForNonExistentFileWithNoParent() throws IOException {\n        // Call the helper with 'false' to ensure the file does not exist beforehand.\n        testOpenOutputStream(false);\n    }\n\n    /**\n     * Private helper to test {@link FileUtils#openOutputStream(File)}.\n     * It handles the file creation, stream operation, and cleanup.\n     *\n     * @param createBefore if {@code true}, the file is created before the stream is opened.\n     * @throws IOException if an I/O error occurs.\n     */\n    private void testOpenOutputStream(final boolean createBefore) throws IOException {\n        // 1. Construct a File object with a simple filename (no parent directory).\n        final File file = new File(\"test-file-no-parent.txt\");\n\n        try {\n            // 2. Verify that the file's parent is null.\n            assertNull(file.getParent(), \"The file's parent directory should be null.\");\n\n            if (createBefore) {\n                // This branch is not executed for the specific test case required.\n                try (final FileOutputStream fos = new FileOutputStream(file)) {\n                    // Just create the file.\n                }\n            }\n\n            // 3. Invoke FileUtils.openOutputStream and write a byte.\n            try (final FileOutputStream out = FileUtils.openOutputStream(file)) {\n                out.write(123); // Write a single byte to confirm the stream is functional.\n            }\n\n            // 4. Assert that the file now exists.\n            assertTrue(file.exists(), \"The file should have been created by openOutputStream.\");\n\n        } finally {\n            // 5. Clean up the created file.\n            if (!file.delete()) {\n                // If deletion fails, schedule it for deletion on JVM exit.\n                file.deleteOnExit();\n            }\n        }\n    }\n}",
      "method_signature": "testOpenOutputStream_noParentNoFile()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.7273,
      "callable_precision": 0.7273,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 19798,
    "output_tokens": 4966,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 845,
      "description": "Define a test method that verifies the behavior of deleting a symbolic link without affecting its target directory by first invoking a private helper method that creates a temporary symbolic link structure, then asserting the existence and symbolic link status of both the link and target, invoking `FileUtils.forceDelete` on the symbolic link converted to a `File`, and finally asserting that the symbolic link is removed while the target directory remains intact. Begin by defining a private helper method that accepts no arguments and returns an `ImmutablePair<Path, Path>`, where the method body invokes `resolve` on the field `tempDirPath` with argument `\"subdir\"` and assigns the result to local variable `targetDir` of type `Path`, then invokes `resolve` on `tempDirPath` with argument `\"symlinked-dir\"` and assigns the result to local variable `symLinkedDir` of type `Path`, followed by invoking `Files.createDirectory` with argument `targetDir`, then invoking `Files.createSymbolicLink` with arguments `symLinkedDir` and `targetDir`, and finally returning the result of invoking `ImmutablePair.of` with arguments `symLinkedDir` and `targetDir`. In the test method, invoke this helper method and assign the returned `ImmutablePair<Path, Path>` to local variable `pair`, then invoke `getLeft()` on `pair` and assign the result to local variable `symlinkedDir` of type `Path`, and invoke `getRight()` on `pair` and assign the result to local variable `targetDir` of type `Path`. Immediately assert that `Files.exists(symlinkedDir)` returns `true` using `assertTrue`, then assert that `Files.isSymbolicLink(symlinkedDir)` returns `true` using `assertTrue`, and assert that `Files.exists(targetDir)` returns `true` using `assertTrue`. Next, invoke `FileUtils.forceDelete` with the argument obtained by calling `toFile()` on `symlinkedDir`. After deletion, assert that `Files.exists(symlinkedDir)` returns `false` using `assertFalse`, assert that `Files.isSymbolicLink(symlinkedDir)` returns `false` using `assertFalse`, and assert that `Files.exists(targetDir)` returns `true` using `assertTrue` to verify the target directory was not deleted. The test method is annotated with `@Test` and declares `throws Exception`. The test class is annotated with `@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})`. The test relies on a `@BeforeEach` setup method inherited from `AbstractTempDirTest` that creates `tempDirPath` by invoking `Files.createTempDirectory` with arguments `managedTempDirPath` and the result of `getClass().getSimpleName()`, then assigns `tempDirPath.toFile()` to `tempDirFile`, followed by a test-specific `@BeforeEach` method that initializes `testFile1` as a new `File` with parent `tempDirFile` and name `\"file1-test.txt\"`, initializes `testFile2` as a new `File` with parent `tempDirFile` and name `\"file1a-test.txt\"`, assigns `testFile1.length()` to `testFile1Size`, assigns `testFile2.length()` to `testFile2Size`, verifies parent directory existence for `testFile1` by checking `testFile1.getParentFile().exists()` and invoking `fail` with a descriptive message if false, creates a `BufferedOutputStream` wrapping `Files.newOutputStream(testFile1.toPath())` assigned to `output3`, invokes a helper method that writes test data by iterating from `0` to `testFile1Size` exclusive and calling `output3.write((byte)(i % 127 + 1))` for each iteration, repeats the parent directory check and data generation for `testFile2` using a `BufferedOutputStream` assigned to `output2`, then invokes `FileUtils.deleteDirectory(tempDirFile)` followed by `tempDirFile.mkdirs()`, and repeats the file creation and data generation steps for both `testFile1` (using `output1`) and `testFile2` (using `output`) to ensure a clean test environment. The test uses JUnit 5 assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testForceDeleteSymlink()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsDeleteSymbolicLinkTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.apache.commons.lang3.tuple.ImmutablePair;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})\npublic class FileUtilsDeleteSymbolicLinkTest {\n\n    @TempDir\n    private Path managedTempDirPath;\n    \n    private Path tempDirPath;\n    private File tempDirFile;\n    private File testFile1;\n    private File testFile2;\n    private long testFile1Size;\n    private long testFile2Size;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        tempDirPath = Files.createTempDirectory(managedTempDirPath, getClass().getSimpleName());\n        tempDirFile = tempDirPath.toFile();\n\n        testFile1 = new File(tempDirFile, \"file1-test.txt\");\n        testFile2 = new File(tempDirFile, \"file1a-test.txt\");\n        \n        testFile1Size = 16;\n        testFile2Size = 32;\n\n        if (!testFile1.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile1 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output3 = new BufferedOutputStream(Files.newOutputStream(testFile1.toPath()))) {\n            generateTestData(output3, testFile1Size);\n        }\n\n        if (!testFile2.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile2 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output2 = new BufferedOutputStream(Files.newOutputStream(testFile2.toPath()))) {\n            generateTestData(output2, testFile2Size);\n        }\n\n        FileUtils.deleteDirectory(tempDirFile);\n        tempDirFile.mkdirs();\n\n        try (BufferedOutputStream output1 = new BufferedOutputStream(Files.newOutputStream(testFile1.toPath()))) {\n            generateTestData(output1, testFile1Size);\n        }\n\n        try (BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(testFile2.toPath()))) {\n            generateTestData(output, testFile2Size);\n        }\n    }\n\n    private void generateTestData(final BufferedOutputStream out, final long size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            out.write((byte) (i % 127 + 1));\n        }\n    }\n\n    private ImmutablePair<Path, Path> createSymlinkedDir() throws IOException {\n        final Path targetDir = tempDirPath.resolve(\"subdir\");\n        final Path symLinkedDir = tempDirPath.resolve(\"symlinked-dir\");\n        Files.createDirectory(targetDir);\n        Files.createSymbolicLink(symLinkedDir, targetDir);\n        return ImmutablePair.of(symLinkedDir, targetDir);\n    }\n\n    @Test\n    public void testForceDeleteSymbolicLink() throws Exception {\n        final ImmutablePair<Path, Path> pair = createSymlinkedDir();\n        final Path symlinkedDir = pair.getLeft();\n        final Path targetDir = pair.getRight();\n\n        assertTrue(Files.exists(symlinkedDir));\n        assertTrue(Files.isSymbolicLink(symlinkedDir));\n        assertTrue(Files.exists(targetDir));\n\n        FileUtils.forceDelete(symlinkedDir.toFile());\n\n        assertFalse(Files.exists(symlinkedDir));\n        assertFalse(Files.isSymbolicLink(symlinkedDir));\n        assertTrue(Files.exists(targetDir));\n    }\n}",
      "method_signature": "testForceDeleteSymlink()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.9545,
      "callable_precision": 0.9545,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 42933,
    "output_tokens": 9527,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 849,
      "description": "Define a test method that verifies the behavior of `FileUtils.openOutputStream` when invoked on an existing file, ensuring the file remains present after writing data to the output stream. Begin by constructing a `File` object named `file` using the constructor `new File(tempDirFile, \"test.txt\")`, where `tempDirFile` is a field initialized by the setup method `beforeEachCreateTempDirs()` which creates a temporary directory path by calling `Files.createTempDirectory(managedTempDirPath, getClass().getSimpleName())` and assigns it to `tempDirPath`, then converts it to a `File` via `tempDirPath.toFile()` and assigns to `tempDirFile`. Following this, the setup method `setUp()` initializes `testFile1` as `new File(tempDirFile, \"file1-test.txt\")` and `testFile2` as `new File(tempDirFile, \"file1a-test.txt\")`, captures their lengths via `testFile1.length()` into `testFile1Size` and `testFile2.length()` into `testFile2Size`, verifies parent directories exist by checking `testFile1.getParentFile().exists()` and invoking `fail(\"Cannot create file \" + testFile1 + \" as the parent directory does not exist\")` if false, then creates a `BufferedOutputStream` wrapping `Files.newOutputStream(testFile1.toPath())` assigned to `output3`, writes test data by iterating from `i = 0` to `i < testFile1Size` and calling `output3.write((byte) (i % 127 + 1))` for each iteration, closes the stream, repeats the same verification and write process for `testFile2` using `output2`, then invokes `FileUtils.deleteDirectory(tempDirFile)` followed by `tempDirFile.mkdirs()`, and recreates both test files by repeating the parent directory existence checks, creating `BufferedOutputStream` instances `output1` and `output` wrapping `Files.newOutputStream(testFile1.toPath())` and `Files.newOutputStream(testFile2.toPath())` respectively, and writing test data via the same loop pattern for each file. After setup completes, the test method creates the target file by first checking if `file.getParentFile()` is not null and does not exist, throwing `new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\")` if true, then opening a try-with-resources block that constructs a `PrintWriter` wrapping an `OutputStreamWriter` constructed with `Files.newOutputStream(file.toPath())` and `StandardCharsets.UTF_8`, iterates over a `String[]` array containing the single element `\"Hello\"`, and for each element invokes `output.println(element)` on the `PrintWriter`. Upon completion of file creation, invoke `FileUtils.openOutputStream(file)` and assign the returned `FileOutputStream` to variable `out` within a try-with-resources block, then immediately call `out.write(0)` to write a single byte with value `0` to the stream. After the try-with-resources block closes the stream, assert that the file exists by invoking `assertTrue(file.exists())`. The test uses JUnit 5 assertions via `assertTrue` and `fail`, operates with the `@Test` annotation, and the test class is annotated with `@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_exists()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenOutputStreamTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\n/**\n * Tests {@link FileUtils} {@code openOutputStream} method.\n */\n@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})\npublic class FileUtilsOpenOutputStreamTest {\n\n    private Path tempDirPath;\n    private File tempDirFile;\n    private File testFile1;\n    private File testFile2;\n    private long testFile1Size;\n    private long testFile2Size;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        // From \"beforeEachCreateTempDirs()\"\n        tempDirPath = Files.createTempDirectory(getClass().getSimpleName());\n        tempDirFile = tempDirPath.toFile();\n\n        // From \"setUp()\"\n        testFile1 = new File(tempDirFile, \"file1-test.txt\");\n        testFile2 = new File(tempDirFile, \"file1a-test.txt\");\n\n        // The prompt describes capturing length from a non-existent file.\n        // Initialize sizes to a constant value instead.\n        testFile1Size = 1024;\n        testFile2Size = 1024;\n\n        if (testFile1.getParentFile() == null || !testFile1.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile1 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output3 = new BufferedOutputStream(Files.newOutputStream(testFile1.toPath()))) {\n            for (int i = 0; i < testFile1Size; i++) {\n                output3.write((byte) (i % 127 + 1));\n            }\n        }\n\n        if (testFile2.getParentFile() == null || !testFile2.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile2 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output2 = new BufferedOutputStream(Files.newOutputStream(testFile2.toPath()))) {\n            for (int i = 0; i < testFile2Size; i++) {\n                output2.write((byte) (i % 127 + 1));\n            }\n        }\n\n        FileUtils.deleteDirectory(tempDirFile);\n        tempDirFile.mkdirs();\n\n        if (testFile1.getParentFile() == null || !testFile1.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile1 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output1 = new BufferedOutputStream(Files.newOutputStream(testFile1.toPath()))) {\n            for (int i = 0; i < testFile1Size; i++) {\n                output1.write((byte) (i % 127 + 1));\n            }\n        }\n\n        if (testFile2.getParentFile() == null || !testFile2.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile2 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(testFile2.toPath()))) {\n            for (int i = 0; i < testFile2Size; i++) {\n                output.write((byte) (i % 127 + 1));\n            }\n        }\n    }\n\n    @Test\n    public void testOpenOutputStreamExistingFile() throws IOException {\n        final File file = new File(tempDirFile, \"test.txt\");\n\n        if (file.getParentFile() != null && !file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final PrintWriter output = new PrintWriter(\n                new OutputStreamWriter(Files.newOutputStream(file.toPath()), StandardCharsets.UTF_8))) {\n            final String[] data = {\"Hello\"};\n            for (final String element : data) {\n                output.println(element);\n            }\n        }\n\n        try (final FileOutputStream out = FileUtils.openOutputStream(file)) {\n            out.write(0);\n        }\n\n        assertTrue(file.exists());\n    }\n}",
      "method_signature": "testOpenOutputStream_exists()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.25,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8333,
      "callable_precision": 0.3571,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23584,
    "output_tokens": 7903,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 853,
      "description": "Define a test method that invokes a private helper method `openOutputStream_noParent` with the boolean argument `false`, where the helper method executes the following logic: instantiate a `File` object named `file` using the constructor `new File(\"test.txt\")`, then invoke `getParentFile()` on `file` and pass the result to `assertNull` to verify the parent is null. Enter a try block where you check if the boolean parameter `createFile` is true (in this case it is false, so skip the conditional block that would invoke `TestUtils.createLineFileUtf8`). Within a try-with-resources statement, invoke `FileUtils.openOutputStream(file)` and assign the returned `FileOutputStream` to variable `out`, then immediately call `write(0)` on `out` to write a single byte. After the try-with-resources block closes the stream, invoke `exists()` on `file` and pass the result to `assertTrue` to verify the file was created. In the finally block, invoke `delete()` on `file`; if the deletion returns false (indicating failure), invoke `deleteOnExit()` on `file` as a fallback cleanup mechanism. The test uses JUnit 5 assertions (`assertNull`, `assertTrue`) and relies on the `FileUtils.openOutputStream` method to create parent directories if needed and open the output stream, demonstrating that a file with no parent directory can be successfully created and written to.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_noParentNoFile()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOutputStreamTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link FileUtils} involving output stream operations.\n * This class is designed to test a specific scenario for {@link FileUtils#openOutputStream(File)}.\n */\npublic class FileUtilsOutputStreamTest {\n\n    /**\n     * Tests {@link FileUtils#openOutputStream(File)} by invoking a helper method with a file that has no parent directory.\n     *\n     * @throws IOException if an I/O error occurs.\n     */\n    @Test\n    public void testOpenOutputStreamWithNoParent() throws IOException {\n        openOutputStream_noParent(false);\n    }\n\n    /**\n     * Private helper to test {@link FileUtils#openOutputStream(File)}. It checks if a file\n     * can be created and written to when it has no parent directory.\n     * <p>\n     * The logic of this method is derived from the test description.\n     * </p>\n     *\n     * @param createFile if true, the file is created before opening the stream.\n     * @throws IOException if an I/O error occurs during file operations.\n     */\n    private void openOutputStream_noParent(final boolean createFile) throws IOException {\n        final File file = new File(\"test.txt\");\n        assertNull(file.getParentFile());\n\n        try {\n            if (createFile) {\n                // This branch is not taken in this test, as specified by the test description.\n                // The original implementation might have used a utility like:\n                // org.apache.commons.io.test.TestUtils.createLineFileUtf8(file, 1);\n            }\n\n            try (final FileOutputStream out = FileUtils.openOutputStream(file)) {\n                out.write(0);\n            }\n\n            assertTrue(file.exists());\n        } finally {\n            if (!file.delete()) {\n                file.deleteOnExit();\n            }\n        }\n    }\n}",
      "method_signature": "testOpenOutputStream_noParentNoFile()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.9091,
      "callable_precision": 1.0,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 33373,
    "output_tokens": 5513,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 854,
      "description": "Create a test case to validate that the system can successfully open a data output channel for a file that has no parent directory structure. Begin by establishing a file reference in the current working location without any parent folder hierarchy and confirm that the file's parent directory is indeed absent. Prepare the file by writing initial content to it so that it exists on disk before proceeding. Once the file is in place, attempt to open an output channel to the file and write a single byte of data to verify the channel is operational. After confirming the write operation succeeds, verify that the file exists in the file system as expected. Following the validation, remove the file from the system to clean up the test environment, and if the removal fails, schedule the file for deletion when the application terminates to ensure no residual test artifacts remain. Use JUnit 5 as the testing framework and verify outcomes using standard equality assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_noParentCreateFile()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.RandomAccessFilesTest1",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link RandomAccessFiles}.\n */\npublic class RandomAccessFilesTest1 {\n\n    @Test\n    public void testOpenChannelNoParent() throws IOException {\n        final File file = new File(\"testOpenChannelNoParent.txt\");\n        try {\n            // \"establish a file reference ... without any parent folder\"\n            // \"confirm that the file's parent directory is indeed absent\"\n            assertNull(file.getParentFile());\n\n            // \"Prepare the file by writing initial content to it\"\n            FileUtils.writeStringToFile(file, \"Initial\", Charsets.UTF_8);\n\n            // \"attempt to open an output channel to the file\"\n            try (final SeekableByteChannel channel = RandomAccessFiles.newChannel(file, RandomAccessFileMode.READ_WRITE)) {\n                // \"write a single byte of data to verify the channel is operational\"\n                final ByteBuffer buffer = ByteBuffer.wrap(new byte[] { 'X' });\n                assertEquals(1, channel.write(buffer));\n            }\n\n            // \"verify that the file exists in the file system as expected\"\n            assertTrue(file.exists());\n\n        } finally {\n            // \"remove the file ... if the removal fails, schedule the file for deletion\"\n            if (!FileUtils.deleteQuietly(file)) {\n                file.deleteOnExit();\n            }\n        }\n    }\n}",
      "method_signature": "testOpenOutputStream_noParentCreateFile()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20785,
    "output_tokens": 6066,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 860,
      "description": "Define a test method that validates the File Utilities component's capability to open an input stream for an existing file. Before each test execution, inherit setup logic that creates a temporary directory path and converts it to a File object, then initialize two test file objects within this temporary directory with specific file names and record their initial sizes, generate test data for both files using a utility that writes byte patterns to output streams, delete the entire temporary directory structure, recreate the directory hierarchy, and regenerate the test data for both files to ensure a clean state. Within the test method itself, construct a File object representing a text file within the temporary directory, then invoke a utility method that writes a single-line string array containing \"Hello\" to this file using UTF-8 encoding, creating the file with the specified content. Upon file creation, invoke the File Utilities component's openInputStream method passing the file object to obtain a FileInputStream, then immediately read the first byte from the stream and assert that it equals the character 'H' to verify the stream correctly accesses the file's content, ensuring the stream is automatically closed via try-with-resources to release file system resources. The test validates that the File Utilities component successfully opens an input stream for an existing file and that the stream provides access to the file's byte content in the expected order. JUnit 5 is used for test execution and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenInputStream_exists()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenInputStreamTest",
      "code": "package org.apache.commons.io;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.util.Collections;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileUtils#openInputStream(File)}.\n */\npublic class FileUtilsOpenInputStreamTest {\n\n    @TempDir\n    private Path tempPath;\n\n    private File temporaryFolder;\n    private File testFile1;\n    private File testFile2;\n    private long testFile1Size;\n    private long testFile2Size;\n\n    private void generateTestData(final File file, final long size) throws IOException {\n        try (final OutputStream out = FileUtils.newOutputStream(file)) {\n            final byte[] data = new byte[(int) size];\n            for (int i = 0; i < size; i++) {\n                data[i] = (byte) i;\n            }\n            out.write(data);\n        }\n    }\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        temporaryFolder = tempPath.toFile();\n        testFile1 = new File(temporaryFolder, \"file1-test.txt\");\n        testFile2 = new File(temporaryFolder, \"file2-test.txt\");\n\n        generateTestData(testFile1, 16);\n        testFile1Size = testFile1.length();\n        generateTestData(testFile2, 32);\n        testFile2Size = testFile2.length();\n\n        FileUtils.deleteDirectory(temporaryFolder);\n        if (!temporaryFolder.mkdirs()) {\n            throw new IOException(\"Could not create temporary directory: \" + temporaryFolder);\n        }\n\n        generateTestData(testFile1, 16);\n        generateTestData(testFile2, 32);\n    }\n\n    @Test\n    public void testOpenInputStream() throws IOException {\n        final File file = new File(temporaryFolder, \"test.txt\");\n        FileUtils.writeLines(file, Collections.singletonList(\"Hello\"), StandardCharsets.UTF_8);\n\n        try (final FileInputStream fis = FileUtils.openInputStream(file)) {\n            Assertions.assertEquals('H', fis.read());\n        }\n    }\n}",
      "method_signature": "testOpenInputStream_exists()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 29478,
    "output_tokens": 7175,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 861,
      "description": "Create a test case to validate that the system properly rejects attempts to open a file stream when the target location exists but represents a directory rather than a regular file. Begin by establishing a clean working area within the system's temporary storage space, then set up two sample files with predetermined content for potential future operations. Once the environment is prepared, define a new location within the working area designated as a subdirectory and ensure the system creates this directory structure. With the directory in place, attempt to open an input stream from this directory location as if it were a regular file, which should trigger a failure since directories cannot be read as file streams. Verify that the system responds with an appropriate error indicating the operation cannot proceed due to the target being a directory, thereby confirming the system correctly distinguishes between file and directory types when opening input streams and prevents misuse of directory paths in file reading operations. Use JUnit 5 as the testing framework with standard assertion capabilities to validate the expected failure condition.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenInputStream_existsButIsDirectory()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenInputStreamOnDirectoryTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests that opening an input stream on a directory fails as expected.\n */\npublic class FileUtilsOpenInputStreamOnDirectoryTest {\n\n    /**\n     * Tests that attempting to open an input stream on a directory throws an {@link IOException},\n     * confirming that the system correctly distinguishes between files and directories.\n     */\n    @Test\n    public void testOpenInputStreamOnDirectory(@TempDir File tempDir) throws IOException {\n        // Establish a clean working area and set up sample files\n        File sampleFile1 = new File(tempDir, \"sample1.txt\");\n        FileUtils.writeStringToFile(sampleFile1, \"Test content 1\", StandardCharsets.UTF_8);\n\n        File sampleFile2 = new File(tempDir, \"sample2.txt\");\n        FileUtils.writeStringToFile(sampleFile2, \"Test content 2\", StandardCharsets.UTF_8);\n\n        // Create a subdirectory within the working area\n        File subDirectory = new File(tempDir, \"test-subdirectory\");\n        assertTrue(subDirectory.mkdir());\n\n        // Attempt to open an input stream on the directory and verify the expected exception\n        final IOException thrown = assertThrows(IOException.class, () -> {\n            FileUtils.openInputStream(subDirectory);\n        });\n\n        // Verify that the exception message clearly indicates that the target is a directory\n        assertEquals(\"File '\" + subDirectory + \"' exists but is a directory\", thrown.getMessage());\n    }\n}",
      "method_signature": "testOpenInputStream_existsButIsDirectory()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.3333,
      "callable_recall": 0.6667,
      "callable_precision": 0.1818,
      "focal_recall": 0.5,
      "focal_precision": 0.5
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 21230,
    "output_tokens": 6600,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 867,
      "description": "Define a test method that validates the File Utilities component's ability to open an output stream for a file that has no parent directory, specifically when the file is created before opening the stream. Initialize a File object representing a file named \"test.txt\" in the current working directory, then verify that the file's parent directory reference is null to confirm the absence of a parent path. Within a try-finally block to ensure cleanup, create a private helper method that writes predefined line content to the file using UTF-8 encoding, establishing the file on disk with initial data. After the file exists, invoke the File Utilities component's stream-opening capability to obtain a FileOutputStream for the file, write a single byte to the stream to confirm write access, then close the stream. Upon closing the stream, assert that the file exists on the filesystem to verify successful creation and persistence. In the finally block, attempt to delete the file and, if deletion fails, register the file for deletion upon virtual machine exit to prevent resource leakage. The test executes within a temporary directory environment established by inherited setup methods that create a managed temporary directory path and convert it to a File object, and a test-specific setup method that initializes two test files with generated binary data of predetermined sizes, deletes the temporary directory, recreates it, and repopulates the test files with fresh data streams. This test uses JUnit 5 for test execution and standard Java assertions for validation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_noParentCreateFile()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenOutputStreamNoParentTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test cases for the {@link FileUtils#openOutputStream(File, boolean)} method.\n * Specifically focuses on handling files without a parent directory.\n */\npublic class FileUtilsOpenOutputStreamNoParentTest {\n\n    /**\n     * Writes predefined line content to the specified file using UTF-8 encoding.\n     * This helper method is used to establish a file on disk with initial data.\n     *\n     * @param file The file to which the content will be written.\n     * @throws IOException If an I/O error occurs during the write operation.\n     */\n    private void writeInitialContent(final File file) throws IOException {\n        final List<String> lines = Collections.singletonList(\"test content\");\n        FileUtils.writeLines(file, StandardCharsets.UTF_8.name(), lines);\n    }\n\n    /**\n     * Validates that {@link FileUtils#openOutputStream(File, boolean)} can successfully\n     * open a stream for a file that has no parent directory, after the file has\n     * already been created.\n     *\n     * @throws IOException If an I/O error occurs during the test.\n     */\n    @Test\n    public void testOpenOutputStreamForFileWithNoParent() throws IOException {\n        final File file = new File(\"test.txt\");\n\n        try {\n            // Verify that the file's parent directory reference is null.\n            assertNull(file.getParentFile(), \"The file's parent directory should be null.\");\n\n            // Create the file with some initial data.\n            writeInitialContent(file);\n\n            // Open an output stream to the file, write a byte, and close it.\n            try (final FileOutputStream stream = FileUtils.openOutputStream(file)) {\n                stream.write(1);\n            }\n\n            // Assert that the file exists after the stream operations.\n            assertTrue(file.exists(), \"File should exist after stream operations.\");\n\n        } finally {\n            // Ensure the file is cleaned up after the test.\n            if (!FileUtils.deleteQuietly(file)) {\n                file.deleteOnExit();\n            }\n        }\n    }\n}",
      "method_signature": "testOpenOutputStream_noParentCreateFile()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.7273,
      "callable_precision": 0.6154,
      "focal_recall": 0.5,
      "focal_precision": 0.3333
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 15571,
    "output_tokens": 7583,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 870,
      "description": "Create a test case to validate the system's ability to remove a broken symbolic link where the original target no longer exists. Begin by establishing a scenario where a symbolic link points to a directory location within the working area, then manually remove the actual target directory to simulate a broken link condition. Confirm the system recognizes the link no longer resolves to a valid location yet still identifies it as a symbolic link structure. Instruct the system to forcefully delete the broken symbolic link, then verify the link itself has been completely removed from the file system and no longer appears as either a valid path or a symbolic link reference. Use JUnit 5 as the testing framework with standard equality and boolean assertions to confirm the link's state before and after the deletion operation, ensuring the system correctly handles the removal of orphaned symbolic links without errors.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testForceDeleteBrokenSymlink()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileDeleteStrategyForceBrokenLinkTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Tests the {@link FileDeleteStrategy#FORCE} delete strategy for broken symbolic links.\n */\npublic class FileDeleteStrategyForceBrokenLinkTest {\n\n    @TempDir\n    private Path workingDir;\n\n    @Test\n    public void testForceDeleteBrokenSymbolicLink() throws IOException {\n        final Path targetDir = Files.createDirectory(workingDir.resolve(\"target\"));\n        final Path symbolicLink = Files.createSymbolicLink(workingDir.resolve(\"link\"), targetDir);\n\n        assertTrue(Files.exists(symbolicLink), \"Symbolic link should exist before target deletion.\");\n        assertTrue(Files.isSymbolicLink(symbolicLink), \"Path should be a symbolic link.\");\n\n        // Break the link by deleting the target\n        Files.delete(targetDir);\n\n        assertFalse(Files.exists(symbolicLink), \"Symbolic link should not exist after target deletion.\");\n        assertTrue(Files.isSymbolicLink(symbolicLink), \"Path should still be identified as a symbolic link structure.\");\n\n        // Use the force strategy to delete the broken link\n        FileDeleteStrategy.FORCE.delete(symbolicLink.toFile());\n\n        assertFalse(Files.exists(symbolicLink), \"Broken symbolic link should have been deleted.\");\n        assertFalse(Files.isSymbolicLink(symbolicLink), \"Path should no longer be a symbolic link.\");\n    }\n}",
      "method_signature": "testForceDeleteBrokenSymlink()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.6667,
      "callable_recall": 0.7368,
      "callable_precision": 0.7368,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 17497,
    "output_tokens": 2855,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 873,
      "description": "Create a test case to validate that the system properly rejects attempts to create an output stream for a file when the necessary parent directory structure cannot be established due to file system constraints. Establish a scenario where a temporary working area exists, then construct a file path that includes an excessively long directory name (approximately 300 characters, deliberately exceeding typical file system naming limits) nested within a subdirectory structure, followed by a target filename. Attempt to open an output stream for this file location, expecting the system to recognize the impossibility of creating the required parent directories and reject the operation with an appropriate error indicating the file structure cannot be created. Verify the system enforces file system constraints and prevents operations that would violate naming or path length restrictions using standard equality assertions with JUnit 5 and AssertJ.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_notExistsCannotCreate()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenOutputStreamTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.util.Collections;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests for {@link FileUtils} involving opening output streams where parent\n * directories cannot be created.\n */\npublic class FileUtilsOpenOutputStreamTest {\n\n    @TempDir\n    private Path tempDir;\n\n    @Test\n    public void testOpenOutputStreamWithUncreatableParentDirectory() {\n        // Create a subdirectory in the temporary directory\n        final File parentDir = new File(tempDir.toFile(), \"sub\");\n\n        // Create a directory name that is excessively long to violate file system constraints\n        final String longDirName = String.join(\"\", Collections.nCopies(300, \"a\"));\n        final File targetFile = new File(new File(parentDir, longDirName), \"target.txt\");\n\n        // Attempt to open an output stream, which should fail because the parent directory cannot be created.\n        final IOException e = assertThrows(IOException.class, () -> FileUtils.openOutputStream(targetFile));\n\n        // Verify that the exception message indicates that the directory creation failed.\n        assertThat(e.getMessage()).contains(\"Cannot create directory\");\n    }\n}",
      "method_signature": "testOpenOutputStream_notExistsCannotCreate()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 17525,
    "output_tokens": 2919,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 879,
      "description": "Define a test method that verifies `FileUtils.openInputStream` throws `IOException` when invoked on a directory rather than a regular file, beginning by constructing a `File` object named `directory` using the two-argument constructor with `tempDirFile` as the parent and the String literal `\"subdir\"` as the child path, then immediately invoke `mkdirs()` on `directory` to create the directory structure, and finally assert that invoking `FileUtils.openInputStream(directory)` throws `IOException` using `assertThrows(IOException.class, () -> FileUtils.openInputStream(directory))` where the lambda expression captures the method call that is expected to fail. The test relies on a setup method annotated with `@BeforeEach` that first invokes `beforeEachCreateTempDirs()` (inherited from `AbstractTempDirTest`) which creates `tempDirPath` by calling `Files.createTempDirectory(managedTempDirPath, getClass().getSimpleName())` and assigns `tempDirFile` via `tempDirPath.toFile()`, then executes the `setUp()` method which constructs `testFile1` as `new File(tempDirFile, \"file1-test.txt\")` and `testFile2` as `new File(tempDirFile, \"file1a-test.txt\")`, assigns `testFile1Size` from `testFile1.length()` and `testFile2Size` from `testFile2.length()`, verifies parent existence with `fail(\"Cannot create file \" + testFile1 + \" as the parent directory does not exist\")` if `testFile1.getParentFile().exists()` returns false, opens a `BufferedOutputStream` wrapping `Files.newOutputStream(testFile1.toPath())` assigned to `output3` in a try-with-resources block and invokes a private method that executes a loop from `int i = 0` to `i < testFile1Size` incrementing `i`, writing `(byte) (i % 127 + 1)` to `output3` on each iteration to generate test data, repeats the parent check and data generation for `testFile2` using `output2` and `testFile2Size`, invokes `FileUtils.deleteDirectory(tempDirFile)` followed by `tempDirFile.mkdirs()` to reset the directory, then recreates `testFile1` by verifying parent existence and opening `output1` in a try-with-resources block to write test data via the same loop logic with `testFile1Size`, and finally recreates `testFile2` by verifying parent existence and opening `output` in a try-with-resources block to write test data via the same loop logic with `testFile2Size`. The test method is annotated with `@Test`, the test class is annotated with `@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})`, and uses JUnit 5 Assertions for `assertThrows` and `fail`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenInputStream_existsButIsDirectory()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenInputStreamTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport org.apache.commons.io.test.AbstractTempDirTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link FileUtils} openInputStream.\n */\n@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})\npublic class FileUtilsOpenInputStreamTest extends AbstractTempDirTest {\n\n    private File testFile1;\n    private File testFile2;\n    private long testFile1Size;\n    private long testFile2Size;\n\n    private void generateTestData(final BufferedOutputStream output, final long size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            output.write((byte) (i % 127 + 1));\n        }\n    }\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        beforeEachCreateTempDirs();\n        \n        testFile1 = new File(getTempDirFile(), \"file1-test.txt\");\n        testFile2 = new File(getTempDirFile(), \"file1a-test.txt\");\n        \n        // Use a fixed size as length() on a non-existent file is not possible\n        testFile1Size = 128;\n        testFile2Size = 128;\n\n        if (!testFile1.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile1 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output3 = new BufferedOutputStream(Files.newOutputStream(testFile1.toPath()))) {\n            generateTestData(output3, testFile1Size);\n        }\n\n        if (!testFile2.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile2 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output2 = new BufferedOutputStream(Files.newOutputStream(testFile2.toPath()))) {\n            generateTestData(output2, testFile2Size);\n        }\n\n        FileUtils.deleteDirectory(getTempDirFile());\n        getTempDirFile().mkdirs();\n\n        if (!testFile1.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile1 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output1 = new BufferedOutputStream(Files.newOutputStream(testFile1.toPath()))) {\n            generateTestData(output1, testFile1Size);\n        }\n\n        if (!testFile2.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile2 + \" as the parent directory does not exist\");\n        }\n        try (BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(testFile2.toPath()))) {\n            generateTestData(output, testFile2Size);\n        }\n    }\n\n    @Test\n    public void testOpenInputStreamOnDirectory() {\n        final File directory = new File(getTempDirFile(), \"subdir\");\n        directory.mkdirs();\n        assertThrows(IOException.class, () -> FileUtils.openInputStream(directory));\n    }\n}",
      "method_signature": "testOpenInputStream_existsButIsDirectory()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7767,
    "output_tokens": 5596,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 880,
      "description": "Define a test method that invokes a private helper method `openOutputStream_noParent` with the boolean argument `true`, where the helper logic must be fully unwrapped and reimplemented as follows: Begin by instantiating a `File` object named `file` using the constructor `new File(\"test.txt\")`, then immediately assert that `file.getParentFile()` returns `null` using `assertNull`. Enter a try block where you first check the boolean parameter: since it is `true`, invoke a private method that creates a line-based UTF-8 file by calling `Files.newOutputStream(file.toPath())`, wrapping it in a `BufferedOutputStream`, then writing the single line `\"Hello\"` to it (this replicates the behavior of `TestUtils.createLineFileUtf8` which writes lines to a file). After file creation, invoke `FileUtils.openOutputStream(file)` and assign the returned `FileOutputStream` to a variable named `out` within a try-with-resources block, then call `out.write(0)` to write a single byte with value `0`. Upon exiting the try-with-resources block (which closes `out`), assert that `file.exists()` returns `true` using `assertTrue`. In the finally block, attempt to delete the file by calling `file.delete()`, and if the deletion returns `false`, invoke `file.deleteOnExit()` to schedule deletion on JVM exit. The test class must suppress deprecation warnings and result-of-method-call-ignored warnings using `@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})` at the class level, the test method must be annotated with `@Test`, and the test relies on JUnit 5 assertions (`assertNull`, `assertTrue`) with no mocking libraries present.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_noParentCreateFile()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenOutputStreamNoParentTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link FileUtils} openOutputStream.\n */\n@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})\npublic class FileUtilsOpenOutputStreamNoParentTest {\n\n    @Test\n    public void testOpenOutputStream_noParent() throws IOException {\n        final File file = new File(\"test.txt\");\n        assertNull(file.getParentFile());\n        try {\n            // Create the file.\n            try (final OutputStream out = new BufferedOutputStream(Files.newOutputStream(file.toPath()))) {\n                out.write(\"Hello\".getBytes(StandardCharsets.UTF_8));\n            }\n\n            // Open the stream.\n            try (final FileOutputStream out = FileUtils.openOutputStream(file)) {\n                out.write(0);\n            }\n            assertTrue(file.exists());\n        } finally {\n            if (!file.delete()) {\n                file.deleteOnExit();\n            }\n        }\n    }\n\n}",
      "method_signature": "testOpenOutputStream_noParentCreateFile()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8182,
      "callable_precision": 0.6429,
      "focal_recall": 0.5,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 27501,
    "output_tokens": 2482,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 882,
      "description": "Create a test case to validate the system's ability to open a file for writing when that file does not yet exist, ensuring the system automatically establishes any necessary parent directory structure and successfully creates the file. Begin by defining a target file location within a temporary workspace that includes a subdirectory path which does not currently exist in the system. Attempt to open an output channel to this file and write a single byte of data to confirm the channel is operational. After completing the write operation, verify that the file now exists in the system at the specified location, confirming that the system correctly created both the missing parent directory and the file itself during the output operation. Use JUnit 5 as the testing framework and standard equality assertions to verify the file's existence, ensuring the system properly handles file creation scenarios where intermediate directories must be established on demand.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_notExists()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenOutputStreamTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileUtils} {@code openOutputStream} method.\n */\npublic class FileUtilsOpenOutputStreamTest {\n\n    @Test\n    public void testOpenOutputStreamCreatesParentDirectories(@TempDir final File tempDir) throws IOException {\n        final File file = new File(tempDir, \"new/dir/file.txt\");\n        try (final OutputStream out = FileUtils.openOutputStream(file)) {\n            out.write(0);\n        }\n        assertTrue(file.exists(), \"File should have been created, including parent directories.\");\n    }\n\n}",
      "method_signature": "testOpenOutputStream_notExists()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 0.5,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 24796,
    "output_tokens": 3616,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 887,
      "description": "Define a test method that validates the behavior of the file output stream opening utility when attempting to create a file at a path that exceeds the file system's naming constraints. Within the test setup inherited from the enclosing test suite, initialize two test file references within a temporary directory, generate test data for each file using a utility that writes a specified number of bytes, then delete the entire temporary directory structure and recreate it before regenerating the test files with their data. Construct a file reference representing a deeply nested path by concatenating a subdirectory prefix with a string exceeding 256 characters (the typical file system limit for filenames) and appending a target filename, creating a path structure that cannot be physically created due to the excessively long intermediate directory name. Invoke the file output stream opening method on the FileUtils utility with this invalid file reference, expecting the operation to fail due to the file system's inability to create the necessary parent directories. Assert that the invocation throws an IOException, confirming that the utility correctly propagates file system constraints when the directory structure cannot be established. The test executes within JUnit 5.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_notExistsCannotCreate()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenOutputStreamWithInvalidPathTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests for {@link FileUtils#openOutputStream(File)} when the parent directory cannot be created.\n */\npublic class FileUtilsOpenOutputStreamWithInvalidPathTest {\n\n    /**\n     * A temporary directory managed by JUnit.\n     */\n    @TempDir\n    private File temporaryDirectory;\n\n    /**\n     * Tests that attempting to open an output stream to a file in a path with a directory name\n     * that exceeds file system limits throws an IOException.\n     */\n    @Test\n    public void testOpenOutputStreamWithExcessivelyLongDirectoryName() {\n        // A string exceeding 256 characters is typically invalid for a directory/file name.\n        final char[] longName = new char[260];\n        Arrays.fill(longName, 'x');\n        final String longDirectoryName = new String(longName);\n\n        // Construct a file reference with an invalid parent directory path.\n        final File invalidFile = new File(new File(temporaryDirectory, longDirectoryName), \"test.txt\");\n\n        // Assert that FileUtils.openOutputStream throws an IOException because it cannot\n        // create the parent directory with an illegally long name.\n        assertThrows(IOException.class, () -> {\n            FileUtils.openOutputStream(invalidFile);\n        }, \"Expected an IOException when creating a file with a path that exceeds file system naming limits.\");\n    }\n}",
      "method_signature": "testOpenOutputStream_notExistsCannotCreate()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.5,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.3333,
      "focal_recall": 0.5,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18814,
    "output_tokens": 4074,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 891,
      "description": "Define a test method that verifies the File Utilities component's capability to open an output stream for a file located within a nested directory structure that does not yet exist. Within the test's execution context, construct a File object representing a target file positioned inside a subdirectory path relative to the temporary directory established during setup, where the setup process has already created two test files with generated content, then deleted and recreated the temporary directory to ensure a clean state. Invoke the File Utilities component's stream-opening method, passing the constructed File object to obtain a FileOutputStream instance, then immediately write a single byte value to the stream to confirm writability before closing the stream via try-with-resources. Upon stream closure, validate that the file now exists on the filesystem by querying its existence status, confirming that the component successfully created all necessary parent directories and the target file itself during the stream-opening operation. The test executes using JUnit 5 as the testing framework.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_notExists()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsNestedDirectoryTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests for {@link FileUtils} that involve creating nested directories.\n */\npublic class FileUtilsNestedDirectoryTest {\n\n    @TempDir\n    private File temporaryFolder;\n\n    @Test\n    public void testOpenOutputStreamCreatesParentDirectories() throws IOException {\n        final File file = new File(temporaryFolder, \"nested/dirs/file.txt\");\n        try (final FileOutputStream out = FileUtils.openOutputStream(file)) {\n            out.write(1);\n        }\n        assertTrue(file.exists());\n    }\n}",
      "method_signature": "testOpenOutputStream_notExists()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 0.5,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 16922,
    "output_tokens": 2273,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 895,
      "description": "Create a test case to validate that the system properly rejects attempts to open an output stream when the target location is a directory rather than a file. Begin by establishing a temporary working area with a subdirectory structure in place. Once the directory structure exists, attempt to open an output stream pointing to the subdirectory itself rather than a file within it. Ensure the system recognizes this invalid operation and responds by signaling an illegal argument condition, preventing any file operations from proceeding on a directory. This test verifies using JUnit 5 with standard assertion libraries to confirm the expected failure occurs when attempting to write to a directory location.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_existsButIsDirectory()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOutputStreamTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileUtils} open output stream methods.\n */\npublic class FileUtilsOutputStreamTest {\n\n    @TempDir\n    private Path tempDir;\n\n    @Test\n    public void testOpenOutputStream_directory() throws IOException {\n        final File directory = Files.createDirectory(tempDir.resolve(\"test-dir\")).toFile();\n        assertThrows(IllegalArgumentException.class, () -> FileUtils.newOutputStream(directory, false));\n    }\n}",
      "method_signature": "testOpenOutputStream_existsButIsDirectory()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.3333,
      "callable_precision": 0.25,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 143914,
    "output_tokens": 3873,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 897,
      "description": "Define a test method that validates the behavior of the File Utilities component when attempting to open an output stream for a path that exists as a directory rather than a file. Within the temporary directory established by the inherited setup, construct a File object representing a subdirectory with a specific name, then invoke the directory creation method to establish it on the filesystem. With the directory now present, invoke the File Utilities' stream-opening method passing this directory File object, and assert that this operation throws an IllegalArgumentException, confirming that the component correctly rejects attempts to open output streams on directory paths. The test relies on JUnit 5 for test execution and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_existsButIsDirectory()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 901,
      "description": "Define a test method that validates the force deletion behavior of a broken symbolic link by first establishing a temporary directory structure containing a symbolic link and its target directory, then breaking the link by removing the target, and subsequently confirming that the FileUtils component can successfully delete the orphaned symbolic link. Begin by invoking a helper method that creates a temporary symbolic link pointing to a target directory within the test's temporary directory space, capturing both the symbolic link path and the target directory path as a pair. Extract the symbolic link path and target directory path from the returned pair into separate variables for clarity. Delete the target directory using the Files API to intentionally break the symbolic link, leaving the link itself orphaned. Verify that the symbolic link no longer resolves to an existing target by asserting that the Files existence check returns false, while simultaneously confirming that the path remains recognized as a symbolic link by asserting that the symbolic link check returns true. Invoke the forceDelete method on the FileUtils component, passing the symbolic link converted to a File object, to remove the broken link. After deletion, validate that the symbolic link path no longer exists by asserting that the Files existence check returns false, and confirm complete removal by asserting that the symbolic link check also returns false, ensuring no remnant of the link persists in the file system. The test relies on JUnit for execution and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testForceDeleteBrokenSymlink()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsBrokenSymlinkTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests {@link FileUtils} with broken symbolic links.\n */\npublic class FileUtilsBrokenSymlinkTest {\n\n    private static class PathPair {\n        private final Path symbolicLink;\n        private final Path target;\n\n        PathPair(final Path symbolicLink, final Path target) {\n            this.symbolicLink = symbolicLink;\n            this.target = target;\n        }\n    }\n\n    @TempDir\n    private Path tempDir;\n\n    private PathPair createTempSymbolicLink(final Path tempDir) throws IOException {\n        final Path targetDir = tempDir.resolve(\"target\");\n        final Path symbolicLink = tempDir.resolve(\"link\");\n        Files.createDirectory(targetDir);\n        Files.createSymbolicLink(symbolicLink, targetDir.getFileName());\n        return new PathPair(symbolicLink, targetDir);\n    }\n\n    @Test\n    public void testForceDeleteBrokenSymbolicLink() throws IOException {\n        final PathPair pair = createTempSymbolicLink(tempDir);\n        final Path symbolicLink = pair.symbolicLink;\n        final Path targetDir = pair.target;\n\n        Files.delete(targetDir);\n\n        assertFalse(Files.exists(symbolicLink), \"Symbolic link should not exist after target is deleted\");\n        assertTrue(Files.isSymbolicLink(symbolicLink), \"Path should still be a symbolic link\");\n\n        FileUtils.forceDelete(symbolicLink.toFile());\n\n        assertFalse(Files.exists(symbolicLink), \"Symbolic link should not exist after forceDelete\");\n        assertFalse(Files.isSymbolicLink(symbolicLink), \"Path should no longer be a symbolic link\");\n    }\n}",
      "method_signature": "testForceDeleteBrokenSymlink()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.7895,
      "callable_precision": 0.8333,
      "focal_recall": 0.5,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18527,
    "output_tokens": 3693,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 906,
      "description": "Create a test case to validate the system's capability to write content into a file located within a directory that exists as a symbolic link pointing to an actual directory. Begin by establishing a symbolic link that references a real directory within the test workspace, then specify a file path that resides within this symbolically linked directory structure. Open an output stream for this file to confirm the system properly resolves the symbolic link and creates the file in the correct location, write a single byte of test data to verify the stream functions correctly, close the stream to finalize the write operation, and confirm that the file now exists at the expected location within the symbolically linked directory, thereby ensuring the system handles symbolic directory links transparently when creating and writing to files. Use JUnit 5 as the testing framework and verify the file's existence using standard boolean assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_intoExistingSymlinkedDir()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsSymlinkTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Tests {@link FileUtils} with symbolic links.\n */\npublic class FileUtilsSymlinkTest {\n\n    @TempDir\n    private Path tempDir;\n\n    @Test\n    public void testWriteFileInSymlinkedDirectory() throws IOException {\n        final Path realDir = Files.createDirectory(tempDir.resolve(\"realdir\"));\n        final Path symlinkDir = Files.createSymbolicLink(tempDir.resolve(\"symlinkdir\"), realDir);\n\n        final File fileInSymlink = new File(symlinkDir.toFile(), \"file.txt\");\n\n        try (final OutputStream os = FileUtils.openOutputStream(fileInSymlink)) {\n            os.write(1);\n        }\n\n        assertTrue(Files.exists(fileInSymlink.toPath()), \"File should exist at the symlinked path\");\n    }\n}",
      "method_signature": "testOpenOutputStream_intoExistingSymlinkedDir()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.6923,
      "callable_precision": 0.8182,
      "focal_recall": 0.5,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23927,
    "output_tokens": 4827,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 911,
      "description": "Create a test case to validate that the system handles resource closure operations safely and consistently, ensuring that closing an already-closed byte channel produces no adverse effects or errors. Begin by establishing a new byte channel resource within a managed scope to ensure proper cleanup. Once the channel is available, initiate the first closure operation and immediately verify that the system correctly reports the channel as no longer available for use. After confirming the initial closure succeeded, attempt to close the same channel a second time to simulate repeated shutdown requests, then verify once again that the system still accurately indicates the channel remains closed without throwing errors or entering an inconsistent state. The managed scope automatically releases any remaining system resources after validation completes. Use JUnit 5 for the testing framework and standard boolean assertions to verify the channel's availability status after each closure attempt, confirming the operation remains safe regardless of how many times it executes.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testCloseIsIdempotent()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.FileChannelsTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests that a byte channel can be safely closed multiple times.\n */\npublic class FileChannelsTest1 {\n\n    @Test\n    public void testCloseChannelMultipleTimes(@TempDir Path tempDir) throws IOException {\n        final Path testFile = Files.createFile(tempDir.resolve(\"test.txt\"));\n\n        try (FileChannel channel = FileChannel.open(testFile, StandardOpenOption.READ)) {\n            assertTrue(channel.isOpen(), \"Channel should be open initially.\");\n\n            channel.close();\n            assertFalse(channel.isOpen(), \"Channel should be closed after the first close operation.\");\n\n            channel.close();\n            assertFalse(channel.isOpen(), \"Channel should remain closed after subsequent close operations.\");\n        }\n    }\n}",
      "method_signature": "testCloseIsIdempotent()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.6667,
      "callable_recall": 0.8571,
      "callable_precision": 0.5455,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23423,
    "output_tokens": 8801,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 913,
      "description": "Define a test method that validates the idempotent behavior of the close operation on a Seekable Byte Channel implementation by instantiating a Byte Array Seekable Byte Channel within a try-with-resources block to ensure automatic resource management. Immediately invoke the close method on the channel instance, then verify that the channel's open status returns false to confirm the channel has transitioned to a closed state. Invoke the close method a second time on the already-closed channel to test idempotency, and again verify that the open status remains false, demonstrating that repeated close invocations do not alter the channel's state or produce errors. After the test completes, execute a teardown step that validates the integrity of the static test data byte array by asserting its contents match the expected UTF-8 encoded string value, ensuring that read operations performed by other tests have not inadvertently modified the shared data. This test uses JUnit 5 for the testing framework and standard JUnit assertions for verification.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testCloseIsIdempotent()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14706,
    "output_tokens": 903,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 921,
      "description": "Define a test method that validates the channel's behavior when attempting to reposition after closure by first instantiating a ByteArraySeekableByteChannel within a try-with-resources block to ensure automatic resource management, then explicitly invoke the close method on the channel to transition it into a closed state, and immediately verify that invoking the position method with a long value throws a ClosedChannelException to confirm the channel correctly enforces its closed state contract. Upon exiting the try-with-resources block, the channel is automatically closed if not already closed. In the teardown phase, validate that the static test data byte array remains unmodified by asserting its contents match the expected UTF-8 encoded byte sequence to ensure no unintended mutations occurred during test execution. This test uses JUnit 5 for the testing framework and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testThrowsClosedChannelExceptionWhenPositionIsSetOnClosedChannel()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * JUnit 5 tests for {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] TEST_DATA = \"test data\".getBytes(StandardCharsets.UTF_8);\n    private static final byte[] EXPECTED_DATA = \"test data\".getBytes(StandardCharsets.UTF_8);\n\n    /**\n     * Tests that validates the channel's behavior when attempting to reposition after closure.\n     *\n     * @throws IOException If an I/O error occurs.\n     */\n    @Test\n    public void testRepositionAfterCloseThrowsClosedChannelException() throws IOException {\n        try (final ByteArraySeekableByteChannel channel = new ByteArraySeekableByteChannel(TEST_DATA)) {\n            channel.close();\n            assertThrows(ClosedChannelException.class, () -> channel.position(1L));\n        }\n        // Validate that the static test data byte array remains unmodified.\n        assertArrayEquals(EXPECTED_DATA, TEST_DATA, \"The source byte array should not be modified.\");\n    }\n}",
      "method_signature": "testThrowsClosedChannelExceptionWhenPositionIsSetOnClosedChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 14659,
    "output_tokens": 6523,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 924,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]`, then write a test method annotated with `@Test` that declares the method signature `testCloseIsIdempotent()` and throws `Exception`. Begin the test method by opening a try-with-resources block that declares a variable `c` of type `SeekableByteChannel`, initialized by invoking the no-argument constructor `new ByteArraySeekableByteChannel()`. Within the try block, invoke `close()` on `c`, then immediately invoke `isOpen()` on `c` and pass the result to `assertFalse()` to verify the channel is closed. Next, invoke `close()` on `c` a second time, then again invoke `isOpen()` on `c` and pass the result to `assertFalse()` to confirm the channel remains closed after the redundant close call. The try-with-resources block will automatically invoke `close()` upon exiting. After the test method completes, execute a teardown method that invokes `getBytes(StandardCharsets.UTF_8)` on the String literal `\"Some data\"`, then passes the resulting byte array along with the field `testData` to `assertArrayEquals()` to verify the test data remains unmodified. The test uses the method-level annotation `@Test` and relies on JUnit 5 Assertions for verification.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testCloseIsIdempotent()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testCloseIsIdempotent() throws Exception {\n        try (SeekableByteChannel c = new ByteArraySeekableByteChannel()) {\n            c.close();\n            assertFalse(c.isOpen());\n            c.close();\n            assertFalse(c.isOpen());\n        }\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n}",
      "method_signature": "testCloseIsIdempotent()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.6667,
      "callable_recall": 1.0,
      "callable_precision": 0.7778,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "list_directory": 1,
          "read_file": 2,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 64099,
    "output_tokens": 5067,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 926,
      "description": "Create a test case to validate that the system properly enforces access restrictions on closed data channels by confirming that attempting to reposition within a channel after it has been closed results in the appropriate failure condition. Begin by establishing a new data channel for byte operations, then immediately close the channel to simulate a scenario where the resource is no longer available for use. With the channel in a closed state, attempt to set the reading or writing position to a specific location within the channel and verify that the system correctly rejects this operation by signaling that the channel is no longer accessible. After confirming the expected failure behavior, ensure any allocated resources are properly released. The validation should confirm that operations on closed channels are prevented as a safeguard against invalid state access. Use JUnit 5 for the testing framework and standard exception assertion capabilities to verify the system raises the correct failure signal when position manipulation is attempted on a closed channel.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testThrowsClosedChannelExceptionWhenPositionIsSetOnClosedChannel()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.SeekableByteChannelClosedTest",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests that operations on a closed {@link SeekableByteChannel} fail as expected.\n */\npublic class SeekableByteChannelClosedTest {\n\n    /**\n     * Tests that attempting to change the position on a closed channel throws a ClosedChannelException.\n     *\n     * @param tempDir A temporary directory managed by JUnit.\n     * @throws IOException If an I/O error occurs.\n     */\n    @Test\n    public void testRepositionOnClosedChannelThrowsException(@TempDir final Path tempDir) throws IOException {\n        final Path file = Files.createFile(tempDir.resolve(\"test.txt\"));\n        \n        // Begin by establishing a new data channel for byte operations\n        final SeekableByteChannel channel = Files.newByteChannel(file, StandardOpenOption.WRITE);\n        \n        // Immediately close the channel to simulate a scenario where the resource is no longer available\n        channel.close();\n        \n        // Verify that attempting to reposition within the closed channel results in the appropriate failure\n        assertThrows(ClosedChannelException.class, () -> {\n            channel.position(1L);\n        }, \"Attempting to set position on a closed channel should throw ClosedChannelException.\");\n        \n        // Resources are released automatically: the channel is closed, and @TempDir handles file cleanup.\n    }\n}",
      "method_signature": "testThrowsClosedChannelExceptionWhenPositionIsSetOnClosedChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.6667,
      "callable_precision": 0.3333,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18765,
    "output_tokens": 4121,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 927,
      "description": "Define a test method that verifies the behavior of `forceDelete` when invoked on a broken symbolic link by first invoking a private method that creates a temporary symbolic link structure, then deleting the target directory to break the link, asserting the link's state, invoking `forceDelete` on the broken link, and finally verifying the link has been removed. Begin by invoking a private method that creates the symbolic link structure: call `resolve` on the field `tempDirPath` with argument `\"subdir\"` to produce `targetDir` of type `Path`, then call `resolve` on `tempDirPath` with argument `\"symlinked-dir\"` to produce `symLinkedDir` of type `Path`, invoke `Files.createDirectory` with `targetDir`, invoke `Files.createSymbolicLink` with arguments `symLinkedDir` and `targetDir`, and return an `ImmutablePair` by calling `ImmutablePair.of(symLinkedDir, targetDir)`. Assign the returned `ImmutablePair<Path, Path>` to variable `pair`, then extract the left element by invoking `getLeft()` on `pair` and assign it to variable `symlinkedDir` of type `Path`, and extract the right element by invoking `getRight()` on `pair` and assign it to variable `targetDir` of type `Path`. Invoke `Files.delete` with argument `targetDir` to remove the target directory, thereby breaking the symbolic link. Immediately assert that `Files.exists(symlinkedDir)` returns `false` by passing the result to `assertFalse`, verifying the broken link does not resolve to an existing file. Next, assert that `Files.isSymbolicLink(symlinkedDir)` returns `true` by passing the result to `assertTrue`, confirming the symbolic link itself still exists despite being broken. Invoke `FileUtils.forceDelete` with the argument produced by calling `toFile()` on `symlinkedDir`, which converts the `Path` to a `File` object, to delete the broken symbolic link. After the deletion, verify the symbolic link has been removed by asserting that `Files.exists(symlinkedDir)` returns `false` using `assertFalse`, and assert that `Files.isSymbolicLink(symlinkedDir)` returns `false` using `assertFalse`, confirming the link no longer exists in the file system. The test method is annotated with `@Test` and declares `throws Exception`. The test class is annotated with `@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})`. The test relies on a setup method annotated with `@BeforeEach` that initializes `tempDirPath` by invoking `Files.createTempDirectory` with arguments `managedTempDirPath` and the result of `getClass().getSimpleName()`, then assigns `tempDirPath.toFile()` to `tempDirFile`, followed by another setup method that initializes `testFile1` as a new `File` with parent `tempDirFile` and name `\"file1-test.txt\"`, initializes `testFile2` as a new `File` with parent `tempDirFile` and name `\"file1a-test.txt\"`, assigns `testFile1.length()` to `testFile1Size`, assigns `testFile2.length()` to `testFile2Size`, verifies parent directories exist or fails with appropriate messages, creates output streams by wrapping `Files.newOutputStream(testFile1.toPath())` and `Files.newOutputStream(testFile2.toPath())` in `BufferedOutputStream` instances, invokes a helper method that writes test data by iterating from `0` to `size - 1` and calling `write((byte)(i % 127 + 1))` on the output stream for each iteration, invokes `FileUtils.deleteDirectory` with `tempDirFile`, invokes `mkdirs()` on `tempDirFile`, and repeats the file creation process for both test files. The test uses JUnit 5 assertions (`assertFalse`, `assertTrue`) and the Java NIO Files API for file system operations.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testForceDeleteBrokenSymlink()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsForceDeleteBrokenSymlinkTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.apache.commons.lang3.tuple.ImmutablePair;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})\npublic class FileUtilsForceDeleteBrokenSymlinkTest {\n\n    @TempDir\n    static Path managedTempDirPath;\n\n    private Path tempDirPath;\n    private File tempDirFile;\n    private File testFile1;\n    private File testFile2;\n    private long testFile1Size;\n    private long testFile2Size;\n\n    private void writeTestData(final OutputStream out, final int size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            out.write((byte) (i % 127 + 1));\n        }\n    }\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        tempDirPath = Files.createTempDirectory(managedTempDirPath, getClass().getSimpleName());\n        tempDirFile = tempDirPath.toFile();\n\n        testFile1 = new File(tempDirFile, \"file1-test.txt\");\n        testFile2 = new File(tempDirFile, \"file1a-test.txt\");\n\n        testFile1Size = testFile1.length();\n        testFile2Size = testFile2.length();\n\n        try (final BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(testFile1.toPath()))) {\n            writeTestData(out, 16);\n        }\n        try (final BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(testFile2.toPath()))) {\n            writeTestData(out, 16);\n        }\n\n        FileUtils.deleteDirectory(tempDirFile);\n\n        tempDirFile.mkdirs();\n\n        try (final BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(testFile1.toPath()))) {\n            writeTestData(out, 16);\n        }\n        try (final BufferedOutputStream out = new BufferedOutputStream(Files.newOutputStream(testFile2.toPath()))) {\n            writeTestData(out, 16);\n        }\n    }\n\n    private ImmutablePair<Path, Path> createSymbolicLinkStructure() throws IOException {\n        final Path targetDir = tempDirPath.resolve(\"subdir\");\n        final Path symLinkedDir = tempDirPath.resolve(\"symlinked-dir\");\n        Files.createDirectory(targetDir);\n        Files.createSymbolicLink(symLinkedDir, targetDir);\n        return ImmutablePair.of(symLinkedDir, targetDir);\n    }\n\n    @Test\n    public void testForceDeleteBrokenSymbolicLink() throws Exception {\n        final ImmutablePair<Path, Path> pair = createSymbolicLinkStructure();\n        final Path symlinkedDir = pair.getLeft();\n        final Path targetDir = pair.getRight();\n\n        Files.delete(targetDir);\n\n        assertFalse(Files.exists(symlinkedDir));\n        assertTrue(Files.isSymbolicLink(symlinkedDir));\n\n        FileUtils.forceDelete(symlinkedDir.toFile());\n\n        assertFalse(Files.exists(symlinkedDir));\n        assertFalse(Files.isSymbolicLink(symlinkedDir));\n    }\n}",
      "method_signature": "testForceDeleteBrokenSymlink()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.9474,
      "callable_precision": 0.9474,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 25090,
    "output_tokens": 9125,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 931,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]` (initialization not shown in test method context), then write a test method annotated with `@Test` that declares the method signature to throw `Exception`. Begin by instantiating a `ByteArraySeekableByteChannel` using its no-argument constructor and assign it to a variable `c` of type `SeekableByteChannel` within a try-with-resources statement. Inside the try block, invoke `close()` on `c`, then immediately assert that invoking `position(0)` on `c` throws `ClosedChannelException` by calling `assertThrows(ClosedChannelException.class, () -> c.position(0))`. After the try-with-resources block completes, define a teardown method annotated with `@AfterEach` that invokes `assertArrayEquals` passing the result of `\"Some data\".getBytes(StandardCharsets.UTF_8)` as the first argument and `testData` as the second argument to verify the test data remains unmodified. The test uses JUnit 5 Assertions with method-level annotation `@Test` and teardown annotation `@AfterEach`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testThrowsClosedChannelExceptionWhenPositionIsSetOnClosedChannel()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testCloseAndPosition() throws Exception {\n        try (SeekableByteChannel c = new ByteArraySeekableByteChannel()) {\n            c.close();\n            assertThrows(ClosedChannelException.class, () -> c.position(0));\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n}",
      "method_signature": "testThrowsClosedChannelExceptionWhenPositionIsSetOnClosedChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 43228,
    "output_tokens": 6986,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 932,
      "description": "Define a test method that validates the FileUtils utility's capability to open an output stream into a file located within a symbolic link directory structure. Before the test executes, leverage inherited setup logic that initializes a temporary directory path and converts it to a File representation, then invoke a local setup method that constructs two test file references within the temporary directory, captures their initial sizes, writes generated test data to both files using buffered output streams, deletes the entire temporary directory tree, recreates the directory structure, and repopulates both test files with the same generated data to establish a clean baseline. Within the test method itself, create a helper method that constructs a symbolic link directory by resolving a subdirectory path and a symlink path within the temporary directory, creating the physical subdirectory, establishing a symbolic link pointing to that subdirectory, and returning both paths as a paired result. Invoke this helper to obtain the symbolic link directory, then extract the symlink path from the returned pair and resolve a file path named \"test.txt\" within it, converting the resulting path to a File object. Call the openOutputStream method on FileUtils with this file reference to obtain a FileOutputStream, write a single byte value to the stream to verify write capability, and close the stream using try-with-resources. Assert that the file exists at the resolved location to confirm successful creation through the symbolic link. This test uses JUnit 5 for the testing framework and standard JUnit assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_intoExistingSymlinkedDir()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsSymlinkTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assumptions.assumeTrue;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Define a test method that validates the FileUtils utility's capability to open an output stream into a file located\n * within a symbolic link directory structure.\n */\npublic class FileUtilsSymlinkTest {\n\n    private File tempDir;\n\n    /**\n     * Constructs two test file references within the temporary directory, captures their initial sizes, writes\n     * generated test data to both files using buffered output streams, deletes the entire temporary directory tree,\n     * recreates the directory structure, and repopulates both test files with the same generated data to establish a\n     * clean baseline.\n     *\n     * @throws IOException if an I/O error occurs.\n     */\n    @BeforeEach\n    public void setUp() throws IOException {\n        tempDir = new File(\"target\", \"FileUtilsSymlinkTest\");\n        FileUtils.deleteDirectory(tempDir);\n        tempDir.mkdirs();\n\n        final File testFile1 = new File(tempDir, \"testfile1.txt\");\n        final File testFile2 = new File(tempDir, \"testfile2.txt\");\n        final byte[] testData = \"data\".getBytes(StandardCharsets.UTF_8);\n\n        try (final BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(testFile1))) {\n            out.write(testData);\n        }\n        try (final BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(testFile2))) {\n            out.write(testData);\n        }\n\n        FileUtils.deleteDirectory(tempDir);\n        tempDir.mkdirs();\n\n        try (final BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(testFile1))) {\n            out.write(testData);\n        }\n        try (final BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(testFile2))) {\n            out.write(testData);\n        }\n    }\n\n    @AfterEach\n    public void tearDown() throws IOException {\n        FileUtils.deleteDirectory(tempDir);\n    }\n\n    /**\n     * Constructs a symbolic link directory by resolving a subdirectory path and a symlink path within the temporary\n     * directory, creating the physical subdirectory, establishing a symbolic link pointing to that subdirectory, and\n     * returning both paths as a paired result.\n     *\n     * @return A Pair of Paths, with the left being the target directory and the right being the symbolic link.\n     */\n    private Pair<Path, Path> createSymbolicLinkDirectory() {\n        final Path target = tempDir.toPath().resolve(\"subdir\");\n        final Path symlink = tempDir.toPath().resolve(\"symlink\");\n        try {\n            Files.createDirectory(target);\n            Files.createSymbolicLink(symlink, target);\n            return Pair.of(target, symlink);\n        } catch (final IOException | UnsupportedOperationException e) {\n            // For example on Windows, a special privilege is required to create symbolic links\n            return null;\n        }\n    }\n\n    /**\n     * Validates the FileUtils utility's capability to open an output stream into a file located within a symbolic link\n     * directory structure.\n     *\n     * @throws IOException if an I/O error occurs.\n     */\n    @Test\n    public void testOpenOutputStreamInSymbolicLinkDirectory() throws IOException {\n        final Pair<Path, Path> paths = createSymbolicLinkDirectory();\n        assumeTrue(paths != null, \"Test cannot run because symbolic links are not supported or could not be created.\");\n\n        final Path symlinkPath = paths.getRight();\n        final File testFile = symlinkPath.resolve(\"test.txt\").toFile();\n\n        try (FileOutputStream fos = FileUtils.openOutputStream(testFile)) {\n            fos.write(1);\n        }\n\n        assertTrue(testFile.exists());\n    }\n}",
      "method_signature": "testOpenOutputStream_intoExistingSymlinkedDir()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 0.8462,
      "callable_precision": 0.6875,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 0.6,
      "line_coverage": 0.3333,
      "branch_coverage": 0.6667
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23032,
    "output_tokens": 8120,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 933,
      "description": "Define a test method that validates the behavior of a ByteArraySeekableByteChannel when attempting to write data after the channel has been closed. Instantiate a new ByteArraySeekableByteChannel with default capacity, then immediately invoke its close method to transition the channel into a closed state. With the channel now closed, verify that attempting to write data triggers the appropriate exception by invoking the write method with a newly allocated ByteBuffer of minimal capacity and asserting that a ClosedChannelException is thrown during this operation. After the test completes, perform cleanup by validating that the class-level test data byte array remains unmodified, comparing it against the expected UTF-8 encoded byte representation of the original string to ensure reading operations have not altered the shared state. This test uses JUnit 5 for test execution and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldThrowExceptionOnWritingToClosedChannel()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.charset.StandardCharsets;\n\nimport org.apache.commons.io.channel.ByteArraySeekableByteChannel;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final String ORIGINAL_STRING = \"test data\";\n    private static final byte[] TEST_DATA = ORIGINAL_STRING.getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testWriteToClosedChannel() throws IOException {\n        try (final ByteArraySeekableByteChannel channel = new ByteArraySeekableByteChannel()) {\n            channel.close();\n            final ByteBuffer buffer = ByteBuffer.allocate(1);\n            assertThrows(ClosedChannelException.class, () -> channel.write(buffer));\n        }\n        // Validate that the shared test data has not been modified.\n        assertArrayEquals(ORIGINAL_STRING.getBytes(StandardCharsets.UTF_8), TEST_DATA);\n    }\n}",
      "method_signature": "testShouldThrowExceptionOnWritingToClosedChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 18363,
    "output_tokens": 3748,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 935,
      "description": "Create a test case to validate that the system properly enforces access restrictions on data channels after they have been released, ensuring data integrity and preventing unauthorized modifications. Begin by establishing a new data channel in the system with no initial content, then immediately release the channel to mark it as no longer available for operations. Once the channel has been released, attempt to write a small amount of data to verify the system correctly rejects this operation, confirming that the channel enforces its closed state by preventing any further write attempts and raising an appropriate business failure indicating the channel is no longer accessible. After verifying the expected rejection behavior, ensure any test resources are properly released by confirming the underlying test data remains unmodified throughout the validation process. Use JUnit 5 for the testing framework and standard exception assertions to verify the system raises the expected access violation when attempting to write to a released channel.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldThrowExceptionOnWritingToClosedChannel()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.output.WriterOutputStreamClosedTest",
      "code": "package org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests that access restrictions are enforced on a released (closed) channel.\n */\npublic class WriterOutputStreamClosedTest {\n\n    /**\n     * This test validates that a {@link WriterOutputStream} correctly prevents writes after it has been closed.\n     * This fulfills the requirement of enforcing access restrictions on a released data channel.\n     */\n    @Test\n    public void testWriteToReleasedChannelThrowsException() {\n        // Establish a new data channel (WriterOutputStream) with no initial content.\n        final StringWriter underlyingWriter = new StringWriter();\n        final WriterOutputStream channel = new WriterOutputStream(underlyingWriter, StandardCharsets.UTF_8, 1024, true);\n\n        // Immediately release the channel to mark it as no longer available for operations.\n        try {\n            channel.close();\n        } catch (final IOException e) {\n            // Should not fail on close. If it does, the test setup is wrong.\n            // Using a simple fail here is not ideal without a framework assertion,\n            // but we want to ensure close itself doesn't cause the test to fail.\n        }\n\n        // Attempt to write a small amount of data to verify the system correctly rejects this operation.\n        // The system should enforce its closed state by preventing any further write attempts.\n        final byte[] testData = \"test data\".getBytes(StandardCharsets.UTF_8);\n        assertThrows(IOException.class, () -> {\n            channel.write(testData);\n        }, \"Should not be able to write to a closed channel.\");\n\n        // After verifying the expected rejection behavior, ensure the underlying test data remains unmodified.\n        assertEquals(0, underlyingWriter.toString().length(), \"Underlying writer should remain unmodified after a failed write to a closed channel.\");\n    }\n}",
      "method_signature": "testShouldThrowExceptionOnWritingToClosedChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.5,
      "callable_recall": 0.5,
      "callable_precision": 0.2222,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 7332,
    "output_tokens": 7528,
    "llm_calls": 0,
    "failed_test_file_generation": true,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 947,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]` (its initialization is not used in this test). Implement a test method annotated with `@Test` that begins by instantiating a `ByteArraySeekableByteChannel` using its no-argument constructor and assigning it to a local variable `c` of type `ByteArraySeekableByteChannel`. Immediately invoke the `close()` method on `c` to close the channel. Then assert that attempting to write to the closed channel throws a `ClosedChannelException` by calling `assertThrows(ClosedChannelException.class, () -> c.write(ByteBuffer.allocate(1)))`, where the lambda expression invokes `write` on `c` with a `ByteBuffer` created by calling `ByteBuffer.allocate(1)` as the argument. After the test method completes, execute a teardown method that performs an assertion by calling `assertArrayEquals` with two arguments: the first is the byte array obtained by invoking `getBytes(StandardCharsets.UTF_8)` on the String literal `\"Some data\"`, and the second is the field `testData`, verifying that the test data remains unmodified. The test uses JUnit 5 Assertions with method-level annotation `@Test`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldThrowExceptionOnWritingToClosedChannel()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testWriteToClosedChannelThrowsException() throws IOException {\n        final ByteArraySeekableByteChannel c = new ByteArraySeekableByteChannel();\n        c.close();\n        assertThrows(ClosedChannelException.class, () -> c.write(ByteBuffer.allocate(1)));\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n}",
      "method_signature": "testShouldThrowExceptionOnWritingToClosedChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.5,
      "callable_recall": 1.0,
      "callable_precision": 0.6667,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "glob": 1,
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22823,
    "output_tokens": 3675,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 948,
      "description": "Define a test method that validates the channel's behavior when attempting to read from a closed channel by first instantiating a ByteArraySeekableByteChannel with default configuration, then immediately invoking the close method on this channel instance to transition it into a closed state. With the channel now closed, attempt to read from it by invoking the read method with a newly allocated ByteBuffer of minimal capacity, and assert that this operation throws a ClosedChannelException to confirm that the channel correctly enforces access restrictions on closed resources. After the test completes, verify in the teardown phase that the class-level test data byte array remains unmodified by comparing it against the original UTF-8 encoded byte representation of the expected string content, ensuring that reading operations have not inadvertently altered shared test state. This test uses JUnit 5 for the testing framework and its assertion capabilities.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldThrowExceptionOnReadingClosedChannel()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final String TEST_STRING = \"test content\";\n    private static final byte[] TEST_DATA = TEST_STRING.getBytes(StandardCharsets.UTF_8);\n\n    @AfterEach\n    public void tearDown() {\n        // Verifies that the test data byte array has not been modified.\n        assertArrayEquals(TEST_STRING.getBytes(StandardCharsets.UTF_8), TEST_DATA);\n    }\n\n    @Test\n    public void testReadFromClosedChannel() throws IOException {\n        try (final ByteArraySeekableByteChannel channel = new ByteArraySeekableByteChannel(TEST_DATA)) {\n            channel.close();\n            assertThrows(ClosedChannelException.class, () -> channel.read(ByteBuffer.allocate(1)));\n        }\n    }\n}",
      "method_signature": "testShouldThrowExceptionOnReadingClosedChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 17698,
    "output_tokens": 3131,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 951,
      "description": "Create a test case to validate that the byte channel system properly enforces access restrictions once a channel has been closed, ensuring data integrity and preventing operations on terminated resources. Begin by establishing a new byte channel in the system, then immediately terminate the channel to simulate a closed state. Once the channel is closed, attempt to perform a read operation by requesting data retrieval into a small buffer, and verify that the system correctly rejects this action by raising an appropriate failure indicating the channel is no longer available for operations. After confirming the expected failure behavior, perform a validation step to ensure that any test data used during the verification process remains unmodified, confirming that read operations throughout the test suite have not altered the original data state. Use JUnit 5 as the testing framework with standard exception assertions to verify that the system prevents operations on closed channels, ensuring the business rule that closed resources cannot be accessed is properly enforced.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldThrowExceptionOnReadingClosedChannel()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.FileChannelsTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests for the byte channel system, focusing on access control for closed channels.\n */\npublic class FileChannelsTest1 {\n\n    /**\n     * Tests that attempting to read from a closed byte channel throws a {@link ClosedChannelException}.\n     *\n     * @throws IOException if an I/O error occurs during test setup.\n     */\n    @Test\n    public void testReadOnClosedChannelThrowsException(@TempDir final Path tempDir) throws IOException {\n        final Path testFile = Files.createFile(tempDir.resolve(\"test.txt\"));\n        final byte[] originalData = \"test data\".getBytes(StandardCharsets.UTF_8);\n        Files.write(testFile, originalData);\n\n        final SeekableByteChannel channel = Files.newByteChannel(testFile);\n        channel.close();\n\n        final ByteBuffer buffer = ByteBuffer.allocate(originalData.length);\n\n        assertThrows(ClosedChannelException.class, () -> {\n            channel.read(buffer);\n        }, \"Expected a ClosedChannelException when reading from a closed channel.\");\n\n        assertArrayEquals(new byte[originalData.length], buffer.array(),\n            \"Buffer should remain unmodified after a failed read operation.\");\n    }\n}",
      "method_signature": "testShouldThrowExceptionOnReadingClosedChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 0.5,
      "callable_recall": 0.5,
      "callable_precision": 0.1818,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 37157,
    "output_tokens": 10160,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 953,
      "description": "Define a test method annotated with `@Test` that verifies exception behavior when attempting to read from a closed channel. Begin by instantiating a new `ByteArraySeekableByteChannel` using the no-argument constructor and assign it to a final variable named `c`. Immediately invoke the `close()` method on `c` to transition the channel into a closed state. Following closure, use `assertThrows` with the expected exception class `ClosedChannelException.class` and provide a lambda expression that invokes `read` on `c`, passing as argument a `ByteBuffer` created by calling `ByteBuffer.allocate(1)` to allocate a buffer with capacity of integer literal `1`. After the test method completes, execute teardown logic by invoking `assertArrayEquals` with two arguments: the first obtained by calling `getBytes(StandardCharsets.UTF_8)` on the String literal `\"Some data\"`, and the second being the class field `testData` of type `byte[]`, thereby verifying that the static test data remains unmodified. The test uses JUnit 5 Assertions with method-level annotation `@Test`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "testShouldThrowExceptionOnReadingClosedChannel()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.charset.StandardCharsets;\n\nimport org.apache.commons.io.input.ByteArrayInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @Test\n    public void testReadFromClosedChannel() throws IOException {\n        final ByteArraySeekableByteChannel c = new ByteArraySeekableByteChannel();\n        c.close();\n        assertThrows(ClosedChannelException.class, () -> c.read(ByteBuffer.allocate(1)));\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n}",
      "method_signature": "testShouldThrowExceptionOnReadingClosedChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 20031,
    "output_tokens": 5265,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 955,
      "description": "Create a test case to validate that the system properly enforces operational boundaries on a byte channel resource by ensuring that once a channel has been closed, any attempt to resize its capacity results in a failure indicating the resource is no longer available. Begin by establishing a new byte channel resource in the system, then immediately close that resource to simulate its decommissioning or end-of-life state. With the resource now in a closed state, attempt to resize the channel's capacity to zero bytes, which should fail because the channel is no longer operational. Verify that the system correctly rejects this resize operation by signaling that the channel is closed and unavailable for further modifications. After confirming this protective behavior, ensure that any test data remains unmodified by validating its integrity matches the original state. Use JUnit 5 as the testing framework with standard equality assertions to confirm the expected failure condition when operating on a closed resource.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "throwsClosedChannelExceptionWhenTruncateIsCalledOnClosedChannel()",
      "abstraction_level": "high",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "",
      "code": "",
      "method_signature": null
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 29362,
    "output_tokens": 2783,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": true
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 956,
      "description": "Define a test method that validates the channel's behavior when attempting to truncate after closure by first instantiating a Byte Array Seekable Byte Channel within a try-with-resources block to ensure automatic resource management, then immediately invoke the close method on the channel to transition it into a closed state. With the channel now closed, verify that invoking the truncate method with a size parameter throws a Closed Channel Exception, confirming that the channel properly enforces its closed state contract and prevents further modification operations. Upon completion of the try-with-resources block, the channel is automatically cleaned up. After the test method completes, execute a teardown step that validates the integrity of the test data byte array by asserting it remains unchanged from its original state, ensuring that read-only test operations have not inadvertently modified the shared test fixture. This test uses JUnit 5 for test execution and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "throwsClosedChannelExceptionWhenTruncateIsCalledOnClosedChannel()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.nio.channels.ClosedChannelException;\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] ORIGINAL_DATA = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\n    /**\n     * Define a test method that validates the channel's behavior when attempting\n     * to truncate after closure by first instantiating a Byte Array Seekable Byte\n     * Channel within a try-with-resources block to ensure automatic resource\n     * management, then immediately invoke the close method on the channel to\n     * transition it into a closed state. With the channel now closed, verify that\n     * invoking the truncate method with a size parameter throws a Closed Channel\n     * Exception, confirming that the channel properly enforces its closed state\n     * contract and prevents further modification operations. Upon completion of\n     * the try-with-resources block, the channel is automatically cleaned up. After\n     * the test method completes, execute a teardown step that validates the\n     * integrity of the test data byte array by asserting it remains unchanged\n     * from its original state, ensuring that read-only test operations have not\n     * inadvertently modified the shared test fixture. This test uses JUnit 5 for\n     * test execution and assertions.\n     *\n     * @throws IOException Thrown when an I/O error occurs.\n     */\n    @Test\n    public void testTruncateThrowsOnClosedChannel() throws IOException {\n        final byte[] testData = Arrays.copyOf(ORIGINAL_DATA, ORIGINAL_DATA.length);\n        try (final ByteArraySeekableByteChannel channel = new ByteArraySeekableByteChannel(testData)) {\n            channel.close();\n            assertThrows(ClosedChannelException.class, () -> channel.truncate(5));\n        }\n        assertArrayEquals(ORIGINAL_DATA, testData, \"Data should not be modified.\");\n    }\n}",
      "method_signature": "throwsClosedChannelExceptionWhenTruncateIsCalledOnClosedChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 41703,
    "output_tokens": 6974,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 960,
      "description": "Define a test class containing a private static final field `testData` of type `byte[]`, then write a test method annotated with `@Test` that declares the method signature to throw `Exception`. Begin by instantiating a `ByteArraySeekableByteChannel` using its no-argument constructor and assign it to a variable `c` of type `SeekableByteChannel` within a try-with-resources statement. Immediately invoke `close()` on `c`, then invoke `assertThrows` passing `ClosedChannelException.class` as the first argument and a lambda expression `() -> c.truncate(0)` as the second argument, which attempts to call `truncate` with the long literal `0` on the closed channel. After the try-with-resources block completes, define an `afterEach` teardown method that invokes `assertArrayEquals` with two arguments: the result of calling `getBytes(StandardCharsets.UTF_8)` on the String literal `\"Some data\"` as the first argument, and the field `testData` as the second argument, verifying that the test data remains unmodified. The test uses method-level annotation `@Test`, assertion library JUnit 5 Assertions (specifically `assertThrows` and `assertArrayEquals`), and no mocking libraries.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelCompressTest",
      "method_signature": "throwsClosedChannelExceptionWhenTruncateIsCalledOnClosedChannel()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.channels.ByteArraySeekableByteChannelTest1",
      "code": "package org.apache.commons.io.channels;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ByteArraySeekableByteChannel}.\n */\npublic class ByteArraySeekableByteChannelTest1 {\n\n    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n\n    @AfterEach\n    public void afterEach() {\n        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n    }\n\n    @Test\n    public void testTruncateOnClosedChannel() throws Exception {\n        try (SeekableByteChannel c = new ByteArraySeekableByteChannel()) {\n            c.close();\n            assertThrows(ClosedChannelException.class, () -> c.truncate(0));\n        }\n    }\n}",
      "method_signature": "throwsClosedChannelExceptionWhenTruncateIsCalledOnClosedChannel()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 35996,
    "output_tokens": 3069,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 962,
      "description": "Define a test method that verifies `FileUtils.openOutputStream` throws an `IllegalArgumentException` when invoked on a directory rather than a file, beginning by constructing a `File` instance with arguments `tempDirFile` and the String literal `\"subdir\"`, assigning the result to local variable `directory`, then immediately invoke `mkdirs()` on `directory` to create the directory structure, and finally assert that invoking `FileUtils.openOutputStream(directory)` throws `IllegalArgumentException` by wrapping the invocation in `assertThrows(IllegalArgumentException.class, () -> FileUtils.openOutputStream(directory))`. The test relies on a setup method that initializes `tempDirFile` by invoking `Files.createTempDirectory(managedTempDirPath, getClass().getSimpleName())` to obtain `tempDirPath`, then converting it via `tempDirPath.toFile()` to assign `tempDirFile`, followed by constructing `testFile1` as `new File(tempDirFile, \"file1-test.txt\")` and `testFile2` as `new File(tempDirFile, \"file1a-test.txt\")`, capturing their lengths via `testFile1.length()` into `testFile1Size` and `testFile2.length()` into `testFile2Size`, verifying parent existence with `testFile1.getParentFile().exists()` and failing via `fail(\"Cannot create file \" + testFile1 + \" as the parent directory does not exist\")` if false, opening a `BufferedOutputStream` wrapping `Files.newOutputStream(testFile1.toPath())` as `output3` in a try-with-resources block and invoking a private method that executes a loop from `i = 0` to `i < testFile1Size` writing `(byte)(i % 127 + 1)` to `output3` for each iteration, repeating the parent check and stream creation for `testFile2` with `output2` and the same data generation logic using `testFile2Size`, then invoking `FileUtils.deleteDirectory(tempDirFile)` followed by `tempDirFile.mkdirs()` to reset the directory, and recreating both test files by repeating the parent existence checks, stream creation (`output1` for `testFile1`, `output` for `testFile2`), and data generation steps with their respective sizes. Class-level annotations: `@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})`. Method-level annotation: `@Test`. Assertion library: JUnit 5 Assertions. No mocking libraries present.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_existsButIsDirectory()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenOutputStreamTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})\npublic class FileUtilsOpenOutputStreamTest {\n\n    @TempDir\n    private Path managedTempDirPath;\n\n    private File tempDirFile;\n    private File testFile1;\n    private File testFile2;\n    private long testFile1Size;\n    private long testFile2Size;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        tempDirFile = managedTempDirPath.toFile();\n        testFile1 = new File(tempDirFile, \"file1-test.txt\");\n        testFile2 = new File(tempDirFile, \"file1a-test.txt\");\n\n        testFile1Size = testFile1.length();\n        testFile2Size = testFile2.length();\n\n        if (!testFile1.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile1 + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output3 = new BufferedOutputStream(Files.newOutputStream(testFile1.toPath()))) {\n            writeTheBytes(output3, testFile1Size);\n        }\n\n        if (!testFile2.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile2 + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output2 = new BufferedOutputStream(Files.newOutputStream(testFile2.toPath()))) {\n            writeTheBytes(output2, testFile2Size);\n        }\n\n        FileUtils.deleteDirectory(tempDirFile);\n        tempDirFile.mkdirs();\n\n        if (!testFile1.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile1 + \" as the parent directory does not exist\");\n        }\n        try (final OutputStream output1 = Files.newOutputStream(testFile1.toPath())) {\n            writeTheBytes(output1, testFile1Size);\n        }\n\n        if (!testFile2.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile2 + \" as the parent directory does not exist\");\n        }\n        try (final OutputStream output = Files.newOutputStream(testFile2.toPath())) {\n            writeTheBytes(output, testFile2Size);\n        }\n    }\n\n    private void writeTheBytes(final OutputStream out, final long size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            out.write((byte) (i % 127 + 1));\n        }\n    }\n\n    @Test\n    public void testOpenOutputStreamOnDirectory() {\n        final File directory = new File(tempDirFile, \"subdir\");\n        directory.mkdirs();\n        assertThrows(IllegalArgumentException.class, () -> FileUtils.openOutputStream(directory));\n    }\n}",
      "method_signature": "testOpenOutputStream_existsButIsDirectory()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 22389,
    "output_tokens": 7027,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 964,
      "description": "Define a test method that creates a symbolic link to a subdirectory within the temporary directory, writes a single byte to a file inside that symlinked directory using `FileUtils.openOutputStream`, and verifies the file exists. Begin by invoking `createTempSymbolicLinkedRelativeDir()` on the test instance, which internally calls `resolve(\"subdir\")` on `tempDirPath` to create a `Path` named `targetDir`, then calls `resolve(\"symlinked-dir\")` on `tempDirPath` to create a `Path` named `symLinkedDir`, invokes `Files.createDirectory(targetDir)` to create the physical directory, invokes `Files.createSymbolicLink(symLinkedDir, targetDir)` to create the symbolic link, and returns `ImmutablePair.of(symLinkedDir, targetDir)`. Chain `getLeft()` on the returned pair to extract the symbolic link path and assign it to a local variable `symlinkedDir` of type `Path`. Invoke `resolve(\"test.txt\")` on `symlinkedDir` to obtain a child path, then chain `toFile()` to convert it to a `File` and assign the result to a local variable `file`. Open a try-with-resources block by invoking `FileUtils.openOutputStream(file)` (which internally calls `FileUtils.openOutputStream(file, false)`, passing `file` through `Objects.requireNonNull`, checking existence via `file.exists()`, validating it is a file if it exists, creating parent directories if necessary, and constructing a new `FileOutputStream(file, false)`), assigning the returned `FileOutputStream` to a variable `out`. Within the try block, invoke `write(0)` on `out` to write a single byte with integer value `0`. After the try-with-resources block closes the stream, invoke `file.exists()` and pass the result to `assertTrue` to verify the file was created. The test method is annotated with `@Test` and declares `throws Exception`. The test class is annotated with `@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})` at the class level. The test relies on a `@BeforeEach` setup method `beforeEachCreateTempDirs()` (inherited from `AbstractTempDirTest`) that invokes `Files.createTempDirectory(managedTempDirPath, getClass().getSimpleName())` to create `tempDirPath` and assigns `tempDirPath.toFile()` to `tempDirFile`, and another `@BeforeEach` method `setUp()` that constructs `testFile1` as `new File(tempDirFile, \"file1-test.txt\")`, constructs `testFile2` as `new File(tempDirFile, \"file1a-test.txt\")`, assigns `testFile1.length()` to `testFile1Size`, assigns `testFile2.length()` to `testFile2Size`, validates parent directories exist or fails with a message, creates `testFile1` by opening a `BufferedOutputStream` wrapping `Files.newOutputStream(testFile1.toPath())` and invoking a helper that writes `testFile1Size` bytes where each byte equals `(i % 127 + 1)` for index `i` from `0` to `testFile1Size - 1`, creates `testFile2` similarly, invokes `FileUtils.deleteDirectory(tempDirFile)`, invokes `tempDirFile.mkdirs()`, and recreates both test files with the same byte-writing logic. Use JUnit 5 assertions (`assertTrue`).",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_intoExistingSymlinkedDir()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenOutputStreamSymlinkTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.apache.commons.lang3.tuple.ImmutablePair;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.condition.EnabledOnOs;\nimport org.junit.jupiter.api.condition.OS;\n\n@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})\n@EnabledOnOs({OS.LINUX, OS.MAC})\npublic class FileUtilsOpenOutputStreamSymlinkTest extends AbstractTempDirTest {\n\n    private ImmutablePair<Path, Path> createTempSymbolicLinkedRelativeDir() throws Exception {\n        final Path targetDir = tempDirPath.resolve(\"subdir\");\n        final Path symLinkedDir = tempDirPath.resolve(\"symlinked-dir\");\n        Files.createDirectory(targetDir);\n        Files.createSymbolicLink(symLinkedDir, targetDir);\n        return ImmutablePair.of(symLinkedDir, targetDir);\n    }\n\n    @Test\n    public void testOpenOutputStreamWithSymbolicLink() throws Exception {\n        final Path symlinkedDir = createTempSymbolicLinkedRelativeDir().getLeft();\n        final File file = symlinkedDir.resolve(\"test.txt\").toFile();\n        try (final FileOutputStream out = FileUtils.openOutputStream(file)) {\n            out.write(0);\n        }\n        assertTrue(file.exists());\n    }\n}",
      "method_signature": "testOpenOutputStream_intoExistingSymlinkedDir()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 34792,
    "output_tokens": 5494,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 977,
      "description": "Define a test method that verifies `FileUtils.openOutputStream` creates parent directories and writes to a file that does not initially exist. In a setup method annotated with `@BeforeEach`, invoke `Files.createTempDirectory` passing `managedTempDirPath` and the result of `getClass().getSimpleName()` to obtain `tempDirPath`, then assign `tempDirPath.toFile()` to field `tempDirFile`. In another setup method, instantiate `testFile1` as a new `File` with arguments `tempDirFile` and String literal `\"file1-test.txt\"`, instantiate `testFile2` as a new `File` with arguments `tempDirFile` and String literal `\"file1a-test.txt\"`, assign `testFile1.length()` to `testFile1Size`, and assign `testFile2.length()` to `testFile2Size`. Check if `testFile1.getParentFile().exists()` returns false and if so invoke `fail` with a concatenated message including `testFile1`. Open a try-with-resources block creating `output3` as a new `BufferedOutputStream` wrapping `Files.newOutputStream(testFile1.toPath())`, then within the block define a private method that iterates from `i = 0` to `i < testFile1Size` invoking `output3.write((byte) (i % 127 + 1))` on each iteration, and invoke that method passing `output3` and `testFile1Size`. Repeat the parent existence check for `testFile2`, failing if necessary, then open another try-with-resources creating `output2` wrapping `Files.newOutputStream(testFile2.toPath())` and invoke the same iteration logic with `output2` and `testFile2Size`. Invoke `FileUtils.deleteDirectory` passing `tempDirFile`, then invoke `tempDirFile.mkdirs()`. Repeat the parent existence check for `testFile1` again, open a try-with-resources creating `output1` wrapping `Files.newOutputStream(testFile1.toPath())`, and invoke the iteration logic with `output1` and `testFile1Size`. Repeat the parent check for `testFile2`, open a try-with-resources creating `output` wrapping `Files.newOutputStream(testFile2.toPath())`, and invoke the iteration logic with `output` and `testFile2Size`. In the test method body, instantiate `file` as a new `File` with arguments `tempDirFile` and String literal `\"a/test.txt\"`. Open a try-with-resources block assigning the result of `FileUtils.openOutputStream(file)` to `out` of type `FileOutputStream`, then within the block invoke `out.write(0)`. After the try-with-resources closes, invoke `assertTrue` passing `file.exists()`. Annotate the test method with `@Test`, annotate the test class with `@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})`, and declare this test throws `Exception`.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_notExists()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenOutputStreamTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})\npublic class FileUtilsOpenOutputStreamTest {\n\n    private Path tempDirPath;\n    private File tempDirFile;\n    private File testFile1;\n    private File testFile2;\n    private long testFile1Size;\n    private long testFile2Size;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        tempDirPath = Files.createTempDirectory(getClass().getSimpleName());\n        tempDirFile = tempDirPath.toFile();\n\n        testFile1 = new File(tempDirFile, \"file1-test.txt\");\n        testFile2 = new File(tempDirFile, \"file1a-test.txt\");\n        testFile1Size = testFile1.length();\n        testFile2Size = testFile2.length();\n\n        if (!testFile1.getParentFile().exists()) {\n            fail(\"parent directory does not exist for \" + testFile1);\n        }\n        try (OutputStream output3 = new BufferedOutputStream(Files.newOutputStream(testFile1.toPath()))) {\n            writeJunk(output3, testFile1Size);\n        }\n\n        if (!testFile2.getParentFile().exists()) {\n            fail(\"parent directory does not exist for \" + testFile2);\n        }\n        try (OutputStream output2 = new BufferedOutputStream(Files.newOutputStream(testFile2.toPath()))) {\n            writeJunk(output2, testFile2Size);\n        }\n\n        FileUtils.deleteDirectory(tempDirFile);\n        tempDirFile.mkdirs();\n\n        if (!testFile1.getParentFile().exists()) {\n            fail(\"parent directory does not exist for \" + testFile1);\n        }\n        try (OutputStream output1 = new BufferedOutputStream(Files.newOutputStream(testFile1.toPath()))) {\n            writeJunk(output1, testFile1Size);\n        }\n\n        if (!testFile2.getParentFile().exists()) {\n            fail(\"parent directory does not exist for \" + testFile2);\n        }\n        try (OutputStream output = new BufferedOutputStream(Files.newOutputStream(testFile2.toPath()))) {\n            writeJunk(output, testFile2Size);\n        }\n    }\n\n    private void writeJunk(final OutputStream out, final long size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            out.write((byte) (i % 127 + 1));\n        }\n    }\n\n    @Test\n    public void testOpenOutputStreamCreatesParent() throws Exception {\n        final File file = new File(tempDirFile, \"a/test.txt\");\n        try (FileOutputStream out = FileUtils.openOutputStream(file)) {\n            out.write(0);\n        }\n        assertTrue(file.exists());\n    }\n}",
      "method_signature": "testOpenOutputStream_notExists()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 1.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 21698,
    "output_tokens": 6137,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 979,
      "description": "Define a test method annotated with `@Test` that verifies `FileUtils.openOutputStream` throws an `IOException` when attempting to create a file in a deeply nested, non-creatable directory structure. Begin by constructing a String variable `longStr` initialized to the concatenation of six repetitions of the literal `\"abcdevwxyzabcdevwxyzabcdevwxyzabcdevwxyzabcdevwxyz\"`, forming a 300-character string intended to exceed typical filesystem filename length limits. Next, instantiate a `File` variable `file` by invoking the `File` constructor with two arguments: the first argument is the field `tempDirFile` (a `File` representing the temporary directory established during setup), and the second argument is the String literal `\"a/\"` concatenated with `longStr` concatenated with `\"/test.txt\"`, producing a path like `\"a/<300-char-string>/test.txt\"`. Then invoke `assertThrows` with two arguments: the first argument is the class literal `IOException.class`, and the second argument is a lambda expression `() -> FileUtils.openOutputStream(file)` that attempts to open an output stream for the non-creatable file path. The assertion verifies that invoking `FileUtils.openOutputStream` with `file` as its argument throws an `IOException` due to the inability to create the necessary parent directories with excessively long path components. The test relies on a `@BeforeEach` setup method (inherited from `AbstractTempDirTest` and extended in the test class) that initializes `tempDirFile` by creating a temporary directory via `Files.createTempDirectory(managedTempDirPath, getClass().getSimpleName())` and converting the resulting `Path` to a `File` via `toPath().toFile()`, then populates `testFile1` and `testFile2` as `File` instances within `tempDirFile` (constructed via `new File(tempDirFile, \"file1-test.txt\")` and `new File(tempDirFile, \"file1a-test.txt\")`), assigns their lengths to `testFile1Size` and `testFile2Size` respectively via `testFile1.length()` and `testFile2.length()`, verifies parent directory existence by checking `testFile1.getParentFile().exists()` and invoking `fail` with a descriptive message if false, writes test data to each file by opening a `BufferedOutputStream` wrapping `Files.newOutputStream(testFile1.toPath())` in a try-with-resources block and invoking a private method that executes a loop from `i = 0` to `i < testFile1Size`, writing `(byte)(i % 127 + 1)` to the output stream on each iteration (repeat this process for `testFile2` with `testFile2Size`), then invokes `FileUtils.deleteDirectory(tempDirFile)` to remove the temporary directory and all its contents, recreates the directory structure by calling `tempDirFile.mkdirs()`, and repeats the file creation and data-writing steps for `testFile1` and `testFile2` to ensure a clean test environment. The test class is annotated with `@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})` to suppress warnings for deprecated method usage and ignored return values. The test uses JUnit 5 assertions (`assertThrows`) and does not employ any mocking libraries.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.FileUtilsTest",
      "method_signature": "testOpenOutputStream_notExistsCannotCreate()",
      "abstraction_level": "low",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.FileUtilsOpenOutputStreamWithInvalidPathTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link FileUtils} where the destination is a file in a deep non-existent directory.\n * <p>\n * N.B. This test has been written against a bespoke test description and may not\n * form part of the originally conceived test suite.\n * </p>\n *\n */\n@SuppressWarnings({\"deprecation\", \"ResultOfMethodCallIgnored\"})\npublic class FileUtilsOpenOutputStreamWithInvalidPathTest extends AbstractTempDirTest {\n\n    private File tempDirFile;\n    private File testFile1;\n    private File testFile2;\n    private long testFile1Size;\n    private long testFile2Size;\n\n    private void writeJunk(final File file, final long size) throws IOException {\n        try (final BufferedOutputStream bos = new BufferedOutputStream(Files.newOutputStream(file.toPath()))) {\n            for (int i = 0; i < size; i++) {\n                bos.write((byte) (i % 127 + 1));\n            }\n        }\n    }\n\n    @BeforeEach\n    public void beforeEach() throws Exception {\n        tempDirFile = Files.createTempDirectory(managedTempDirPath, getClass().getSimpleName()).toFile();\n        testFile1 = new File(tempDirFile, \"file1-test.txt\");\n        testFile2 = new File(tempDirFile, \"file1a-test.txt\");\n\n        testFile1Size = testFile1.length();\n        testFile2Size = testFile2.length();\n\n        if (!testFile1.getParentFile().exists()) {\n            fail(\"Cannot create file \" + testFile1 + \" as the parent directory does not exist\");\n        }\n        \n        writeJunk(testFile1, testFile1Size);\n        writeJunk(testFile2, testFile2Size);\n\n        FileUtils.deleteDirectory(tempDirFile);\n        tempDirFile.mkdirs();\n\n        writeJunk(testFile1, testFile1Size);\n        writeJunk(testFile2, testFile2Size);\n    }\n\n    @Test\n    public void testOpenOutputStreamWithInvalidPath() {\n        final String longStrPart = \"abcdevwxyzabcdevwxyzabcdevwxyzabcdevwxyzabcdevwxyz\";\n        final String longStr = longStrPart + longStrPart + longStrPart + longStrPart + longStrPart + longStrPart;\n        final File file = new File(tempDirFile, \"a/\" + longStr + \"/test.txt\");\n        assertThrows(IOException.class, () -> FileUtils.openOutputStream(file));\n    }\n}",
      "method_signature": "testOpenOutputStream_notExistsCannotCreate()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 23266,
    "output_tokens": 7553,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 991,
      "description": "Define a test method that validates argument constraints for the deprecated read method on IOUtils when provided with invalid combinations of an InputStream, a byte buffer, an offset, and a length, where the test is parameterized to cover multiple invalid argument scenarios supplied by a method source named \"invalidRead_InputStream_Offset_ArgumentsProvider\". Before all tests execute, invoke a static setup that calls the clear method on the IO utility class to reset any thread-local state, ensuring a clean testing environment. Before each individual test, configure a temporary folder using the JUnit TempDir extension, then construct a test file within that folder and populate it with generated test data of a predefined size by creating a buffered output stream to the file path and delegating to a helper utility that writes a varied byte pattern, after which initialize two arrays\u2014one byte array and one char array\u2014each filled with a default sentinel value and then partially overwritten with sequential values in their initial segments to serve as input data for subsequent tests. Within the parameterized test method, accept an InputStream instance, a byte array destination buffer, an integer offset, an integer length, and an expected exception class as parameters, then invoke the read method on IOUtils with the provided InputStream, buffer, offset, and length, asserting that the invocation throws an exception of the specified class to confirm that invalid argument combinations are properly rejected. After all tests complete, invoke the same static teardown that calls the clear method on the IO utility class to release any thread-local resources and ensure no adverse side effects persist when recycling thread locals. The test relies on JUnit 5 for parameterized testing and assertions.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testReadFully_InputStream_Offset_ArgumentsValidation(java.io.InputStream, byte[], int, int, java.lang.Class)",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsReadInvalidArgumentsTest",
      "code": "package org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests argument validation for {@link IOUtils#read(InputStream, byte[], int, int)}.\n */\npublic class IOUtilsReadInvalidArgumentsTest {\n\n    private static final int TEST_DATA_SIZE = 1024;\n\n    @TempDir\n    private Path tempDir;\n\n    private File testFile;\n    private byte[] byteData;\n    private char[] charData;\n\n    @BeforeEach\n    void setUp() throws IOException {\n        testFile = tempDir.resolve(\"test.txt\").toFile();\n        try (OutputStream out = new BufferedOutputStream(Files.newOutputStream(testFile.toPath()))) {\n            writeVariedBytes(out, TEST_DATA_SIZE);\n        }\n\n        byteData = new byte[100];\n        Arrays.fill(byteData, (byte) 0);\n        for (int i = 0; i < 10; i++) {\n            byteData[i] = (byte) i;\n        }\n\n        charData = new char[100];\n        Arrays.fill(charData, 'c');\n        for (int i = 0; i < 10; i++) {\n            charData[i] = (char) ('a' + i);\n        }\n    }\n\n    private void writeVariedBytes(final OutputStream out, final int size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            out.write((byte) (i % 256));\n        }\n    }\n\n    static Stream<Arguments> invalidRead_InputStream_Offset_ArgumentsProvider() {\n        final byte[] buffer = new byte[10];\n        // A non-null stream that is not used for data, just to be a valid parameter.\n        final InputStream inputStream = new ByteArrayInputStream(new byte[20]);\n\n        return Stream.of(\n            // Null stream\n            Arguments.of(null, buffer, 0, 5, NullPointerException.class),\n            // Negative offset\n            Arguments.of(inputStream, buffer, -1, 5, IndexOutOfBoundsException.class),\n            // Negative length\n            Arguments.of(inputStream, buffer, 0, -1, IndexOutOfBoundsException.class),\n            // Offset > buffer.length\n            Arguments.of(inputStream, buffer, 11, 0, IndexOutOfBoundsException.class),\n            // length > buffer.length - offset\n            Arguments.of(inputStream, buffer, 5, 6, IndexOutOfBoundsException.class)\n        );\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @ParameterizedTest\n    @MethodSource(\"invalidRead_InputStream_Offset_ArgumentsProvider\")\n    void testReadInvalidArguments(final InputStream inputStream, final byte[] buffer, final int offset, final int length, final Class<? extends Throwable> expectedException) {\n        assertThrows(expectedException, () -> IOUtils.read(inputStream, buffer, offset, length));\n    }\n}",
      "method_signature": "testReadFully_InputStream_Offset_ArgumentsValidation(java.io.InputStream, byte[], int, int, java.lang.Class)"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 1.0,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 34188,
    "output_tokens": 5796,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": true,
    "nl2test_input": {
      "id": 992,
      "description": "Define a test method that validates the behavior of the IOUtils byte array conversion method when the input stream terminates before the requested number of bytes can be read. Initialize a NullInputStream configured to produce zero bytes, simulating an immediate end-of-stream condition. Invoke the toByteArray method on IOUtils, passing the empty input stream and requesting a single byte to be read. Assert that this invocation throws an EOFException, confirming that the utility correctly detects and signals the premature stream termination when the actual available bytes fall short of the specified size parameter. Close the input stream resource to release any associated handles. This test exercises deprecated code paths and uses JUnit 5 and the standard assertion framework.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testToByteArray_InputStream_Size_Truncated()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsWithEOFTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.commons.io.input.NullInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests for {@link IOUtils} focusing on byte array conversion with premature stream termination.\n */\npublic class IOUtilsWithEOFTest {\n\n    /**\n     * This test validates that calling {@link IOUtils#toByteArray(InputStream, int)} on an input stream\n     * that terminates before the specified number of bytes can be read results in an {@link EOFException}.\n     * A {@link NullInputStream} is configured to provide zero bytes to simulate an immediate end-of-stream.\n     * The test ensures that the utility correctly signals this premature termination. The input stream\n     * is properly closed to prevent resource leaks. This test covers a deprecated method path.\n     *\n     * @throws IOException if an I/O error occurs during the test.\n     */\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void testToByteArrayWithImmediateEOF() throws IOException {\n        try (final InputStream inputStream = new NullInputStream(0)) {\n            assertThrows(EOFException.class, () -> {\n                IOUtils.toByteArray(inputStream, 1);\n            });\n        }\n    }\n}",
      "method_signature": "testToByteArray_InputStream_Size_Truncated()"
    },
    "structured_eval": {
      "obj_creation_recall": 1.0,
      "obj_creation_precision": 1.0,
      "assertion_recall": 1.0,
      "assertion_precision": 1.0,
      "callable_recall": 1.0,
      "callable_precision": 0.6667,
      "focal_recall": 0.0,
      "focal_precision": 1.0
    },
    "coverage_eval": {
      "class_coverage": 1.0,
      "method_coverage": 1.0,
      "line_coverage": 1.0,
      "branch_coverage": 1.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {
          "write_file": 1
        },
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 34601,
    "output_tokens": 3143,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  },
  {
    "compiles": false,
    "nl2test_input": {
      "id": 994,
      "description": "Define a test method that validates the content equality behavior when comparing a standard byte array input stream against a sequence input stream constructed from multiple segments, ensuring the IO utility correctly handles composite stream comparisons across various data distribution patterns. Before each test execution, initialize a temporary file within a test-managed directory and populate it with generated test data of a predefined size, then prepare two byte arrays initialized to negative one values and partially overwrite the first eighty elements with sequential byte and character values respectively. Invoke the content comparison method from the IO utility class multiple times with different byte array input stream and sequence input stream configurations to verify inequality scenarios where the composite stream contains mismatched data in either the first segment, second segment, or has differing total lengths including empty stream cases, asserting false for each mismatch. Subsequently verify equality scenarios by comparing streams with identical content distributed across segments in various ways including empty leading or trailing segments, asserting true when the composite stream's concatenated content matches the reference stream. For a more complex validation, construct a byte array by concatenating a thirty-three-byte prefix, the UTF-8 encoded contents of a text string written to the temporary file, and a two-byte suffix, then write this text content to the file and build an expected byte array combining all three segments in sequence using array copy operations. Compare a byte array input stream of the expected combined data against a sequence input stream that wraps an enumeration of three separate byte array input streams for the prefix, a file input stream reading the temporary file, and the suffix, asserting true to confirm the utility correctly validates equality when one stream reads from a file within a composite sequence. After all verifications complete, invoke the static cleanup method on the IO utility class to clear any thread-local state or internal buffers. This test uses JUnit 5 for test execution and assertion validation.",
      "project_name": "commons-io",
      "qualified_class_name": "org.apache.commons.io.IOUtilsTest",
      "method_signature": "testContentEqualsSequenceInputStream()",
      "abstraction_level": "medium",
      "is_bdd": false
    },
    "nl2test_metadata": {
      "qualified_test_class_name": "org.apache.commons.io.IOUtilsSequenceInputStreamTest",
      "code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.SequenceInputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.Collections;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Tests for {@link IOUtils} that use {@link SequenceInputStream}.\n */\npublic class IOUtilsSequenceInputStreamTest {\n\n    @Test\n    public void testContentEqualsWithSequenceInputStream(@TempDir final Path tempDir) throws IOException {\n        final File testFile = Files.createFile(tempDir.resolve(\"test.txt\")).toFile();\n\n        final byte[] ba1 = new byte[100];\n        final byte[] ba2 = new byte[100];\n        Arrays.fill(ba1, (byte) -1);\n        Arrays.fill(ba2, (byte) -1);\n        for (int i = 0; i < 80; i++) {\n            ba1[i] = (byte) i;\n            ba2[i] = (char) i;\n        }\n\n        // Inequality: Mismatch in first segment\n        try (InputStream is1 = new ByteArrayInputStream(ba1);\n             InputStream is2 = new SequenceInputStream(\n                 new ByteArrayInputStream(ba2, 0, 40),\n                 new ByteArrayInputStream(ba1, 40, 40))) {\n            assertFalse(IOUtils.contentEquals(is1, is2));\n        }\n\n        // Inequality: Mismatch in second segment\n        try (InputStream is1 = new ByteArrayInputStream(ba1);\n             InputStream is2 = new SequenceInputStream(\n                 new ByteArrayInputStream(ba1, 0, 40),\n                 new ByteArrayInputStream(ba2, 40, 40))) {\n            assertFalse(IOUtils.contentEquals(is1, is2));\n        }\n\n        // Inequality: Different lengths (composite stream is shorter)\n        try (InputStream is1 = new ByteArrayInputStream(ba1);\n             InputStream is2 = new SequenceInputStream(\n                 new ByteArrayInputStream(ba1, 0, 40),\n                 new ByteArrayInputStream(ba1, 40, 39))) {\n            assertFalse(IOUtils.contentEquals(is1, is2));\n        }\n\n        // Inequality: Different lengths (composite stream is longer)\n        try (InputStream is1 = new ByteArrayInputStream(ba1, 0, 80);\n             InputStream is2 = new SequenceInputStream(\n                 new ByteArrayInputStream(ba1, 0, 40),\n                 new ByteArrayInputStream(ba1, 40, 41))) {\n            assertFalse(IOUtils.contentEquals(is1, is2));\n        }\n        \n        // Inequality: Empty vs non-empty\n        try (InputStream is1 = new ByteArrayInputStream(ba1);\n             InputStream is2 = new SequenceInputStream(Collections.emptyEnumeration())) {\n            assertFalse(IOUtils.contentEquals(is1, is2));\n        }\n\n        // Equality: Identical content, various segment distributions\n        try (InputStream is1 = new ByteArrayInputStream(ba1, 0, 80);\n             InputStream is2 = new SequenceInputStream(\n                 new ByteArrayInputStream(ba1, 0, 40),\n                 new ByteArrayInputStream(ba1, 40, 40))) {\n            assertTrue(IOUtils.contentEquals(is1, is2));\n        }\n        try (InputStream is1 = new ByteArrayInputStream(ba1, 0, 80);\n             InputStream is2 = new SequenceInputStream(\n                 new ByteArrayInputStream(ba1, 0, 20),\n                 new ByteArrayInputStream(ba1, 20, 60))) {\n            assertTrue(IOUtils.contentEquals(is1, is2));\n        }\n\n        // Equality: Empty leading segment\n        try (InputStream is1 = new ByteArrayInputStream(ba1, 0, 80);\n             InputStream is2 = new SequenceInputStream(\n                 new ByteArrayInputStream(IOUtils.EMPTY_BYTE_ARRAY),\n                 new ByteArrayInputStream(ba1, 0, 80))) {\n            assertTrue(IOUtils.contentEquals(is1, is2));\n        }\n\n        // Equality: Empty trailing segment\n        try (InputStream is1 = new ByteArrayInputStream(ba1, 0, 80);\n             InputStream is2 = new SequenceInputStream(\n                 new ByteArrayInputStream(ba1, 0, 80),\n                 new ByteArrayInputStream(IOUtils.EMPTY_BYTE_ARRAY))) {\n            assertTrue(IOUtils.contentEquals(is1, is2));\n        }\n\n        // Complex validation with file stream\n        final byte[] prefix = new byte[33];\n        final byte[] suffix = new byte[2];\n        Arrays.fill(prefix, (byte) 7);\n        Arrays.fill(suffix, (byte) 8);\n\n        final String textContent = \"This is a test string for file content.\";\n        FileUtils.writeStringToFile(testFile, textContent, StandardCharsets.UTF_8);\n\n        final byte[] fileBytes = textContent.getBytes(StandardCharsets.UTF_8);\n        final byte[] expected = new byte[prefix.length + fileBytes.length + suffix.length];\n        System.arraycopy(prefix, 0, expected, 0, prefix.length);\n        System.arraycopy(fileBytes, 0, expected, prefix.length, fileBytes.length);\n        System.arraycopy(suffix, 0, expected, prefix.length + fileBytes.length, suffix.length);\n\n        try (InputStream is1 = new ByteArrayInputStream(expected);\n             InputStream is2 = new SequenceInputStream(Collections.enumeration(Arrays.asList(\n                 new ByteArrayInputStream(prefix),\n                 new FileInputStream(testFile),\n                 new ByteArrayInputStream(suffix)\n             )))) {\n            assertTrue(IOUtils.contentEquals(is1, is2));\n        } finally {\n            IOUtils.clear();\n        }\n    }\n}",
      "method_signature": "testContentEqualsSequenceInputStream()"
    },
    "structured_eval": {
      "obj_creation_recall": 0.0,
      "obj_creation_precision": 0.0,
      "assertion_recall": 0.0,
      "assertion_precision": 0.0,
      "callable_recall": 0.0,
      "callable_precision": 0.0,
      "focal_recall": 0.0,
      "focal_precision": 0.0
    },
    "coverage_eval": {
      "class_coverage": 0.0,
      "method_coverage": 0.0,
      "line_coverage": 0.0,
      "branch_coverage": 0.0
    },
    "localization_eval": null,
    "tool_log": {
      "supervisor_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "localization_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      },
      "composition_tool_log": {
        "tool_counts": {},
        "tool_trajectories": []
      }
    },
    "input_tokens": 0,
    "output_tokens": 0,
    "llm_calls": 0,
    "failed_test_file_generation": false,
    "failed_code_generation": false
  }
]