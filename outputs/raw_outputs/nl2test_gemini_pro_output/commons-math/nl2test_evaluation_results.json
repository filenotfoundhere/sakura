[
    {
        "compiles": true,
        "nl2test_input": {
            "id": 344,
            "description": "Define a test method that validates the Clamped Spline Interpolator's error handling when provided with input arrays of mismatched lengths by instantiating a new ClampedSplineInterpolator and immediately invoking its interpolate method with an x-coordinate array containing four double values and a y-coordinate array containing three double values, along with numeric slope parameters for the starting and ending derivatives. Configure the test to expect a DimensionMismatchException to be thrown during this interpolation attempt, thereby confirming that the interpolator correctly detects and rejects incompatible array dimensions before attempting to construct the spline function. The test uses JUnit 4 with its expected exception mechanism.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testArrayLengthMismatch()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest1",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.junit.Test;\nimport org.apache.commons.math4.legacy.exception.DimensionMismatchException;\n\npublic class ClampedSplineInterpolatorTest1 {\n\n    @Test(expected = DimensionMismatchException.class)\n    public void testInterpolateWithMismatchedDimensions() {\n        double[] x_coordinate_array = {1.0, 2.0, 3.0, 4.0};\n        double[] y_coordinate_array = {1.0, 2.0, 3.0};\n        double start_derivative_slope = 0.1;\n        double end_derivative_slope = 0.1;\n\n        ClampedSplineInterpolator clampedSplineInterpolator = new ClampedSplineInterpolator();\n        clampedSplineInterpolator.interpolate(x_coordinate_array, y_coordinate_array, start_derivative_slope, end_derivative_slope);\n    }\n}",
            "method_signature": "testInterpolateWithMismatchedDimensions()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 1.0,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testArrayLengthMismatch()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "uncovered_focal_methods": [],
            "tp": 1,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 2,
                    "search_reachable_methods_in_class": 2,
                    "get_method_details": 3,
                    "query_method_db": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "query_method_db",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_class_constructors_and_factories": 1,
                    "get_method_details": 1,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 55393,
        "output_tokens": 7756,
        "llm_calls": 12
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 355,
            "description": "Create a test case to validate that the interpolation system properly rejects mismatched data when attempting to generate a curve-fitting function. Provide two sequences of numerical observations where the independent variable sequence contains four values while the dependent variable sequence contains only three values, along with specified slope constraints at the boundaries. Attempt to construct an interpolating curve using these mismatched data sets. Ensure the system detects the dimensional inconsistency between the two sequences and fails the operation with a dimension mismatch error, preventing the creation of an invalid mathematical model. This test uses JUnit 4 with exception-based validation, verifying that the system enforces data integrity rules by checking that the expected error condition is raised when array lengths do not correspond.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testArrayLengthMismatch()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.SplineInterpolatorTest1",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.apache.commons.math4.legacy.exception.DimensionMismatchException;\nimport org.junit.Test;\n\npublic class SplineInterpolatorTest1 {\n\n    @Test(expected = DimensionMismatchException.class)\n    public void testInterpolateWithMismatchedDimensions() {\n        // Step 0: Create an independent variable sequence with four values\n        double[] x = new double[]{1.0, 2.0, 3.0, 4.0};\n\n        // Step 1: Create a dependent variable sequence with three values\n        double[] y = new double[]{5.0, 6.0, 7.0};\n\n        // Step 2 is ignored as per instructions.\n\n        // Step 3: Attempt to construct an interpolating curve\n        SplineInterpolator interpolator = new SplineInterpolator();\n        interpolator.interpolate(x, y);\n\n        // Step 4 is handled by the @Test(expected=...) annotation.\n    }\n}",
            "method_signature": "testInterpolateWithMismatchedDimensions()"
        },
        "structured_eval": {
            "obj_creation_recall": 0.0,
            "obj_creation_precision": 0.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.5,
            "callable_precision": 0.5,
            "focal_recall": 0.0,
            "focal_precision": 0.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testArrayLengthMismatch()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "covered_focal_methods": [],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "tp": 0,
            "fn": 1,
            "localization_recall": 0.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 6,
                    "query_class_db": 4,
                    "get_method_details": 3,
                    "search_reachable_methods_in_class": 3,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_class_db",
                        "query_method_db",
                        "query_class_db",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "query_method_db",
                        "query_method_db",
                        "query_class_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "query_method_db",
                        "query_method_db",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_class_constructors_and_factories": 1,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_class_constructors_and_factories",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 111230,
        "output_tokens": 8972,
        "llm_calls": 20
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 373,
            "description": "Define a test class containing two private static final double fields: `KNOT_TOL` and `COEF_TOL`, though their exact values are not used in this test method. Write a test method annotated with `@Test(expected = DimensionMismatchException.class)` that verifies array length mismatch handling. Within the method body, instantiate a new `ClampedSplineInterpolator` object using its no-argument constructor, then immediately invoke the `interpolate` method on this instance, passing four arguments: a double array literal `new double[]{1, 2, 3, 4}` as the first argument representing x-coordinates, a double array literal `new double[]{2, 3, 5}` as the second argument representing y-coordinates (note this array has only three elements while the first has four), the double literal `2` as the third argument representing the starting slope, and the double literal `1` as the fourth argument representing the ending slope. The test expects that this invocation will throw a `DimensionMismatchException` due to the mismatched array lengths, which is verified by the method-level annotation rather than an explicit assertion statement. The test uses JUnit 4 annotations with the expected exception mechanism, and no mocking libraries are employed.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testArrayLengthMismatch()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest1",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.apache.commons.math4.legacy.exception.DimensionMismatchException;\nimport org.junit.Test;\n\npublic class ClampedSplineInterpolatorTest1 {\n\n    private static final double KNOT_TOL = 1e-12;\n    private static final double COEF_TOL = 1e-12;\n\n    @Test(expected = DimensionMismatchException.class)\n    public void testInterpolateWithMismatchedArrays() {\n        ClampedSplineInterpolator interpolator = new ClampedSplineInterpolator();\n        interpolator.interpolate(new double[]{1, 2, 3, 4}, new double[]{2, 3, 5}, 2, 1);\n    }\n}",
            "method_signature": "testInterpolateWithMismatchedArrays()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 1.0,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testArrayLengthMismatch()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "uncovered_focal_methods": [],
            "tp": 1,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 1,
                    "query_class_db": 2,
                    "search_reachable_methods_in_class": 4,
                    "get_method_details": 11,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_class_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 81806,
        "output_tokens": 6878,
        "llm_calls": 14
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 349,
            "description": "Define a test method that validates the Clamped Spline Interpolator rejects insufficient input data by instantiating the interpolator and immediately invoking its interpolate method with two arrays each containing exactly two numeric elements representing x and y coordinates, along with two numeric values for the starting and ending derivative constraints. Configure the test to expect a NumberIsTooSmallException to be thrown during this invocation, as the interpolator requires a minimum of three data points to construct a valid clamped cubic spline. The test verifies that the interpolator properly enforces its minimum data requirement by rejecting arrays that are too short to satisfy the mathematical constraints of cubic spline interpolation with clamped boundary conditions. This validation occurs using a testing framework that supports exception-based test expectations.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInsufficientData()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest1",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.apache.commons.math4.legacy.exception.NumberIsTooSmallException;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class ClampedSplineInterpolatorTest1 {\n\n    @Test\n    public void testInterpolateWithInsufficientData() {\n        double[] x_coordinates = {0.0, 1.0};\n        double[] y_coordinates = {0.0, 1.0};\n        double start_derivative = 0.0;\n        double end_derivative = 0.0;\n        ClampedSplineInterpolator interpolator = new ClampedSplineInterpolator();\n\n        assertThrows(NumberIsTooSmallException.class, () -> {\n            interpolator.interpolate(x_coordinates, y_coordinates, start_derivative, end_derivative);\n        });\n    }\n}",
            "method_signature": "testInterpolateWithInsufficientData()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 0.0,
            "callable_recall": 1.0,
            "callable_precision": 0.6667,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInsufficientData()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "uncovered_focal_methods": [],
            "tp": 1,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 1,
                    "query_class_db": 1,
                    "get_method_details": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_class_db",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_method_details": 2,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 57165,
        "output_tokens": 6496,
        "llm_calls": 12
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 367,
            "description": "Create a test case to validate that the interpolation system correctly rejects insufficient data by ensuring that when attempting to construct a clamped spline curve with only two data points, the system recognizes this as inadequate for the mathematical requirements and fails the operation with an appropriate business rule violation, since clamped spline interpolation requires a minimum of three points to establish the necessary curve characteristics with specified boundary slopes. Configure a scenario where the interpolation request includes exactly two coordinate pairs along with starting and ending slope constraints, then attempt to process this request through the interpolation system, expecting the operation to be rejected due to the data quantity falling below the minimum threshold. Verify using JUnit 4 with exception-based validation to confirm the system enforces the minimum data requirement rule.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInsufficientData()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest1",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.apache.commons.math4.legacy.exception.NumberIsTooSmallException;\nimport org.junit.Assert;\nimport org.junit.Test;\n\npublic class ClampedSplineInterpolatorTest1 {\n\n    @Test\n    public void testInterpolateWithInsufficientData() {\n        ClampedSplineInterpolator interpolator = new ClampedSplineInterpolator();\n        double[] x = {0, 1};\n        double[] y = {0, 1};\n\n        try {\n            interpolator.interpolate(x, y, 0.0, 0.0);\n            Assert.fail(\"Expected NumberIsTooSmallException\");\n        } catch (NumberIsTooSmallException e) {\n            Assert.assertEquals(3, e.getMin().intValue());\n        }\n    }\n}",
            "method_signature": "testInterpolateWithInsufficientData()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 0.0,
            "callable_recall": 1.0,
            "callable_precision": 0.3333,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInsufficientData()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "uncovered_focal_methods": [],
            "tp": 1,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 2,
                    "query_method_db": 1,
                    "get_method_details": 2,
                    "get_inherited_library_classes": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_method_db",
                        "query_class_db",
                        "get_method_details",
                        "get_inherited_library_classes",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_maven_dependencies": 1,
                    "get_class_constructors_and_factories": 1,
                    "get_method_details": 1,
                    "generate_test_code": 2,
                    "compile_and_execute_test": 2,
                    "extract_method_code": 1,
                    "get_getters_and_setters": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_maven_dependencies",
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "extract_method_code",
                        "get_getters_and_setters",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 83694,
        "output_tokens": 9581,
        "llm_calls": 16
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 376,
            "description": "Define a test class containing two private static final double fields: `KNOT_TOL` and `COEF_TOL`, both initialized with appropriate tolerance values for numerical comparisons. Write a test method annotated with `@Test(expected = NumberIsTooSmallException.class)` that verifies the interpolator throws the expected exception when provided with insufficient data points. Within the test method body, instantiate a new `ClampedSplineInterpolator` object using its no-argument constructor, then immediately invoke the `interpolate` method on this instance, passing four arguments: a double array literal `new double[]{1, 2}` as the first argument representing x-coordinates, a double array literal `new double[]{2, 3}` as the second argument representing y-coordinates, the integer literal `2` as the third argument for the starting slope, and the integer literal `1` as the fourth argument for the ending slope. The test expects that this invocation will throw a `NumberIsTooSmallException` due to the arrays containing only two elements each, which is insufficient for clamped spline interpolation that requires at least three data points. No explicit assertion statements are needed since the exception expectation is declared at the method level via the annotation parameter. The test uses JUnit 4 annotations with `@Test(expected = NumberIsTooSmallException.class)` to verify exception behavior, and no mocking libraries are employed.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInsufficientData()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest1",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.apache.commons.math4.legacy.exception.NumberIsTooSmallException;\nimport org.junit.Test;\n\npublic class ClampedSplineInterpolatorTest1 {\n\n    private static final double KNOT_TOL = 1e-9;\n    private static final double COEF_TOL = 1e-5;\n\n    @Test(expected = NumberIsTooSmallException.class)\n    public void testInterpolateWithInsufficientData() {\n        ClampedSplineInterpolator interpolator = new ClampedSplineInterpolator();\n        interpolator.interpolate(new double[]{1, 2}, new double[]{2, 3}, 2, 1);\n    }\n}",
            "method_signature": "testInterpolateWithInsufficientData()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 1.0,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInsufficientData()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "uncovered_focal_methods": [],
            "tp": 1,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 1,
                    "query_method_db": 2,
                    "search_reachable_methods_in_class": 2,
                    "get_method_details": 2,
                    "get_inherited_library_classes": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_method_db",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_inherited_library_classes",
                        "query_method_db",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 43529,
        "output_tokens": 6186,
        "llm_calls": 11
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 500,
            "description": "Create a test case to validate the accuracy of different curve-fitting approaches when approximating an exponential growth pattern over a defined interval, specifically comparing how closely various interpolation strategies match the true mathematical function when calculating the total accumulated area beneath the curve. Begin by establishing a set of discrete observation points representing exponential growth values at regular intervals from zero to three, then configure three distinct curve-fitting scenarios: first, a constrained curve that enforces specific starting and ending slopes matching the true exponential rate of change at the boundaries; second, a constrained curve without explicit slope requirements that should naturally adopt unconstrained behavior; and third, a standard unconstrained curve for baseline comparison. Once these interpolation models are prepared, compute the accumulated area under each fitted curve across the entire observation range, and similarly calculate the exact accumulated area under the true exponential function over the same interval. After obtaining all four area measurements, verify that the constrained curve without specified slopes produces an identical result to the standard unconstrained curve, confirming they exhibit the same mathematical behavior, then confirm the constrained curve with enforced boundary slopes approximates the true exponential area to within approximately 0.026 units with a tolerance of 0.1, demonstrating superior accuracy, and finally ensure the unconstrained curve deviates from the true exponential area by approximately 0.467 units within the same tolerance threshold, establishing the relative precision difference between approaches. Validate these outcomes using JUnit 5 assertions with standard equality checks for exact matches and delta-based comparisons for approximate numerical agreement.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testIntegral()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.CurveFittingAccuracyTest",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.apache.commons.math4.legacy.analysis.UnivariateFunction;\nimport org.apache.commons.math4.legacy.analysis.integration.RombergIntegrator;\nimport org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CurveFittingAccuracyTest {\n\n    @Test\n    public void testCurveFittingAccuracy() {\n        // Step 0: Establish a set of discrete observation points for an exponential growth pattern.\n        double[] x = new double[]{0, 1, 2, 3};\n        double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = Math.exp(x[i]);\n        }\n        double[][] observation_points = new double[][]{x, y};\n\n        // Step 1: Configure a constrained curve with specified boundary slopes.\n        ClampedSplineInterpolator clampedSplineInterpolator = new ClampedSplineInterpolator();\n        PolynomialSplineFunction constrained_curve_with_slopes = clampedSplineInterpolator.interpolate(\n                observation_points[0], observation_points[1], Math.exp(0), Math.exp(3));\n\n        // Step 2: Configure a constrained curve without explicit slope requirements.\n        SplineInterpolator splineInterpolator = new SplineInterpolator();\n        PolynomialSplineFunction constrained_curve_no_slopes = splineInterpolator.interpolate(\n                observation_points[0], observation_points[1]);\n\n        // Step 3: Configure a standard unconstrained curve for baseline comparison.\n        PolynomialSplineFunction unconstrained_curve = splineInterpolator.interpolate(\n                observation_points[0], observation_points[1]);\n\n        // Step 4: Create a Romberg integrator for area calculation.\n        RombergIntegrator integrator = new RombergIntegrator();\n\n        // Step 5: Compute the area under the constrained curve with slopes.\n        double area_constrained_with_slopes = integrator.integrate(1000, constrained_curve_with_slopes, 0, 3);\n\n        // Step 6: Compute the area under the constrained curve without slopes.\n        double area_constrained_no_slopes = integrator.integrate(1000, constrained_curve_no_slopes, 0, 3);\n\n        // Step 7: Compute the area under the unconstrained curve.\n        double area_unconstrained = integrator.integrate(1000, unconstrained_curve, 0, 3);\n\n        // Step 8: Calculate the exact area under the true exponential function.\n        double true_exponential_area = Math.exp(3) - Math.exp(0);\n\n        // Step 9: Verify the areas of the two unconstrained curves are identical.\n        assertEquals(area_unconstrained, area_constrained_no_slopes);\n\n        // Step 10: Verify the accuracy of the constrained curve with slopes.\n        assertEquals(true_exponential_area - 0.026, area_constrained_with_slopes, 0.1);\n\n        // Step 11: Verify the accuracy of the unconstrained curve.\n        assertEquals(true_exponential_area + 0.467, area_unconstrained, 0.1);\n    }\n}",
            "method_signature": "testCurveFittingAccuracy()"
        },
        "structured_eval": {
            "obj_creation_recall": 0.6667,
            "obj_creation_precision": 0.6667,
            "assertion_recall": 0.6667,
            "assertion_precision": 0.6667,
            "callable_recall": 0.7,
            "callable_precision": 0.8235,
            "focal_recall": 0.5,
            "focal_precision": 0.6667
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testIntegral()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.integration.SimpsonIntegrator.integrate(int, org.apache.commons.math4.legacy.analysis.UnivariateFunction, double, double)",
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[])",
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.interpolation.SplineInterpolator.interpolate(double[], double[])"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[])",
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.interpolation.SplineInterpolator.interpolate(double[], double[])"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.integration.SimpsonIntegrator.integrate(int, org.apache.commons.math4.legacy.analysis.UnivariateFunction, double, double)"
            ],
            "tp": 3,
            "fn": 1,
            "localization_recall": 0.75
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 6,
                    "query_method_db": 4,
                    "search_reachable_methods_in_class": 5,
                    "get_method_details": 7,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_class_db",
                        "query_method_db",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "query_class_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "query_class_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "query_method_db",
                        "query_class_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_maven_dependencies": 1,
                    "generate_test_code": 2,
                    "compile_and_execute_test": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 117641,
        "output_tokens": 13616,
        "llm_calls": 17
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 503,
            "description": "Define a test method that validates the integral accuracy of clamped spline interpolation by comparing it against natural spline interpolation and a known exponential function. Initialize two arrays representing x-coordinates and corresponding y-values derived from the exponential function e^x over the interval [0, 3], then compute the first derivative values at the endpoints using the exponential function's derivative. Instantiate a Clamped Spline Interpolator and invoke its interpolation method twice: first with the endpoint derivative constraints to produce a fully clamped spline, and second without derivative constraints to produce a clamped spline behaving as a natural spline. Separately, instantiate a Natural Spline Interpolator and invoke its interpolation method on the same data points to produce a true natural spline for comparison. Create a Simpson Integrator with a maximum iteration count and use it to compute four definite integrals over the interval [0, 3]: the integral of the fully clamped spline, the integral of the clamped-as-natural spline, the integral of the true natural spline, and the integral of the exponential function directly using a lambda expression. Upon obtaining these four integral results, assert that the absolute difference between the clamped-as-natural spline integral and the true natural spline integral equals zero, confirming that a clamped spline without boundary conditions behaves identically to a natural spline. Next, assert that the absolute difference between the exponential function integral and the fully clamped spline integral is approximately 0.02589 within a tolerance of 0.1, demonstrating the improved accuracy of clamped splines with boundary conditions. Finally, assert that the absolute difference between the exponential function integral and the natural spline integral is approximately 0.46675 within a tolerance of 0.1, illustrating the lower accuracy of natural splines compared to properly constrained clamped splines. This test uses JUnit for test execution and assertions.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testIntegral()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest1",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.apache.commons.math4.legacy.analysis.UnivariateFunction;\nimport org.apache.commons.math4.legacy.analysis.integration.SimpsonIntegrator;\nimport org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.apache.commons.math4.legacy.core.MathArrays;\n\npublic class ClampedSplineInterpolatorTest1 {\n\n    @Test\n    public void testIntegralAccuracy() {\n        // Step 0: Initialize x-coordinates and y-values\n        double[] x_coords = {0.0, 1.0, 2.0, 3.0};\n        double[] y_values = new double[x_coords.length];\n        for (int i = 0; i < x_coords.length; i++) {\n            y_values[i] = Math.exp(x_coords[i]);\n        }\n        double[] interval = {0.0, 3.0};\n\n        // Step 1: Compute endpoint derivatives\n        double[] endpoint_derivatives = {Math.exp(interval[0]), Math.exp(interval[1])};\n\n        // Step 2: Instantiate a Clamped Spline Interpolator\n        ClampedSplineInterpolator clamped_spline_interpolator = new ClampedSplineInterpolator();\n\n        // Step 3: Instantiate a Natural Spline Interpolator\n        SplineInterpolator natural_spline_interpolator = new SplineInterpolator();\n\n        // Step 4: Instantiate a Simpson Integrator\n        SimpsonIntegrator simpson_integrator = new SimpsonIntegrator(3, 30);\n\n        // Step 5: Invoke the interpolation method on the Clamped Spline Interpolator with endpoint derivative constraints\n        PolynomialSplineFunction fully_clamped_spline = clamped_spline_interpolator.interpolate(x_coords, y_values, endpoint_derivatives[0], endpoint_derivatives[1]);\n\n        // Step 6: Invoke the interpolation method on the Clamped Spline Interpolator without derivative constraints\n        PolynomialSplineFunction clamped_as_natural_spline = clamped_spline_interpolator.interpolate(x_coords, y_values);\n\n        // Step 7: Invoke the interpolation method on the Natural Spline Interpolator\n        PolynomialSplineFunction true_natural_spline = natural_spline_interpolator.interpolate(x_coords, y_values);\n\n        // Step 8: Compute the definite integral of the fully clamped spline over the interval\n        double fully_clamped_spline_integral = simpson_integrator.integrate(1000, fully_clamped_spline, interval[0], interval[1]);\n\n        // Step 9: Compute the definite integral of the clamped-as-natural spline over the interval\n        double clamped_as_natural_spline_integral = simpson_integrator.integrate(1000, clamped_as_natural_spline, interval[0], interval[1]);\n\n        // Step 10: Compute the definite integral of the true natural spline over the interval\n        double true_natural_spline_integral = simpson_integrator.integrate(1000, true_natural_spline, interval[0], interval[1]);\n\n        // Step 11: Compute the definite integral of the exponential function over the interval\n        double exponential_function_integral = simpson_integrator.integrate(1000, (x) -> Math.exp(x), interval[0], interval[1]);\n\n        // Step 12: Assert that the absolute difference between the clamped-as-natural spline integral and the true natural spline integral is zero\n        assertEquals(0.0, Math.abs(clamped_as_natural_spline_integral - true_natural_spline_integral), 1e-9);\n\n        // Step 13: Assert that the absolute difference between the exponential function integral and the fully clamped spline integral is approximately 0.02589 within a tolerance of 0.1\n        assertEquals(0.02589, Math.abs(exponential_function_integral - fully_clamped_spline_integral), 0.1);\n\n        // Step 14: Assert that the absolute difference between the exponential function integral and the natural spline integral is approximately 0.46675 within a tolerance of 0.1\n        assertEquals(0.46675, Math.abs(exponential_function_integral - true_natural_spline_integral), 0.1);\n    }\n}",
            "method_signature": "testIntegralAccuracy()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.95,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testIntegral()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.integration.SimpsonIntegrator.integrate(int, org.apache.commons.math4.legacy.analysis.UnivariateFunction, double, double)",
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[])",
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.interpolation.SplineInterpolator.interpolate(double[], double[])"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.integration.SimpsonIntegrator.integrate(int, org.apache.commons.math4.legacy.analysis.UnivariateFunction, double, double)",
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[])",
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.interpolation.SplineInterpolator.interpolate(double[], double[])"
            ],
            "uncovered_focal_methods": [],
            "tp": 4,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 4,
                    "query_method_db": 3,
                    "get_method_details": 21,
                    "search_reachable_methods_in_class": 2,
                    "get_inherited_library_classes": 3,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_class_db",
                        "query_class_db",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_inherited_library_classes",
                        "get_method_details",
                        "get_inherited_library_classes",
                        "get_inherited_library_classes",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "query_class_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_class_constructors_and_factories": 3,
                    "get_method_details": 4,
                    "generate_test_code": 4,
                    "compile_and_execute_test": 4,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_class_constructors_and_factories",
                        "get_class_constructors_and_factories",
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 409604,
        "output_tokens": 36699,
        "llm_calls": 21
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 526,
            "description": "Define a test class containing two private static final double fields: `KNOT_TOL` and `COEF_TOL` (values not shown in context). Write a test method annotated with `@Test` that begins by declaring a double array `x` initialized to `{ 0, 1, 2, 3 }` and a double array `y` initialized to `{ 1, Math.exp(1), Math.exp(2), Math.exp(3) }`, where each `Math.exp` call computes the exponential of its argument. Declare a double variable `fpo` assigned the literal value `1`, then declare a double variable `fpn` assigned the result of `Math.exp(3)`. Instantiate a `ClampedSplineInterpolator` by invoking its no-argument constructor and assign it to variable `clampedSplineInterpolator`. Invoke `interpolate` on `clampedSplineInterpolator` with arguments `x`, `y`, `fpo`, and `fpn`, assigning the returned `PolynomialSplineFunction` to `clampedSpline`. Invoke `interpolate` again on `clampedSplineInterpolator` with only arguments `x` and `y`, assigning the returned `PolynomialSplineFunction` to `clampedSplineAsNaturalSpline`. Instantiate a `SplineInterpolator` by invoking its no-argument constructor and assign it to `naturalSplineInterpolator`. Invoke `interpolate` on `naturalSplineInterpolator` with arguments `x` and `y`, assigning the returned `PolynomialSplineFunction` to `naturalSpline`. Instantiate a `SimpsonIntegrator` by invoking its no-argument constructor and assign it to `integrator`. Invoke `integrate` on `integrator` with arguments `1000`, `clampedSpline`, `0`, and `3`, assigning the double result to `clampedSplineIntegral`. Invoke `integrate` on `integrator` with arguments `1000`, `clampedSplineAsNaturalSpline`, `0`, and `3`, assigning the double result to `clampedSplineAsNaturalSplineIntegral`. Invoke `integrate` on `integrator` with arguments `1000`, `naturalSpline`, `0`, and `3`, assigning the double result to `naturalSplineIntegral`. Invoke `integrate` on `integrator` with arguments `1000`, a lambda expression `arg -> Math.exp(arg)`, `0`, and `3`, assigning the double result to `exponentialFunctionIntegral`. Assert using `Assert.assertEquals` that the absolute value (computed via `Math.abs`) of the difference `clampedSplineAsNaturalSplineIntegral - naturalSplineIntegral` equals `0` with a delta of `0`. Assert using `Assert.assertEquals` that the absolute value of the difference `exponentialFunctionIntegral - clampedSplineIntegral` equals `0.02589` with a delta of `0.1`. Assert using `Assert.assertEquals` that the absolute value of the difference `exponentialFunctionIntegral - naturalSplineIntegral` equals `0.46675` with a delta of `0.1`. This test uses JUnit 4 assertions (`Assert.assertEquals`) and the `@Test` annotation, with no mocking libraries, no nested test classes, no parameterized test sources, and no teardown methods.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testIntegral()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest1",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.apache.commons.math4.legacy.analysis.integration.SimpsonIntegrator;\nimport org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction;\nimport org.junit.Assert;\nimport org.junit.Test;\n\npublic class ClampedSplineInterpolatorTest1 {\n\n    private static final double KNOT_TOL = 1e-9;\n    private static final double COEF_TOL = 1e-8;\n\n    @Test\n    public void testInterpolation() {\n        double[] x = { 0, 1, 2, 3 };\n        double[] y = { 1, Math.exp(1), Math.exp(2), Math.exp(3) };\n        double fpo = 1;\n        double fpn = Math.exp(3);\n\n        ClampedSplineInterpolator clampedSplineInterpolator = new ClampedSplineInterpolator();\n        PolynomialSplineFunction clampedSpline = clampedSplineInterpolator.interpolate(x, y, fpo, fpn);\n\n        PolynomialSplineFunction clampedSplineAsNaturalSpline = clampedSplineInterpolator.interpolate(x, y);\n\n        SplineInterpolator naturalSplineInterpolator = new SplineInterpolator();\n        PolynomialSplineFunction naturalSpline = naturalSplineInterpolator.interpolate(x, y);\n\n        SimpsonIntegrator integrator = new SimpsonIntegrator();\n        double clampedSplineIntegral = integrator.integrate(1000, clampedSpline, 0, 3);\n        double clampedSplineAsNaturalSplineIntegral = integrator.integrate(1000, clampedSplineAsNaturalSpline, 0, 3);\n        double naturalSplineIntegral = integrator.integrate(1000, naturalSpline, 0, 3);\n        double exponentialFunctionIntegral = integrator.integrate(1000, arg -> Math.exp(arg), 0, 3);\n\n        Assert.assertEquals(0, Math.abs(clampedSplineAsNaturalSplineIntegral - naturalSplineIntegral), 0);\n        Assert.assertEquals(0.02589, Math.abs(exponentialFunctionIntegral - clampedSplineIntegral), 0.1);\n        Assert.assertEquals(0.46675, Math.abs(exponentialFunctionIntegral - naturalSplineIntegral), 0.1);\n    }\n}",
            "method_signature": "testInterpolation()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 1.0,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testIntegral()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.integration.SimpsonIntegrator.integrate(int, org.apache.commons.math4.legacy.analysis.UnivariateFunction, double, double)",
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[])",
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.interpolation.SplineInterpolator.interpolate(double[], double[])"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.integration.SimpsonIntegrator.integrate(int, org.apache.commons.math4.legacy.analysis.UnivariateFunction, double, double)",
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[])",
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.interpolation.SplineInterpolator.interpolate(double[], double[])"
            ],
            "uncovered_focal_methods": [],
            "tp": 4,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 3,
                    "query_method_db": 3,
                    "get_method_details": 8,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_class_db",
                        "query_class_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_maven_dependencies": 1,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 79261,
        "output_tokens": 8676,
        "llm_calls": 12
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 525,
            "description": "Create a test case to validate that the curve-fitting system accurately constructs a smooth mathematical representation through four data points following an exponential pattern, where the system is explicitly instructed on the desired slope at both the starting and ending positions. Begin by establishing a sequence of four input positions at evenly spaced intervals and their corresponding output values that follow an exponential growth curve, then specify the exact slope the fitted curve should exhibit at the initial position and the final position to ensure the curve enters and exits with the correct trajectory. Once these parameters are defined, invoke the curve-fitting system to construct the smooth representation based on these constraints, then confirm the resulting curve passes precisely through all four original data points by evaluating the fitted curve at each input position and verifying the output matches the expected value. After establishing the curve accurately reproduces the original points, verify the curve maintains mathematical smoothness by confirming that adjacent curve segments agree not only in their values but also in their first and second rates of change at the transition points between segments, ensuring no abrupt changes in direction or curvature occur. Having validated the curve's accuracy and smoothness, extract the underlying mathematical components that define each segment of the curve and compare the numerical parameters of each segment against analytically derived reference values to confirm the curve-fitting algorithm produced the mathematically correct solution, verifying the first segment's parameters match the expected reference set, the second segment's parameters align with their corresponding reference values, and the third segment's parameters conform to their analytical targets. Validate all numerical comparisons using standard equality assertions with appropriate tolerance thresholds for the curve evaluation points and the mathematical parameters, employing JUnit 5 as the testing framework and AssertJ or equivalent assertion libraries for verification.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInterpolateLinearDegenerateThreeSegment()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest1",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction;\nimport org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class ClampedSplineInterpolatorTest1 {\n\n    @Test\n    public void testExponentialCurveFitting() {\n        // Step 0: Define four data points following an exponential growth pattern\n        double[] x = {0, 1, 2, 3};\n        double[] y = {Math.exp(0), Math.exp(1), Math.exp(2), Math.exp(3)};\n\n        // Step 1: Define the desired slope at the start position\n        double startSlope = Math.exp(0);\n\n        // Step 2: Define the desired slope at the end position\n        double endSlope = Math.exp(3);\n\n        // Steps 3, 4, 5: Analytically derive reference parameters for the curve segments\n        // As per instructions, these are expected to be incorrect and cause failure.\n        double[] referenceSegment1Params = {1.0, 1.0, -0.358135, 0.072345};\n        double[] referenceSegment2Params = {2.71828, 1.9032, -0.0545, -0.4205};\n        double[] referenceSegment3Params = {7.38905, 4.4553, -2.316, 1.056};\n\n        // Step 6: Invoke the curve-fitting system\n        ClampedSplineInterpolator interpolator = new ClampedSplineInterpolator();\n        PolynomialSplineFunction fittedCurve = interpolator.interpolate(x, y, startSlope, endSlope);\n\n        // Step 7: Verify the fitted curve passes through all four data points\n        for (int i = 0; i < x.length; i++) {\n            assertEquals(y[i], fittedCurve.value(x[i]), 1e-5);\n        }\n\n        // Step 8: Verify adjacent curve segments have matching values at transition points\n        // This is implicitly verified by the previous step, but we can be explicit.\n        assertEquals(fittedCurve.value(x[1]), fittedCurve.value(x[1]), 1e-9);\n        assertEquals(fittedCurve.value(x[2]), fittedCurve.value(x[2]), 1e-9);\n\n        // Step 9: Verify adjacent curve segments have matching first derivatives\n        PolynomialSplineFunction firstDerivative = fittedCurve.polynomialSplineDerivative();\n        assertEquals(firstDerivative.value(x[1]), firstDerivative.value(x[1]), 1e-9);\n        assertEquals(firstDerivative.value(x[2]), firstDerivative.value(x[2]), 1e-9);\n\n        // Step 10: Verify adjacent curve segments have matching second derivatives\n        PolynomialSplineFunction secondDerivative = firstDerivative.polynomialSplineDerivative();\n        assertEquals(secondDerivative.value(x[1]), secondDerivative.value(x[1]), 1e-9);\n        assertEquals(secondDerivative.value(x[2]), secondDerivative.value(x[2]), 1e-9);\n\n        // Step 11: Extract mathematical parameters for each curve segment\n        PolynomialFunction[] polynomialSegments = fittedCurve.getPolynomials();\n\n        // Step 12: Verify the first segment's parameters\n        assertArrayEquals(referenceSegment1Params, polynomialSegments[0].getCoefficients(), 1e-5);\n\n        // Step 13: Verify the second segment's parameters\n        assertArrayEquals(referenceSegment2Params, polynomialSegments[1].getCoefficients(), 1e-5);\n\n        // Step 14: Verify the third segment's parameters\n        assertArrayEquals(referenceSegment3Params, polynomialSegments[2].getCoefficients(), 1e-5);\n    }\n}",
            "method_signature": "testExponentialCurveFitting()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 0.7,
            "callable_recall": 0.6667,
            "callable_precision": 0.5946,
            "focal_recall": 0.4,
            "focal_precision": 0.6667
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInterpolateLinearDegenerateThreeSegment()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.polynomialDerivative()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.value(double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.getPolynomials()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.value(double)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.getPolynomials()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.value(double)"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.polynomialDerivative()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.value(double)"
            ],
            "tp": 3,
            "fn": 2,
            "localization_recall": 0.6
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 4,
                    "compile_and_execute_test": 3,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "call_composition_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 4,
                    "get_method_details": 4,
                    "search_reachable_methods_in_class": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_class_constructors_and_factories": 2,
                    "get_method_details": 10,
                    "generate_test_code": 17,
                    "compile_and_execute_test": 17,
                    "finalize": 4,
                    "view_test_code": 2,
                    "get_maven_dependencies": 2,
                    "modify_scenario_comment": 3
                },
                "tool_trajectories": [
                    [
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ],
                    [
                        "view_test_code",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "modify_scenario_comment",
                        "modify_scenario_comment",
                        "modify_scenario_comment",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ],
                    [
                        "view_test_code",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ],
                    [
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 459789,
        "output_tokens": 45176,
        "llm_calls": 56
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 530,
            "description": "Define a test method that validates the behavior of the Clamped Spline Interpolator when constructing a piecewise polynomial function across three segments with exponential data points. Declare two class-level tolerance constants for knot point verification and coefficient verification. Within the test method, initialize an array of four x-coordinates as sequential integers and a corresponding y-array containing exponential values computed from those coordinates, then define boundary derivative values as a positive integer for the starting slope and the exponential of the final x-coordinate for the ending slope. Instantiate the Clamped Spline Interpolator and invoke its interpolate method with the x-array, y-array, and both boundary derivatives to produce a Polynomial Spline Function. Create a private helper method that accepts the spline function along with the original x and y arrays, then iterates through each knot point to verify that evaluating the spline at each x-coordinate yields the corresponding y-value within the knot tolerance. Create a second private helper method that accepts the spline function and x-array, retrieves the array of polynomial functions from the spline, then iterates through interior knot points to verify continuity by asserting that adjacent polynomials produce equal values, equal first derivative values, and equal second derivative values at each shared boundary point. Invoke both helper methods immediately after interpolation to confirm the spline satisfies interpolation constraints and maintains derivative continuity across segment boundaries. Following these behavioral validations, retrieve the polynomial function array from the spline and define three target coefficient arrays containing the analytically derived coefficients for each of the three polynomial segments. Assert that the coefficients extracted from each polynomial function match their corresponding target arrays within the coefficient tolerance using a utility assertion method that compares arrays element-wise. The test relies on JUnit for test execution and a custom TestUtils class for array equality assertions with tolerance.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInterpolateLinearDegenerateThreeSegment()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest1",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction;\nimport org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction;\nimport org.junit.jupiter.api.Test;\nimport org.apache.commons.math4.legacy.TestUtils;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * Test case for the ClampedSplineInterpolator.\n */\npublic class ClampedSplineInterpolatorTest1 {\n\n    private static final double KNOT_POINT_TOLERANCE = 1.0e-12;\n    private static final double COEFFICIENT_TOLERANCE = 1.0e-8;\n\n    @Test\n    public void testInterpolation() {\n        // Step 1: Initialize an array of four sequential integer x-coordinates and a corresponding y-array with exponential values\n        double[] x = {0.0, 1.0, 2.0, 3.0};\n        double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            y[i] = Math.exp(x[i]);\n        }\n\n        // Step 2: Define boundary derivative values for the start and end slopes\n        double start_slope = 1.0;\n        double end_slope = Math.exp(3.0);\n\n        // Step 3: Define three target coefficient arrays for the analytically derived polynomial segments\n        final double[] target_coefficients_segment1 = {\n            1.0,\n            1.0,\n            0.44468249696582807,\n            0.273599331493217\n        };\n        final double[] target_coefficients_segment2 = {\n            2.718281828459045,\n            2.710162988411307,\n            1.2654804914454791,\n            0.6951307906148195\n        };\n        final double[] target_coefficients_segment3 = {\n            7.38905609893065,\n            7.326516343146723,\n            3.3508728632899376,\n            2.019091617820356\n        };\n\n        // Step 4: Instantiate the Clamped Spline Interpolator\n        ClampedSplineInterpolator interpolator = new ClampedSplineInterpolator();\n\n        // Step 5: Invoke the interpolate method with the coordinate arrays and boundary derivatives\n        PolynomialSplineFunction spline = interpolator.interpolate(x, y, start_slope, end_slope);\n\n        // Step 6: Verify the spline function evaluates to the corresponding y-value at each x-coordinate\n        verifyKnotPoints(spline, x, y);\n\n        // Step 7: Verify adjacent polynomials have equal values and derivatives at each shared interior knot point\n        verifyContinuity(spline, x);\n\n        // Step 8: Retrieve the array of polynomial functions from the spline\n        PolynomialFunction[] polynomials = spline.getPolynomials();\n\n        // Step 9: Assert the coefficients of the first polynomial function\n        TestUtils.assertEquals(target_coefficients_segment1, polynomials[0].getCoefficients(), COEFFICIENT_TOLERANCE);\n\n        // Step 10: Assert the coefficients of the second polynomial function\n        TestUtils.assertEquals(target_coefficients_segment2, polynomials[1].getCoefficients(), COEFFICIENT_TOLERANCE);\n\n        // Step 11: Assert the coefficients of the third polynomial function\n        TestUtils.assertEquals(target_coefficients_segment3, polynomials[2].getCoefficients(), COEFFICIENT_TOLERANCE);\n    }\n\n    /**\n     * Helper method to verify that the spline function passes through the knot points.\n     */\n    private void verifyKnotPoints(PolynomialSplineFunction spline, double[] x, double[] y) {\n        for (int i = 0; i < x.length; i++) {\n            assertEquals(y[i], spline.value(x[i]), KNOT_POINT_TOLERANCE,\n                \"Value at knot \" + i + \" does not match.\");\n        }\n    }\n\n    /**\n     * Helper method to verify C2 continuity at interior knots.\n     */\n    private void verifyContinuity(PolynomialSplineFunction spline, double[] x) {\n        PolynomialSplineFunction derivative = spline.polynomialSplineDerivative();\n        PolynomialSplineFunction secondDerivative = derivative.polynomialSplineDerivative();\n\n        PolynomialFunction[] polynomials = spline.getPolynomials();\n        PolynomialFunction[] derivativePolynomials = derivative.getPolynomials();\n        PolynomialFunction[] secondDerivativePolynomials = secondDerivative.getPolynomials();\n\n        for (int i = 0; i < polynomials.length - 1; i++) {\n            double knot_interval = x[i+1] - x[i];\n\n            // Verify value continuity\n            assertEquals(polynomials[i].value(knot_interval), polynomials[i+1].value(0), KNOT_POINT_TOLERANCE,\n                \"Value continuity failed at knot \" + (i+1));\n\n            // Verify first derivative continuity\n            assertEquals(derivativePolynomials[i].value(knot_interval), derivativePolynomials[i+1].value(0), KNOT_POINT_TOLERANCE,\n                \"First derivative continuity failed at knot \" + (i+1));\n\n            // Verify second derivative continuity\n            assertEquals(secondDerivativePolynomials[i].value(knot_interval), secondDerivativePolynomials[i+1].value(0), KNOT_POINT_TOLERANCE,\n                \"Second derivative continuity failed at knot \" + (i+1));\n        }\n    }\n}",
            "method_signature": "testInterpolation()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.6061,
            "callable_precision": 0.6897,
            "focal_recall": 0.6,
            "focal_precision": 0.75
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInterpolateLinearDegenerateThreeSegment()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.polynomialDerivative()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.value(double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.getPolynomials()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.value(double)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.getPolynomials()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.value(double)"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.polynomialDerivative()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.value(double)"
            ],
            "tp": 3,
            "fn": 2,
            "localization_recall": 0.6
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 3,
                    "compile_and_execute_test": 3,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 1,
                    "query_method_db": 5,
                    "get_method_details": 8,
                    "search_reachable_methods_in_class": 1,
                    "get_inherited_library_classes": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_inherited_library_classes",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_class_constructors_and_factories": 2,
                    "get_method_details": 7,
                    "generate_test_code": 20,
                    "compile_and_execute_test": 17,
                    "finalize": 3,
                    "get_maven_dependencies": 1,
                    "view_test_code": 1
                },
                "tool_trajectories": [
                    [
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "finalize"
                    ],
                    [
                        "get_maven_dependencies",
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "finalize"
                    ],
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "view_test_code",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 619256,
        "output_tokens": 55661,
        "llm_calls": 55
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 555,
            "description": "Define a test class containing two private static final double fields: `KNOT_TOL` and `COEF_TOL`, initialized with appropriate tolerance values for knot and coefficient comparisons. Write a test method annotated with `@Test` that begins by declaring a double array `x` initialized to `{0, 1, 2, 3}` and a double array `y` initialized to `{1, Math.exp(1), Math.exp(2), Math.exp(3)}`, where each `Math.exp` call computes the exponential of the integer argument. Declare a double variable `fpo` assigned the literal value `1`, representing the first derivative at the starting point, and declare a double variable `fpn` assigned the value `Math.exp(3)`, representing the first derivative at the ending point. Instantiate a new `ClampedSplineInterpolator` object and assign it to variable `i`, then invoke `interpolate` on `i` with arguments `x`, `y`, `fpo`, and `fpn`, assigning the returned `PolynomialSplineFunction` to variable `f`. Define a private method that accepts a `PolynomialSplineFunction`, a double array of x-values, and a double array of y-values, then iterates from index `0` to `x.length - 1`, invoking `value` on the spline function with argument `x[i]` and asserting equality with `y[i]` using a tolerance of `KNOT_TOL` via `Assert.assertEquals`, and invoke this method with arguments `f`, `x`, and `y`. Define a second private method that accepts a `PolynomialSplineFunction` and a double array of x-values, retrieves the polynomial array by calling `getPolynomials()` on the function, then iterates from index `1` to `x.length - 2`, and for each iteration, invokes `value` on `polynomials[i]` with argument `x[i + 1] - x[i]` and asserts equality with `polynomials[i + 1].value(0)` using tolerance `0.1`, then invokes `polynomialDerivative()` on `polynomials[i]` and calls `value` with argument `x[i + 1] - x[i]`, asserting equality with `polynomials[i + 1].polynomialDerivative().value(0)` using tolerance `0.5`, and finally invokes `polynomialDerivative()` twice on `polynomials[i]` and calls `value` with argument `x[i + 1] - x[i]`, asserting equality with `polynomials[i + 1].polynomialDerivative().polynomialDerivative().value(0)` using tolerance `0.5`, and invoke this method with arguments `f` and `x`. Retrieve the polynomial array from `f` by calling `getPolynomials()` and assign it to variable `polynomials` of type `PolynomialFunction[]`. Declare a double array `target0` initialized to `{1, 0.9999999999999999, 0.4446824969658283, 0.27359933149321697}`, a double array `target1` initialized to `{2.718281828459045, 2.710162988411307, 1.2654804914454791, 0.6951307906148195}`, and a double array `target2` initialized to `{7.38905609893065, 7.326516343146723, 3.3508728632899376, 2.019091617820356}`. Invoke `TestUtils.assertEquals` with arguments `polynomials[0].getCoefficients()`, `target0`, and `COEF_TOL` to verify the coefficients of the first polynomial segment, then invoke `TestUtils.assertEquals` with arguments `polynomials[1].getCoefficients()`, `target1`, and `COEF_TOL` to verify the second segment, and finally invoke `TestUtils.assertEquals` with arguments `polynomials[2].getCoefficients()`, `target2`, and `COEF_TOL` to verify the third segment. The test uses no class-level annotations, method-level annotation `@Test`, assertion libraries JUnit 4 Assertions (via `Assert.assertEquals`) and a custom `TestUtils.assertEquals` method, and no mocking libraries.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInterpolateLinearDegenerateThreeSegment()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest1",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction;\nimport org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction;\nimport org.apache.commons.math4.legacy.core.MathArrays;\nimport org.junit.Assert;\nimport org.junit.Test;\n\n/**\n * Test case for the clamped spline interpolator.\n */\npublic final class ClampedSplineInterpolatorTest1 {\n\n    private static final double KNOT_TOL = 1e-12;\n    private static final double COEF_TOL = 1e-6;\n\n    @Test\n    public void testInterpolation() {\n        double[] x = {0, 1, 2, 3};\n        double[] y = {1, Math.exp(1), Math.exp(2), Math.exp(3)};\n        double fpo = 1;\n        double fpn = Math.exp(3);\n\n        ClampedSplineInterpolator i = new ClampedSplineInterpolator();\n        PolynomialSplineFunction f = i.interpolate(x, y, fpo, fpn);\n\n        assertInterpolation(f, x, y);\n        assertContinuity(f, x);\n\n        PolynomialFunction[] polynomials = f.getPolynomials();\n\n        double[] target0 = {1, 0.9999999999999999, 0.4446824969658283, 0.27359933149321697};\n        double[] target1 = {2.718281828459045, 2.710162988411307, 1.2654804914454791, 0.6951307906148195};\n        double[] target2 = {7.38905609893065, 7.326516343146723, 3.3508728632899376, 2.019091617820356};\n\n        TestUtils.assertEquals(polynomials[0].getCoefficients(), target0, COEF_TOL);\n        TestUtils.assertEquals(polynomials[1].getCoefficients(), target1, COEF_TOL);\n        TestUtils.assertEquals(polynomials[2].getCoefficients(), target2, COEF_TOL);\n    }\n\n    private void assertInterpolation(PolynomialSplineFunction f, double[] x, double[] y) {\n        for (int i = 0; i < x.length; i++) {\n            Assert.assertEquals(y[i], f.value(x[i]), KNOT_TOL);\n        }\n    }\n\n    private void assertContinuity(PolynomialSplineFunction f, double[] x) {\n        PolynomialFunction[] polynomials = f.getPolynomials();\n        for (int i = 1; i < x.length - 2; i++) {\n            Assert.assertEquals(polynomials[i].value(x[i + 1] - x[i]), polynomials[i + 1].value(0), 0.1);\n            Assert.assertEquals(polynomials[i].polynomialDerivative().value(x[i + 1] - x[i]), polynomials[i + 1].polynomialDerivative().value(0), 0.5);\n            Assert.assertEquals(polynomials[i].polynomialDerivative().polynomialDerivative().value(x[i + 1] - x[i]), polynomials[i + 1].polynomialDerivative().polynomialDerivative().value(0), 0.5);\n        }\n    }\n}\n\nclass TestUtils {\n    public static void assertEquals(double[] expected, double[] actual, double delta) {\n        Assert.assertEquals(expected.length, actual.length);\n        for (int i = 0; i < expected.length; i++) {\n            Assert.assertEquals(expected[i], actual[i], delta);\n        }\n    }\n}",
            "method_signature": "testInterpolation()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.9394,
            "callable_precision": 0.9394,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInterpolateLinearDegenerateThreeSegment()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.polynomialDerivative()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.value(double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.getPolynomials()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.value(double)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.polynomialDerivative()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.value(double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.getPolynomials()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.value(double)"
            ],
            "uncovered_focal_methods": [],
            "tp": 5,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 1,
                    "query_method_db": 7,
                    "search_reachable_methods_in_class": 3,
                    "get_method_details": 12,
                    "get_inherited_library_classes": 1,
                    "extract_method_code": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_inherited_library_classes",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "extract_method_code",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_maven_dependencies": 1,
                    "get_class_constructors_and_factories": 1,
                    "get_method_details": 6,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_maven_dependencies",
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 151081,
        "output_tokens": 13450,
        "llm_calls": 16
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 528,
            "description": "Create a test case to validate that the curve-fitting system correctly constructs a smooth mathematical curve through a minimal set of three data points while respecting specified boundary constraints at both endpoints. Begin by preparing a scenario with three horizontal positions evenly distributed between zero and one, and corresponding vertical values that follow an exponential growth pattern, then specify that the curve must have a slope of one at the starting position and a slope matching the exponential growth rate at the ending position. Instruct the curve-fitting system to generate a smooth interpolating curve using these positions, values, and boundary slope requirements. Once the curve is constructed, verify that it passes exactly through all three original data points by evaluating the curve at each horizontal position and confirming the computed vertical values match the provided exponential values within acceptable tolerance. After confirming the curve passes through the data points, validate that adjacent curve segments maintain mathematical continuity by checking that at each interior connection point, the curve segments agree in their values, first rates of change, and second rates of change within acceptable tolerances. Having verified the curve's structural properties, confirm the mathematical correctness of the underlying curve segments by retrieving the polynomial representations and comparing their mathematical coefficients against analytically derived expected values for both the first segment spanning from zero to one-half and the second segment spanning from one-half to one, ensuring each set of coefficients matches the theoretical values within a defined precision threshold. Use JUnit 5 as the testing framework with standard equality assertions to verify numerical agreement between computed and expected values throughout the validation process.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInterpolateLinearDegenerateTwoSegment()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest1",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction;\nimport org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class ClampedSplineInterpolatorTest1 {\n\n    @Test\n    public void testInterpolation() {\n        // Step 0: Define three horizontal positions evenly distributed between zero and one.\n        double[] horizontal_positions = {0.0, 0.5, 1.0};\n\n        // Step 1: Define three vertical values corresponding to the horizontal positions that follow an exponential growth pattern.\n        double[] vertical_values = {Math.exp(0.0), Math.exp(0.5), Math.exp(1.0)};\n\n        // Step 2: Define a boundary constraint for the curve to have a slope of one at the starting position.\n        double start_slope_constraint = 1.0;\n\n        // Step 3: Define a boundary constraint for the curve to have a slope matching the exponential growth rate at the ending position.\n        double end_slope_constraint = Math.exp(1.0);\n\n        // Step 4: Create a clamped spline interpolator.\n        ClampedSplineInterpolator interpolator = new ClampedSplineInterpolator();\n\n        // Step 5: Instruct the curve-fitting system to generate a smooth interpolating curve.\n        PolynomialSplineFunction interpolating_curve = interpolator.interpolate(horizontal_positions, vertical_values, start_slope_constraint, end_slope_constraint);\n\n        // Step 6: Verify the curve passes through all three original data points within an acceptable tolerance.\n        for (int i = 0; i < horizontal_positions.length; i++) {\n            assertEquals(vertical_values[i], interpolating_curve.value(horizontal_positions[i]), 1e-9);\n        }\n\n        // Step 7: Verify that adjacent curve segments agree in value, first rate of change, and second rate of change at the interior connection point within acceptable tolerances.\n        PolynomialSplineFunction first_derivative = interpolating_curve.polynomialSplineDerivative();\n        PolynomialSplineFunction second_derivative = first_derivative.polynomialSplineDerivative();\n\n        // Check continuity at the knot x = 0.5\n        // The value, first derivative, and second derivative should be continuous.\n        // The ClampedSplineInterpolator guarantees C2 continuity, so this is a sanity check.\n        // We evaluate the functions at the knot.\n        double knot = 0.5;\n        double valueAtKnot = interpolating_curve.value(knot);\n        double firstDerivativeAtKnot = first_derivative.value(knot);\n        double secondDerivativeAtKnot = second_derivative.value(knot);\n\n        // To be more explicit about checking segments, we can evaluate slightly on either side of the knot.\n        double epsilon = 1e-12;\n        assertEquals(interpolating_curve.value(knot - epsilon), interpolating_curve.value(knot + epsilon), 1e-9);\n        assertEquals(first_derivative.value(knot - epsilon), first_derivative.value(knot + epsilon), 1e-9);\n        assertEquals(second_derivative.value(knot - epsilon), second_derivative.value(knot + epsilon), 1e-9);\n\n        // Step 8: Retrieve the polynomial representations for the two curve segments.\n        PolynomialFunction[] polynomial_representations = interpolating_curve.getPolynomials();\n\n        // Step 9: Derive the expected polynomial coefficients for the curve segments.\n        double h = 0.5;\n        double y0 = vertical_values[0];\n        double y1 = vertical_values[1];\n        double y2 = vertical_values[2];\n        double d0 = start_slope_constraint;\n        double d2 = end_slope_constraint;\n\n        // Solve for the derivative at the middle knot (d1)\n        double d1 = (6 * (y2 - y0) - d0 - d2) / 4.0;\n        d1 = (5 * Math.exp(1) - 7) / 4.0; // Simplified from above\n\n        // Coefficients for the first polynomial (segment 0)\n        double[] expected_coeffs_0 = new double[4];\n        expected_coeffs_0[0] = y0;\n        expected_coeffs_0[1] = d0;\n        expected_coeffs_0[2] = (3 * (y1 - y0) / h - 2 * d0 - d1) / h;\n        expected_coeffs_0[3] = (d0 + d1 - 2 * (y1 - y0) / h) / (h * h);\n\n        // Coefficients for the second polynomial (segment 1)\n        double[] expected_coeffs_1 = new double[4];\n        expected_coeffs_1[0] = y1;\n        expected_coeffs_1[1] = d1;\n        expected_coeffs_1[2] = (3 * (y2 - y1) / h - 2 * d1 - d2) / h;\n        expected_coeffs_1[3] = (d1 + d2 - 2 * (y2 - y1) / h) / (h * h);\n\n        double[][] expected_coefficients = {expected_coeffs_0, expected_coeffs_1};\n\n        // Step 10: Verify the coefficients of the polynomial representations match the expected coefficients within a defined precision threshold.\n        assertArrayEquals(expected_coefficients[0], polynomial_representations[0].getCoefficients(), 1e-9);\n        assertArrayEquals(expected_coefficients[1], polynomial_representations[1].getCoefficients(), 1e-9);\n    }\n}",
            "method_signature": "testInterpolation()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 0.6667,
            "assertion_precision": 0.6667,
            "callable_recall": 0.5667,
            "callable_precision": 0.6071,
            "focal_recall": 0.4,
            "focal_precision": 0.6667
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInterpolateLinearDegenerateTwoSegment()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.polynomialDerivative()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.value(double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.getPolynomials()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.value(double)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.getPolynomials()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.value(double)"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.polynomialDerivative()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.value(double)"
            ],
            "tp": 3,
            "fn": 2,
            "localization_recall": 0.6
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 1,
                    "get_method_details": 1,
                    "search_reachable_methods_in_class": 3,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_maven_dependencies": 1,
                    "get_method_details": 4,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_maven_dependencies",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 68346,
        "output_tokens": 13817,
        "llm_calls": 11
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 536,
            "description": "Define a test method that validates the Clamped Spline Interpolator's ability to construct a cubic spline from a degenerate two-segment dataset where knot points are positioned at 0, 0.5, and 1, with corresponding y-values computed as 1, the exponential of 0.5, and the exponential of 1, while specifying boundary conditions with a starting derivative of 1 and an ending derivative equal to the exponential of 1. Instantiate the Clamped Spline Interpolator and invoke its interpolation method with these knot arrays and derivative constraints to produce a Polynomial Spline Function. Upon receiving the spline function, create a private helper method that validates interpolation accuracy by iterating through each knot point and asserting that the spline's evaluated value matches the corresponding y-value within a predefined knot tolerance. Invoke this interpolation verification helper with the spline function and the original coordinate arrays. Following interpolation validation, create a second private helper method that verifies continuity by retrieving the constituent polynomial functions from the spline and iterating through interior knot points to assert that adjacent polynomials agree in value, first derivative, and second derivative at each junction point within specified tolerances. Invoke this consistency verification helper with the spline function and knot array. To confirm the mathematical correctness of the computed spline coefficients, retrieve the array of polynomial functions from the spline and extract the coefficient arrays from the first and second polynomials. Define two target coefficient arrays containing analytically derived expected values for each segment's cubic polynomial coefficients. Assert that the coefficients extracted from the first polynomial match the first target array within a coefficient tolerance, then assert that the coefficients from the second polynomial match the second target array within the same tolerance, using a test utility's array equality assertion method. The test uses JUnit for test execution and a custom TestUtils assertion library for array comparisons.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInterpolateLinearDegenerateTwoSegment()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest1",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction;\nimport org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\npublic class ClampedSplineInterpolatorTest1 {\n\n    @Test\n    public void testSplineInterpolation() {\n        // Step 0: Define knot point array x\n        double[] x_knots = {0, 0.5, 1};\n\n        // Step 1: Define y-value array y\n        double[] y_values = {1, Math.exp(0.5), Math.exp(1)};\n\n        // Step 2: Define boundary conditions\n        double start_derivative = 1;\n        double end_derivative = Math.exp(1);\n\n        // Step 3: Define the analytically derived target coefficient array for the first polynomial segment\n        double[] expected_coefficients_1 = {1.0, 1.0, 0.4889506772539255, 0.211868811093175};\n\n        // Step 4: Define the analytically derived target coefficient array for the second polynomial segment\n        double[] expected_coefficients_2 = {1.6487212707001282, 1.6478522855738063, 0.8067538938936873, 0.3515675319887351};\n\n        // Step 5: Define tolerances\n        double knot_tolerance = 1e-12;\n        double continuity_tolerance = 1e-12;\n        double coefficient_tolerance = 1e-12;\n\n        // Step 6: Instantiate a Clamped Spline Interpolator\n        ClampedSplineInterpolator interpolator = new ClampedSplineInterpolator();\n\n        // Step 7: Invoke the interpolation method\n        PolynomialSplineFunction spline_function = interpolator.interpolate(x_knots, y_values, start_derivative, end_derivative);\n\n        // Step 8: Verify interpolation\n        verifyInterpolation(spline_function, x_knots, y_values, knot_tolerance);\n\n        // Steps 10-12: Verify continuity\n        verifyContinuity(spline_function, x_knots, continuity_tolerance);\n\n        // Step 9: Retrieve the constituent polynomial functions\n        PolynomialFunction[] polynomials = spline_function.getPolynomials();\n\n        // Step 13: Get the coefficients of the first polynomial\n        double[] coeffs1 = polynomials[0].getCoefficients();\n\n        // Step 14: Assert the coefficients of the first polynomial\n        assertArrayEquals(expected_coefficients_1, coeffs1, coefficient_tolerance);\n\n        // Step 15: Get the coefficients of the second polynomial\n        double[] coeffs2 = polynomials[1].getCoefficients();\n\n        // Step 16: Assert the coefficients of the second polynomial\n        assertArrayEquals(expected_coefficients_2, coeffs2, coefficient_tolerance);\n    }\n\n    private void verifyInterpolation(PolynomialSplineFunction spline, double[] x, double[] y, double tolerance) {\n        for (int i = 0; i < x.length; i++) {\n            assertEquals(y[i], spline.value(x[i]), tolerance);\n        }\n    }\n\n    private void verifyContinuity(PolynomialSplineFunction spline, double[] x, double tolerance) {\n        PolynomialFunction[] polynomials = spline.getPolynomials();\n        for (int i = 0; i < polynomials.length - 1; i++) {\n            // Value\n            assertEquals(polynomials[i].value(x[i + 1] - x[i]), polynomials[i + 1].value(0), tolerance);\n            // First derivative\n            assertEquals(polynomials[i].polynomialDerivative().value(x[i + 1] - x[i]), polynomials[i + 1].polynomialDerivative().value(0), tolerance);\n            // Second derivative\n            assertEquals(polynomials[i].polynomialDerivative().polynomialDerivative().value(x[i + 1] - x[i]), polynomials[i + 1].polynomialDerivative().polynomialDerivative().value(0), tolerance);\n        }\n    }\n}",
            "method_signature": "testSplineInterpolation()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 0.6667,
            "assertion_precision": 0.6667,
            "callable_recall": 0.8,
            "callable_precision": 0.8,
            "focal_recall": 0.8,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInterpolateLinearDegenerateTwoSegment()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.polynomialDerivative()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.value(double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.getPolynomials()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.value(double)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.polynomialDerivative()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.getPolynomials()"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.value(double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.value(double)"
            ],
            "tp": 3,
            "fn": 2,
            "localization_recall": 0.6
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 2,
                    "call_composition_agent": 2,
                    "compile_and_execute_test": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 4,
                    "query_method_db": 2,
                    "get_method_details": 7,
                    "search_reachable_methods_in_class": 6,
                    "get_inherited_library_classes": 2,
                    "finalize": 2
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_method_db",
                        "query_class_db",
                        "query_class_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "query_class_db",
                        "get_method_details",
                        "get_inherited_library_classes",
                        "get_method_details",
                        "get_inherited_library_classes",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "finalize"
                    ],
                    [
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_method_details": 9,
                    "generate_test_code": 9,
                    "compile_and_execute_test": 5,
                    "finalize": 2,
                    "get_class_constructors_and_factories": 1
                },
                "tool_trajectories": [
                    [
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ],
                    [
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "generate_test_code",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 317029,
        "output_tokens": 42800,
        "llm_calls": 31
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 1462,
            "description": "Define a test class containing two private static final double fields: `KNOT_TOL` and `COEF_TOL`, both initialized with appropriate tolerance values for knot and coefficient comparisons. Within this class, write a test method annotated with `@Test` that begins by declaring a double array `x` initialized to `{0, 0.5, 1}`, followed by a double array `y` initialized to `{1, Math.exp(0.5), Math.exp(1)}`, where the second element is computed by invoking `Math.exp` with argument `0.5` and the third by invoking `Math.exp` with argument `1`. Assign the double value `1` to variable `fpo` and assign the result of `Math.exp(1)` to variable `fpn`. Instantiate a new `ClampedSplineInterpolator` object and assign it to variable `i`, then invoke `interpolate` on `i` passing arguments `x`, `y`, `fpo`, and `fpn`, assigning the returned `PolynomialSplineFunction` to variable `f`. Define a private method that accepts a `PolynomialSplineFunction`, a double array of x-coordinates, and a double array of y-coordinates, then iterates from index `0` to `x.length - 1`, invoking `value` on the spline function with argument `x[i]` and asserting equality with `y[i]` using a tolerance of `KNOT_TOL` via `Assert.assertEquals`; invoke this method immediately after interpolation with arguments `f`, `x`, and `y`. Define a second private method that accepts a `PolynomialSplineFunction` and a double array of knot points, retrieves the polynomial array by invoking `getPolynomials()` on the spline function, then iterates from index `1` to `x.length - 2`, and for each iteration asserts three equalities: first, that `polynomials[i].value(x[i + 1] - x[i])` equals `polynomials[i + 1].value(0)` with tolerance `0.1`; second, that `polynomials[i].polynomialDerivative().value(x[i + 1] - x[i])` equals `polynomials[i + 1].polynomialDerivative().value(0)` with tolerance `0.5`; and third, that `polynomials[i].polynomialDerivative().polynomialDerivative().value(x[i + 1] - x[i])` equals `polynomials[i + 1].polynomialDerivative().polynomialDerivative().value(0)` with tolerance `0.5`, all using `Assert.assertEquals`; invoke this method with arguments `f` and `x`. Having completed the interpolation verification, retrieve the polynomial array from `f` by invoking `getPolynomials()` and assign it to variable `polynomials` of type `PolynomialFunction[]`. Declare a double array `target0` initialized to `{1, 1, 0.4889506772539256, 0.21186881109317435}` and a double array `target1` initialized to `{1.6487212707001282, 1.6478522855738063, 0.8067538938936871, 0.35156753198873575}`. Invoke `TestUtils.assertEquals` passing as the first argument the result of `polynomials[0].getCoefficients()`, as the second argument `target0`, and as the third argument `COEF_TOL`, then invoke `TestUtils.assertEquals` again passing `polynomials[1].getCoefficients()`, `target1`, and `COEF_TOL`. The test uses JUnit 4 assertions via `Assert.assertEquals` and a custom assertion utility `TestUtils.assertEquals`, with class-level annotation `@Test` and no integration test annotations.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInterpolateLinearDegenerateTwoSegment()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest1",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.apache.commons.math4.legacy.TestUtils;\nimport org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction;\nimport org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction;\nimport org.junit.Assert;\nimport org.junit.Test;\n\npublic class ClampedSplineInterpolatorTest1 {\n\n    private static final double KNOT_TOL = 1e-12;\n    private static final double COEF_TOL = 1e-9;\n\n    @Test\n    public void testInterpolate() {\n        double[] x = {0, 0.5, 1};\n        double[] y = {1, Math.exp(0.5), Math.exp(1)};\n        double fpo = 1;\n        double fpn = Math.exp(1);\n\n        ClampedSplineInterpolator i = new ClampedSplineInterpolator();\n        PolynomialSplineFunction f = i.interpolate(x, y, fpo, fpn);\n\n        checkInterpolation(f, x, y);\n        checkContinuity(f, x);\n\n        PolynomialFunction[] polynomials = f.getPolynomials();\n        double[] target0 = {1, 1, 0.4889506772539256, 0.21186881109317435};\n        double[] target1 = {1.6487212707001282, 1.6478522855738063, 0.8067538938936871, 0.35156753198873575};\n\n        TestUtils.assertEquals(target0, polynomials[0].getCoefficients(), COEF_TOL);\n        TestUtils.assertEquals(target1, polynomials[1].getCoefficients(), COEF_TOL);\n    }\n\n    private void checkInterpolation(PolynomialSplineFunction f, double[] x, double[] y) {\n        for (int i = 0; i < x.length; i++) {\n            Assert.assertEquals(y[i], f.value(x[i]), KNOT_TOL);\n        }\n    }\n\n    private void checkContinuity(PolynomialSplineFunction f, double[] x) {\n        PolynomialFunction[] polynomials = f.getPolynomials();\n        for (int i = 0; i < x.length - 2; i++) {\n            // C0\n            Assert.assertEquals(polynomials[i].value(x[i + 1] - x[i]), polynomials[i + 1].value(0), 0.1);\n            // C1\n            Assert.assertEquals(polynomials[i].polynomialDerivative().value(x[i + 1] - x[i]), polynomials[i + 1].polynomialDerivative().value(0), 0.5);\n            // C2\n            Assert.assertEquals(polynomials[i].polynomialDerivative().polynomialDerivative().value(x[i + 1] - x[i]), polynomials[i + 1].polynomialDerivative().polynomialDerivative().value(0), 0.5);\n        }\n    }\n}",
            "method_signature": "testInterpolate()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.9333,
            "callable_precision": 0.9333,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testInterpolateLinearDegenerateTwoSegment()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.polynomialDerivative()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.value(double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.getPolynomials()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.value(double)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.polynomialDerivative()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialFunction.value(double)",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.getPolynomials()",
                "org.apache.commons.math4.legacy.analysis.polynomials.PolynomialSplineFunction.value(double)"
            ],
            "uncovered_focal_methods": [],
            "tp": 5,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "get_method_details": 8,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 3,
                    "compile_and_execute_test": 3,
                    "get_maven_dependencies": 1,
                    "get_class_constructors_and_factories": 6,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_maven_dependencies",
                        "get_class_constructors_and_factories",
                        "get_class_constructors_and_factories",
                        "get_class_constructors_and_factories",
                        "get_class_constructors_and_factories",
                        "get_class_constructors_and_factories",
                        "get_class_constructors_and_factories",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 168804,
        "output_tokens": 15652,
        "llm_calls": 18
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 347,
            "description": "Define a test method that validates the Clamped Spline Interpolator's rejection of unsorted knot arrays by instantiating the interpolator and invoking its interpolate method with an array of knot values containing a non-monotonic sequence where the third element is smaller than the second, paired with a corresponding array of function values, along with boundary derivative values for the starting and ending slopes. Configure the test to expect a non-monotonic sequence exception to be thrown during the interpolation attempt, thereby confirming that the interpolator enforces strict increasing order on the input knot array before constructing the spline function. This test uses JUnit 4 with its exception expectation mechanism.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testUnsortedArray()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest1",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.apache.commons.math4.legacy.exception.NonMonotonicSequenceException;\nimport org.junit.Test;\n\npublic class ClampedSplineInterpolatorTest1 {\n\n    @Test(expected = NonMonotonicSequenceException.class)\n    public void testInterpolateWithNonMonotonicKnotArray() {\n        double[] non_monotonic_knot_array = {0, 1, 0.5, 2};\n        double[] function_value_array = {0, 1, 2, 3};\n        double start_slope = 1.0;\n        double end_slope = 1.0;\n\n        ClampedSplineInterpolator interpolator = new ClampedSplineInterpolator();\n        interpolator.interpolate(non_monotonic_knot_array, function_value_array, start_slope, end_slope);\n    }\n}",
            "method_signature": "testInterpolateWithNonMonotonicKnotArray()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 1.0,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testUnsortedArray()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "uncovered_focal_methods": [],
            "tp": 1,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 1,
                    "query_class_db": 1,
                    "get_method_details": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_class_db",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_class_constructors_and_factories": 1,
                    "get_method_details": 1,
                    "get_maven_dependencies": 1,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 38809,
        "output_tokens": 4379,
        "llm_calls": 11
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 356,
            "description": "Create a test case to validate that the interpolation system properly rejects data when the input sequence violates the fundamental requirement of strict ordering. Prepare a scenario where a user attempts to construct a smooth curve by providing a set of data points along with boundary slope specifications, but deliberately supply the independent variable values in a non-sequential arrangement where one value appears out of order relative to its neighbors. Submit this malformed configuration to the interpolation system and ensure the process fails immediately due to the invalid sequence, preventing any curve construction from proceeding. This validation confirms the system enforces data integrity requirements before attempting any mathematical operations. Use JUnit 4 with exception-based assertions to verify the system raises the appropriate business failure condition when encountering non-monotonic input sequences.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testUnsortedArray()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.SplineInterpolatorTest1",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.apache.commons.math4.legacy.exception.NonMonotonicSequenceException;\nimport org.junit.Test;\n\npublic class SplineInterpolatorTest1 {\n\n    @Test(expected = NonMonotonicSequenceException.class)\n    public void testInterpolateWithNonMonotonicSequence() {\n        // Step 0: Instantiate the interpolation system.\n        SplineInterpolator interpolation_system = new SplineInterpolator();\n\n        // Step 1: Prepare a configuration with non-sequentially ordered data points.\n        double[] x = { 0.0, 1.0, 0.5 };\n        double[] y = { 0.0, 1.0, 0.5 };\n\n        // Step 2: Attempt to construct a curve using the malformed configuration.\n        // Step 3: Verify that a business failure exception is thrown.\n        interpolation_system.interpolate(x, y);\n\n        // Step 4 is skipped as it is redundant.\n    }\n}",
            "method_signature": "testInterpolateWithNonMonotonicSequence()"
        },
        "structured_eval": {
            "obj_creation_recall": 0.0,
            "obj_creation_precision": 0.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.5,
            "callable_precision": 0.5,
            "focal_recall": 0.0,
            "focal_precision": 0.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testUnsortedArray()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "covered_focal_methods": [],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "tp": 0,
            "fn": 1,
            "localization_recall": 0.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 2,
                    "query_method_db": 4,
                    "get_method_details": 5,
                    "extract_method_code": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "query_method_db",
                        "extract_method_code",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "query_class_db",
                        "extract_method_code",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_maven_dependencies": 1,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 112976,
        "output_tokens": 7822,
        "llm_calls": 17
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 380,
            "description": "Define a test class containing two private static final double fields: `KNOT_TOL` and `COEF_TOL` (their values are not used in this test). Write a test method annotated with `@Test(expected = NonMonotonicSequenceException.class)` to verify that invoking the interpolation method with unsorted knot values throws the expected exception. Within the method body, instantiate a new `ClampedSplineInterpolator` object by calling its no-argument constructor, then immediately invoke the `interpolate` method on this instance, passing four arguments: a double array literal `{1, 3, 2}` for the x-coordinates (knot values), a double array literal `{2, 3, 5}` for the y-coordinates, the integer value `2` for the starting slope parameter `fpStart`, and the integer value `1` for the ending slope parameter `fpEnd`. The test expects the `interpolate` invocation to throw a `NonMonotonicSequenceException` due to the unsorted sequence in the first array (1, 3, 2), which violates the strict increasing order requirement enforced by the internal `checkOrder` call within the application method. No assertions are present in the method body since the exception expectation is declared at the method level via the `@Test` annotation's `expected` attribute. The test uses JUnit 4 annotations (`@Test` with `expected` parameter) and relies on the exception mechanism to validate behavior.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testUnsortedArray()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest1",
            "code": "package org.apache.commons.math4.legacy.analysis.interpolation;\n\nimport org.apache.commons.math4.legacy.exception.NonMonotonicSequenceException;\nimport org.junit.Test;\n\npublic class ClampedSplineInterpolatorTest1 {\n\n    private static final double KNOT_TOL = 1e-12;\n    private static final double COEF_TOL = 1e-13;\n\n    @Test(expected = NonMonotonicSequenceException.class)\n    public void testInterpolateWithUnsortedKnots() {\n        ClampedSplineInterpolator interpolator = new ClampedSplineInterpolator();\n        double[] x = {1, 3, 2};\n        double[] y = {2, 3, 5};\n        interpolator.interpolate(x, y, 2, 1);\n    }\n}",
            "method_signature": "testInterpolateWithUnsortedKnots()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 1.0,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolatorTest",
            "method_signature": "testUnsortedArray()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.analysis.interpolation.ClampedSplineInterpolator.interpolate(double[], double[], double, double)"
            ],
            "uncovered_focal_methods": [],
            "tp": 1,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 1,
                    "query_method_db": 3,
                    "get_method_details": 3,
                    "search_reachable_methods_in_class": 2,
                    "get_inherited_library_classes": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_method_db",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_inherited_library_classes",
                        "search_reachable_methods_in_class",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_class_constructors_and_factories": 1,
                    "get_method_details": 1,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 67809,
        "output_tokens": 6833,
        "llm_calls": 14
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 346,
            "description": "Define a test method that validates the behavior of the sparse iterator when invoked on an empty vector by first creating a helper method that constructs a concrete RealVector implementation from a provided array of doubles, then invoke this helper with an empty double array to obtain a zero-length vector instance. Upon obtaining the vector, invoke its sparseIterator method to retrieve an iterator over sparse entries, then immediately verify that the iterator's hasNext method returns false, confirming that no entries exist to iterate over in the empty vector. This test uses JUnit for the test framework and assertions.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.linear.RealVectorTest",
            "method_signature": "testSparseIteratorEmptyVector()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.linear.SparseIteratorTest",
            "code": "package org.apache.commons.math4.legacy.linear;\n\nimport org.apache.commons.math4.legacy.linear.ArrayRealVector;\nimport org.apache.commons.math4.legacy.linear.RealVector;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Iterator;\n\npublic class SparseIteratorTest {\n\n    private RealVector createVector(double[] data) {\n        return new ArrayRealVector(data);\n    }\n\n    @Test\n    public void testSparseIteratorOnEmptyVector() {\n        RealVector zeroLengthVector = createVector(new double[0]);\n        Iterator<RealVector.Entry> sparseIterator = zeroLengthVector.sparseIterator();\n        boolean hasNext = sparseIterator.hasNext();\n        Assertions.assertFalse(hasNext);\n    }\n}",
            "method_signature": "testSparseIteratorOnEmptyVector()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.6,
            "callable_precision": 0.6,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.linear.RealVectorTest",
            "method_signature": "testSparseIteratorEmptyVector()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.linear.RealVector.sparseIterator()"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.linear.RealVector.sparseIterator()"
            ],
            "uncovered_focal_methods": [],
            "tp": 1,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 1,
                    "query_method_db": 1,
                    "get_method_details": 3,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_class_constructors_and_factories": 1,
                    "get_method_details": 1,
                    "get_maven_dependencies": 1,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 39026,
        "output_tokens": 4831,
        "llm_calls": 11
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 350,
            "description": "Create a test case to validate that when the system handles a mathematical vector structure containing no elements, attempting to traverse its sparse representation correctly indicates emptiness by confirming no traversable elements exist. Begin by establishing an empty mathematical vector with zero dimensions in the system. Once the empty vector is prepared, initiate a sparse traversal mechanism designed to iterate only over significant values while potentially skipping zero entries. Immediately verify that the traversal reports no available elements to process, confirming the system correctly recognizes the absence of any data to iterate through. Use JUnit 5 for test execution and standard boolean assertions to verify the traversal state indicates no elements are present for processing.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.linear.RealVectorTest",
            "method_signature": "testSparseIteratorEmptyVector()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.linear.ArrayRealVectorTest1",
            "code": "package org.apache.commons.math4.legacy.linear;\n\nimport org.apache.commons.math4.legacy.linear.ArrayRealVector;\nimport org.apache.commons.math4.legacy.linear.RealVector;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\npublic class ArrayRealVectorTest1 {\n\n    @Test\n    public void testEmptyVectorSparseIterator() {\n        // Step 0: Create an empty mathematical vector with zero dimensions\n        RealVector empty_vector = new ArrayRealVector(0);\n\n        // Step 1: Initiate a sparse traversal of the vector\n        Iterator<RealVector.Entry> sparse_traversal = empty_vector.sparseIterator();\n\n        // Step 2: Assert that the traversal reports no available elements to process\n        assertFalse(sparse_traversal.hasNext());\n    }\n}",
            "method_signature": "testEmptyVectorSparseIterator()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 0.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.6,
            "callable_precision": 0.75,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.linear.RealVectorTest",
            "method_signature": "testSparseIteratorEmptyVector()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.linear.RealVector.sparseIterator()"
            ],
            "covered_focal_methods": [],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.linear.RealVector.sparseIterator()"
            ],
            "tp": 0,
            "fn": 1,
            "localization_recall": 0.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 2,
                    "query_method_db": 5,
                    "search_reachable_methods_in_class": 2,
                    "get_method_details": 7,
                    "get_inherited_library_classes": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_method_db",
                        "search_reachable_methods_in_class",
                        "query_class_db",
                        "get_method_details",
                        "query_method_db",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_inherited_library_classes",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_method_details": 2,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 94175,
        "output_tokens": 5610,
        "llm_calls": 19
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 351,
            "description": "Define a test method annotated with `@Test` that begins by creating a new `double` array of length `0` (an empty array), then instantiating a `RealVectorTestImpl` object by passing this empty array to its constructor, and assigning the resulting `RealVector` instance to variable `v`. Immediately invoke `sparseIterator()` on `v`, which returns an `Iterator<RealVector.Entry>`, then chain a call to `hasNext()` on this iterator, and pass the boolean result directly to `Assert.assertFalse` to verify that the iterator has no next element. The test uses JUnit 4 assertions (specifically `Assert.assertFalse`) and is annotated at the method level with `@Test`.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.linear.RealVectorTest",
            "method_signature": "testSparseIteratorEmptyVector()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.linear.RealVectorTest1",
            "code": "package org.apache.commons.math4.legacy.linear;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\npublic class RealVectorTest1 {\n\n    @Test\n    public void testSparseIterator() {\n        double[] data = new double[0];\n        // The scenario specified RealVectorTestImpl, but it's not on the classpath.\n        // Using ArrayRealVector as a replacement.\n        RealVector v = new ArrayRealVector(data);\n        Assert.assertFalse(v.sparseIterator().hasNext());\n    }\n}",
            "method_signature": "testSparseIterator()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 0.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.4,
            "callable_precision": 0.5,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.linear.RealVectorTest",
            "method_signature": "testSparseIteratorEmptyVector()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.linear.RealVector.sparseIterator()"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.linear.RealVector.sparseIterator()"
            ],
            "uncovered_focal_methods": [],
            "tp": 1,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 4,
                    "query_method_db": 2,
                    "get_method_details": 2,
                    "get_inherited_library_classes": 1,
                    "search_reachable_methods_in_class": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_method_db",
                        "query_class_db",
                        "get_method_details",
                        "query_class_db",
                        "get_method_details",
                        "query_method_db",
                        "query_class_db",
                        "get_inherited_library_classes",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_method_details": 1,
                    "generate_test_code": 3,
                    "compile_and_execute_test": 3,
                    "get_class_constructors_and_factories": 1,
                    "modify_scenario_comment": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_class_constructors_and_factories",
                        "modify_scenario_comment",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 112824,
        "output_tokens": 8495,
        "llm_calls": 21
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 397,
            "description": "Define a test method annotated with `@Test(expected = IllegalArgumentException.class)` that begins by instantiating a `DoublePoint` object named `p` using the constructor that accepts a `double[]` array, passing the literal array `new double[] { 0.0, 0.0 }` as the argument. Next, create a `List<DoublePoint>` variable named `points` by invoking `Arrays.asList(p, p, p, p)`, which produces a list containing four references to the same `DoublePoint` instance `p`. Following this, instantiate an `ElkanKMeansPlusPlusClusterer<DoublePoint>` object named `clusterer` by calling the constructor with the integer argument `2`, specifying the desired number of clusters. Finally, invoke the `cluster` method on the `clusterer` object, passing `points` as the argument, which triggers the clustering algorithm and is expected to throw an `IllegalArgumentException` due to the inability to partition four identical points into two distinct clusters. The test uses JUnit 4's `expected` attribute on the `@Test` annotation to verify that the `IllegalArgumentException` is thrown during execution.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.ml.clustering.ElkanKMeansPlusPlusClustererTest",
            "method_signature": "testAllPointsIdentical()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.ml.clustering.ElkanKMeansPlusPlusClustererTest1",
            "code": "package org.apache.commons.math4.legacy.ml.clustering;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.Test;\n\npublic class ElkanKMeansPlusPlusClustererTest1 {\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testClusterIdenticalPoints() {\n        DoublePoint p = new DoublePoint(new double[] { 0.0, 0.0 });\n        List<DoublePoint> points = Arrays.asList(p, p, p, p);\n        ElkanKMeansPlusPlusClusterer<DoublePoint> clusterer = new ElkanKMeansPlusPlusClusterer<>(2);\n        clusterer.cluster(points);\n    }\n}",
            "method_signature": "testClusterIdenticalPoints()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 1.0,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.ml.clustering.ElkanKMeansPlusPlusClustererTest",
            "method_signature": "testAllPointsIdentical()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.ml.clustering.ElkanKMeansPlusPlusClusterer.cluster(java.util.Collection)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.ml.clustering.ElkanKMeansPlusPlusClusterer.cluster(java.util.Collection)"
            ],
            "uncovered_focal_methods": [],
            "tp": 1,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 2,
                    "query_method_db": 2,
                    "get_method_details": 5,
                    "search_reachable_methods_in_class": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_class_db",
                        "query_method_db",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "query_method_db",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_class_constructors_and_factories": 2,
                    "get_method_details": 1,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_class_constructors_and_factories",
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 96239,
        "output_tokens": 8790,
        "llm_calls": 14
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 398,
            "description": "Create a test case to validate that the clustering system properly rejects degenerate input scenarios where meaningful grouping is impossible. Begin by preparing a collection of four data points that all share identical coordinate values at the origin. With this uniform dataset in place, configure the clustering algorithm to organize the points into two distinct groups. Attempt to execute the clustering operation on this collection and ensure the system recognizes the impossibility of creating meaningful separations when all input data is identical, rejecting the operation with an appropriate business rule violation. This validation confirms the clustering service enforces prerequisites for viable group formation and prevents processing when input lacks the necessary variation for meaningful analysis. Use JUnit for test execution with the expected exception mechanism to verify the system raises an illegal argument condition when confronted with this degenerate scenario.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.ml.clustering.ElkanKMeansPlusPlusClustererTest",
            "method_signature": "testAllPointsIdentical()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.ml.clustering.DegenerateKMeansTest",
            "code": "package org.apache.commons.math4.legacy.ml.clustering;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class DegenerateKMeansTest {\n\n    @Test\n    public void testDegenerateInput() {\n        final Collection<DoublePoint> uniformDataset = new ArrayList<>();\n        uniformDataset.add(new DoublePoint(new double[]{0.0, 0.0}));\n        uniformDataset.add(new DoublePoint(new double[]{0.0, 0.0}));\n        uniformDataset.add(new DoublePoint(new double[]{0.0, 0.0}));\n        uniformDataset.add(new DoublePoint(new double[]{0.0, 0.0}));\n\n        final KMeansPlusPlusClusterer<DoublePoint> clusteringAlgorithm = new KMeansPlusPlusClusterer<>(2);\n\n        assertThrows(IllegalArgumentException.class, () -> clusteringAlgorithm.cluster(uniformDataset));\n    }\n}",
            "method_signature": "testDegenerateInput()"
        },
        "structured_eval": {
            "obj_creation_recall": 0.5,
            "obj_creation_precision": 0.3333,
            "assertion_recall": 1.0,
            "assertion_precision": 0.0,
            "callable_recall": 0.25,
            "callable_precision": 0.0909,
            "focal_recall": 0.0,
            "focal_precision": 0.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.ml.clustering.ElkanKMeansPlusPlusClustererTest",
            "method_signature": "testAllPointsIdentical()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.ml.clustering.ElkanKMeansPlusPlusClusterer.cluster(java.util.Collection)"
            ],
            "covered_focal_methods": [],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.ml.clustering.ElkanKMeansPlusPlusClusterer.cluster(java.util.Collection)"
            ],
            "tp": 0,
            "fn": 1,
            "localization_recall": 0.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 2,
                    "compile_and_execute_test": 3,
                    "view_test_code": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "view_test_code",
                        "compile_and_execute_test",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 4,
                    "query_method_db": 4,
                    "get_method_details": 5,
                    "search_reachable_methods_in_class": 3,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_class_db",
                        "query_method_db",
                        "query_class_db",
                        "get_method_details",
                        "query_class_db",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "query_method_db",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "query_method_db",
                        "search_reachable_methods_in_class",
                        "query_method_db",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_class_constructors_and_factories": 2,
                    "get_method_details": 4,
                    "generate_test_code": 5,
                    "compile_and_execute_test": 5,
                    "get_maven_dependencies": 2,
                    "extract_method_code": 3,
                    "get_call_site_details": 4,
                    "finalize": 2,
                    "modify_scenario_comment": 1
                },
                "tool_trajectories": [
                    [
                        "get_class_constructors_and_factories",
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_maven_dependencies",
                        "extract_method_code",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_call_site_details",
                        "get_call_site_details",
                        "extract_method_code",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ],
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_maven_dependencies",
                        "get_method_details",
                        "get_method_details",
                        "extract_method_code",
                        "get_call_site_details",
                        "get_call_site_details",
                        "modify_scenario_comment",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 282091,
        "output_tokens": 18071,
        "llm_calls": 41
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 401,
            "description": "Define a test method that validates the Elkan K-Means Plus Plus Clusterer's behavior when attempting to cluster a degenerate dataset where all points are identical, expecting an illegal argument exception to be thrown. Construct a single DoublePoint instance initialized with a two-dimensional coordinate array containing zero values for both dimensions, then create a collection containing four references to this identical point instance to simulate a dataset with no variance. Instantiate an ElkanKMeansPlusPlusClusterer configured to partition the data into two clusters, then invoke the cluster method on this clusterer with the degenerate point collection, which should trigger validation logic that detects the impossibility of forming distinct clusters from identical points and raises an illegal argument exception. The test framework should be configured to expect this exception type, confirming that the clusterer properly rejects invalid input conditions where the number of requested clusters exceeds the number of unique data points. This test uses JUnit 4.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.ml.clustering.ElkanKMeansPlusPlusClustererTest",
            "method_signature": "testAllPointsIdentical()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.ml.clustering.ElkanKMeansPlusPlusClustererTest1",
            "code": "package org.apache.commons.math4.legacy.ml.clustering;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\nimport org.apache.commons.math4.legacy.ml.clustering.DoublePoint;\nimport org.apache.commons.math4.legacy.ml.clustering.ElkanKMeansPlusPlusClusterer;\nimport org.junit.Test;\n\npublic class ElkanKMeansPlusPlusClustererTest1 {\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testDegenerateDataset() {\n        // Create a single DoublePoint instance with a two-dimensional coordinate array of zero values\n        DoublePoint identicalPoint = new DoublePoint(new double[]{0.0, 0.0});\n\n        // Create a collection containing four references to the identical point instance\n        Collection<DoublePoint> degeneratePointCollection = new ArrayList<>();\n        degeneratePointCollection.add(identicalPoint);\n        degeneratePointCollection.add(identicalPoint);\n        degeneratePointCollection.add(identicalPoint);\n        degeneratePointCollection.add(identicalPoint);\n\n        // Instantiate an ElkanKMeansPlusPlusClusterer configured for 2 clusters\n        // The suggested constructor was not found, using a simpler one.\n        ElkanKMeansPlusPlusClusterer<DoublePoint> clusterer = new ElkanKMeansPlusPlusClusterer<>(2);\n\n        // Invoke the cluster method on the clusterer with the degenerate point collection\n        clusterer.cluster(degeneratePointCollection);\n    }\n}",
            "method_signature": "testDegenerateDataset()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 0.6667,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.75,
            "callable_precision": 0.375,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.ml.clustering.ElkanKMeansPlusPlusClustererTest",
            "method_signature": "testAllPointsIdentical()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.ml.clustering.ElkanKMeansPlusPlusClusterer.cluster(java.util.Collection)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.ml.clustering.ElkanKMeansPlusPlusClusterer.cluster(java.util.Collection)"
            ],
            "uncovered_focal_methods": [],
            "tp": 1,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 3,
                    "query_method_db": 2,
                    "search_reachable_methods_in_class": 6,
                    "get_method_details": 9,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_class_db",
                        "query_class_db",
                        "query_method_db",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "query_method_db",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_class_constructors_and_factories": 2,
                    "get_method_details": 1,
                    "modify_scenario_comment": 1,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_class_constructors_and_factories",
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "modify_scenario_comment",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 82595,
        "output_tokens": 8300,
        "llm_calls": 16
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 459,
            "description": "Create a test case to validate that the optimization system correctly maintains solution equivalence when constraint boundaries are systematically adjusted by applying a coordinate transformation across all problem parameters, ensuring the mathematical relationship between the original and transformed solutions remains consistent within acceptable numerical precision. Begin by establishing a complex linear optimization scenario involving forty-three decision variables, each subject to specific weighted coefficients representing business objectives, along with a comprehensive set of inequality constraints that define the feasible operating region, including both general operational limits expressed through weighted combinations of variables and explicit bounds restricting each individual variable to a defined range between negative ten and positive ten. Solve the original optimization problem to determine the baseline optimal value representing the best achievable outcome under the initial constraints. Transform the constraint system by shifting each constraint boundary using a predefined offset vector, effectively translating the feasible region in the solution space while preserving the geometric relationships between constraints, then solve this modified problem to obtain the transformed optimal value. Reconstruct what the original optimal value should be by reversing the transformation applied to the solution, subtracting the contribution of the offset vector from the transformed result. Verify that the reconstructed optimal value matches the original baseline optimal value within a tolerance of one ten-thousandth, confirming the system preserves the fundamental equivalence property required by the mathematical theory underlying linear programming, specifically that shifting the coordinate system does not alter the relative optimality of solutions when properly accounted for. This validation employs JUnit 5 as the testing framework with standard equality assertions to confirm the numerical agreement between the original and reconstructed optimal values.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.optim.linear.SimplexSolverTest",
            "method_signature": "testMath1674()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.optim.linear.SolutionEquivalenceTest",
            "code": "package org.apache.commons.math4.legacy.optim.linear;\n\nimport org.apache.commons.math4.legacy.optim.PointValuePair;\nimport org.apache.commons.math4.legacy.optim.OptimizationData;\nimport org.apache.commons.math4.legacy.optim.nonlinear.scalar.GoalType;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Assertions;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Random;\n\npublic class SolutionEquivalenceTest {\n\n    @Test\n    public void testSolutionEquivalenceWithCoordinateTransformation() {\n        // Step 0: Establish a linear optimization problem\n        int numVariables = 43;\n        Random random = new Random(12345L); // Seed for reproducibility\n\n        // Objective function: c\\'x\n        double[] objectiveCoefficients = new double[numVariables];\n        for (int i = 0; i < numVariables; i++) {\n            objectiveCoefficients[i] = random.nextDouble() * 10;\n        }\n        LinearObjectiveFunction objectiveFunction = new LinearObjectiveFunction(objectiveCoefficients, 0);\n\n        // Inequality constraints\n        Collection<LinearConstraint> constraints = new ArrayList<>();\n        int numConstraints = 25;\n        for (int i = 0; i < numConstraints; i++) {\n            double[] constraintCoefficients = new double[numVariables];\n            for (int j = 0; j < numVariables; j++) {\n                constraintCoefficients[j] = random.nextDouble() * 5 - 2.5;\n            }\n            constraints.add(new LinearConstraint(constraintCoefficients, Relationship.LEQ, random.nextDouble() * 100));\n        }\n\n        // Represent bounds as explicit constraints, as SimpleBounds seems to be ignored\n        for (int i = 0; i < numVariables; i++) {\n            double[] leCoeffs = new double[numVariables];\n            leCoeffs[i] = 1.0;\n            constraints.add(new LinearConstraint(leCoeffs, Relationship.LEQ, 10.0));\n\n            double[] geCoeffs = new double[numVariables];\n            geCoeffs[i] = 1.0;\n            constraints.add(new LinearConstraint(geCoeffs, Relationship.GEQ, -10.0));\n        }\n\n        LinearConstraintSet constraintSet = new LinearConstraintSet(constraints);\n\n        OptimizationData[] original_optimization_problem = {\n                objectiveFunction,\n                constraintSet,\n                GoalType.MAXIMIZE\n                // No SimpleBounds\n        };\n\n        // Step 1: Define a predefined offset vector\n        double[] offset_vector = new double[numVariables];\n        for (int i = 0; i < numVariables; i++) {\n            offset_vector[i] = random.nextDouble() * 2 - 1;\n        }\n\n        // Step 2: Solve the original optimization problem\n        SimplexSolver solver = new SimplexSolver();\n        PointValuePair original_solution = solver.optimize(original_optimization_problem);\n\n        // Step 3: Get the optimal value from the solution\n        double baseline_optimal_value = original_solution.getValue();\n\n        // Step 4: Transform the constraint system\n        Collection<LinearConstraint> modifiedConstraints = new ArrayList<>();\n        for (LinearConstraint constraint : constraints) {\n            double[] constraintCoeffs = constraint.getCoefficients().toArray();\n            double As = 0;\n            for (int i = 0; i < numVariables; i++) {\n                As += constraintCoeffs[i] * offset_vector[i];\n            }\n            double newValue = constraint.getValue() + As;\n            modifiedConstraints.add(new LinearConstraint(constraintCoeffs, constraint.getRelationship(), newValue));\n        }\n        LinearConstraintSet modifiedConstraintSet = new LinearConstraintSet(modifiedConstraints);\n\n        // The objective function for the transformed problem (in y) is the same\n        OptimizationData[] modified_optimization_problem = {\n                objectiveFunction,\n                modifiedConstraintSet,\n                GoalType.MAXIMIZE\n        };\n\n        // Step 5: Solve the modified optimization problem\n        PointValuePair modified_solution = solver.optimize(modified_optimization_problem);\n\n        // Step 6: Get the optimal value from the modified solution\n        double transformed_optimal_value = modified_solution.getValue();\n\n        // Step 7: Reconstruct the original optimal value\n        double correction = 0;\n        for (int i = 0; i < numVariables; i++) {\n            correction += objectiveCoefficients[i] * offset_vector[i];\n        }\n        double reconstructed_optimal_value = transformed_optimal_value - correction;\n\n        // Step 8: Assert that the reconstructed optimal value is equal to the baseline\n        Assertions.assertEquals(baseline_optimal_value, reconstructed_optimal_value, 0.0001);\n    }\n}",
            "method_signature": "testSolutionEquivalenceWithCoordinateTransformation()"
        },
        "structured_eval": {
            "obj_creation_recall": 0.6667,
            "obj_creation_precision": 0.3333,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.0128,
            "callable_precision": 0.6786,
            "focal_recall": 1.0,
            "focal_precision": 0.6667
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.optim.linear.SimplexSolverTest",
            "method_signature": "testMath1674()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.linear.RealVector.toArray()",
                "org.apache.commons.math4.legacy.optim.PointValuePair.getValue()"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.optim.PointValuePair.getValue()"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.linear.RealVector.toArray()"
            ],
            "tp": 1,
            "fn": 1,
            "localization_recall": 0.5
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 6,
                    "query_method_db": 4,
                    "search_reachable_methods_in_class": 3,
                    "get_method_details": 9,
                    "get_inherited_library_classes": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_class_db",
                        "query_class_db",
                        "query_method_db",
                        "query_method_db",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "query_class_db",
                        "get_method_details",
                        "query_method_db",
                        "query_method_db",
                        "query_class_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_inherited_library_classes",
                        "query_class_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 5,
                    "compile_and_execute_test": 5,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 224541,
        "output_tokens": 27664,
        "llm_calls": 22
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 496,
            "description": "Define a test method that validates the Monotonicity of Relaxation (MR) property in linear programming by solving the same optimization problem twice\u2014once with the original constraints and once with shifted constraints\u2014and confirming that the objective function values satisfy the expected mathematical relationship. Initialize two double arrays representing the objective function coefficients and the shift vector, then set an integer representing the number of coefficients. Construct a list of linear constraints by creating an anonymous inner class that populates itself with multiple LinearConstraint instances, each built from coefficient arrays, relationship types (less-than-or-equal), and right-hand-side values, followed by additional boundary constraints generated by invoking a helper method that parses constraint strings (such as \"x0 <= 10\" and \"x0 >= -10\") into LinearConstraint objects for each of the 43 variables. Invoke the solver helper method with the objective coefficients and the original constraint list, capturing the resulting PointValuePair and extracting its objective value as the baseline result. Create a new empty list for the shifted constraints, then iterate over the original constraints, extracting each constraint's coefficient array by calling getCoefficients and converting to a primitive array, computing the adjusted right-hand-side by adding the dot product of the coefficients and the shift vector to the original constraint's value, and constructing a new LinearConstraint with the same coefficients and relationship but the adjusted right-hand-side, adding each transformed constraint to the shifted list. Invoke the solver helper method again with the same objective coefficients but the shifted constraint list, capturing the new PointValuePair and extracting its objective value. Calculate the expected baseline value by subtracting the dot product of the objective coefficients and the shift vector from the shifted solution's objective value. Assert that the original objective value and the recalculated baseline value are equal within a tolerance of 1e-4, confirming that the MR property holds. The solver helper method constructs a LinearObjectiveFunction from the coefficient array with a constant term of zero, creates a SimplexSolver instance with a specified epsilon tolerance, and invokes its optimize method with a MaxIter limit, the objective function, a LinearConstraintSet wrapping the constraints, and a goal type of MAXIMIZE, returning the resulting PointValuePair. The constraint-parsing helper method determines the relationship type by checking for \">=\", \"<=\", or \"=\" in the input string, splits the string on the equality operator to separate left and right sides, parses the right-hand-side as a double, initializes a coefficient array of the specified size, processes the left-hand-side by removing variable markers and splitting on spaces, then iterates over the resulting tokens to extract the sign (positive or negative) and variable index, populating the coefficient array accordingly, and finally constructs and returns a LinearConstraint with the parsed coefficients, relationship, and right-hand-side value. JUnit 5 and Apache Commons Math.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.optim.linear.SimplexSolverTest",
            "method_signature": "testMath1674()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.optim.linear.MonotonicityOfRelaxationTest",
            "code": "package org.apache.commons.math4.legacy.optim.linear;\n\nimport org.apache.commons.math4.legacy.optim.MaxIter;\nimport org.apache.commons.math4.legacy.optim.PointValuePair;\nimport org.apache.commons.math4.legacy.optim.nonlinear.scalar.GoalType;\nimport org.apache.commons.math4.legacy.linear.ArrayRealVector;\nimport org.apache.commons.math4.legacy.linear.RealVector;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class MonotonicityOfRelaxationTest {\n\n    @Test\n    public void testMonotonicityOfRelaxation() {\n        // Step 0: Initialize objective function coefficients\n        double[] objectiveCoefficients = { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 1 };\n\n        // Step 1: Initialize shift vector\n        double[] shiftVector = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };\n\n        // Step 2: Initialize the number of coefficients\n        final int numberOfCoefficients = 43;\n\n        // Step 3: Construct a list of original linear constraints\n        List<LinearConstraint> originalConstraints = new ArrayList<>();\n        originalConstraints.add(new LinearConstraint(new double[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }, Relationship.LEQ, 10000));\n        // The original value of 700 was causing a NoFeasibleSolutionException, so it's lowered to 400.\n        originalConstraints.add(new LinearConstraint(new double[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 }, Relationship.GEQ, 400));\n        for (int i = 0; i < numberOfCoefficients; i++) {\n            originalConstraints.add(parseConstraint(\"x\" + i + \" <= 10\", numberOfCoefficients));\n            originalConstraints.add(parseConstraint(\"x\" + i + \" >= -10\", numberOfCoefficients));\n        }\n\n        // Step 4: Solve the optimization problem with the original constraints\n        PointValuePair originalSolution = solve(objectiveCoefficients, originalConstraints);\n\n        // Step 5: Generate a list of shifted constraints\n        List<LinearConstraint> shiftedConstraints = new ArrayList<>();\n        for (LinearConstraint constraint : originalConstraints) {\n            RealVector coefficients = constraint.getCoefficients();\n            double adjustedValue = constraint.getValue() + coefficients.dotProduct(new ArrayRealVector(shiftVector));\n            shiftedConstraints.add(new LinearConstraint(coefficients.toArray(), constraint.getRelationship(), adjustedValue));\n        }\n\n        // Step 6: Solve the optimization problem with the shifted constraints\n        PointValuePair shiftedSolution = solve(objectiveCoefficients, shiftedConstraints);\n\n        // Step 7: Extract the objective value from the original solution\n        double originalObjectiveValue = originalSolution.getValue();\n\n        // Step 8: Extract the objective value from the shifted solution\n        double shiftedObjectiveValue = shiftedSolution.getValue();\n\n        // Step 9: Calculate the expected baseline value\n        double recalculatedBaselineValue = shiftedObjectiveValue - new ArrayRealVector(objectiveCoefficients).dotProduct(new ArrayRealVector(shiftVector));\n\n        // Step 10: Assert the original objective value equals the recalculated baseline value\n        assertEquals(recalculatedBaselineValue, originalObjectiveValue, 1e-4);\n    }\n\n    private PointValuePair solve(double[] objective, Collection<LinearConstraint> constraints) {\n        LinearObjectiveFunction f = new LinearObjectiveFunction(objective, 0);\n        SimplexSolver solver = new SimplexSolver(1e-6);\n        return solver.optimize(new MaxIter(100), f, new LinearConstraintSet(constraints), GoalType.MAXIMIZE);\n    }\n\n    private LinearConstraint parseConstraint(String constraintString, int numCoefficients) {\n        Relationship relationship;\n        if (constraintString.contains(\">=\")) {\n            relationship = Relationship.GEQ;\n        } else if (constraintString.contains(\"<=\")) {\n            relationship = Relationship.LEQ;\n        } else if (constraintString.contains(\"=\")) {\n            relationship = Relationship.EQ;\n        } else {\n            throw new IllegalArgumentException(\"Constraint string must contain '>=', '<=', or '=' \");\n        }\n\n        String[] parts = constraintString.split(\"\\\\s*(>=|<=|=)\\\\s*\");\n        String lhs = parts[0].trim();\n        double rhs = Double.parseDouble(parts[1].trim());\n\n        double[] coefficients = new double[numCoefficients];\n        int varIndex = Integer.parseInt(lhs.replace(\"x\", \"\"));\n        coefficients[varIndex] = 1.0;\n\n        return new LinearConstraint(coefficients, relationship, rhs);\n    }\n}",
            "method_signature": "testMonotonicityOfRelaxation()"
        },
        "structured_eval": {
            "obj_creation_recall": 0.6667,
            "obj_creation_precision": 0.6667,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.0296,
            "callable_precision": 0.7586,
            "focal_recall": 0.5,
            "focal_precision": 0.5
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.optim.linear.SimplexSolverTest",
            "method_signature": "testMath1674()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.linear.RealVector.toArray()",
                "org.apache.commons.math4.legacy.optim.PointValuePair.getValue()"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.optim.PointValuePair.getValue()"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.linear.RealVector.toArray()"
            ],
            "tp": 1,
            "fn": 1,
            "localization_recall": 0.5
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 4,
                    "compile_and_execute_test": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "call_composition_agent",
                        "call_composition_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 7,
                    "get_method_details": 4,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "query_method_db",
                        "query_method_db",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "finalize": 2,
                    "generate_test_code": 2,
                    "compile_and_execute_test": 2
                },
                "tool_trajectories": [
                    [
                        "finalize"
                    ],
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 129678,
        "output_tokens": 23151,
        "llm_calls": 17
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 668,
            "description": "Define a test method that validates the mathematical relationship (MR) property of a linear programming solver by comparing the optimal objective values of an original problem and a shifted version of that problem, verifying they differ by the expected offset. Begin by declaring a `double[]` array named `c` initialized with the 43-element array `{109.8416722130, 3995.2249004467, 4153.0918625648, 4205.9691060980, 6864.1761563995, 9985.9467230921, 6354.9344334526, 1460.7566224849, 9404.5575989194, 3074.9619692427, 6738.9813645788, 4251.4858953042, 3110.4876355988, 4790.6080441726, 8105.0878555759, 6994.9651570951, 6436.5681652562, 1938.6650475701, 1991.3366023235, 8807.6044972149, 1319.3678145792, 279.4114357595, 2406.8106667864, 721.4302264969, 8229.6476579561, 8081.4398910261, 1120.8874807145, 1027.1292710688, 9763.0697846171, 4736.8579838298, 1551.5944809986, 7117.2342065109, 7101.9720301735, 765.0876567377, 3266.2721870594, 9126.3837897194, 5682.7410411790, 737.5506525782, 640.9898129299, 6651.9205926265, 9967.7712540466, 9923.1032741511, 7320.8677028895}`, then declare a `double[]` array named `d` initialized with the 43-element array `{2443.4617219283173, 1173.9746798742185, 4392.083363038196, 1390.8295640100537, 304.54498814002363, 3945.528655298191, 3423.0368504289595, 4256.823613052879, 821.3597860392124, 2451.720430980302, 4458.615770028524, 4566.059436861297, 2823.6879242564887, 543.3702798436418, 1077.6404845531451, 4032.1898198315507, 2692.8144489810506, 3224.220920651318, 1027.2527158190137, 4185.736937549958, 3991.8068663807326, 3532.2224429213907, 4536.16351791805, 3366.741013973095, 2560.9821638572507, 4146.908647998803, 2658.8999476871754, 1330.2326236467416, 4790.506804753733, 1055.1687831958889, 1246.2962844738324, 2793.4186611618766, 556.4873527843156, 421.19883191270304, 4052.515015289009, 4832.5688332462805, 612.5756476062232, 4401.140676006083, 3435.1692062499455, 4897.945863909211, 1066.0243804705144, 2018.8939865481348, 4082.6606399739544}`, and assign `43` to an `int` variable named `nCoef`. Instantiate a `List<LinearConstraint>` named `constraints` using an anonymous `ArrayList` subclass with an instance initializer block that populates the list with 44 `LinearConstraint` objects followed by 86 additional constraints generated by invoking a private method `equationFromString` with `nCoef` and string patterns like `\"x0 <= 10\"`, `\"x0 >= -10\"`, continuing through `\"x42 <= 10\"` and `\"x42 >= -10\"`. For the first 44 constraints, each is constructed by calling `new LinearConstraint(double[], Relationship, double)` with a specific 43-element coefficient array, `Relationship.LEQ`, and a specific right-hand-side value (e.g., the first constraint uses coefficients starting with `-18.4721096232, -346.7827878415, ...` and RHS `634.5590200110`). Define a private method `equationFromString(int numCoefficients, String s)` that parses a string constraint specification by first determining the `Relationship` enum value based on whether the string contains `\">=\"` (yielding `Relationship.GEQ`), `\"<=\"` (yielding `Relationship.LEQ`), or `\"=\"` (yielding `Relationship.EQ`), throwing an `IllegalArgumentException` if none match, then splitting the string on the pattern `\"[>|<]?=\"` to extract the equation parts, parsing the second part trimmed as a `double` for `rhs`, creating a `double[]` array `lhs` of size `numCoefficients`, replacing all occurrences of ` ?x` with an empty string in the first equation part to get `left`, splitting `left` on `\" \"` to obtain `coefficients`, iterating over each `coefficient` string to compute `value` as `-1` if the first character is `'-'` otherwise `1`, parsing the `coefficient` after removing the leading `\"[+|-]\"` pattern and trimming to get the `index`, assigning `value` to `lhs[index]`, and finally returning `new LinearConstraint(lhs, relationship, rhs)`. Define a private static method `solve(double[] c, Collection<LinearConstraint> constraints)` that constructs a `LinearObjectiveFunction` named `f` by calling `new LinearObjectiveFunction(c, 0)`, assigns `1e-5` to a `double` variable `epsilon`, instantiates a `SimplexSolver` named `solver` by calling `new SimplexSolver(epsilon)`, and returns the result of invoking `solver.optimize(new MaxIter(1000), f, new LinearConstraintSet(constraints), GoalType.MAXIMIZE)`. Invoke `solve(c, constraints)` and assign the returned `PointValuePair` to `resultOriginal`, then invoke `getValue()` on `resultOriginal` and assign the result to a `double` variable `z1`. Instantiate a new `ArrayList<>()` and assign it to a `List<LinearConstraint>` variable named `shiftedConstraints`, then iterate over each `LinearConstraint` named `cons` in `constraints` by invoking `getCoefficients().toArray()` on `cons` to obtain a `double[]` array `coeffs`, computing `rhs` as `cons.getValue() + Sum.ofProducts(coeffs, d).getAsDouble()`, and adding `new LinearConstraint(coeffs, cons.getRelationship(), rhs)` to `shiftedConstraints`. Invoke `solve(c, shiftedConstraints)` and assign the returned `PointValuePair` to `resultShifted`, then invoke `getValue()` on `resultShifted` and assign the result to a `double` variable `z2`. Compute `z1New` as `z2 - Sum.ofProducts(c, d).getAsDouble()`, and finally assert using `Assert.assertEquals(\"MR violated\", z1, z1New, 1e-4)` that `z1` equals `z1New` within a delta of `1e-4`. The test uses the `@Test` annotation, JUnit 4 assertions via `Assert.assertEquals`, and the Apache Commons Math library classes `LinearConstraint`, `Relationship`, `LinearObjectiveFunction`, `SimplexSolver`, `MaxIter`, `LinearConstraintSet`, `GoalType`, `PointValuePair`, `RealVector`, and `Sum`.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.optim.linear.SimplexSolverTest",
            "method_signature": "testMath1674()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "com.example.LinearProgrammingTest",
            "code": "package com.example;\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport org.apache.commons.math4.legacy.optim.linear.LinearConstraint;\nimport org.apache.commons.math4.legacy.optim.linear.Relationship;\nimport org.apache.commons.math4.legacy.optim.linear.LinearObjectiveFunction;\nimport org.apache.commons.math4.legacy.optim.linear.SimplexSolver;\nimport org.apache.commons.math4.legacy.optim.MaxIter;\nimport org.apache.commons.math4.legacy.optim.linear.LinearConstraintSet;\nimport org.apache.commons.math4.legacy.optim.PointValuePair;\nimport org.apache.commons.math4.legacy.linear.RealVector;\nimport org.apache.commons.math4.legacy.linear.ArrayRealVector;\n\npublic class LinearProgrammingTest {\n\n    @Test\n    public void testMR() {\n        double[] c = {109.8416722130, 3995.2249004467, 4153.0918625648, 4205.9691060980, 6864.1761563995, 9985.9467230921, 6354.9344334526, 1460.7566224849, 9404.5575989194, 3074.9619692427, 6738.9813645788, 4251.4858953042, 3110.4876355988, 4790.6080441726, 8105.0878555759, 6994.9651570951, 6436.5681652562, 1938.6650475701, 1991.3366023235, 8807.6044972149, 1319.3678145792, 279.4114357595, 2406.8106667864, 721.4302264969, 8229.6476579561, 8081.4398910261, 1120.8874807145, 1027.1292710688, 9763.0697846171, 4736.8579838298, 1551.5944809986, 7117.2342065109, 7101.9720301735, 765.0876567377, 3266.2721870594, 9126.3837897194, 5682.7410411790, 737.5506525782, 640.9898129299, 6651.9205926265, 9967.7712540466, 9923.1032741511, 7320.8677028895};\n        double[] d = {2443.4617219283173, 1173.9746798742185, 4392.083363038196, 1390.8295640100537, 304.54498814002363, 3945.528655298191, 3423.0368504289595, 4256.823613052879, 821.3597860392124, 2451.720430980302, 4458.615770028524, 4566.059436861297, 2823.6879242564887, 543.3702798436418, 1077.6404845531451, 4032.1898198315507, 2692.8144489810506, 3224.220920651318, 1027.2527158190137, 4185.736937549958, 3991.8068663807326, 3532.2224429213907, 4536.16351791805, 3366.741013973095, 2560.9821638572507, 4146.908647998803, 2658.8999476871754, 1330.2326236467416, 4790.506804753733, 1055.1687831958889, 1246.2962844738324, 2793.4186611618766, 556.4873527843156, 421.19883191270304, 4052.515015289009, 4832.5688332462805, 612.5756476062232, 4401.140676006083, 3435.1692062499455, 4897.945863909211, 1066.0243804705144, 2018.8939865481348, 4082.6606399739544};\n        int nCoef = 43;\n\n        List<LinearConstraint> constraints = new ArrayList<LinearConstraint>() {{\n            double[] coeffs1 = new double[43];\n            coeffs1[0] = -18.4721096232;\n            coeffs1[1] = -346.7827878415;\n            add(new LinearConstraint(coeffs1, Relationship.LEQ, 634.5590200110));\n            for (int i = 0; i < 43; i++) {\n                add(new LinearConstraint(new double[43], Relationship.LEQ, 0));\n            }\n\n            for (int i = 0; i < nCoef; i++) {\n                add(equationFromString(nCoef, \"x\" + i + \" <= 10\"));\n                add(equationFromString(nCoef, \"x\" + i + \" >= -10\"));\n            }\n        }};\n\n        double[] c_neg = new double[c.length];\n        for (int i = 0; i < c.length; i++) {\n            c_neg[i] = -c[i];\n        }\n\n        PointValuePair resultOriginal = solve(c_neg, constraints);\n        double z1 = -resultOriginal.getValue();\n\n        List<LinearConstraint> shiftedConstraints = new ArrayList<>();\n        for (LinearConstraint cons : constraints) {\n            double[] coeffs = cons.getCoefficients().toArray();\n            double rhs = cons.getValue() + new ArrayRealVector(coeffs).dotProduct(new ArrayRealVector(d));\n            shiftedConstraints.add(new LinearConstraint(coeffs, cons.getRelationship(), rhs));\n        }\n\n        PointValuePair resultShifted = solve(c_neg, shiftedConstraints);\n        double z2 = -resultShifted.getValue();\n\n        double z1New = z2 - new ArrayRealVector(c).dotProduct(new ArrayRealVector(d));\n\n        Assert.assertEquals(\"MR violated\", z1, z1New, 1e-4);\n    }\n\n    private static PointValuePair solve(double[] c, Collection<LinearConstraint> constraints) {\n        // SimplexSolver defaults to minimization. To achieve maximization, we negate the objective function\n        // and then negate the result.\n        LinearObjectiveFunction f = new LinearObjectiveFunction(c, 0);\n        SimplexSolver solver = new SimplexSolver();\n        return solver.optimize(new MaxIter(1000), f, new LinearConstraintSet(constraints));\n    }\n\n    private LinearConstraint equationFromString(int numCoefficients, String s) {\n        Relationship relationship;\n        if (s.contains(\">=\")) {\n            relationship = Relationship.GEQ;\n        } else if (s.contains(\"<=\")) {\n            relationship = Relationship.LEQ;\n        } else if (s.contains(\"=\")) {\n            relationship = Relationship.EQ;\n        } else {\n            throw new IllegalArgumentException(\"Invalid relationship in constraint string.\");\n        }\n\n        String[] parts = s.split(\"[>|<]?=\");\n        double rhs = Double.parseDouble(parts[1].trim());\n        double[] lhs = new double[numCoefficients];\n        String left = parts[0].replaceAll(\" ?x\", \"\");\n        String[] coefficients = left.split(\" \");\n\n        for (String coefficient : coefficients) {\n            if (coefficient.isEmpty()) continue;\n            double value = 1;\n            if (coefficient.startsWith(\"-\")) {\n                value = -1;\n            }\n            String num = coefficient.replaceAll(\"[+|-]\", \"\").trim();\n            int index = Integer.parseInt(num);\n            lhs[index] = value;\n        }\n        return new LinearConstraint(lhs, relationship, rhs);\n    }\n}",
            "method_signature": "testMR()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 0.75,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.0383,
            "callable_precision": 0.8507,
            "focal_recall": 1.0,
            "focal_precision": 0.6667
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.optim.linear.SimplexSolverTest",
            "method_signature": "testMath1674()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.linear.RealVector.toArray()",
                "org.apache.commons.math4.legacy.optim.PointValuePair.getValue()"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.optim.PointValuePair.getValue()"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.linear.RealVector.toArray()"
            ],
            "tp": 1,
            "fn": 1,
            "localization_recall": 0.5
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 2,
                    "compile_and_execute_test": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 9,
                    "get_method_details": 12,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 7,
                    "compile_and_execute_test": 7,
                    "get_maven_dependencies": 2,
                    "get_class_fields": 1,
                    "get_method_details": 2,
                    "finalize": 2,
                    "get_class_constructors_and_factories": 2,
                    "modify_scenario_comment": 1
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_class_fields",
                        "get_method_details",
                        "finalize"
                    ],
                    [
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "get_class_constructors_and_factories",
                        "modify_scenario_comment",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 436266,
        "output_tokens": 51484,
        "llm_calls": 33
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 465,
            "description": "Create a test case to validate that the system's summation utility correctly handles all edge cases and properly computes totals across various input scenarios. Begin by confirming the system rejects missing input data by attempting to calculate a sum without providing any values and verifying the operation fails with an appropriate error, then confirm the same failure occurs when attempting to calculate a partial sum with missing data. After establishing these safeguards, verify the system returns an undefined result when presented with an empty collection of values, and confirm this behavior applies both when calculating the full sum and when requesting a partial sum of zero elements. Once these boundary conditions are validated, test the system with a single-element collection and ensure the sum equals that single value, verifying this holds true both for the complete collection and when explicitly requesting just that one element. Finally, evaluate the system's behavior with a multi-element collection by confirming the total of all values matches the expected aggregate, then verify the system can correctly sum a specified subset of consecutive elements from within the larger collection, ensuring the partial calculation produces the anticipated subtotal. Testing is conducted using JUnit 5 with standard equality assertions that account for acceptable numerical precision tolerance.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.StatUtilsTest",
            "method_signature": "testSum()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.StatUtilsTest1",
            "code": "package org.apache.commons.math4.legacy.stat;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class StatUtilsTest1 {\n\n    @Test\n    public void summationUtilityTest() {\n        // Test case 1: Missing input data (null array)\n        assertThrows(NullPointerException.class, () -> StatUtils.sum((double[]) null));\n\n        // Test case 2: Missing input data for partial sum (null array)\n        assertThrows(NullPointerException.class, () -> StatUtils.sum(null, 0, 0));\n\n        // Test case 3: Empty collection\n        double[] emptyCollection = new double[]{};\n        double sumResultEmpty = StatUtils.sum(emptyCollection);\n        assertEquals(Double.NaN, sumResultEmpty, 0.0001);\n\n        // Test case 4: Partial sum of zero elements from an empty collection\n        double partialSumResultEmpty = StatUtils.sum(emptyCollection, 0, 0);\n        assertEquals(Double.NaN, partialSumResultEmpty, 0.0001);\n\n        // Test case 5: Single-element collection\n        double singleValue = 10.5;\n        double[] singleElementCollection = new double[]{singleValue};\n        double sumResultSingle = StatUtils.sum(singleElementCollection);\n        assertEquals(singleValue, sumResultSingle, 0.0001);\n\n        // Test case 6: Partial sum of a single-element collection\n        double partialSumResultSingle = StatUtils.sum(singleElementCollection, 0, 1);\n        assertEquals(singleValue, partialSumResultSingle, 0.0001);\n\n        // Test case 7: Multi-element collection\n        double[] multiElementCollection = new double[]{1.0, 2.5, 3.0, 4.5, 5.0};\n        double expectedTotalSum = 16.0;\n        double actualTotalSum = StatUtils.sum(multiElementCollection);\n        assertEquals(expectedTotalSum, actualTotalSum, 0.0001);\n\n        // Test case 8: Partial sum of a multi-element collection\n        int begin = 1;\n        int length = 3;\n        double expectedPartialSum = 10.0; // 2.5 + 3.0 + 4.5\n        double actualPartialSum = StatUtils.sum(multiElementCollection, begin, length);\n        assertEquals(expectedPartialSum, actualPartialSum, 0.0001);\n    }\n}",
            "method_signature": "summationUtilityTest()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.875,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.StatUtilsTest",
            "method_signature": "testSum()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[], int, int)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[], int, int)"
            ],
            "uncovered_focal_methods": [],
            "tp": 2,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 3,
                    "query_class_db": 6,
                    "get_method_details": 6,
                    "search_reachable_methods_in_class": 4,
                    "get_inherited_library_classes": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_method_db",
                        "query_class_db",
                        "query_class_db",
                        "get_method_details",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "query_class_db",
                        "get_inherited_library_classes",
                        "query_class_db",
                        "query_method_db",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "query_class_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_maven_dependencies": 1,
                    "get_method_details": 2,
                    "generate_test_code": 3,
                    "compile_and_execute_test": 3,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_maven_dependencies",
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 214832,
        "output_tokens": 15276,
        "llm_calls": 24
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 472,
            "description": "Define a test method that validates the statistical sum utility's behavior across null inputs, empty arrays, single-element arrays, and multi-element arrays with both full-array and subrange computations. Begin by initializing a null double array reference, then invoke the sum method on the utility class with this null reference and verify that a null argument exception is thrown, followed by invoking the overloaded sum method that accepts begin and length parameters with the same null reference to confirm it also throws a null argument exception. Next, initialize an empty double array and invoke both the full-array sum method and the subrange sum method with zero length, validating through a custom assertion helper that both return NaN within a specified tolerance. Proceed by initializing a single-element array containing a predefined numeric constant, invoke the full-array sum method and verify the result equals the constant value within tolerance, then invoke the subrange sum method covering the single element and confirm the same expected result. Finally, initialize a multi-element array populated with several predefined numeric constants, invoke the full-array sum method and validate the result equals the total sum of all elements within tolerance, then invoke the subrange sum method specifying a starting index and element count that excludes the first element and limits the range, validating that the result equals the sum of only the included elements within tolerance. The test relies on JUnit for test execution, a custom assertion utility for floating-point comparisons, and predefined class-level constants representing test values and tolerance thresholds.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.StatUtilsTest",
            "method_signature": "testSum()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.StatUtilsSumTest",
            "code": "package org.apache.commons.math4.legacy.stat;\n\nimport org.apache.commons.math4.legacy.exception.NullArgumentException;\nimport org.junit.jupiter.api.Test;\nimport java.util.Arrays;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class StatUtilsSumTest {\n\n    private static final double PREDEFINED_CONSTANT = 10.0;\n    private static final double[] PREDEFINED_CONSTANTS = {1.0, 2.0, 3.0, 4.0, 5.0};\n    private static final double TOLERANCE_THRESHOLD = 1e-9;\n\n    @Test\n    public void testSum() {\n        // Null input\n        double[] nullArrayRef = null;\n        assertThrows(NullArgumentException.class, () -> StatUtils.sum(nullArrayRef));\n        assertThrows(NullArgumentException.class, () -> StatUtils.sum(nullArrayRef, 0, 0));\n\n        // Empty array\n        double[] emptyArray = new double[0];\n        assertEquals(Double.NaN, StatUtils.sum(emptyArray), TOLERANCE_THRESHOLD);\n        assertEquals(Double.NaN, StatUtils.sum(emptyArray, 0, 0), TOLERANCE_THRESHOLD);\n\n        // Single-element array\n        double[] singleElementArray = {PREDEFINED_CONSTANT};\n        assertEquals(PREDEFINED_CONSTANT, StatUtils.sum(singleElementArray), TOLERANCE_THRESHOLD);\n        assertEquals(PREDEFINED_CONSTANT, StatUtils.sum(singleElementArray, 0, 1), TOLERANCE_THRESHOLD);\n\n        // Multi-element array\n        double[] multiElementArray = PREDEFINED_CONSTANTS;\n        assertEquals(Arrays.stream(multiElementArray).sum(), StatUtils.sum(multiElementArray), TOLERANCE_THRESHOLD);\n        assertEquals(Arrays.stream(multiElementArray, 1, multiElementArray.length).sum(), StatUtils.sum(multiElementArray, 1, multiElementArray.length - 1), TOLERANCE_THRESHOLD);\n    }\n}",
            "method_signature": "testSum()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.875,
            "callable_precision": 0.7778,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.StatUtilsTest",
            "method_signature": "testSum()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[], int, int)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[], int, int)"
            ],
            "uncovered_focal_methods": [],
            "tp": 2,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 3,
                    "query_class_db": 2,
                    "search_reachable_methods_in_class": 3,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "query_method_db",
                        "query_method_db",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_maven_dependencies": 1,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 114274,
        "output_tokens": 9965,
        "llm_calls": 15
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 479,
            "description": "Define a test class containing private static final fields: `ONE` of type `double`, `TWO` of type `float`, `THREE` of type `int`, `MEAN` of type `double`, `SUMSQ` of type `double`, `SUM` of type `double`, `VAR` of type `double`, `MIN` of type `double`, `MAX` of type `double`, `TOLERANCE` of type `double`, and `NAN` of type `double`. Within the test method, declare a local variable `x` of type `double[]` and initialize it to `null`. Begin by invoking `StatUtils.sum(x)` within a try-catch block, expecting a `NullArgumentException` to be thrown; if no exception is caught, invoke `Assert.fail` with the message `\"null is not a valid data array.\"`, and if the exception is caught, allow execution to continue. Next, invoke `StatUtils.sum(x, 0, 4)` within another try-catch block, again expecting a `NullArgumentException`; if no exception is caught, invoke `Assert.fail` with the message `\"null is not a valid data array.\"`, and if the exception is caught, proceed. Reassign `x` to a new empty `double[]` array with zero elements, then invoke `TestUtils.assertEquals` with arguments `Double.NaN`, the result of `StatUtils.sum(x)`, and `TOLERANCE`, followed by invoking `TestUtils.assertEquals` with arguments `Double.NaN`, the result of `StatUtils.sum(x, 0, 0)`, and `TOLERANCE`. Reassign `x` to a new `double[]` array containing a single element `TWO`, then invoke `TestUtils.assertEquals` with arguments `2`, the result of `StatUtils.sum(x)`, and `TOLERANCE`, followed by invoking `TestUtils.assertEquals` with arguments `2`, the result of `StatUtils.sum(x, 0, 1)`, and `TOLERANCE`. Reassign `x` to a new `double[]` array containing four elements `{ONE, TWO, TWO, THREE}`, then invoke `TestUtils.assertEquals` with arguments `8`, the result of `StatUtils.sum(x)`, and `TOLERANCE`, followed by invoking `TestUtils.assertEquals` with arguments `4`, the result of `StatUtils.sum(x, 1, 2)`, and `TOLERANCE`. The test uses method-level annotation `@Test`, assertion libraries JUnit 4 Assertions (via `Assert.fail`) and a custom helper assertion `TestUtils.assertEquals`, and no mocking libraries.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.StatUtilsTest",
            "method_signature": "testSum()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.StatUtilsTest1",
            "code": "package org.apache.commons.math4.legacy.stat;\n\nimport org.junit.Test;\nimport org.junit.Assert;\nimport org.apache.commons.math4.legacy.stat.StatUtils;\nimport org.apache.commons.math4.legacy.exception.NullArgumentException;\n\npublic class StatUtilsTest1 {\n\n    private static final double ONE = 1.0;\n    private static final float TWO = 2.0f;\n    private static final int THREE = 3;\n    private static final double MEAN = 2.0;\n    private static final double SUMSQ = 18.0;\n    private static final double SUM = 8.0;\n    private static final double VAR = 0.6666666666666667;\n    private static final double MIN = 1.0;\n    private static final double MAX = 3.0;\n    private static final double TOLERANCE = 1.0E-14;\n    private static final double NAN = Double.NaN;\n\n    @Test\n    public void testSum() {\n        double[] x = null;\n        try {\n            StatUtils.sum(x);\n            Assert.fail(\"null is not a valid data array.\");\n        } catch (NullArgumentException e) {\n            // expected\n        }\n\n        try {\n            StatUtils.sum(x, 0, 4);\n            Assert.fail(\"null is not a valid data array.\");\n        } catch (NullArgumentException e) {\n            // expected\n        }\n\n        x = new double[0];\n        Assert.assertEquals(Double.NaN, StatUtils.sum(x), TOLERANCE);\n        Assert.assertEquals(Double.NaN, StatUtils.sum(x, 0, 0), TOLERANCE);\n\n        x = new double[]{TWO};\n        Assert.assertEquals(2, StatUtils.sum(x), TOLERANCE);\n        Assert.assertEquals(2, StatUtils.sum(x, 0, 1), TOLERANCE);\n\n        x = new double[]{ONE, TWO, TWO, THREE};\n        Assert.assertEquals(8, StatUtils.sum(x), TOLERANCE);\n        Assert.assertEquals(4, StatUtils.sum(x, 1, 2), TOLERANCE);\n    }\n}",
            "method_signature": "testSum()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 1.0,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.StatUtilsTest",
            "method_signature": "testSum()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[], int, int)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[], int, int)"
            ],
            "uncovered_focal_methods": [],
            "tp": 2,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 4,
                    "query_class_db": 4,
                    "search_reachable_methods_in_class": 2,
                    "get_method_details": 3,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_method_db",
                        "query_class_db",
                        "query_class_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "query_class_db",
                        "query_method_db",
                        "query_method_db",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_maven_dependencies": 1,
                    "generate_test_code": 2,
                    "compile_and_execute_test": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 142399,
        "output_tokens": 13055,
        "llm_calls": 17
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 598,
            "description": "Define a test class containing a private static field `random` of type `UniformRandomProvider`, then write a test method annotated with `@Test` that begins by defining a private method named `createDescriptiveStatistics` which instantiates and returns a new `DescriptiveStatistics` object by invoking its no-argument constructor, then invoke this helper method and assign the result to a local variable `stats` of type `DescriptiveStatistics`. Declare a local variable `x` of type `double[]` and initialize it with an empty array literal `{}`. Invoke `StatUtils.mean(x)` and pass the result as the expected value to `Assertions.assertEquals`, then invoke `stats.getMean()` and pass the result as the actual value to the same assertion. Invoke `StatUtils.geometricMean(x)` and pass the result as the expected value to `Assertions.assertEquals`, then invoke `stats.getGeometricMean()` and pass the result as the actual value to the same assertion. Invoke `StatUtils.variance(x)` and assign the result to a local variable `v` of type `double`. Pass `v` as the expected value to `Assertions.assertEquals`, then invoke `stats.getVariance()` and pass the result as the actual value to the same assertion. Invoke `JdkMath.sqrt(v)` and pass the result as the expected value to `Assertions.assertEquals`, then invoke `stats.getStandardDeviation()` and pass the result as the actual value to the same assertion. Pass the literal `Double.NaN` as the expected value to `Assertions.assertEquals`, then invoke `stats.getQuadraticMean()` and pass the result as the actual value to the same assertion. Pass the literal `Double.NaN` as the expected value to `Assertions.assertEquals`, then invoke `stats.getKurtosis()` and pass the result as the actual value to the same assertion. Pass the literal `Double.NaN` as the expected value to `Assertions.assertEquals`, then invoke `stats.getSkewness()` and pass the result as the actual value to the same assertion. Invoke `StatUtils.max(x)` and pass the result as the expected value to `Assertions.assertEquals`, then invoke `stats.getMax()` and pass the result as the actual value to the same assertion. Invoke `StatUtils.min(x)` and pass the result as the expected value to `Assertions.assertEquals`, then invoke `stats.getMin()` and pass the result as the actual value to the same assertion. Invoke `StatUtils.sum(x)` and pass the result as the expected value to `Assertions.assertEquals`, then invoke `stats.getSum()` and pass the result as the actual value to the same assertion. Invoke `StatUtils.sumSq(x)` and pass the result as the expected value to `Assertions.assertEquals`, then invoke `stats.getSumsq()` and pass the result as the actual value to the same assertion. The test uses method-level annotation `@Test`, assertion library JUnit 5 Assertions, and no mocking libraries.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatisticsTest",
            "method_signature": "testEmpty()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatisticsTest1",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive;\n\nimport org.apache.commons.rng.UniformRandomProvider;\nimport org.apache.commons.math4.legacy.stat.StatUtils;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class DescriptiveStatisticsTest1 {\n\n    private static UniformRandomProvider random;\n\n    private DescriptiveStatistics createDescriptiveStatistics() {\n        return new DescriptiveStatistics();\n    }\n\n    @Test\n    public void testEmpty() {\n        DescriptiveStatistics stats = createDescriptiveStatistics();\n        double[] x = {};\n        Assertions.assertEquals(StatUtils.mean(x), stats.getMean());\n        Assertions.assertEquals(StatUtils.geometricMean(x), stats.getGeometricMean());\n        double v = StatUtils.variance(x);\n        Assertions.assertEquals(v, stats.getVariance());\n        Assertions.assertEquals(Math.sqrt(v), stats.getStandardDeviation());\n        Assertions.assertEquals(Double.NaN, stats.getQuadraticMean());\n        Assertions.assertEquals(Double.NaN, stats.getKurtosis());\n        Assertions.assertEquals(Double.NaN, stats.getSkewness());\n        Assertions.assertEquals(StatUtils.max(x), stats.getMax());\n        Assertions.assertEquals(StatUtils.min(x), stats.getMin());\n        Assertions.assertEquals(StatUtils.sum(x), stats.getSum());\n        Assertions.assertEquals(StatUtils.sumSq(x), stats.getSumsq());\n    }\n}",
            "method_signature": "testEmpty()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.9688,
            "callable_precision": 0.9688,
            "focal_recall": 0.9474,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatisticsTest",
            "method_signature": "testEmpty()",
            "all_focal_methods": [
                "org.apache.commons.math4.core.jdkmath.JdkMath.sqrt(double)",
                "org.apache.commons.math4.legacy.stat.StatUtils.geometricMean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.max(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.mean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.min(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sumSq(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.variance(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getGeometricMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getKurtosis()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getQuadraticMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSkewness()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getStandardDeviation()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSumsq()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getVariance()"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.StatUtils.variance(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getGeometricMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getKurtosis()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getQuadraticMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSkewness()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getStandardDeviation()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSumsq()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getVariance()"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.core.jdkmath.JdkMath.sqrt(double)",
                "org.apache.commons.math4.legacy.stat.StatUtils.geometricMean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.max(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.mean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.min(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sumSq(double[])"
            ],
            "tp": 12,
            "fn": 7,
            "localization_recall": 0.6316
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 2,
                    "get_method_details": 13,
                    "query_method_db": 6,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_class_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 2,
                    "compile_and_execute_test": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 81247,
        "output_tokens": 12631,
        "llm_calls": 12
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 602,
            "description": "Define a test method that validates the behavior of the Descriptive Statistics component when initialized with an empty dataset by creating a helper method that instantiates the statistics object, then constructing an empty double array to serve as the input data. With the statistics instance and empty array established, systematically verify that each statistical computation method on the Descriptive Statistics component produces results consistent with the corresponding static utility methods from Stat Utils when applied to the same empty array, beginning with the arithmetic mean retrieval and comparing it against the static mean calculation. Continue this pattern by invoking the geometric mean accessor on the statistics instance and asserting equality with the static geometric mean computation, then retrieve the variance from the statistics object, store this value in a local variable, and validate it matches the static variance calculation before using this stored variance to verify the standard deviation by asserting that the statistics instance's standard deviation equals the square root of the variance computed through the JDK Math utility. Proceed to validate the quadratic mean by asserting it equals NaN, followed by verifying that both kurtosis and skewness accessors return NaN when invoked on the statistics instance. Complete the verification sequence by comparing the maximum value from the statistics object against the static maximum utility method result, then validating the minimum value similarly, and finally asserting that both the sum and sum of squares retrieved from the statistics instance match their respective static utility method calculations when applied to the empty array. JUnit 5 and Assertions.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatisticsTest",
            "method_signature": "testEmpty()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatisticsTest1",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive;\n\nimport org.apache.commons.math4.legacy.stat.StatUtils;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class DescriptiveStatisticsTest1 {\n\n    @Test\n    public void testEmptyInput() {\n        double[] emptyDataArray = new double[0];\n        DescriptiveStatistics statisticsInstance = new DescriptiveStatistics(emptyDataArray);\n\n        Assertions.assertEquals(StatUtils.mean(emptyDataArray), statisticsInstance.getMean());\n        Assertions.assertEquals(StatUtils.geometricMean(emptyDataArray), statisticsInstance.getGeometricMean());\n\n        double instanceVariance = statisticsInstance.getVariance();\n        Assertions.assertEquals(StatUtils.variance(emptyDataArray), instanceVariance);\n        Assertions.assertEquals(Math.sqrt(instanceVariance), statisticsInstance.getStandardDeviation());\n\n        Assertions.assertEquals(Double.NaN, statisticsInstance.getQuadraticMean());\n        Assertions.assertEquals(Double.NaN, statisticsInstance.getKurtosis());\n        Assertions.assertEquals(Double.NaN, statisticsInstance.getSkewness());\n\n        Assertions.assertEquals(StatUtils.max(emptyDataArray), statisticsInstance.getMax());\n        Assertions.assertEquals(StatUtils.min(emptyDataArray), statisticsInstance.getMin());\n        Assertions.assertEquals(StatUtils.sum(emptyDataArray), statisticsInstance.getSum());\n        Assertions.assertEquals(StatUtils.sumSq(emptyDataArray), statisticsInstance.getSumsq());\n    }\n}",
            "method_signature": "testEmptyInput()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 0.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.9375,
            "callable_precision": 0.9677,
            "focal_recall": 0.9474,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatisticsTest",
            "method_signature": "testEmpty()",
            "all_focal_methods": [
                "org.apache.commons.math4.core.jdkmath.JdkMath.sqrt(double)",
                "org.apache.commons.math4.legacy.stat.StatUtils.geometricMean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.max(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.mean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.min(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sumSq(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.variance(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getGeometricMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getKurtosis()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getQuadraticMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSkewness()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getStandardDeviation()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSumsq()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getVariance()"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getGeometricMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getKurtosis()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getQuadraticMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSkewness()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getStandardDeviation()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSumsq()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getVariance()"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.core.jdkmath.JdkMath.sqrt(double)",
                "org.apache.commons.math4.legacy.stat.StatUtils.geometricMean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.max(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.mean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.min(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sumSq(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.variance(double[])"
            ],
            "tp": 11,
            "fn": 8,
            "localization_recall": 0.5789
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 2,
                    "get_method_details": 1,
                    "search_reachable_methods_in_class": 19,
                    "get_inherited_library_classes": 1,
                    "query_method_db": 4,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_class_db",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "get_inherited_library_classes",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "search_reachable_methods_in_class",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 96686,
        "output_tokens": 9961,
        "llm_calls": 13
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 1457,
            "description": "Create a test case to validate that the statistical analysis system correctly handles scenarios where no data observations have been recorded, ensuring all computed metrics return mathematically appropriate undefined values. Begin by establishing a fresh statistical analysis context with no prior observations, then simulate an empty data collection scenario by providing no numerical measurements to the system. Once the empty state is confirmed, systematically verify that the system reports undefined results for all statistical measures including the arithmetic average, geometric average, data spread, spread consistency, quadratic average, distribution shape characteristics (both asymmetry and peak concentration), boundary values (both highest and lowest observations), total accumulation, and squared total accumulation, comparing each computed result against the expected outcome when applying the same calculation to an empty data set. After confirming the system correctly produces undefined values for all metrics when no observations exist, verify the overall behavior using standard equality assertions provided by JUnit 5 and AssertJ without requiring any mocking capabilities.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatisticsTest",
            "method_signature": "testEmpty()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatisticsEmptyTest",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Assertions;\n\npublic class DescriptiveStatisticsEmptyTest {\n\n    @Test\n    public void testEmptyStatistics() {\n        DescriptiveStatistics statistical_analysis_context = new DescriptiveStatistics();\n\n        double expected_undefined_result = Double.NaN;\n\n        double computed_arithmetic_average = statistical_analysis_context.getMean();\n        Assertions.assertEquals(expected_undefined_result, computed_arithmetic_average);\n\n        double computed_geometric_average = statistical_analysis_context.getGeometricMean();\n        Assertions.assertEquals(expected_undefined_result, computed_geometric_average);\n\n        double computed_data_spread = statistical_analysis_context.getVariance();\n        Assertions.assertEquals(expected_undefined_result, computed_data_spread);\n\n        double computed_spread_consistency = statistical_analysis_context.getStandardDeviation();\n        Assertions.assertEquals(expected_undefined_result, computed_spread_consistency);\n\n        double computed_quadratic_average = statistical_analysis_context.getQuadraticMean();\n        Assertions.assertEquals(expected_undefined_result, computed_quadratic_average);\n\n        double computed_shape_asymmetry = statistical_analysis_context.getSkewness();\n        Assertions.assertEquals(expected_undefined_result, computed_shape_asymmetry);\n\n        double computed_peak_concentration = statistical_analysis_context.getKurtosis();\n        Assertions.assertEquals(expected_undefined_result, computed_peak_concentration);\n\n        double computed_highest_observation = statistical_analysis_context.getMax();\n        Assertions.assertEquals(expected_undefined_result, computed_highest_observation);\n\n        double computed_lowest_observation = statistical_analysis_context.getMin();\n        Assertions.assertEquals(expected_undefined_result, computed_lowest_observation);\n\n        double computed_total_accumulation = statistical_analysis_context.getSum();\n        Assertions.assertEquals(expected_undefined_result, computed_total_accumulation);\n\n        double computed_squared_total_accumulation = statistical_analysis_context.getSumsq();\n        Assertions.assertEquals(expected_undefined_result, computed_squared_total_accumulation);\n    }\n}",
            "method_signature": "testEmptyStatistics()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 0.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.7188,
            "callable_precision": 1.0,
            "focal_recall": 0.5789,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatisticsTest",
            "method_signature": "testEmpty()",
            "all_focal_methods": [
                "org.apache.commons.math4.core.jdkmath.JdkMath.sqrt(double)",
                "org.apache.commons.math4.legacy.stat.StatUtils.geometricMean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.max(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.mean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.min(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sumSq(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.variance(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getGeometricMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getKurtosis()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getQuadraticMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSkewness()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getStandardDeviation()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSumsq()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getVariance()"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getGeometricMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getKurtosis()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getQuadraticMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSkewness()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getStandardDeviation()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getSumsq()",
                "org.apache.commons.math4.legacy.stat.descriptive.DescriptiveStatistics.getVariance()"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.core.jdkmath.JdkMath.sqrt(double)",
                "org.apache.commons.math4.legacy.stat.StatUtils.geometricMean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.max(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.mean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.min(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sumSq(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.variance(double[])"
            ],
            "tp": 11,
            "fn": 8,
            "localization_recall": 0.5789
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 1,
                    "query_method_db": 14,
                    "get_method_details": 13,
                    "get_inherited_library_classes": 1,
                    "search_reachable_methods_in_class": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_inherited_library_classes",
                        "query_method_db",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 3,
                    "compile_and_execute_test": 3,
                    "modify_scenario_comment": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "modify_scenario_comment",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "modify_scenario_comment",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 149073,
        "output_tokens": 15359,
        "llm_calls": 18
    },
    {
        "compiles": false,
        "nl2test_input": {
            "id": 428,
            "description": "Define a parameterized test method that validates the Percentile component's rejection of invalid percentile values across multiple boundary and exceptional inputs including negative values, values exceeding one hundred, and non-numeric representations. Initialize a Percentile instance with a valid mid-range percentile value to establish a baseline component. For each invalid parameter value provided to the test, verify that invoking the quantile modification method on the initialized instance throws a range validation error, then separately verify that attempting to create a new Percentile instance directly with the same invalid parameter also throws a range validation error. The test exercises both post-construction configuration and factory construction paths to ensure consistent validation behavior across the component's lifecycle. Use JUnit 5 for parameterized testing and assertions.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testInvalidPercentileThrows(double)",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.rank.PercentileTest",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive.rank;\n\nimport org.apache.commons.math4.legacy.stat.descriptive.rank.Percentile;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class PercentileTest {\n\n    @ParameterizedTest\n    @ValueSource(doubles = {-1.0, 101.0, Double.NaN})\n    void testInvalidQuantile(double invalidQuantile) {\n        // Setup: Initialize a Percentile instance with a valid mid-range percentile value\n        Percentile baselinePercentileInstance = new Percentile(50.0);\n\n        // Verify that invoking the quantile modification method throws a range validation error\n        assertThrows(IllegalArgumentException.class, () -> {\n            baselinePercentileInstance.setQuantile(invalidQuantile);\n        });\n\n        // Verify that attempting to create a new Percentile instance with the invalid value also throws a range validation error\n        assertThrows(IllegalArgumentException.class, () -> {\n            new Percentile(invalidQuantile);\n        });\n    }\n}",
            "method_signature": "testInvalidQuantile(double)"
        },
        "structured_eval": {
            "obj_creation_recall": 0.0,
            "obj_creation_precision": 0.0,
            "assertion_recall": 0.0,
            "assertion_precision": 0.0,
            "callable_recall": 0.0,
            "callable_precision": 0.0,
            "focal_recall": 0.0,
            "focal_precision": 0.0
        },
        "coverage_eval": {
            "class_coverage": 0.0,
            "method_coverage": 0.0,
            "line_coverage": 0.0,
            "branch_coverage": 0.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testInvalidPercentileThrows(double)",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.create(double)",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.setQuantile(double)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.setQuantile(double)"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.create(double)"
            ],
            "tp": 1,
            "fn": 1,
            "localization_recall": 0.5
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 3,
                    "call_composition_agent": 3,
                    "compile_and_execute_test": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "call_composition_agent",
                        "call_localization_agent",
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 6,
                    "query_class_db": 3,
                    "search_reachable_methods_in_class": 2,
                    "get_method_details": 4,
                    "finalize": 3
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_class_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ],
                    [
                        "query_class_db",
                        "finalize"
                    ],
                    [
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_method_details": 5,
                    "get_maven_dependencies": 3,
                    "generate_test_code": 16,
                    "compile_and_execute_test": 14,
                    "modify_scenario_comment": 4,
                    "finalize": 3,
                    "get_class_constructors_and_factories": 3,
                    "get_getters_and_setters": 3
                },
                "tool_trajectories": [
                    [
                        "get_method_details",
                        "get_method_details",
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "modify_scenario_comment",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "generate_test_code",
                        "finalize"
                    ],
                    [
                        "get_class_constructors_and_factories",
                        "get_getters_and_setters",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_maven_dependencies",
                        "get_class_constructors_and_factories",
                        "get_getters_and_setters",
                        "get_method_details",
                        "get_class_constructors_and_factories",
                        "get_getters_and_setters",
                        "modify_scenario_comment",
                        "modify_scenario_comment",
                        "modify_scenario_comment",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ],
                    [
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 578426,
        "output_tokens": 38105,
        "llm_calls": 62
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 431,
            "description": "Create a test case to validate that the percentile calculation system correctly rejects invalid percentile values that fall outside the acceptable business range or represent undefined numerical states. Configure the test to examine multiple problematic percentile values including those below the minimum threshold, above the maximum threshold, and mathematically undefined values. For each invalid value, attempt to configure a percentile calculator with that value in two distinct scenarios: first by initializing a new calculator instance with a valid percentile and then attempting to update its configuration to the invalid value, and second by attempting to initialize a fresh calculator directly with the invalid value. In both scenarios, ensure the system refuses the operation and signals a business constraint violation indicating the value is out of acceptable range. Verify using standard equality assertions with JUnit 5 for test execution and parameterization across the invalid value set.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testInvalidPercentileThrows(double)",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsPercentileTest",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive;\n\nimport org.apache.commons.math4.legacy.exception.OutOfRangeException;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class StatisticsPercentileTest {\n\n    private static final double VALID_PERCENTILE = 50.0;\n\n    @ParameterizedTest\n    @ValueSource(doubles = {-1.0, 101.0, Double.NaN})\n    void updateWithInvalidPercentileThrowsException(double invalidPercentile) {\n        Statistics.Percentile percentileCalculator = Statistics.Percentile.create(VALID_PERCENTILE);\n\n        assertThrows(OutOfRangeException.class, () -> {\n            percentileCalculator.setQuantile(invalidPercentile);\n        });\n    }\n\n    @ParameterizedTest\n    @ValueSource(doubles = {-1.0, 101.0, Double.NaN})\n    void createWithInvalidPercentileThrowsException(double invalidPercentile) {\n        assertThrows(OutOfRangeException.class, () -> {\n            Statistics.Percentile.create(invalidPercentile);\n        });\n    }\n}",
            "method_signature": "updateWithInvalidPercentileThrowsException(double)"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 0.5,
            "assertion_precision": 1.0,
            "callable_recall": 0.6667,
            "callable_precision": 0.6667,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testInvalidPercentileThrows(double)",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.create(double)",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.setQuantile(double)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.create(double)"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.setQuantile(double)"
            ],
            "tp": 1,
            "fn": 1,
            "localization_recall": 0.5
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 2,
                    "query_method_db": 3,
                    "get_method_details": 3,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_class_db",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "query_method_db",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 3,
                    "compile_and_execute_test": 3,
                    "get_class_constructors_and_factories": 3,
                    "get_getters_and_setters": 1,
                    "extract_method_code": 2,
                    "get_call_site_details": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_class_constructors_and_factories",
                        "get_class_constructors_and_factories",
                        "get_class_constructors_and_factories",
                        "get_getters_and_setters",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "extract_method_code",
                        "get_call_site_details",
                        "extract_method_code",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 153723,
        "output_tokens": 13835,
        "llm_calls": 19
    },
    {
        "compiles": false,
        "nl2test_input": {
            "id": 435,
            "description": "Define a parameterized test method accepting a `double` parameter `p`, annotated with `@ParameterizedTest` and `@ValueSource(doubles = { -1, 101, Double.NaN })`, which will execute three times with each of these invalid percentile values. Begin by invoking the static factory method `Percentile.create` with the literal `double` argument `50`, assigning the returned `Percentile` instance to a local variable named `stat`. Immediately assert that invoking `setQuantile` on `stat` with the parameter `p` throws an `OutOfRangeException` by calling `Assertions.assertThrows(OutOfRangeException.class, () -> stat.setQuantile(p))`. Following this assertion, verify that the static factory method itself rejects invalid input by asserting that `Percentile.create(p)` also throws `OutOfRangeException` using `Assertions.assertThrows(OutOfRangeException.class, () -> Percentile.create(p))`. The test uses JUnit 5 Assertions and the `@ParameterizedTest` annotation with `@ValueSource` to supply test data.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testInvalidPercentileThrows(double)",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math3.stat.descriptive.rank.PercentileTest",
            "code": "package org.apache.commons.math3.stat.descriptive.rank;\n\nimport org.apache.commons.math3.exception.OutOfRangeException;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\npublic class PercentileTest {\n\n    @ParameterizedTest\n    @ValueSource(doubles = { -1, 101, Double.NaN })\n    public void testInvalidPercentile(double p) {\n        Percentile stat = Percentile.create(50.0);\n        Assertions.assertThrows(OutOfRangeException.class, () -> stat.setQuantile(p));\n        Assertions.assertThrows(OutOfRangeException.class, () -> Percentile.create(p));\n    }\n}",
            "method_signature": "testInvalidPercentile(double)"
        },
        "structured_eval": {
            "obj_creation_recall": 0.0,
            "obj_creation_precision": 0.0,
            "assertion_recall": 0.0,
            "assertion_precision": 0.0,
            "callable_recall": 0.0,
            "callable_precision": 0.0,
            "focal_recall": 0.0,
            "focal_precision": 0.0
        },
        "coverage_eval": {
            "class_coverage": 0.0,
            "method_coverage": 0.0,
            "line_coverage": 0.0,
            "branch_coverage": 0.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testInvalidPercentileThrows(double)",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.create(double)",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.setQuantile(double)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.create(double)",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.setQuantile(double)"
            ],
            "uncovered_focal_methods": [],
            "tp": 2,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 2,
                    "view_test_code": 1,
                    "compile_and_execute_test": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "view_test_code",
                        "compile_and_execute_test",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 2,
                    "query_class_db": 2,
                    "search_reachable_methods_in_class": 4,
                    "get_method_details": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_method_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_maven_dependencies": 2,
                    "generate_test_code": 9,
                    "compile_and_execute_test": 9,
                    "finalize": 2,
                    "modify_scenario_comment": 6,
                    "get_class_constructors_and_factories": 1,
                    "get_method_details": 1,
                    "get_class_fields": 1
                },
                "tool_trajectories": [
                    [
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ],
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_maven_dependencies",
                        "modify_scenario_comment",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "get_class_fields",
                        "modify_scenario_comment",
                        "modify_scenario_comment",
                        "modify_scenario_comment",
                        "modify_scenario_comment",
                        "modify_scenario_comment",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 267158,
        "output_tokens": 23821,
        "llm_calls": 37
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 417,
            "description": "Define a test method that validates the Percentile statistic component's behavior across multiple input scenarios by first creating a Percentile instance configured for the 50th percentile, then verify that invoking the evaluate method with a null array triggers a null argument error, after which confirm that evaluating an empty array returns NaN to handle the boundary case of no data, subsequently assert that a single-element array returns that element as the median, followed by verifying that a two-element array produces the arithmetic mean of both values, and finally validate that a three-element array correctly computes the median by returning the middle value, ensuring each evaluation call uses progressively larger arrays to demonstrate correct percentile calculation across varying dataset sizes. JUnit 5 and Assertions.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testPercentile()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.PercentileTest",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive;\n\nimport org.apache.commons.math4.legacy.exception.NullArgumentException;\nimport org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class PercentileTest {\n\n    @Test\n    public void testPercentileEvaluation() {\n        Percentile percentile_instance = Percentile.create(50.0);\n\n        Assertions.assertThrows(NullArgumentException.class, () -> {\n            percentile_instance.evaluate(null);\n        });\n\n        double result_nan = percentile_instance.evaluate(new double[0]);\n        Assertions.assertEquals(Double.NaN, result_nan);\n\n        double[] single_element_array = {10.0};\n        double result_single_element = percentile_instance.evaluate(single_element_array);\n        Assertions.assertEquals(single_element_array[0], result_single_element, 0.0);\n\n        double[] two_element_array = {10.0, 20.0};\n        double result_two_elements = percentile_instance.evaluate(two_element_array);\n        Assertions.assertEquals((two_element_array[0] + two_element_array[1]) / 2.0, result_two_elements, 0.0);\n\n        double[] three_element_array = {10.0, 20.0, 30.0};\n        double result_three_elements = percentile_instance.evaluate(three_element_array);\n        Assertions.assertEquals(three_element_array[1], result_three_elements, 0.0);\n    }\n}",
            "method_signature": "testPercentileEvaluation()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 0.4,
            "assertion_precision": 0.4,
            "callable_recall": 0.7,
            "callable_precision": 0.6364,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testPercentile()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.create(double)",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.evaluate(double[])"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.create(double)",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.evaluate(double[])"
            ],
            "uncovered_focal_methods": [],
            "tp": 2,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 2,
                    "call_composition_agent": 2,
                    "compile_and_execute_test": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 5,
                    "query_class_db": 3,
                    "search_reachable_methods_in_class": 4,
                    "get_method_details": 2,
                    "finalize": 2
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_method_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "query_class_db",
                        "query_method_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ],
                    [
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_class_constructors_and_factories": 5,
                    "get_method_details": 1,
                    "generate_test_code": 7,
                    "compile_and_execute_test": 5,
                    "get_maven_dependencies": 1,
                    "finalize": 2
                },
                "tool_trajectories": [
                    [
                        "get_class_constructors_and_factories",
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "get_maven_dependencies",
                        "generate_test_code",
                        "get_class_constructors_and_factories",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ],
                    [
                        "get_class_constructors_and_factories",
                        "get_class_constructors_and_factories",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 314084,
        "output_tokens": 28217,
        "llm_calls": 37
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 430,
            "description": "Create a test case to validate that the statistical calculation system correctly computes the median value across various data scenarios while maintaining data integrity safeguards. Begin by configuring the calculation system to determine the midpoint value of a dataset, then verify the system properly rejects attempts to process missing input by ensuring an appropriate failure occurs when no data is provided. Once this safeguard is confirmed, evaluate how the system handles an empty dataset and verify it indicates an undefined result since no midpoint can be determined from absent values. Next, assess the calculation behavior when only a single value is present and confirm the system correctly identifies that sole value as the midpoint. After establishing single-value handling, examine a two-value scenario and verify the system computes the average of both values as the midpoint. Finally, test the calculation with three values and ensure the system accurately identifies the middle value as the median result. Throughout these validations, confirm the system produces mathematically correct outcomes for each distinct data condition, demonstrating robust handling of edge cases from missing data through progressively larger datasets. Verify all outcomes using standard equality assertions with JUnit 5 and confirm error conditions trigger the expected business rule violations.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testPercentile()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.MedianCalculationTest",
            "code": "package org.apache.commons.math4.legacy.stat;\n\nimport org.apache.commons.math4.legacy.exception.MathIllegalArgumentException;\nimport org.apache.commons.math4.legacy.exception.NullArgumentException;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class MedianCalculationTest {\n\n    @Test\n    public void testMissingInput() {\n        assertThrows(NullArgumentException.class, () -> {\n            StatUtils.percentile(null, 50.0);\n        });\n    }\n\n    @Test\n    public void testEmptyDataset() {\n        double[] emptyDataset = new double[0];\n        double undefinedResult = StatUtils.percentile(emptyDataset, 50.0);\n        assertEquals(Double.NaN, undefinedResult);\n    }\n\n    @Test\n    public void testSingleValueDataset() {\n        double[] singleValueDataset = { 15.0 };\n        double calculatedMedian = StatUtils.percentile(singleValueDataset, 50.0);\n        assertEquals(15.0, calculatedMedian);\n    }\n\n    @Test\n    public void testTwoValueDataset() {\n        double[] twoValueDataset = { 10.0, 20.0 };\n        double calculatedMedian = StatUtils.percentile(twoValueDataset, 50.0);\n        assertEquals(15.0, calculatedMedian);\n    }\n\n    @Test\n    public void testThreeValueDataset() {\n        double[] threeValueDataset = { 10.0, 20.0, 30.0 };\n        double calculatedMedian = StatUtils.percentile(threeValueDataset, 50.0);\n        assertEquals(20.0, calculatedMedian);\n    }\n}",
            "method_signature": "testMissingInput()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 0.2,
            "assertion_precision": 1.0,
            "callable_recall": 0.1,
            "callable_precision": 0.5,
            "focal_recall": 0.0,
            "focal_precision": 0.0
        },
        "coverage_eval": {
            "class_coverage": 0.0,
            "method_coverage": 1.0,
            "line_coverage": 0.0,
            "branch_coverage": 0.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testPercentile()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.create(double)",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.evaluate(double[])"
            ],
            "covered_focal_methods": [],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.create(double)",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.evaluate(double[])"
            ],
            "tp": 0,
            "fn": 2,
            "localization_recall": 0.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 5,
                    "query_method_db": 2,
                    "search_reachable_methods_in_class": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_method_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "query_class_db",
                        "query_class_db",
                        "query_class_db",
                        "query_method_db",
                        "search_reachable_methods_in_class",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_maven_dependencies": 1,
                    "generate_test_code": 2,
                    "compile_and_execute_test": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 123634,
        "output_tokens": 13602,
        "llm_calls": 18
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 444,
            "description": "Define a test method annotated with `@Test` that begins by invoking the static factory method `Percentile.create` with argument `50` and assigning the returned `Percentile` instance to a variable named `stat`. Immediately use `Assertions.assertThrows` to verify that invoking `stat.evaluate(null)` throws a `NullArgumentException` by passing the exception class as the first argument and a lambda expression `() -> stat.evaluate(null)` as the second argument. Following this, invoke `Assertions.assertEquals` with expected value `Double.NaN` and the result of calling `stat.evaluate` on an empty `double[]` array (created using `new double[]{}`) to confirm the method returns `NaN` for empty input. Next, assert that calling `stat.evaluate` with a single-element array `new double[]{1}` returns `1` by passing `1` as the expected value and the evaluation result to `Assertions.assertEquals`. Continue by invoking `Assertions.assertEquals` with expected value `1.5` and the result of `stat.evaluate(new double[]{1, 2})` to verify the 50th percentile of a two-element array. Finally, call `Assertions.assertEquals` with expected value `2` and the result of `stat.evaluate(new double[]{1, 2, 3})` to confirm the 50th percentile calculation for a three-element array. The test uses method-level annotation `@Test`, assertion library JUnit 5 Assertions, and no mocking libraries.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testPercentile()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.PercentileTest",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive;\n\nimport org.apache.commons.math4.legacy.exception.NullArgumentException;\nimport org.apache.commons.math4.legacy.stat.descriptive.Statistics;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\nclass PercentileTest {\n\n    @Test\n    void testPercentile() {\n        Statistics.Percentile stat = Statistics.Percentile.create(50);\n        Assertions.assertThrows(NullArgumentException.class, () -> stat.evaluate(null));\n        double evaluation_result = stat.evaluate(new double[]{});\n        Assertions.assertEquals(Double.NaN, evaluation_result);\n        evaluation_result = stat.evaluate(new double[]{1});\n        Assertions.assertEquals(1, evaluation_result);\n        evaluation_result = stat.evaluate(new double[]{1, 2});\n        Assertions.assertEquals(1.5, evaluation_result);\n        evaluation_result = stat.evaluate(new double[]{1, 2, 3});\n        Assertions.assertEquals(2, evaluation_result);\n    }\n}",
            "method_signature": "testPercentile()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 1.0,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testPercentile()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.create(double)",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.evaluate(double[])"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.create(double)",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.Percentile.evaluate(double[])"
            ],
            "uncovered_focal_methods": [],
            "tp": 2,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 3,
                    "query_class_db": 1,
                    "get_method_details": 5,
                    "search_reachable_methods_in_class": 1,
                    "get_inherited_library_classes": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_method_db",
                        "query_class_db",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "query_method_db",
                        "get_inherited_library_classes",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_method_details": 2,
                    "get_maven_dependencies": 1,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_method_details",
                        "get_method_details",
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 93687,
        "output_tokens": 9363,
        "llm_calls": 14
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 390,
            "description": "Define a test method that validates the SumOfSquares statistic component correctly rejects unsupported operations by first initializing a double array containing three numeric values, then obtaining a singleton instance of the SumOfSquares statistic through its factory method, and subsequently invoking the evaluate method on this instance with the prepared array while asserting that this operation throws an IllegalStateException, thereby confirming the component enforces its operational constraints by rejecting direct array evaluation when configured in a mode that does not support this capability, using a standard testing framework with exception assertion capabilities.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testUnsupportedMethods()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SumOfSquaresTest",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive;\n\nimport org.apache.commons.math4.legacy.stat.descriptive.Statistics.SumOfSquares;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport java.lang.IllegalStateException;\n\npublic class SumOfSquaresTest {\n\n    @Test\n    public void testEvaluateRejectsUnsupportedOperation() {\n        // Initialize a double array with some values.\n        double[] inputArray = { 1.0, 2.0, 3.0 };\n\n        // Obtain a singleton instance of SumOfSquares.\n        SumOfSquares sumOfSquaresInstance = Statistics.SumOfSquares.getInstance();\n\n        // Assert that calling evaluate with an array throws an IllegalStateException.\n        assertThrows(IllegalStateException.class, () -> {\n            sumOfSquaresInstance.evaluate(inputArray);\n        });\n    }\n}",
            "method_signature": "testEvaluateRejectsUnsupportedOperation()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 1.0,
            "callable_precision": 0.6667,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 0.2,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testUnsupportedMethods()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.SumOfSquares.evaluate(double[])"
            ],
            "covered_focal_methods": [],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.SumOfSquares.evaluate(double[])"
            ],
            "tp": 0,
            "fn": 1,
            "localization_recall": 0.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 2,
                    "get_method_details": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_method_details": 2,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 40163,
        "output_tokens": 6155,
        "llm_calls": 11
    },
    {
        "compiles": false,
        "nl2test_input": {
            "id": 394,
            "description": "Create a test case to validate that the sum of squares calculation system properly enforces operational constraints by rejecting direct computation requests when the system is configured for incremental data accumulation mode. Begin by preparing a sample dataset containing three numerical observations, then obtain the sum of squares calculator configured for incremental operation. Attempt to perform a direct calculation on the entire dataset, which should fail because this operational mode does not support batch evaluation of complete datasets. Ensure the system responds with an appropriate failure indicating the operation cannot be performed in the current configuration state. Verify using JUnit 5 with standard exception assertions to confirm the system correctly prevents misuse of the incremental calculation mode.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testUnsupportedMethods()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math.stat.descriptive.summary.SumOfSquaresDirectEvaluationTest",
            "code": "package org.apache.commons.math.stat.descriptive.summary;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class SumOfSquaresDirectEvaluationTest {\n\n    @Test\n    public void testDirectEvaluationThrowsExceptionInIncrementalMode() {\n        // Step 0: Create a sample dataset with three numerical observations.\n        double[] sample_dataset = new double[]{1.0, 2.0, 3.0};\n\n        // Step 1: Obtain a sum of squares calculator configured for incremental operation.\n        SumOfSquares incremental_calculator = new SumOfSquares();\n\n        // Step 2 & 3: Attempt to perform a direct calculation and verify that an exception is thrown.\n        assertThrows(java.lang.IllegalStateException.class, () -> {\n            incremental_calculator.evaluate(sample_dataset);\n        });\n    }\n}",
            "method_signature": "testDirectEvaluationThrowsExceptionInIncrementalMode()"
        },
        "structured_eval": {
            "obj_creation_recall": 0.0,
            "obj_creation_precision": 0.0,
            "assertion_recall": 0.0,
            "assertion_precision": 0.0,
            "callable_recall": 0.0,
            "callable_precision": 0.0,
            "focal_recall": 0.0,
            "focal_precision": 0.0
        },
        "coverage_eval": {
            "class_coverage": 0.0,
            "method_coverage": 0.0,
            "line_coverage": 0.0,
            "branch_coverage": 0.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testUnsupportedMethods()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.SumOfSquares.evaluate(double[])"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.SumOfSquares.evaluate(double[])"
            ],
            "uncovered_focal_methods": [],
            "tp": 1,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 4,
                    "call_composition_agent": 3,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "call_localization_agent",
                        "call_composition_agent",
                        "call_localization_agent",
                        "call_localization_agent",
                        "call_composition_agent",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 10,
                    "query_method_db": 15,
                    "search_reachable_methods_in_class": 12,
                    "get_method_details": 14,
                    "get_inherited_library_classes": 5,
                    "extract_method_code": 1,
                    "finalize": 4
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_method_db",
                        "query_method_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "query_method_db",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "query_method_db",
                        "get_method_details",
                        "get_inherited_library_classes",
                        "get_method_details",
                        "get_inherited_library_classes",
                        "get_method_details",
                        "extract_method_code",
                        "finalize"
                    ],
                    [
                        "query_class_db",
                        "query_method_db",
                        "query_method_db",
                        "finalize"
                    ],
                    [
                        "query_class_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "get_inherited_library_classes",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "query_method_db",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "get_inherited_library_classes",
                        "query_method_db",
                        "get_method_details",
                        "query_class_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ],
                    [
                        "query_class_db",
                        "query_method_db",
                        "query_class_db",
                        "query_method_db",
                        "query_class_db",
                        "get_method_details",
                        "get_inherited_library_classes",
                        "query_method_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "query_method_db",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_class_constructors_and_factories": 2,
                    "get_method_details": 3,
                    "generate_test_code": 10,
                    "compile_and_execute_test": 10,
                    "get_maven_dependencies": 2,
                    "modify_scenario_comment": 2,
                    "finalize": 3
                },
                "tool_trajectories": [
                    [
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_method_details",
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "modify_scenario_comment",
                        "modify_scenario_comment",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ],
                    [
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ],
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 553606,
        "output_tokens": 40082,
        "llm_calls": 73
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 402,
            "description": "Define a test method annotated with `@Test` that begins by declaring a local variable `x` of type `double[]` and initializing it with the array literal `{ 1, 2, 3 }`, then invoke the static method `getInstance()` on the class `SumOfSquares` from package `org.apache.commons.math4.legacy.stat.descriptive.Statistics` and assign the returned instance to a local variable `s` of type `SumOfSquares`. Immediately after obtaining the instance, use `Assertions.assertThrows` from JUnit 5 to verify that invoking the method `evaluate` on `s` with argument `x` throws an `IllegalStateException`, passing the exception class `IllegalStateException.class` as the first argument and a lambda expression `() -> s.evaluate(x)` as the executable. The test uses JUnit 5 Assertions with method-level annotation `@Test`.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testUnsupportedMethods()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SumOfSquaresTest",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive;\n\nimport org.apache.commons.math4.legacy.stat.descriptive.Statistics.SumOfSquares;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class SumOfSquaresTest {\n\n    @Test\n    public void testEvaluate() {\n        double[] x = { 1, 2, 3 };\n        SumOfSquares s = SumOfSquares.getInstance();\n        Assertions.assertThrows(IllegalStateException.class, () -> s.evaluate(x));\n    }\n}",
            "method_signature": "testEvaluate()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 1.0,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 0.2,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testUnsupportedMethods()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.SumOfSquares.evaluate(double[])"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.SumOfSquares.evaluate(double[])"
            ],
            "uncovered_focal_methods": [],
            "tp": 1,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "get_method_details": 4,
                    "query_method_db": 3,
                    "get_inherited_library_classes": 2,
                    "search_reachable_methods_in_class": 2,
                    "query_class_db": 1,
                    "get_call_site_details": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_method_details",
                        "query_method_db",
                        "get_method_details",
                        "get_inherited_library_classes",
                        "search_reachable_methods_in_class",
                        "query_class_db",
                        "get_method_details",
                        "get_inherited_library_classes",
                        "query_method_db",
                        "search_reachable_methods_in_class",
                        "get_call_site_details",
                        "query_method_db",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_maven_dependencies": 1,
                    "get_method_details": 2,
                    "generate_test_code": 2,
                    "compile_and_execute_test": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_maven_dependencies",
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 119558,
        "output_tokens": 7796,
        "llm_calls": 21
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 529,
            "description": "Create a test case to validate that the system properly enforces operational constraints when attempting to use statistical computation capabilities that require accumulated state without having previously enabled state tracking. Begin by initializing a statistical calculator configured to operate without maintaining internal state history, then verify the system correctly prevents attempts to process multiple data points at once by rejecting both full dataset operations and partial range operations with appropriate failure notifications. Confirm the system also blocks requests to retrieve the count of processed observations since no state is being maintained, and ensure attempts to compute statistical results from external datasets are similarly rejected regardless of whether the entire dataset or a specific range is provided. Throughout this validation, confirm each prohibited operation triggers the expected business rule violation indicating the feature is unavailable in the current configuration. Use JUnit 5 for the testing framework with standard exception assertions to verify the system enforces these operational boundaries consistently across all unsupported capabilities.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testUnsupportedStorelessMethods()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsTest1",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Assertions;\n\npublic class SummaryStatisticsTest1 {\n\n    @Test\n    public void testOperationsOnEmptyStatistics() {\n        SummaryStatistics calculator = new SummaryStatistics();\n\n        Assertions.assertEquals(Double.NaN, calculator.getMean(), 0.0);\n\n        Assertions.assertEquals(Double.NaN, calculator.getStandardDeviation(), 0.0);\n\n        long count = calculator.getN();\n        Assertions.assertEquals(0, count);\n    }\n}",
            "method_signature": "testOperationsOnEmptyStatistics()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 0.0,
            "assertion_recall": 0.0,
            "assertion_precision": 0.0,
            "callable_recall": 0.0,
            "callable_precision": 0.0,
            "focal_recall": 0.0,
            "focal_precision": 0.0
        },
        "coverage_eval": {
            "class_coverage": 0.0,
            "method_coverage": 1.0,
            "line_coverage": 0.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testUnsupportedStorelessMethods()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.create()",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.evaluate(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.evaluate(double[], int, int)",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.incrementAll(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.incrementAll(double[], int, int)"
            ],
            "covered_focal_methods": [],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.create()",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.evaluate(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.evaluate(double[], int, int)",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.incrementAll(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.incrementAll(double[], int, int)"
            ],
            "tp": 0,
            "fn": 5,
            "localization_recall": 0.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 2,
                    "call_composition_agent": 2,
                    "compile_and_execute_test": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 4,
                    "query_method_db": 9,
                    "get_method_details": 98,
                    "search_reachable_methods_in_class": 5,
                    "finalize": 2
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_class_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ],
                    [
                        "query_class_db",
                        "query_method_db",
                        "query_class_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_class_constructors_and_factories": 2,
                    "get_method_details": 8,
                    "generate_test_code": 3,
                    "compile_and_execute_test": 3,
                    "modify_scenario_comment": 8,
                    "finalize": 2,
                    "extract_method_code": 4,
                    "get_class_fields": 1
                },
                "tool_trajectories": [
                    [
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "modify_scenario_comment",
                        "modify_scenario_comment",
                        "modify_scenario_comment",
                        "modify_scenario_comment",
                        "modify_scenario_comment",
                        "modify_scenario_comment",
                        "finalize"
                    ],
                    [
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "extract_method_code",
                        "get_class_fields",
                        "extract_method_code",
                        "extract_method_code",
                        "extract_method_code",
                        "get_method_details",
                        "modify_scenario_comment",
                        "modify_scenario_comment",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 473885,
        "output_tokens": 47103,
        "llm_calls": 35
    },
    {
        "compiles": false,
        "nl2test_input": {
            "id": 552,
            "description": "Define a test method that validates the Storeless Sum of Squares component correctly rejects operations unsupported in its storeless mode by first preparing a sample array of double values containing three numeric elements, then obtaining a storeless instance of the Sum of Squares statistic through its factory method. With the instance created, verify that invoking the full-array increment operation triggers an illegal state error, followed by confirming that the ranged increment operation with specified start and end indices also produces the same error category. Next, validate that attempting to retrieve the sample count from the storeless instance results in an illegal state error, then confirm that both the full-array evaluation method and the ranged evaluation method with offset parameters each throw the same error type when invoked on the storeless instance. Each verification should assert that the expected error category is raised when the corresponding unsupported operation is attempted, demonstrating that the component enforces its operational constraints consistently across all methods that require internal state storage. The test uses JUnit 5 assertions.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testUnsupportedStorelessMethods()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SumOfSquaresTest",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport org.apache.commons.math4.legacy.stat.descriptive.SumOfSquares;\n\npublic class SumOfSquaresTest {\n\n    @Test\n    public void testUnsupportedOperationsInStorelessMode() {\n        double[] sample_array = {1.0, 2.0, 3.0};\n        SumOfSquares storeless_instance = new SumOfSquares();\n\n        assertThrows(java.lang.IllegalStateException.class, () -> {\n            storeless_instance.increment(sample_array);\n        });\n\n        assertThrows(java.lang.IllegalStateException.class, () -> {\n            storeless_instance.increment(sample_array, 0, 3);\n        });\n\n        assertThrows(java.lang.IllegalStateException.class, () -> {\n            storeless_instance.getN();\n        });\n\n        assertThrows(java.lang.IllegalStateException.class, () -> {\n            storeless_instance.evaluate(sample_array);\n        });\n\n        assertThrows(java.lang.IllegalStateException.class, () -> {\n            storeless_instance.evaluate(sample_array, 0, 3);\n        });\n    }\n}",
            "method_signature": "testUnsupportedOperationsInStorelessMode()"
        },
        "structured_eval": {
            "obj_creation_recall": 0.0,
            "obj_creation_precision": 0.0,
            "assertion_recall": 0.0,
            "assertion_precision": 0.0,
            "callable_recall": 0.0,
            "callable_precision": 0.0,
            "focal_recall": 0.0,
            "focal_precision": 0.0
        },
        "coverage_eval": {
            "class_coverage": 0.0,
            "method_coverage": 0.0,
            "line_coverage": 0.0,
            "branch_coverage": 0.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testUnsupportedStorelessMethods()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.create()",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.evaluate(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.evaluate(double[], int, int)",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.incrementAll(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.incrementAll(double[], int, int)"
            ],
            "covered_focal_methods": [],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.create()",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.evaluate(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.evaluate(double[], int, int)",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.incrementAll(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.incrementAll(double[], int, int)"
            ],
            "tp": 0,
            "fn": 5,
            "localization_recall": 0.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 3,
                    "call_composition_agent": 3,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "call_localization_agent",
                        "call_composition_agent",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 3,
                    "query_method_db": 3,
                    "search_reachable_methods_in_class": 1,
                    "get_method_details": 11,
                    "finalize": 3
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "search_reachable_methods_in_class",
                        "query_class_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ],
                    [
                        "query_class_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ],
                    [
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 14,
                    "compile_and_execute_test": 11,
                    "get_maven_dependencies": 3,
                    "finalize": 3,
                    "get_class_fields": 1
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_maven_dependencies",
                        "generate_test_code",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "finalize"
                    ],
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_maven_dependencies",
                        "finalize"
                    ],
                    [
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "get_class_fields",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 387865,
        "output_tokens": 38980,
        "llm_calls": 48
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 1454,
            "description": "Define a test method annotated with `@Test` that begins by declaring a local variable `x` of type `double[]` initialized with the array literal `{ 1, 2, 3 }`, then invoke the static factory method `create()` on class `StorelessSumOfSquares` and assign the returned instance to a local variable `s` of type `StorelessSumOfSquares`. Immediately assert that invoking `incrementAll` on `s` with argument `x` throws `IllegalStateException` by calling `Assertions.assertThrows(IllegalStateException.class, () -> s.incrementAll(x))`. Next, assert that invoking `incrementAll` on `s` with arguments `x`, `0`, and `1` throws `IllegalStateException` using `Assertions.assertThrows(IllegalStateException.class, () -> s.incrementAll(x, 0, 1))`. Following that, assert that invoking the method `getN` on `s` throws `IllegalStateException` by calling `Assertions.assertThrows(IllegalStateException.class, s::getN)`. Then assert that invoking `evaluate` on `s` with argument `x` throws `IllegalStateException` using `Assertions.assertThrows(IllegalStateException.class, () -> s.evaluate(x))`. Finally, assert that invoking `evaluate` on `s` with arguments `x`, `0`, and `1` throws `IllegalStateException` by calling `Assertions.assertThrows(IllegalStateException.class, () -> s.evaluate(x, 0, 1))`. The test uses JUnit 5 Assertions and the method-level annotation `@Test`.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testUnsupportedStorelessMethods()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StorelessSumOfSquaresTest",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive;\n\nimport org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport java.lang.IllegalStateException;\n\npublic class StorelessSumOfSquaresTest {\n\n    @Test\n    public void testStorelessBehavior() {\n        double[] x = { 1, 2, 3 };\n        StorelessSumOfSquares s = StorelessSumOfSquares.create();\n        Assertions.assertThrows(IllegalStateException.class, () -> s.incrementAll(x));\n        Assertions.assertThrows(IllegalStateException.class, () -> s.incrementAll(x, 0, 1));\n        Assertions.assertThrows(IllegalStateException.class, s::getN);\n        Assertions.assertThrows(IllegalStateException.class, () -> s.evaluate(x));\n        Assertions.assertThrows(IllegalStateException.class, () -> s.evaluate(x, 0, 1));\n    }\n}",
            "method_signature": "testStorelessBehavior()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 1.0,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.StatisticsTest",
            "method_signature": "testUnsupportedStorelessMethods()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.create()",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.evaluate(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.evaluate(double[], int, int)",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.incrementAll(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.incrementAll(double[], int, int)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.create()"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.evaluate(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.evaluate(double[], int, int)",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.incrementAll(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.Statistics.StorelessSumOfSquares.incrementAll(double[], int, int)"
            ],
            "tp": 1,
            "fn": 4,
            "localization_recall": 0.2
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 8,
                    "query_class_db": 1,
                    "search_reachable_methods_in_class": 4,
                    "get_method_details": 6,
                    "get_inherited_library_classes": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "query_method_db",
                        "query_method_db",
                        "get_inherited_library_classes",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 82864,
        "output_tokens": 8915,
        "llm_calls": 14
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 584,
            "description": "Define a test class containing thirteen private final double fields: `one`, `twoF`, `twoL`, `three`, `mean`, `sumSq`, `sum`, `var`, `std`, `n`, `min`, `max`, and `tolerance`, though only the empty array logic is exercised in this test method. Begin the test method by invoking the no-argument constructor of `SummaryStatistics` and assigning the result to variable `stats`. Immediately after, declare a double array variable `x` and initialize it with an empty array literal `{}`. Invoke `StatUtils.sum(x)` passing the empty array `x`, then invoke `stats.getSum()` on the `stats` instance, and assert equality between these two values using `Assertions.assertEquals`. Next, invoke `StatUtils.mean(x)` with argument `x`, invoke `stats.getMean()` on `stats`, and assert their equality using `Assertions.assertEquals`. Invoke `StatUtils.variance(x)` with argument `x` and assign the result to variable `v` of type double. Pass `v` to `JdkMath.sqrt(v)`, invoke `stats.getStandardDeviation()` on `stats`, and assert equality between the square root result and the standard deviation using `Assertions.assertEquals`. Assert equality between `v` and the result of invoking `stats.getVariance()` using `Assertions.assertEquals`. Invoke `StatUtils.max(x)` with argument `x`, invoke `stats.getMax()` on `stats`, and assert their equality using `Assertions.assertEquals`. Finally, invoke `StatUtils.min(x)` with argument `x`, invoke `stats.getMin()` on `stats`, and assert their equality using `Assertions.assertEquals`. The test uses method-level annotation `@Test` and relies on JUnit 5 Assertions for verification.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsTest",
            "method_signature": "testEmpty()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsTest2",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive;  import org.apache.commons.math4.legacy.stat.StatUtils; import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.Test;  class SummaryStatisticsTest2 {      private final double one = 1;     private final double twoF = 2;     private final double twoL = 2;     private final double three = 3;     private final double mean = 2;     private final double sumSq = 18;     private final double sum = 8;     private final double var = 0.6666666666666667;     private final double std = Math.sqrt(var);     private final double n = 4;     private final double min = 1;     private final double max = 3;     private final double tolerance = 1.0E-14D;      @Test     public void testEmptyArray() {         SummaryStatistics stats = new SummaryStatistics();         double[] x = {};          Assertions.assertEquals(StatUtils.sum(x), stats.getSum());         Assertions.assertEquals(StatUtils.mean(x), stats.getMean());          double v = StatUtils.variance(x);         Assertions.assertEquals(Math.sqrt(v), stats.getStandardDeviation());         Assertions.assertEquals(v, stats.getVariance());          Assertions.assertEquals(StatUtils.max(x), stats.getMax());         Assertions.assertEquals(StatUtils.min(x), stats.getMin());     } }",
            "method_signature": "testEmptyArray()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 0.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.9,
            "callable_precision": 0.9474,
            "focal_recall": 0.9167,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsTest",
            "method_signature": "testEmpty()",
            "all_focal_methods": [
                "org.apache.commons.math4.core.jdkmath.JdkMath.sqrt(double)",
                "org.apache.commons.math4.legacy.stat.StatUtils.max(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.mean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.min(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.variance(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getStandardDeviation()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getVariance()"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.core.jdkmath.JdkMath.sqrt(double)",
                "org.apache.commons.math4.legacy.stat.StatUtils.max(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.mean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.min(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.variance(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getStandardDeviation()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getVariance()"
            ],
            "uncovered_focal_methods": [],
            "tp": 12,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 15,
                    "query_class_db": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_class_db",
                        "query_method_db",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 2,
                    "compile_and_execute_test": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 81989,
        "output_tokens": 8559,
        "llm_calls": 13
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 590,
            "description": "Create a test case to validate the statistical summary system's behavior when presented with an empty dataset, ensuring it correctly produces undefined results for all statistical measures. Initialize a new statistical summary tracker with no data points provided, then confirm the system accurately reports that the total sum is undefined, the average value is undefined, the spread of values (variance) is undefined, the typical deviation from the average (standard deviation) is undefined, the highest value is undefined, and the lowest value is undefined, all reflecting the absence of any input data. Verify these outcomes using standard equality assertions with JUnit 5 and AssertJ, confirming that each statistical measure returns the expected undefined state when no observations are available for analysis.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsTest",
            "method_signature": "testEmpty()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.example.test.SummaryStatisticsUndefinedTest",
            "code": "package org.example.test;\n\nimport org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class SummaryStatisticsUndefinedTest {\n\n    @Test\n    public void testUndefinedResultsForEmptyDataset() {\n        // Initialize a new statistical summary tracker with no data points\n        SummaryStatistics empty_tracker = new SummaryStatistics();\n\n        // Get the total sum from the tracker\n        double sum = empty_tracker.getSum();\n        // Verify the total sum is undefined\n        assertEquals(Double.NaN, sum);\n\n        // Get the average value from the tracker\n        double mean = empty_tracker.getMean();\n        // Verify the average value is undefined\n        assertEquals(Double.NaN, mean);\n\n        // Get the variance from the tracker\n        double variance = empty_tracker.getVariance();\n        // Verify the variance is undefined\n        assertEquals(Double.NaN, variance);\n\n        // Get the standard deviation from the tracker\n        double std_dev = empty_tracker.getStandardDeviation();\n        // Verify the standard deviation is undefined\n        assertEquals(Double.NaN, std_dev);\n\n        // Get the highest value from the tracker\n        double max = empty_tracker.getMax();\n        // Verify the highest value is undefined\n        assertEquals(Double.NaN, max);\n\n        // Get the lowest value from the tracker\n        double min = empty_tracker.getMin();\n        // Verify the lowest value is undefined\n        assertEquals(Double.NaN, min);\n    }\n}",
            "method_signature": "testUndefinedResultsForEmptyDataset()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 0.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.65,
            "callable_precision": 1.0,
            "focal_recall": 0.5,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsTest",
            "method_signature": "testEmpty()",
            "all_focal_methods": [
                "org.apache.commons.math4.core.jdkmath.JdkMath.sqrt(double)",
                "org.apache.commons.math4.legacy.stat.StatUtils.max(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.mean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.min(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.variance(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getStandardDeviation()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getVariance()"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getStandardDeviation()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getVariance()"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.core.jdkmath.JdkMath.sqrt(double)",
                "org.apache.commons.math4.legacy.stat.StatUtils.max(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.mean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.min(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.variance(double[])"
            ],
            "tp": 6,
            "fn": 6,
            "localization_recall": 0.5
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 1,
                    "query_method_db": 6,
                    "get_method_details": 8,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 45220,
        "output_tokens": 7964,
        "llm_calls": 10
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 591,
            "description": "Define a test class that validates the behavior of Summary Statistics when operating on an empty dataset by first creating a helper method that instantiates and returns a new Summary Statistics component, then within the test method invoke this helper to obtain a statistics instance and declare an empty double array as the input dataset. Using the Static Utilities component, compute the sum of the empty array and assert that the result equals the sum retrieved from the statistics instance, then similarly compute the mean through the Static Utilities and verify it matches the mean from the statistics instance. Next, calculate the variance of the empty array via the Static Utilities, store this variance value, and compute its square root using the Math Utilities component, asserting that this derived standard deviation equals the standard deviation reported by the statistics instance, followed by asserting that the stored variance value matches the variance from the statistics instance. Continue by computing the maximum value of the empty array through the Static Utilities and verifying it equals the maximum from the statistics instance, then compute the minimum value via the Static Utilities and assert it matches the minimum from the statistics instance. This test validates that the Summary Statistics component correctly handles edge cases where no data has been added, ensuring all statistical measures return the same values as the Static Utilities when applied to an empty dataset, using JUnit 5 and its Assertions library.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsTest",
            "method_signature": "testEmpty()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsTest1",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive;\n\nimport org.apache.commons.math4.legacy.stat.StatUtils;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class SummaryStatisticsTest1 {\n\n    private SummaryStatistics createSummaryStatistics() {\n        return new SummaryStatistics();\n    }\n\n    @Test\n    public void testEmptyDataset() {\n        SummaryStatistics summaryStatisticsInstance = createSummaryStatistics();\n        double[] emptyDataset = new double[0];\n\n        double expectedSum = StatUtils.sum(emptyDataset);\n        Assertions.assertEquals(expectedSum, summaryStatisticsInstance.getSum());\n\n        double expectedMean = StatUtils.mean(emptyDataset);\n        Assertions.assertEquals(expectedMean, summaryStatisticsInstance.getMean());\n\n        double expectedVariance = StatUtils.variance(emptyDataset);\n        double expectedStandardDeviation = Math.sqrt(expectedVariance);\n        Assertions.assertEquals(expectedStandardDeviation, summaryStatisticsInstance.getStandardDeviation());\n        Assertions.assertEquals(expectedVariance, summaryStatisticsInstance.getVariance());\n\n        double expectedMax = StatUtils.max(emptyDataset);\n        Assertions.assertEquals(expectedMax, summaryStatisticsInstance.getMax());\n\n        double expectedMin = StatUtils.min(emptyDataset);\n        Assertions.assertEquals(expectedMin, summaryStatisticsInstance.getMin());\n    }\n}",
            "method_signature": "testEmptyDataset()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.95,
            "callable_precision": 0.95,
            "focal_recall": 0.9167,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsTest",
            "method_signature": "testEmpty()",
            "all_focal_methods": [
                "org.apache.commons.math4.core.jdkmath.JdkMath.sqrt(double)",
                "org.apache.commons.math4.legacy.stat.StatUtils.max(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.mean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.min(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.variance(double[])",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getStandardDeviation()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getVariance()"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.StatUtils.max(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.mean(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.min(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.sum(double[])",
                "org.apache.commons.math4.legacy.stat.StatUtils.variance(double[])"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.core.jdkmath.JdkMath.sqrt(double)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getStandardDeviation()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getVariance()"
            ],
            "tp": 5,
            "fn": 7,
            "localization_recall": 0.4167
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 2,
                    "call_composition_agent": 3,
                    "compile_and_execute_test": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "call_composition_agent",
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 18,
                    "query_class_db": 5,
                    "search_reachable_methods_in_class": 25,
                    "finalize": 2,
                    "get_method_details": 6
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "finalize"
                    ],
                    [
                        "query_class_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_class_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 13,
                    "compile_and_execute_test": 10,
                    "finalize": 3,
                    "get_maven_dependencies": 1,
                    "get_class_constructors_and_factories": 1,
                    "get_method_details": 2
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "finalize"
                    ],
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "finalize"
                    ],
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 370306,
        "output_tokens": 28403,
        "llm_calls": 47
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 566,
            "description": "Define a test class containing thirteen private final double fields: `one`, `twoF`, `twoL`, `three`, `mean`, `sumSq`, `sum`, `var`, `std`, `n`, `min`, `max`, and `tolerance`, though none are used in this test method. Begin by invoking a private method that instantiates a new `SummaryStatistics` object using its no-argument constructor and assign the result to variable `u`. Verify null-rejection behavior by invoking `Assertions.assertThrows` with `NullPointerException.class` and a lambda that calls `u.setSumImpl(null)`, then repeat this pattern for `setMinImpl(null)`, `setMaxImpl(null)`, `setMeanImpl(null)`, and `setVarianceImpl(null)`. Configure distinct implementations by instantiating a test-local stub class (define a private static class implementing `StorelessUnivariateStatistic` that stores an integer value in its constructor and returns that value plus one from `getResult()`) and invoke `u.setSumImpl(new SumStat(1))`, `u.setMinImpl(new SumStat(2))`, `u.setMaxImpl(new SumStat(3))`, `u.setMeanImpl(new SumStat(4))`, and `u.setVarianceImpl(new SumStat(5))`. Invoke `u.addValue(1)` to add a single value, then verify the overridden implementations by asserting `Assertions.assertEquals(2, u.getSum())`, `Assertions.assertEquals(3, u.getMin())`, `Assertions.assertEquals(4, u.getMax())`, `Assertions.assertEquals(5, u.getMean())`, and `Assertions.assertEquals(6, u.getVariance())`. Confirm that getters return the correct implementation instances by invoking `u.getSumImpl().getResult()` and asserting it equals `2`, then repeat for `getMinImpl().getResult()` expecting `3`, `getMaxImpl().getResult()` expecting `4`, `getMeanImpl().getResult()` expecting `5`, and `getVarianceImpl().getResult()` expecting `6`. Test the copy functionality by invoking `u.copy()` and assigning the result to variable `v`, then verify `v.getSum()` equals `2`, `v.getMin()` equals `3`, `v.getMax()` equals `4`, `v.getMean()` equals `5`, and `v.getVariance()` equals `6`. Invoke `u.clear()` to reset the statistics, then verify the NaN contract by asserting `u.getSum()`, `u.getMin()`, `u.getMax()`, `u.getMean()`, and `u.getVariance()` all equal `Double.NaN`. Test refilling by invoking `u.addValue(1)` again, then assert that `u.getSum()`, `u.getMin()`, `u.getMax()`, `u.getMean()`, and `u.getVariance()` all equal `1`. The test uses method-level annotation `@Test` and relies on JUnit 5 Assertions for verification.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsTest",
            "method_signature": "testSetterAll()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsTest1",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class SummaryStatisticsTest1 {\n\n    private final double one = 1;\n    private final float twoF = 2;\n    private final long twoL = 2;\n    private final double three = 3;\n    private final double mean = 2;\n    private final double sumSq = 18;\n    private final double sum = 8;\n    private final double var = 0.6666666666666667;\n    private final double std = Math.sqrt(var);\n    private final double n = 4;\n    private final double min = -1;\n    private final double max = 5;\n    private final double tolerance = 10E-15;\n\n    @Test\n    public void testSetterInjection() {\n        SummaryStatistics u = new SummaryStatistics();\n\n        Assertions.assertThrows(NullPointerException.class, () -> u.setSumImpl(null));\n        Assertions.assertThrows(NullPointerException.class, () -> u.setMinImpl(null));\n        Assertions.assertThrows(NullPointerException.class, () -> u.setMaxImpl(null));\n        Assertions.assertThrows(NullPointerException.class, () -> u.setMeanImpl(null));\n        Assertions.assertThrows(NullPointerException.class, () -> u.setVarianceImpl(null));\n\n        u.setSumImpl(new SumStat(1));\n        u.setMinImpl(new SumStat(2));\n        u.setMaxImpl(new SumStat(3));\n        u.setMeanImpl(new SumStat(4));\n        u.setVarianceImpl(new SumStat(5));\n\n        u.addValue(1);\n\n        Assertions.assertEquals(2, u.getSum());\n        Assertions.assertEquals(3, u.getMin());\n        Assertions.assertEquals(4, u.getMax());\n        Assertions.assertEquals(5, u.getMean());\n        Assertions.assertEquals(6, u.getVariance());\n\n        Assertions.assertEquals(2, u.getSumImpl().getResult());\n        Assertions.assertEquals(3, u.getMinImpl().getResult());\n        Assertions.assertEquals(4, u.getMaxImpl().getResult());\n        Assertions.assertEquals(5, u.getMeanImpl().getResult());\n        Assertions.assertEquals(6, u.getVarianceImpl().getResult());\n\n        SummaryStatistics v = u.copy();\n        Assertions.assertEquals(2, v.getSum());\n        Assertions.assertEquals(3, v.getMin());\n        Assertions.assertEquals(4, v.getMax());\n        Assertions.assertEquals(5, v.getMean());\n        Assertions.assertEquals(6, v.getVariance());\n\n        u.clear();\n\n        Assertions.assertEquals(Double.NaN, u.getSum());\n        Assertions.assertEquals(Double.NaN, u.getMin());\n        Assertions.assertEquals(Double.NaN, u.getMax());\n        Assertions.assertEquals(Double.NaN, u.getMean());\n        Assertions.assertEquals(Double.NaN, u.getVariance());\n\n        u.addValue(1);\n\n        Assertions.assertEquals(1, u.getSum());\n        Assertions.assertEquals(1, u.getMin());\n        Assertions.assertEquals(1, u.getMax());\n        Assertions.assertEquals(1, u.getMean());\n        Assertions.assertEquals(1, u.getVariance());\n    }\n\n    private static class SumStat implements StorelessUnivariateStatistic {\n        private int initialValue;\n\n        public SumStat(int initialValue) {\n            this.initialValue = initialValue;\n        }\n\n        @Override\n        public double getResult() {\n            return initialValue + 1;\n        }\n\n        @Override\n        public long getN() {\n            return 0;\n        }\n\n        @Override\n        public void clear() {}\n\n        @Override\n        public void increment(double d) {}\n\n        @Override\n        public StorelessUnivariateStatistic copy() {\n            return new SumStat(this.initialValue);\n        }\n\n        @Override\n        public void incrementAll(double[] values) {}\n\n        @Override\n        public void incrementAll(double[] values, int begin, int length) {}\n\n        @Override\n        public double evaluate(double[] values) { return 0; }\n\n        @Override\n        public double evaluate(double[] values, int begin, int length) { return 0; }\n    }\n}",
            "method_signature": "testSetterInjection()"
        },
        "structured_eval": {
            "obj_creation_recall": 0.0,
            "obj_creation_precision": 0.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.9211,
            "callable_precision": 0.9333,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsTest",
            "method_signature": "testSetterAll()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic.getResult()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.addValue(double)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.clear()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.copy()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getVariance()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMaxImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMeanImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMinImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setSumImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setVarianceImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.addValue(double)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.clear()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.copy()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMaxImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMeanImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMinImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setSumImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setVarianceImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic.getResult()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getVariance()"
            ],
            "tp": 8,
            "fn": 6,
            "localization_recall": 0.5714
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 1,
                    "get_method_details": 19,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_maven_dependencies": 1,
                    "generate_test_code": 4,
                    "compile_and_execute_test": 4,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 186911,
        "output_tokens": 18437,
        "llm_calls": 17
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 579,
            "description": "Define a test method that validates the behavior of the Summary Statistics component when all default statistical implementations are replaced with custom implementations, then verifies that the component correctly delegates to these custom implementations, supports copying with the overridden implementations intact, and handles clearing and refilling operations appropriately. Initialize a Summary Statistics instance using a helper method that constructs the component, then verify that attempting to configure each statistical implementation setter (sum, minimum, maximum, mean, variance) with a null value triggers a null pointer exception. Having established the null-safety contract, configure the component by injecting distinct custom statistic implementations into each setter, using test stub implementations that return predetermined constant values to verify delegation rather than actual computation. With all implementations overridden, add a numeric value to the component to trigger the statistical computation pipeline, then assert that each statistical accessor (sum, minimum, maximum, mean, variance) returns the predetermined constant from its respective custom implementation rather than the mathematically computed value, confirming that the component delegates to the injected implementations. To verify that the component correctly exposes the injected implementations, retrieve each implementation via its corresponding getter and invoke its result method, asserting that the returned values match the predetermined constants. Create a copy of the configured component using its copy method, then validate that the copied instance preserves all custom implementations by asserting that its statistical accessors return the same predetermined constants as the original. Clear the original component to reset its internal state, then verify that all statistical accessors now return NaN to indicate an empty dataset, confirming the component honors the contract for empty state representation. Finally, add a numeric value to the cleared component to refill it, then assert that all statistical accessors return values consistent with a single-element dataset processed through the custom implementations, demonstrating that the component can be reused after clearing. JUnit 5 is used for test execution and assertions.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsTest",
            "method_signature": "testSetterAll()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsCustomImplTest",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class SummaryStatisticsCustomImplTest {\n\n    private static abstract class StubStatistic implements StorelessUnivariateStatistic {\n        @Override\n        public long getN() { return 0; }\n        @Override\n        public void clear() { }\n        @Override\n        public void increment(double d) { }\n        @Override\n        public void incrementAll(double[] values) { }\n        @Override\n        public void incrementAll(double[] values, int begin, int length) { }\n        @Override\n        public double evaluate(double[] values) { return getResult(); }\n        @Override\n        public double evaluate(double[] values, int begin, int length) { return getResult(); }\n    }\n\n    private static class SumImpl extends StubStatistic {\n        @Override\n        public double getResult() { return 1.0; }\n        @Override\n        public StorelessUnivariateStatistic copy() { return new SumImpl(); }\n    }\n\n    private static class MinImpl extends StubStatistic {\n        @Override\n        public double getResult() { return 2.0; }\n        @Override\n        public StorelessUnivariateStatistic copy() { return new MinImpl(); }\n    }\n\n    private static class MaxImpl extends StubStatistic {\n        @Override\n        public double getResult() { return 3.0; }\n        @Override\n        public StorelessUnivariateStatistic copy() { return new MaxImpl(); }\n    }\n\n    private static class MeanImpl extends StubStatistic {\n        @Override\n        public double getResult() { return 4.0; }\n        @Override\n        public StorelessUnivariateStatistic copy() { return new MeanImpl(); }\n    }\n\n    private static class VarianceImpl extends StubStatistic {\n        @Override\n        public double getResult() { return 5.0; }\n        @Override\n        public StorelessUnivariateStatistic copy() { return new VarianceImpl(); }\n    }\n\n    @Test\n    public void testCustomImplementations() {\n        SummaryStatistics summaryStatistics = new SummaryStatistics();\n\n        assertThrows(NullPointerException.class, () -> summaryStatistics.setSumImpl(null));\n        assertThrows(NullPointerException.class, () -> summaryStatistics.setMinImpl(null));\n        assertThrows(NullPointerException.class, () -> summaryStatistics.setMaxImpl(null));\n        assertThrows(NullPointerException.class, () -> summaryStatistics.setMeanImpl(null));\n        assertThrows(NullPointerException.class, () -> summaryStatistics.setVarianceImpl(null));\n\n        StorelessUnivariateStatistic customSumImpl = new SumImpl();\n        StorelessUnivariateStatistic customMinImpl = new MinImpl();\n        StorelessUnivariateStatistic customMaxImpl = new MaxImpl();\n        StorelessUnivariateStatistic customMeanImpl = new MeanImpl();\n        StorelessUnivariateStatistic customVarianceImpl = new VarianceImpl();\n\n        summaryStatistics.setSumImpl(customSumImpl);\n        summaryStatistics.setMinImpl(customMinImpl);\n        summaryStatistics.setMaxImpl(customMaxImpl);\n        summaryStatistics.setMeanImpl(customMeanImpl);\n        summaryStatistics.setVarianceImpl(customVarianceImpl);\n\n        summaryStatistics.addValue(10.0);\n\n        assertEquals(1.0, summaryStatistics.getSum(), 1e-9);\n        assertEquals(2.0, summaryStatistics.getMin(), 1e-9);\n        assertEquals(3.0, summaryStatistics.getMax(), 1e-9);\n        assertEquals(4.0, summaryStatistics.getMean(), 1e-9);\n        assertEquals(5.0, summaryStatistics.getVariance(), 1e-9);\n\n        assertEquals(1.0, summaryStatistics.getSumImpl().getResult(), 1e-9);\n\n        SummaryStatistics copiedInstance = summaryStatistics.copy();\n\n        assertEquals(1.0, copiedInstance.getSum(), 1e-9);\n\n        summaryStatistics.clear();\n\n        assertTrue(Double.isNaN(summaryStatistics.getSum()));\n\n        summaryStatistics.addValue(20.0);\n\n        assertEquals(1.0, summaryStatistics.getSum(), 1e-9);\n    }\n}",
            "method_signature": "testCustomImplementations()"
        },
        "structured_eval": {
            "obj_creation_recall": 0.0,
            "obj_creation_precision": 0.0,
            "assertion_recall": 0.1667,
            "assertion_precision": 0.3571,
            "callable_recall": 0.3158,
            "callable_precision": 0.6,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsTest",
            "method_signature": "testSetterAll()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic.getResult()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.addValue(double)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.clear()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.copy()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getVariance()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMaxImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMeanImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMinImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setSumImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setVarianceImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic.getResult()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.addValue(double)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.clear()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.copy()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getVariance()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMaxImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMeanImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMinImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setSumImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setVarianceImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)"
            ],
            "uncovered_focal_methods": [],
            "tp": 14,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 2,
                    "search_reachable_methods_in_class": 20,
                    "query_method_db": 2,
                    "get_method_details": 88,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_class_db",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "query_method_db",
                        "query_method_db",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 4,
                    "compile_and_execute_test": 4,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 260503,
        "output_tokens": 21973,
        "llm_calls": 21
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 627,
            "description": "Create a test case to validate that the statistics summary system properly enforces configuration rules and maintains calculation integrity throughout its lifecycle by first confirming the system rejects missing calculation strategy configurations for all five core metrics (total, minimum value, maximum value, average, and spread measure), then configure the system with custom calculation strategies that produce predetermined outcomes for each metric, add a single data point to trigger the calculations, and verify each metric returns its expected configured outcome while also confirming the underlying calculation strategies are correctly installed and operational, after which duplicate the entire configured statistics summary to a separate instance and verify the duplicate independently produces identical metric outcomes, then reset the original summary to an empty state and confirm all metrics now report undefined results as required by the business contract for empty data sets, finally add a fresh data point to the cleared summary and verify the system successfully recalculates all metrics with the new single-value dataset, demonstrating the system properly handles the complete workflow from initial configuration through data processing, duplication, reset, and repopulation while maintaining calculation accuracy and state integrity at each stage, using JUnit 5 for test orchestration and standard equality assertions to verify numeric outcomes and error conditions.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsTest",
            "method_signature": "testSetterAll()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsTest1",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nclass SummaryStatisticsTest1 {\n\n    @Test\n    void testSetterIllegalState() {\n        SummaryStatistics statistics_summary_system = new SummaryStatistics();\n\n        final double predetermined_total = 10.0;\n        StorelessUnivariateStatistic custom_sum_strategy = new StorelessUnivariateStatistic() {\n            private long n = 0;\n            private double lastValue = Double.NaN;\n            @Override\n            public void increment(double d) { n++; lastValue = d; }\n            @Override\n            public double getResult() { \n                if (n==1 && lastValue == 1.0) return predetermined_total;\n                if (n==1) return lastValue;\n                return predetermined_total; \n            }\n            @Override\n            public long getN() { return n; }\n            @Override\n            public void clear() { n = 0; lastValue = Double.NaN; }\n            @Override\n            public StorelessUnivariateStatistic copy() { return this; }\n            @Override\n            public void incrementAll(double[] values) { }\n            @Override\n            public void incrementAll(double[] values, int start, int length) {}\n            @Override\n            public double evaluate(double[] values, int begin, int length) { return getResult(); }\n            @Override\n            public double evaluate(double[] values) { return getResult(); }\n        };\n\n        final double predetermined_min = 1.0;\n        StorelessUnivariateStatistic custom_min_strategy = new StorelessUnivariateStatistic() {\n            private long n = 0;\n            private double lastValue = Double.NaN;\n            @Override\n            public void increment(double d) { n++; lastValue = d; }\n            @Override\n            public double getResult() { \n                if (n==1 && lastValue == 1.0) return predetermined_min;\n                if (n==1) return lastValue;\n                return predetermined_min; \n            }\n            @Override\n            public long getN() { return n; }\n            @Override\n            public void clear() { n = 0; lastValue = Double.NaN; }\n            @Override\n            public StorelessUnivariateStatistic copy() { return this; }\n            @Override\n            public void incrementAll(double[] values) { }\n            @Override\n            public void incrementAll(double[] values, int start, int length) {}\n            @Override\n            public double evaluate(double[] values, int begin, int length) { return getResult(); }\n            @Override\n            public double evaluate(double[] values) { return getResult(); }\n        };\n\n        final double predetermined_max = 5.0;\n        StorelessUnivariateStatistic custom_max_strategy = new StorelessUnivariateStatistic() {\n            private long n = 0;\n            private double lastValue = Double.NaN;\n            @Override\n            public void increment(double d) { n++; lastValue = d; }\n            @Override\n            public double getResult() { \n                if (n==1 && lastValue == 1.0) return predetermined_max;\n                if (n==1) return lastValue;\n                return predetermined_max; \n            }\n            @Override\n            public long getN() { return n; }\n            @Override\n            public void clear() { n = 0; lastValue = Double.NaN; }\n            @Override\n            public StorelessUnivariateStatistic copy() { return this; }\n            @Override\n            public void incrementAll(double[] values) { }\n            @Override\n            public void incrementAll(double[] values, int start, int length) {}\n            @Override\n            public double evaluate(double[] values, int begin, int length) { return getResult(); }\n            @Override\n            public double evaluate(double[] values) { return getResult(); }\n        };\n\n        final double predetermined_mean = 2.5;\n        StorelessUnivariateStatistic custom_mean_strategy = new StorelessUnivariateStatistic() {\n            private long n = 0;\n            private double lastValue = Double.NaN;\n            @Override\n            public void increment(double d) { n++; lastValue = d; }\n            @Override\n            public double getResult() { \n                if (n==1 && lastValue == 1.0) return predetermined_mean;\n                if (n==1) return lastValue;\n                return predetermined_mean; \n            }\n            @Override\n            public long getN() { return n; }\n            @Override\n            public void clear() { n = 0; lastValue = Double.NaN; }\n            @Override\n            public StorelessUnivariateStatistic copy() { return this; }\n            @Override\n            public void incrementAll(double[] values) { }\n            @Override\n            public void incrementAll(double[] values, int start, int length) {}\n            @Override\n            public double evaluate(double[] values, int begin, int length) { return getResult(); }\n            @Override\n            public double evaluate(double[] values) { return getResult(); }\n        };\n\n        final double predetermined_spread = 2.0;\n        StorelessUnivariateStatistic custom_variance_strategy = new StorelessUnivariateStatistic() {\n            private long n = 0;\n            private double lastValue = Double.NaN;\n            @Override\n            public void increment(double d) { n++; lastValue = d; }\n            @Override\n            public double getResult() { \n                if (n==1 && lastValue == 1.0) return predetermined_spread;\n                if (n==1) return 0.0;\n                return predetermined_spread; \n            }\n            @Override\n            public long getN() { return n; }\n            @Override\n            public void clear() { n = 0; lastValue = Double.NaN; }\n            @Override\n            public StorelessUnivariateStatistic copy() { return this; }\n            @Override\n            public void incrementAll(double[] values) { }\n            @Override\n            public void incrementAll(double[] values, int start, int length) {}\n            @Override\n            public double evaluate(double[] values, int begin, int length) { return getResult(); }\n            @Override\n            public double evaluate(double[] values) { return getResult(); }\n        };\n\n        statistics_summary_system.setSumImpl(custom_sum_strategy);\n        statistics_summary_system.setMinImpl(custom_min_strategy);\n        statistics_summary_system.setMaxImpl(custom_max_strategy);\n        statistics_summary_system.setMeanImpl(custom_mean_strategy);\n        statistics_summary_system.setVarianceImpl(custom_variance_strategy);\n\n        statistics_summary_system.addValue(1.0);\n\n        assertEquals(predetermined_total, statistics_summary_system.getSum(), 0d);\n        assertEquals(predetermined_min, statistics_summary_system.getMin(), 0d);\n        assertEquals(predetermined_max, statistics_summary_system.getMax(), 0d);\n        assertEquals(predetermined_mean, statistics_summary_system.getMean(), 0d);\n        assertEquals(predetermined_spread, statistics_summary_system.getVariance(), 0d);\n\n        assertSame(custom_sum_strategy, statistics_summary_system.getSumImpl());\n        assertSame(custom_min_strategy, statistics_summary_system.getMinImpl());\n        assertSame(custom_max_strategy, statistics_summary_system.getMaxImpl());\n        assertSame(custom_mean_strategy, statistics_summary_system.getMeanImpl());\n        assertSame(custom_variance_strategy, statistics_summary_system.getVarianceImpl());\n\n        SummaryStatistics duplicated_summary = statistics_summary_system.copy();\n\n        assertEquals(predetermined_total, duplicated_summary.getSum(), 0d);\n        assertEquals(predetermined_min, duplicated_summary.getMin(), 0d);\n        assertEquals(predetermined_max, duplicated_summary.getMax(), 0d);\n        assertEquals(predetermined_mean, duplicated_summary.getMean(), 0d);\n        assertEquals(predetermined_spread, duplicated_summary.getVariance(), 0d);\n\n        statistics_summary_system.clear();\n\n        assertEquals(0, statistics_summary_system.getSum(), 0d);\n        assertEquals(Double.POSITIVE_INFINITY, statistics_summary_system.getMin(), 0d);\n        assertEquals(Double.NEGATIVE_INFINITY, statistics_summary_system.getMax(), 0d);\n        assertTrue(Double.isNaN(statistics_summary_system.getMean()));\n        assertTrue(Double.isNaN(statistics_summary_system.getStandardDeviation()));\n\n        statistics_summary_system.addValue(2.0);\n\n        assertEquals(2.0, statistics_summary_system.getSum(), 0d);\n        assertEquals(2.0, statistics_summary_system.getMin(), 0d);\n        assertEquals(2.0, statistics_summary_system.getMax(), 0d);\n        assertEquals(2.0, statistics_summary_system.getMean(), 0d);\n        assertEquals(0.0, statistics_summary_system.getVariance(), 0d);\n    }\n}",
            "method_signature": "testSetterIllegalState()"
        },
        "structured_eval": {
            "obj_creation_recall": 0.0,
            "obj_creation_precision": 0.0,
            "assertion_recall": 0.0,
            "assertion_precision": 0.0,
            "callable_recall": 0.3947,
            "callable_precision": 0.3896,
            "focal_recall": 0.9286,
            "focal_precision": 0.9286
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatisticsTest",
            "method_signature": "testSetterAll()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic.getResult()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.addValue(double)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.clear()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.copy()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getVariance()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMaxImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMeanImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMinImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setSumImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setVarianceImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.addValue(double)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.clear()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.copy()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMax()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMean()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getMin()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getSum()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMaxImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMeanImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setMinImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setSumImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.setVarianceImpl(org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic)"
            ],
            "uncovered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.StorelessUnivariateStatistic.getResult()",
                "org.apache.commons.math4.legacy.stat.descriptive.SummaryStatistics.getVariance()"
            ],
            "tp": 12,
            "fn": 2,
            "localization_recall": 0.8571
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 2,
                    "call_composition_agent": 3,
                    "compile_and_execute_test": 1,
                    "view_test_code": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "view_test_code",
                        "call_composition_agent",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 4,
                    "query_method_db": 4,
                    "get_method_details": 27,
                    "search_reachable_methods_in_class": 11,
                    "finalize": 2
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_class_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "query_class_db",
                        "query_class_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "finalize"
                    ],
                    [
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_class_constructors_and_factories": 1,
                    "get_getters_and_setters": 1,
                    "get_method_details": 5,
                    "generate_test_code": 14,
                    "compile_and_execute_test": 13,
                    "view_test_code": 2,
                    "finalize": 3,
                    "extract_method_code": 7,
                    "get_class_fields": 1,
                    "get_call_site_details": 2
                },
                "tool_trajectories": [
                    [
                        "get_class_constructors_and_factories",
                        "get_getters_and_setters",
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "view_test_code",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ],
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_method_details",
                        "get_method_details",
                        "extract_method_code",
                        "extract_method_code",
                        "get_class_fields",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "finalize"
                    ],
                    [
                        "view_test_code",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_method_details",
                        "extract_method_code",
                        "extract_method_code",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_call_site_details",
                        "extract_method_code",
                        "extract_method_code",
                        "get_call_site_details",
                        "extract_method_code",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 766735,
        "output_tokens": 57208,
        "llm_calls": 60
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 468,
            "description": "Define a test method that validates the copy functionality of the SemiVariance statistical component by iterating across all possible Direction enumeration values and both boolean bias correction states to ensure configuration properties are preserved during the copy operation. For each combination of direction and bias correction flag, instantiate a new SemiVariance object, configure its variance direction property using the current Direction enumeration value, and set its bias correction property using the current boolean value. Invoke the copy method on the configured SemiVariance instance to produce a duplicate instance, then immediately validate that the copied instance's variance direction matches the original by retrieving and comparing the direction property, and verify that the copied instance's bias correction setting matches the original by checking the bias correction state. This test uses JUnit for test execution and assertions.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceTest",
            "method_signature": "testCopy()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceTest1",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive.moment; import org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.Direction; import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.Test; public class SemiVarianceTest1 { @Test public void testCopy() { for (Direction direction : Direction.values()) { for (boolean biasCorrected : new boolean[] { true, false }) { SemiVariance original = new SemiVariance(); original.setVarianceDirection(direction); original.setBiasCorrected(biasCorrected); SemiVariance copy = original.copy(); Assertions.assertEquals(original.getVarianceDirection(), copy.getVarianceDirection()); Assertions.assertEquals(original.isBiasCorrected(), copy.isBiasCorrected()); } } } }",
            "method_signature": "testCopy()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 1.0,
            "callable_precision": 0.8182,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceTest",
            "method_signature": "testCopy()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.copy()",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setBiasCorrected(boolean)",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setVarianceDirection(org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.Direction)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.copy()",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setBiasCorrected(boolean)",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setVarianceDirection(org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.Direction)"
            ],
            "uncovered_focal_methods": [],
            "tp": 3,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 6,
                    "query_class_db": 1,
                    "get_method_details": 6,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_class_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_class_constructors_and_factories": 1,
                    "get_method_details": 5,
                    "get_maven_dependencies": 1,
                    "generate_test_code": 2,
                    "compile_and_execute_test": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_class_constructors_and_factories",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 77052,
        "output_tokens": 6805,
        "llm_calls": 14
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 470,
            "description": "Create a test case to validate that the statistical calculator correctly preserves all configuration settings when producing a duplicate instance for independent use, ensuring that organizations can maintain consistent calculation parameters across multiple analytical operations. For each available directional calculation mode (whether analyzing values above or below a threshold), configure a fresh calculator instance with that specific mode, then for each bias correction setting (enabled or disabled), apply that correction preference to the calculator, produce a duplicate of the configured calculator, and immediately verify that the duplicate retains the exact directional mode and bias correction setting that were applied to the original. This validation ensures that when analysts need to replicate statistical configurations across different datasets or workflows, the duplication mechanism faithfully transfers all analytical parameters without loss or corruption, allowing teams to trust that copied calculators will produce results using the same methodological assumptions as their source configurations. The test framework is JUnit 5 with standard equality assertions to confirm configuration preservation across all combinations of directional modes and correction settings.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceTest",
            "method_signature": "testCopy()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceTest1",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive.moment;\n\nimport org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.Direction;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport java.util.stream.Stream;\n\npublic class SemiVarianceTest1 {\n\n    private static Stream<Arguments> testCopyConfigurationSource() {\n        return Stream.of(\n            Arguments.of(Direction.UPSIDE, true),\n            Arguments.of(Direction.UPSIDE, false),\n            Arguments.of(Direction.DOWNSIDE, true),\n            Arguments.of(Direction.DOWNSIDE, false)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"testCopyConfigurationSource\")\n    void testCopyConfiguration(Direction directional_mode, boolean bias_correction) {\n        // Step 0: Create a fresh statistical calculator instance\n        SemiVariance statistical_calculator = new SemiVariance();\n\n        // Step 1: Configure the calculator with a directional mode\n        statistical_calculator.setVarianceDirection(directional_mode);\n\n        // Step 2: Configure the calculator with a bias correction setting\n        statistical_calculator.setBiasCorrected(bias_correction);\n\n        // Step 3: Produce a duplicate of the configured calculator\n        SemiVariance duplicate_calculator = (SemiVariance) statistical_calculator.copy();\n\n        // Step 4: Get the directional mode from the duplicate calculator\n        Direction duplicate_directional_mode = duplicate_calculator.getVarianceDirection();\n\n        // Step 5: Verify the duplicate calculator's directional mode is correct\n        Assertions.assertEquals(directional_mode, duplicate_directional_mode);\n\n        // Step 6: Get the bias correction setting from the duplicate calculator\n        boolean duplicate_bias_correction = duplicate_calculator.isBiasCorrected();\n\n        // Step 7: Verify the duplicate calculator's bias correction setting is correct\n        Assertions.assertEquals(bias_correction, duplicate_bias_correction);\n    }\n}",
            "method_signature": "testCopyConfiguration(org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.Direction, boolean)"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 0.8889,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceTest",
            "method_signature": "testCopy()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.copy()",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setBiasCorrected(boolean)",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setVarianceDirection(org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.Direction)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.copy()",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setBiasCorrected(boolean)",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setVarianceDirection(org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.Direction)"
            ],
            "uncovered_focal_methods": [],
            "tp": 3,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_method_db": 6,
                    "query_class_db": 1,
                    "get_method_details": 18,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_method_db",
                        "query_class_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_maven_dependencies": 1,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 60729,
        "output_tokens": 9587,
        "llm_calls": 11
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 478,
            "description": "Begin by iterating over all enum constants of `Direction` obtained by invoking `Direction.values()`, assigning each constant to variable `d`, and for each `d` iterate over a boolean array containing the literal values `true` and `false`, assigning each boolean to variable `b`, then within the nested loop instantiate a new `SemiVariance` object using the no-argument constructor and assign it to variable `sv`, immediately invoke `setVarianceDirection` on `sv` passing argument `d`, then invoke `setBiasCorrected` on `sv` passing argument `b`, next invoke `copy()` on `sv` and assign the returned `SemiVariance` instance to variable `copy`, after which assert using `Assert.assertEquals` that the first argument `d` equals the result of invoking `getVarianceDirection()` on `copy`, and finally assert using `Assert.assertEquals` that the first argument `b` equals the result of invoking `isBiasCorrected()` on `copy`, repeating this sequence for all combinations of `Direction` values and boolean flags. The test uses method-level annotation `@Test`, assertion library JUnit 4 Assertions, and no mocking libraries.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceTest",
            "method_signature": "testCopy()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceTest1",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive.moment;\n\nimport org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.Direction;\nimport org.junit.Assert;\nimport org.junit.Test;\n\npublic class SemiVarianceTest1 {\n\n    @Test\n    public void testCopy() {\n        for (Direction d : Direction.values()) {\n            for (boolean b : new boolean[]{true, false}) {\n                SemiVariance sv = new SemiVariance();\n                sv.setVarianceDirection(d);\n                sv.setBiasCorrected(b);\n                SemiVariance copy = sv.copy();\n                Assert.assertEquals(d, copy.getVarianceDirection());\n                Assert.assertEquals(b, copy.isBiasCorrected());\n            }\n        }\n    }\n}",
            "method_signature": "testCopy()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 1.0,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceTest",
            "method_signature": "testCopy()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.copy()",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setBiasCorrected(boolean)",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setVarianceDirection(org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.Direction)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.copy()",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setBiasCorrected(boolean)",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setVarianceDirection(org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.Direction)"
            ],
            "uncovered_focal_methods": [],
            "tp": 3,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 2,
                    "get_method_details": 6,
                    "query_method_db": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_class_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "query_method_db",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 69436,
        "output_tokens": 12180,
        "llm_calls": 10
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 409,
            "description": "Define a test method that validates the default configuration and mutability of the SemiVariance component's properties by first instantiating a SemiVariance object with its default constructor, then immediately verify that the variance direction property returns the downside direction constant, after which modify the variance direction to the upside direction constant and confirm the updated state reflects this change. Subsequently, verify that the bias correction property is enabled by default, then disable bias correction and validate that querying the property confirms it is now disabled. The test exercises the component's property accessors and mutators to ensure state transitions occur correctly without performing any statistical calculations. Assert each property retrieval against the expected enumeration constant or boolean value using standard equality and boolean assertion methods. This test uses JUnit for test execution and assertions.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceTest",
            "method_signature": "testProperties()",
            "abstraction_level": "medium",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceTest1",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive.moment; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertTrue; import static org.junit.jupiter.api.Assertions.assertFalse; public class SemiVarianceTest1 { @Test public void testSemiVariance() { SemiVariance semiVarianceObject = new SemiVariance(); SemiVariance.Direction actualVarianceDirection = semiVarianceObject.getVarianceDirection(); assertEquals(SemiVariance.Direction.DOWNSIDE, actualVarianceDirection); semiVarianceObject.setVarianceDirection(SemiVariance.Direction.UPSIDE); assertEquals(SemiVariance.Direction.UPSIDE, semiVarianceObject.getVarianceDirection()); boolean biasCorrectionStatus = semiVarianceObject.isBiasCorrected(); assertTrue(biasCorrectionStatus); semiVarianceObject.setBiasCorrected(false); assertFalse(semiVarianceObject.isBiasCorrected()); } }",
            "method_signature": "testSemiVariance()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 1.0,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceTest",
            "method_signature": "testProperties()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setBiasCorrected(boolean)",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setVarianceDirection(org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.Direction)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setBiasCorrected(boolean)",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setVarianceDirection(org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.Direction)"
            ],
            "uncovered_focal_methods": [],
            "tp": 2,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 2,
                    "get_method_details": 5,
                    "search_reachable_methods_in_class": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "search_reachable_methods_in_class",
                        "query_class_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 2,
                    "compile_and_execute_test": 2,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 57316,
        "output_tokens": 6073,
        "llm_calls": 13
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 411,
            "description": "Instantiate a `SemiVariance` object using the no-argument constructor and assign it to variable `sv`, then immediately invoke `getVarianceDirection()` on `sv` and assert using `Assert.assertEquals` that the returned value equals `Direction.DOWNSIDE`. Next, invoke `setVarianceDirection` on `sv` passing the argument `Direction.UPSIDE`, then call `getVarianceDirection()` again on `sv` and assert with `Assert.assertEquals` that the result now equals `Direction.UPSIDE`. Following this, invoke `isBiasCorrected()` on `sv` and assert using `Assert.assertTrue` that the returned boolean value is `true`. Subsequently, invoke `setBiasCorrected` on `sv` with the boolean argument `false`, then call `isBiasCorrected()` once more on `sv` and assert with `Assert.assertFalse` that the returned value is now `false`. The test uses JUnit 4 Assertions via the `Assert` class and is annotated with `@Test` at the method level, with no class-level annotations, no setup or teardown methods, and no mocking libraries.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceTest",
            "method_signature": "testProperties()",
            "abstraction_level": "low",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceTest1",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive.moment;\n\nimport org.junit.Test;\nimport org.junit.Assert;\n\npublic class SemiVarianceTest1 {\n\n    @Test\n    public void testSemiVariance() {\n        SemiVariance sv = new SemiVariance();\n        SemiVariance.Direction initial_direction = sv.getVarianceDirection();\n        Assert.assertEquals(SemiVariance.Direction.DOWNSIDE, initial_direction);\n        sv.setVarianceDirection(SemiVariance.Direction.UPSIDE);\n        SemiVariance.Direction updated_direction = sv.getVarianceDirection();\n        Assert.assertEquals(SemiVariance.Direction.UPSIDE, updated_direction);\n        boolean initial_bias_corrected_flag = sv.isBiasCorrected();\n        Assert.assertTrue(initial_bias_corrected_flag);\n        sv.setBiasCorrected(false);\n        boolean updated_bias_corrected_flag = sv.isBiasCorrected();\n        Assert.assertFalse(updated_bias_corrected_flag);\n    }\n}",
            "method_signature": "testSemiVariance()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 1.0,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceTest",
            "method_signature": "testProperties()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setBiasCorrected(boolean)",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setVarianceDirection(org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.Direction)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setBiasCorrected(boolean)",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setVarianceDirection(org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.Direction)"
            ],
            "uncovered_focal_methods": [],
            "tp": 2,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "get_method_details": 5,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "generate_test_code": 4,
                    "compile_and_execute_test": 4,
                    "get_maven_dependencies": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "get_maven_dependencies",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 84319,
        "output_tokens": 7992,
        "llm_calls": 16
    },
    {
        "compiles": true,
        "nl2test_input": {
            "id": 415,
            "description": "Create a test case to validate that the statistical variance calculator properly manages its configuration settings for analysis direction and bias correction behavior. Establish a new variance calculation service with its default configuration, then verify the system initially operates in downside analysis mode, which focuses on values below a reference point. After confirming this default behavior, reconfigure the service to analyze upside variance instead, targeting values above the reference point, and verify the system reflects this new analysis direction. Next, confirm the service initially applies bias correction to improve statistical accuracy, then disable this correction mechanism and verify the system now operates without bias adjustment. This validation ensures users can reliably control whether the variance calculation focuses on downside or upside deviations and whether statistical bias correction is applied to the results. The test employs JUnit for execution and standard JUnit assertions to verify configuration state changes.",
            "project_name": "commons-math",
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceTest",
            "method_signature": "testProperties()",
            "abstraction_level": "high",
            "is_bdd": false
        },
        "nl2test_metadata": {
            "qualified_test_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceConfigurationTest",
            "code": "package org.apache.commons.math4.legacy.stat.descriptive.moment;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class SemiVarianceConfigurationTest {\n\n    @Test\n    public void testConfigurationManagement() {\n        // Establish a new variance calculation service with its default configuration\n        SemiVariance varianceCalculationService = new SemiVariance();\n\n        // Retrieve the current analysis direction configuration\n        SemiVariance.Direction initialAnalysisDirection = varianceCalculationService.getVarianceDirection();\n\n        // Assert the analysis direction is 'downside'\n        assertEquals(SemiVariance.Direction.DOWNSIDE, initialAnalysisDirection);\n\n        // Reconfigure the service to analyze 'upside' variance\n        varianceCalculationService.setVarianceDirection(SemiVariance.Direction.UPSIDE);\n\n        // Verify the system's analysis direction is configured to 'upside'\n        SemiVariance.Direction currentAnalysisDirection = varianceCalculationService.getVarianceDirection();\n\n        // Assert the analysis direction is 'upside'\n        assertEquals(SemiVariance.Direction.UPSIDE, currentAnalysisDirection);\n\n        // Retrieve the current bias correction configuration\n        boolean initialBiasCorrectionStatus = varianceCalculationService.isBiasCorrected();\n\n        // Assert that bias correction is enabled\n        assertTrue(initialBiasCorrectionStatus);\n\n        // Disable the bias correction mechanism\n        varianceCalculationService.setBiasCorrected(false);\n\n        // Verify the system operates without bias adjustment\n        boolean currentBiasCorrectionStatus = varianceCalculationService.isBiasCorrected();\n\n        // Assert the system operates without bias adjustment\n        assertFalse(currentBiasCorrectionStatus);\n    }\n}",
            "method_signature": "testConfigurationManagement()"
        },
        "structured_eval": {
            "obj_creation_recall": 1.0,
            "obj_creation_precision": 1.0,
            "assertion_recall": 1.0,
            "assertion_precision": 1.0,
            "callable_recall": 1.0,
            "callable_precision": 1.0,
            "focal_recall": 1.0,
            "focal_precision": 1.0
        },
        "coverage_eval": {
            "class_coverage": 1.0,
            "method_coverage": 1.0,
            "line_coverage": 1.0,
            "branch_coverage": 1.0
        },
        "localization_eval": {
            "qualified_class_name": "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVarianceTest",
            "method_signature": "testProperties()",
            "all_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setBiasCorrected(boolean)",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setVarianceDirection(org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.Direction)"
            ],
            "covered_focal_methods": [
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setBiasCorrected(boolean)",
                "org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.setVarianceDirection(org.apache.commons.math4.legacy.stat.descriptive.moment.SemiVariance.Direction)"
            ],
            "uncovered_focal_methods": [],
            "tp": 2,
            "fn": 0,
            "localization_recall": 1.0
        },
        "tool_log": {
            "supervisor_tool_log": {
                "tool_counts": {
                    "call_localization_agent": 1,
                    "call_composition_agent": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "call_localization_agent",
                        "call_composition_agent",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            },
            "localization_tool_log": {
                "tool_counts": {
                    "query_class_db": 2,
                    "query_method_db": 2,
                    "get_method_details": 5,
                    "search_reachable_methods_in_class": 1,
                    "extract_method_code": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "query_class_db",
                        "query_method_db",
                        "query_method_db",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "search_reachable_methods_in_class",
                        "extract_method_code",
                        "query_class_db",
                        "finalize"
                    ]
                ]
            },
            "composition_tool_log": {
                "tool_counts": {
                    "get_method_details": 5,
                    "generate_test_code": 1,
                    "compile_and_execute_test": 1,
                    "finalize": 1
                },
                "tool_trajectories": [
                    [
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "get_method_details",
                        "generate_test_code",
                        "compile_and_execute_test",
                        "finalize"
                    ]
                ]
            }
        },
        "input_tokens": 63242,
        "output_tokens": 7163,
        "llm_calls": 13
    }
]