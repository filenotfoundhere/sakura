from __future__ import annotations
_D='1-based end line to slice the returned source.'
_C='1-based start line to slice the returned source.'
_B='The current state of the AtomicBlocks.'
_A=None
import textwrap
from typing import Annotated,Dict,List,Literal,Optional,Union
from langchain_core.messages import BaseMessage
from pydantic import BaseModel,Field
from.decomposition import AtomicBlockList,LocalizedScenario
class AgentState(BaseModel):
	messages:Annotated[List[Union[BaseMessage,Dict[str,str]]],'List of messages (Human/AI/Tool)']=Field(default_factory=list);iterations:Annotated[int,'The current iteration number of the agent']=0;curr_tool_calls:Dict[str,Dict[str,int]]=Field(default_factory=dict,description='Mapping: tool name -> encoded argument -> count of calls for current agent invocation (multiple turns)');total_tool_calls:Dict[str,Dict[str,int]]=Field(default_factory=dict,description='Mapping: tool name -> encoded argument -> cumulative count across invocations');curr_tool_trajectory:List[str]=Field(default_factory=list);tool_trajectories:List[List[str]]=Field(default_factory=list);package:Annotated[Optional[str],'The package selected by the agent for the test code.']=_A;class_name:Annotated[Optional[str],'The test class name selected by the agent.']=_A;method_signature:Annotated[Optional[str],'The annotation-qualified test method signature generated by the agent.']=_A;atomic_blocks:Annotated[Optional[AtomicBlockList],'The current state of the AtomicBlocks']=_A;localized_scenario:Annotated[Optional[LocalizedScenario],'Finalized LocalizedScenario produced by localization']=_A;final_comments:Annotated[Optional[str],'Final comments from the agent, if any']='';finalize_called:Annotated[bool,'True when the agent has successfully called the finalize tool for this run.']=False;force_end_attempts:Annotated[int,'Number of times the agent has entered the force_end node to coerce finalization.']=0;no_tool_retries:Annotated[int,'Number of consecutive LLM responses with no tool calls (reset on successful tool call).']=0
	def reset_message_history(A)->_A:'Reset tracked conversation history between agent invocations.';A.iterations=0;A.final_comments='';A.finalize_called=False;A.force_end_attempts=0;A.no_tool_retries=0;A.messages=[];A.curr_tool_calls={};A.curr_tool_trajectory.clear()
class QueryMethodArgs(BaseModel):qualified_class_name:Annotated[str,Field(description='The qualified class name of the class declaring the method.')];method_signature:Annotated[str,Field(description='The method signature of the method to query.')]
class QueryClassArgs(BaseModel):qualified_class_name:Annotated[str,Field(description='The qualified class name of the class to query.')]
class QueryVectorDataArgs(BaseModel):query:Annotated[str,Field(description='The query string to search for.')];i:Annotated[int,Field(ge=1,description='1-based start rank.')];j:Annotated[int,Field(ge=1,description='1-based end rank (inclusive), must be >= i.')]
class SearchReachableMethodsArgs(BaseModel):qualified_class_name:Annotated[str,Field(description='The fully qualified class name to search reachable methods from.')];query:Annotated[str,Field(description='Natural language or code-like query to match method intent.')];visibility_mode:Annotated[Literal['public','same_package','same_package_or_subclass'],Field(description='The visibility mode of reachable methods.')];k:Annotated[int,Field(default=5,ge=1,description='Maximum number of reachable method matches to return.')]
class InstructionArgs(BaseModel):instructions:Annotated[str,Field(description='The instructions for the modification.')];current_blocks:Annotated[AtomicBlockList,Field(description=_B)]
_TEST_CODE_DESC='\nRaw Java test file source only, with no wrappers (Markdown/JSON/XML) or commentary. Use literal newlines so the string is valid JSON. Include exactly one test method annotated as a test. Align the package with the SUT when needed for package-private access. Use explicit imports only. Helper/setup/teardown methods are allowed but must not be annotated as tests.\n'
_TEST_QUALIFIED_CLASS_DESC='\nFully qualified test class name (package + simple class name, e.g., org.example.myapp.FooServiceTest).\nMUST exactly match the package and top-level class name declared in `test_code`.\n'
_TEST_METHOD_SIG_DESC='\nThe exact Java method signature (e.g., "testFindById()" or "findById(java.lang.Integer)") of the single test method annotated as a test in the generated code.\n'
class GenerateTestCodeArgs(BaseModel):'Arguments for providing raw test code directly to the generate tool.';test_code:Annotated[str,Field(description=textwrap.dedent(_TEST_CODE_DESC).strip())];qualified_class_name:Annotated[str,Field(description=textwrap.dedent(_TEST_QUALIFIED_CLASS_DESC).strip())];method_signature:Annotated[str,Field(description=textwrap.dedent(_TEST_METHOD_SIG_DESC).strip())]
class FinalizeCommentsArgs(BaseModel):'Arguments for finalizing the composition process with comments only.';comments:Annotated[str,Field(description="Provide 1-2 short sentences. If no issues, write 'No issues.'.")]
class FinalizeAtomicBlockArgs(BaseModel):current_blocks:Annotated[AtomicBlockList,Field(description=_B)];comments:Annotated[str,Field(description='Comments about any problems with the procedure or concerns.')]
class ModifyAtomicBlockNotesArgs(BaseModel):order:Annotated[int,Field(description='The order number of the atomic block to modify.')];new_notes:Annotated[str,Field(description='The new notes for the atomic block.')]
_FINALIZE_LOCALIZED_SCENARIO_DESC='\nThe completed localized scenario (type LocalizedScenario), with each step either mapped to a relevant method or justified as non-localizable (e.g., variable initialization).\n'
class FinalizeScenarioArgs(BaseModel):localized_scenario:Annotated[LocalizedScenario,Field(description=textwrap.dedent(_FINALIZE_LOCALIZED_SCENARIO_DESC).strip())];comments:Annotated[str,Field(description='Concise 1â€“2 sentence comments describing any issues with the step or design considerations. Comments are required; if none, write "No issues.".')]
class ModifyScenarioArgs(BaseModel):'Arguments for modifying a localized scenario in composition tools.';scenario:Annotated[LocalizedScenario,Field(description='')]
class ModifyAtomicBlocksArgs(BaseModel):'Arguments for modifying atomic blocks in composition tools.';atomic_blocks:Annotated[AtomicBlockList,Field(description='')]
class ModifyScenarioCommentArgs(BaseModel):id:Annotated[int,Field(ge=0,description='The id of the localized step to update.')];comment:Annotated[str,Field(description='The new comment for the step.')]
class ViewTestCodeArgs(BaseModel):start_line:Annotated[int,Field(ge=1,description=_C)];end_line:Annotated[int,Field(ge=1,description=_D)]
class ModifyAtomicBlockNoteArgs(BaseModel):order:Annotated[int,Field(description='The order of the atomic block to update.')];note:Annotated[str,Field(description='The new note for the atomic block.')]
class ExtractMethodCodeArgs(BaseModel):qualified_class_name:Annotated[str,Field(description='The fully qualified class name of the class containing the method.')];method_signature:Annotated[str,Field(description='The method signature of the method whose code to extract.')];start_line:Annotated[int,Field(ge=1,description=_C)];end_line:Annotated[int,Field(ge=1,description=_D)]
class NoArgs(BaseModel):'Empty args schema for tools that take no arguments.'
_CALL_LOCALIZATION_AGENT_INSTRUCTIONS_DESC='\nInstructions for the localization agent (reference step ids; include errors if relevant).\n'
class CallLocalizationAgentGherkinArgs(BaseModel):'Arguments for delegating from Supervisor to agents in Gherkin mode.';instructions:Annotated[str,Field(description=textwrap.dedent(_CALL_LOCALIZATION_AGENT_INSTRUCTIONS_DESC).strip())]
_CALL_COMPOSITION_AGENT_INSTRUCTIONS_DESC='\nInstructions for the composition agent (reference step ids; include errors if relevant).\n'
class CallCompositionAgentGherkinArgs(BaseModel):'Arguments for delegating from Supervisor to agents in Gherkin mode.';instructions:Annotated[str,Field(description=textwrap.dedent(_CALL_COMPOSITION_AGENT_INSTRUCTIONS_DESC).strip())]
class CallAgentGrammaticalArgs(BaseModel):'Arguments for delegating from Supervisor to agents in Grammatical mode.';instructions:Annotated[str,Field(description='Actionable instructions for the delegated agent.')]